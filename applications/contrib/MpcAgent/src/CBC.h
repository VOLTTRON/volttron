#ifndef __omc_CBC_h_
#define __omc_CBC_h_
#include "adevs.h"
#include "adevs_public_modelica_runtime.h"

/**
 * Define the input and output type of the adevs models.
 */
#ifndef OMC_ADEVS_IO_TYPE
#define OMC_ADEVS_IO_TYPE double
#endif

/**
 * Simulation code for CBC
 * generated by the OpenModelica Compiler.
 */
class CBC:
    public adevs::ode_system<OMC_ADEVS_IO_TYPE>
{
    public:
       /**
        * Constructor. New state events can be added to the model by
        * passing the number of new event conditions to the constructor
        * and then extending the state_event_func method. Your state
        * events will begin at the index returned by numStateEvents().
        * You can also set the hysteresis value for the event surfaces
        * by passing a value for eventHys.
        */
       CBC(int extra_state_events = 0, double eventHys = 1E-4);
       /// Destructor
       ~CBC();
       /// Index of the first extra state event
       int numStateEvents() const { return numZeroCrossings(); }
       /**
        * These methods are generated by the OpenModelica compiler.
        */
       void init(double* q);
       void der_func(const double* q, double* dq);
       void postStep(double* q);
       void state_event_func(const double* q, double* z);
       /**
        * These methods may be overridden by any derived class.
        */
       virtual void extra_state_event_funcs(double* z){}
       double time_event_func(const double* q);
       void internal_event(double* q, const bool* state_event);
       void external_event(double* q, double e,
           const adevs::Bag<OMC_ADEVS_IO_TYPE>& xb){}
       void confluent_event(double *q, const bool* state_event,
           const adevs::Bag<OMC_ADEVS_IO_TYPE>& xb)
       {
           internal_event(q,state_event);
       }
       void output_func(const double *q, const bool* state_event,
           adevs::Bag<OMC_ADEVS_IO_TYPE>& yb){}
       void gc_output(adevs::Bag<OMC_ADEVS_IO_TYPE>& gb){}
       /**
        * These methods are used to access variables and
        * parameters in the modelica model by name.
        */
       double getEventEpsilon() const { return epsilon; }
       double get_time() const { return timeValue; }
       double get_z4_Troom() const { return _z4_Troom; }
       double get_z3_Troom() const { return _z3_Troom; }
       double get_z2_Troom() const { return _z2_Troom; }
       double get_z1_Troom() const { return _z1_Troom; }
       double get_DER_z4_Troom() const { return _DER_z4_Troom; }
       double get_DER_z3_Troom() const { return _DER_z3_Troom; }
       double get_DER_z2_Troom() const { return _DER_z2_Troom; }
       double get_DER_z1_Troom() const { return _DER_z1_Troom; }
       #ifndef ____link_Q_get_adevs_modelica
       #define ____link_Q_get_adevs_modelica
       double get_link_Q(int i0) const { return _link_Q[i0]; }
       #endif
       

       #ifndef ____link_T_get_adevs_modelica
       #define ____link_T_get_adevs_modelica
       double get_link_T(int i0) const { return _link_T[i0]; }
       #endif
       

       double get_outdoor_Tair() const { return _outdoor_Tair; }
       double get_outdoor_dayCycle() const { return _outdoor_dayCycle; }
       double get_outdoor_day() const { return _outdoor_day; }
       double get_z4_pin_Q() const { return _z4_pin_Q; }
       double get_z3_pin_Q() const { return _z3_pin_Q; }
       double get_z2_pin_Q() const { return _z2_pin_Q; }
       double get_z1_pin_Q() const { return _z1_pin_Q; }
       #ifndef ____link_KInterZone_get_adevs_modelica
       #define ____link_KInterZone_get_adevs_modelica
       double get_link_KInterZone(int i0) const { return _link_KInterZone[i0]; }
       #endif
       

       double get_z1_alpha() const { return _z1_alpha; }
       double get_z1_heatHvac() const { return _z1_heatHvac; }
       double get_z1_coolHvac() const { return _z1_coolHvac; }
       double get_z1_delta() const { return _z1_delta; }
       double get_z2_alpha() const { return _z2_alpha; }
       double get_z2_heatHvac() const { return _z2_heatHvac; }
       double get_z2_coolHvac() const { return _z2_coolHvac; }
       double get_z2_delta() const { return _z2_delta; }
       double get_z3_alpha() const { return _z3_alpha; }
       double get_z3_heatHvac() const { return _z3_heatHvac; }
       double get_z3_coolHvac() const { return _z3_coolHvac; }
       double get_z3_delta() const { return _z3_delta; }
       double get_z4_alpha() const { return _z4_alpha; }
       double get_z4_heatHvac() const { return _z4_heatHvac; }
       double get_z4_coolHvac() const { return _z4_coolHvac; }
       double get_z4_delta() const { return _z4_delta; }
       int get_z1_heatStage() const { return _z1_heatStage; }
       int get_z1_coolStage() const { return _z1_coolStage; }
       int get_z2_heatStage() const { return _z2_heatStage; }
       int get_z2_coolStage() const { return _z2_coolStage; }
       int get_z3_heatStage() const { return _z3_heatStage; }
       int get_z3_coolStage() const { return _z3_coolStage; }
       int get_z4_heatStage() const { return _z4_heatStage; }
       int get_z4_coolStage() const { return _z4_coolStage; }
       #ifndef ____link_pb_T_get_adevs_modelica
       #define ____link_pb_T_get_adevs_modelica
       double get_link_pb_T(int i0) const { return _link_pb_T[i0]; }
       #endif
       

       #ifndef ____link_pa_T_get_adevs_modelica
       #define ____link_pa_T_get_adevs_modelica
       double get_link_pa_T(int i0) const { return _link_pa_T[i0]; }
       #endif
       

       #ifndef ____link_pa_Q_get_adevs_modelica
       #define ____link_pa_Q_get_adevs_modelica
       double get_link_pa_Q(int i0) const { return _link_pa_Q[i0]; }
       #endif
       

       #ifndef ____link_pb_Q_get_adevs_modelica
       #define ____link_pb_Q_get_adevs_modelica
       double get_link_pb_Q(int i0) const { return _link_pb_Q[i0]; }
       #endif
       

       double get_z4_pin_T() const { return _z4_pin_T; }
       double get_z3_pin_T() const { return _z3_pin_T; }
       double get_z2_pin_T() const { return _z2_pin_T; }
       double get_z1_pin_T() const { return _z1_pin_T; }
       double get_z4_Tair() const { return _z4_Tair; }
       double get_z3_Tair() const { return _z3_Tair; }
       double get_z2_Tair() const { return _z2_Tair; }
       double get_z1_Tair() const { return _z1_Tair; }
       
       /// These methods are for solving non-linear algebraic eqns
       // Calculate the minimization function for initializing reals
       void initial_objective_func(double* w, double* f, double lambda);
       
    private:
       // State variables
       double _z4_Troom; double _PRE_z4_Troom;
       double _z3_Troom; double _PRE_z3_Troom;
       double _z2_Troom; double _PRE_z2_Troom;
       double _z1_Troom; double _PRE_z1_Troom;
       // Derivative variables
       double _DER_z4_Troom; double _PRE_DER_z4_Troom;
       double _DER_z3_Troom; double _PRE_DER_z3_Troom;
       double _DER_z2_Troom; double _PRE_DER_z2_Troom;
       double _DER_z1_Troom; double _PRE_DER_z1_Troom;
       // Inline variables
       // Algebraic variables
        
        
        
        
        
        
       #ifndef ____link_Q_declared_adevs_modelica
       #define ____link_Q_declared_adevs_modelica
       double _link_Q[4];
       #endif
       
        #ifndef ____PRE_link_Q_declared_adevs_modelica
       #define ____PRE_link_Q_declared_adevs_modelica
       double _PRE_link_Q[4];
       #endif
       

       #ifndef ____link_T_declared_adevs_modelica
       #define ____link_T_declared_adevs_modelica
       double _link_T[4];
       #endif
       
        #ifndef ____PRE_link_T_declared_adevs_modelica
       #define ____PRE_link_T_declared_adevs_modelica
       double _PRE_link_T[4];
       #endif
       

       double _outdoor_Tair; double _PRE_outdoor_Tair;
       double _outdoor_dayCycle; double _PRE_outdoor_dayCycle;
       double _outdoor_day; double _PRE_outdoor_day;
       double _z4_pin_Q; double _PRE_z4_pin_Q;
       double _z3_pin_Q; double _PRE_z3_pin_Q;
       double _z2_pin_Q; double _PRE_z2_pin_Q;
       double _z1_pin_Q; double _PRE_z1_pin_Q;
       // Integer algebraic variables
       // Boolean algebraic variables
       // Alias variables
        
        
        
        
       #ifndef ____link_pb_T_declared_adevs_modelica
       #define ____link_pb_T_declared_adevs_modelica
       double _link_pb_T[4];
       #endif
       
        #ifndef ____PRE_link_pb_T_declared_adevs_modelica
       #define ____PRE_link_pb_T_declared_adevs_modelica
       double _PRE_link_pb_T[4];
       #endif
       

        
       #ifndef ____link_pa_T_declared_adevs_modelica
       #define ____link_pa_T_declared_adevs_modelica
       double _link_pa_T[4];
       #endif
       
        #ifndef ____PRE_link_pa_T_declared_adevs_modelica
       #define ____PRE_link_pa_T_declared_adevs_modelica
       double _PRE_link_pa_T[4];
       #endif
       

        
        
        
        
        
        
        
       #ifndef ____link_pa_Q_declared_adevs_modelica
       #define ____link_pa_Q_declared_adevs_modelica
       double _link_pa_Q[4];
       #endif
       
        #ifndef ____PRE_link_pa_Q_declared_adevs_modelica
       #define ____PRE_link_pa_Q_declared_adevs_modelica
       double _PRE_link_pa_Q[4];
       #endif
       

       #ifndef ____link_pb_Q_declared_adevs_modelica
       #define ____link_pb_Q_declared_adevs_modelica
       double _link_pb_Q[4];
       #endif
       
        #ifndef ____PRE_link_pb_Q_declared_adevs_modelica
       #define ____PRE_link_pb_Q_declared_adevs_modelica
       double _PRE_link_pb_Q[4];
       #endif
       

       double _z4_pin_T; double _PRE_z4_pin_T;
       double _z3_pin_T; double _PRE_z3_pin_T;
       double _z2_pin_T; double _PRE_z2_pin_T;
       double _z1_pin_T; double _PRE_z1_pin_T;
       double _z4_Tair; double _PRE_z4_Tair;
       double _z3_Tair; double _PRE_z3_Tair;
       double _z2_Tair; double _PRE_z2_Tair;
       double _z1_Tair; double _PRE_z1_Tair;
       // Integer alias variables
       // Boolean alias variables
       // Parameter variables
       #ifndef ____link_KInterZone_declared_adevs_modelica
       #define ____link_KInterZone_declared_adevs_modelica
       double _link_KInterZone[4];
       #endif
       
        #ifndef ____PRE_link_KInterZone_declared_adevs_modelica
       #define ____PRE_link_KInterZone_declared_adevs_modelica
       double _PRE_link_KInterZone[4];
       #endif
       

        
        
        
       double _z1_alpha; double _PRE_z1_alpha;
       double _z1_heatHvac; double _PRE_z1_heatHvac;
       double _z1_coolHvac; double _PRE_z1_coolHvac;
       double _z1_delta; double _PRE_z1_delta;
       double _z2_alpha; double _PRE_z2_alpha;
       double _z2_heatHvac; double _PRE_z2_heatHvac;
       double _z2_coolHvac; double _PRE_z2_coolHvac;
       double _z2_delta; double _PRE_z2_delta;
       double _z3_alpha; double _PRE_z3_alpha;
       double _z3_heatHvac; double _PRE_z3_heatHvac;
       double _z3_coolHvac; double _PRE_z3_coolHvac;
       double _z3_delta; double _PRE_z3_delta;
       double _z4_alpha; double _PRE_z4_alpha;
       double _z4_heatHvac; double _PRE_z4_heatHvac;
       double _z4_coolHvac; double _PRE_z4_coolHvac;
       double _z4_delta; double _PRE_z4_delta;
       // Integer parameter variables
       int _z1_heatStage; int _PRE_z1_heatStage;
       int _z1_coolStage; int _PRE_z1_coolStage;
       int _z2_heatStage; int _PRE_z2_heatStage;
       int _z2_coolStage; int _PRE_z2_coolStage;
       int _z3_heatStage; int _PRE_z3_heatStage;
       int _z3_coolStage; int _PRE_z3_coolStage;
       int _z4_heatStage; int _PRE_z4_heatStage;
       int _z4_coolStage; int _PRE_z4_coolStage;
       // Boolean parameter variables
       // String variables
       // String parameters
       // External object variables
       // Constants
       // Integer constants
       // Boolean constants
       // String constants

       
       double epsilon;
       // These must be accessed via a pointer to localVal
       double timeValue, _PRE_timeValue;
       // Are we at an event?
       bool atEvent;
       // Are we initializing the model?
       bool atInit;
       
       // Zero crossing variables
       int *zc;
       int numZeroCrossings() const {
            return numRelations()+2*numMathEvents();
       }
       int numRelations() const { return 0; }
       int numMathEvents() const { return 0; }
       
       // Initial unknowns via solution to least squares
       void solve_for_initial_unknowns();
       std::vector<double*> init_unknown_vars;
       void bound_params();
       void save_vars();
       void restore_vars();
       void clear_event_flags();
       bool check_for_new_events();
       bool initial() const { return atInit; }
       
       void calc_vars(const double* q = NULL, bool doReinit = false);
       
       AdevsSampleData** samples;
       int numTimeEvents() const { return 0; }
       bool sample(int index, double tStart, double tInterval);
       
       AdevsDelayData** delays;
       int numDelays() const { return 0; }
       double calcDelay(int index, double expr, double t, double delay);
       void saveDelay(int index, double expr, double t, double maxdelay);
       
       AdevsMathEventFunc** eventFuncs;
       double floor(double expr, int index);
       double div(double x, double y, int index);
       int integer(double expr, int index);
       double ceil(double expr, int index);
       
       bool selectStateVars();
       
    protected:
       /**
        * Calculate the values of the state and algebraic variables.
        * State variables will be initialized to q if provided,
        * or left unchanged if not. This should be called after your
        * event handler modifies any state variables that
        * appear in the Modelica equations.
        */
       void update_vars(const double* q = NULL, bool doReinit = false)
       {
           calc_vars(q,doReinit);
           for (int i = 0; i < numMathEvents(); i++)
              if (eventFuncs[i] != NULL)
                 eventFuncs[i]->setInit(false);
           save_vars();
       }
       /**
         * These methods may be used to change paramters
         * and state variables at events. Remember to call
         * update_vars(q,true) if you change anything.
         */
       void set_z4_Troom(double val) { _z4_Troom = val; }
       void set_z3_Troom(double val) { _z3_Troom = val; }
       void set_z2_Troom(double val) { _z2_Troom = val; }
       void set_z1_Troom(double val) { _z1_Troom = val; }
       #ifndef ____link_KInterZone_set_adevs_modelica
       #define ____link_KInterZone_set_adevs_modelica
       void set_link_KInterZone(double val, int i0) { _link_KInterZone[i0] = val; }
       #endif
       

       void set_z1_alpha(double val) { _z1_alpha = val; }
       void set_z1_heatHvac(double val) { _z1_heatHvac = val; }
       void set_z1_coolHvac(double val) { _z1_coolHvac = val; }
       void set_z1_delta(double val) { _z1_delta = val; }
       void set_z2_alpha(double val) { _z2_alpha = val; }
       void set_z2_heatHvac(double val) { _z2_heatHvac = val; }
       void set_z2_coolHvac(double val) { _z2_coolHvac = val; }
       void set_z2_delta(double val) { _z2_delta = val; }
       void set_z3_alpha(double val) { _z3_alpha = val; }
       void set_z3_heatHvac(double val) { _z3_heatHvac = val; }
       void set_z3_coolHvac(double val) { _z3_coolHvac = val; }
       void set_z3_delta(double val) { _z3_delta = val; }
       void set_z4_alpha(double val) { _z4_alpha = val; }
       void set_z4_heatHvac(double val) { _z4_heatHvac = val; }
       void set_z4_coolHvac(double val) { _z4_coolHvac = val; }
       void set_z4_delta(double val) { _z4_delta = val; }
       void set_z1_heatStage(int val) { _z1_heatStage = val; }
       void set_z1_coolStage(int val) { _z1_coolStage = val; }
       void set_z2_heatStage(int val) { _z2_heatStage = val; }
       void set_z2_coolStage(int val) { _z2_coolStage = val; }
       void set_z3_heatStage(int val) { _z3_heatStage = val; }
       void set_z3_coolStage(int val) { _z3_coolStage = val; }
       void set_z4_heatStage(int val) { _z4_heatStage = val; }
       void set_z4_coolStage(int val) { _z4_coolStage = val; }
 };

 #endif

