#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Sat Oct 11 16:09:18 2014 by generateDS.py version 2.13a.
#
# Command line options:
#   ('-o', 'xsd_models.py')
#
# Command line arguments:
#   sep.xsd
#
# Command line:
#   generateDS.py -o "xsd_models.py" sep.xsd
#
# Current working directory (os.getcwd()):
#   sep2
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = list(range(3))
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper:
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):  #pylint: disable=super-init-not-called
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, str) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_:
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Temperature(GeneratedsSuper):
    """Specification of a temperature."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, subject=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.subject = subject
        self.value = value
    def factory(*args_, **kwargs_):
        if Temperature.subclass:
            return Temperature.subclass(*args_, **kwargs_)
        else:
            return Temperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_Int16(self, value):
        # Validate type Int16, a restriction on xs:short.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.subject is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Temperature', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Temperature')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Temperature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Temperature'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Temperature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.subject is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubject>%s</%ssubject>%s' % (namespace_, self.gds_format_integer(self.subject, input_name='subject'), namespace_, eol_))
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Temperature'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subject is not None:
            showIndent(outfile, level)
            outfile.write('subject=%d,\n' % self.subject)
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'subject':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subject')
            self.subject = ival_
            self.validate_UInt8(self.subject)    # validate type UInt8
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_Int16(self.value)    # validate type Int16
# end class Temperature


class Condition(GeneratedsSuper):
    """Indicates a condition that must be satisfied for the Notification to
    be triggered."""
    subclass = None
    superclass = None
    def __init__(self, attributeIdentifier=None, lowerThreshold=None, upperThreshold=None):
        self.original_tagname_ = None
        self.attributeIdentifier = attributeIdentifier
        self.lowerThreshold = lowerThreshold
        self.upperThreshold = upperThreshold
    def factory(*args_, **kwargs_):
        if Condition.subclass:
            return Condition.subclass(*args_, **kwargs_)
        else:
            return Condition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_attributeIdentifier(self): return self.attributeIdentifier
    def set_attributeIdentifier(self, attributeIdentifier): self.attributeIdentifier = attributeIdentifier
    def get_lowerThreshold(self): return self.lowerThreshold
    def set_lowerThreshold(self, lowerThreshold): self.lowerThreshold = lowerThreshold
    def get_upperThreshold(self): return self.upperThreshold
    def set_upperThreshold(self, upperThreshold): self.upperThreshold = upperThreshold
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_Int48(self, value):
        # Validate type Int48, a restriction on xs:long.
        pass
    def hasContent_(self):
        if (
            self.attributeIdentifier is not None or
            self.lowerThreshold is not None or
            self.upperThreshold is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Condition', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Condition')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Condition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Condition'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Condition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attributeIdentifier is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeIdentifier>%s</%sattributeIdentifier>%s' % (namespace_, self.gds_format_integer(self.attributeIdentifier, input_name='attributeIdentifier'), namespace_, eol_))
        if self.lowerThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slowerThreshold>%s</%slowerThreshold>%s' % (namespace_, self.gds_format_integer(self.lowerThreshold, input_name='lowerThreshold'), namespace_, eol_))
        if self.upperThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supperThreshold>%s</%supperThreshold>%s' % (namespace_, self.gds_format_integer(self.upperThreshold, input_name='upperThreshold'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Condition'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.attributeIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('attributeIdentifier=%d,\n' % self.attributeIdentifier)
        if self.lowerThreshold is not None:
            showIndent(outfile, level)
            outfile.write('lowerThreshold=%d,\n' % self.lowerThreshold)
        if self.upperThreshold is not None:
            showIndent(outfile, level)
            outfile.write('upperThreshold=%d,\n' % self.upperThreshold)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'attributeIdentifier':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'attributeIdentifier')
            self.attributeIdentifier = ival_
            self.validate_UInt8(self.attributeIdentifier)    # validate type UInt8
        elif nodeName_ == 'lowerThreshold':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lowerThreshold')
            self.lowerThreshold = ival_
            self.validate_Int48(self.lowerThreshold)    # validate type Int48
        elif nodeName_ == 'upperThreshold':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'upperThreshold')
            self.upperThreshold = ival_
            self.validate_Int48(self.upperThreshold)    # validate type Int48
# end class Condition


class AppliedTargetReduction(GeneratedsSuper):
    """Specifies the value of the TargetReduction applied by the device."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.value = value
    def factory(*args_, **kwargs_):
        if AppliedTargetReduction.subclass:
            return AppliedTargetReduction.subclass(*args_, **kwargs_)
        else:
            return AppliedTargetReduction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AppliedTargetReduction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AppliedTargetReduction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AppliedTargetReduction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AppliedTargetReduction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AppliedTargetReduction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AppliedTargetReduction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.UnitType(\n')
            self.type_.exportLiteral(outfile, level, name_='type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = UnitType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt16(self.value)    # validate type UInt16
# end class AppliedTargetReduction


class DRLCCapabilities(GeneratedsSuper):
    """Contains information about the static capabilities of the device, to
    allow service providers to know what types of functions are
    supported, what the normal operating ranges and limits are, and
    other similar information, in order to provide better
    suggestions of applicable programs to receive the maximum
    benefit."""
    subclass = None
    superclass = None
    def __init__(self, averageEnergy=None, maxDemand=None, optionsImplemented=None):
        self.original_tagname_ = None
        self.averageEnergy = averageEnergy
        self.maxDemand = maxDemand
        self.optionsImplemented = optionsImplemented
    def factory(*args_, **kwargs_):
        if DRLCCapabilities.subclass:
            return DRLCCapabilities.subclass(*args_, **kwargs_)
        else:
            return DRLCCapabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_averageEnergy(self): return self.averageEnergy
    def set_averageEnergy(self, averageEnergy): self.averageEnergy = averageEnergy
    def get_maxDemand(self): return self.maxDemand
    def set_maxDemand(self, maxDemand): self.maxDemand = maxDemand
    def get_optionsImplemented(self): return self.optionsImplemented
    def set_optionsImplemented(self, optionsImplemented): self.optionsImplemented = optionsImplemented
    def validate_HexBinary32(self, value):
        # Validate type HexBinary32, a restriction on xs:hexBinary.
        pass
    def hasContent_(self):
        if (
            self.averageEnergy is not None or
            self.maxDemand is not None or
            self.optionsImplemented is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DRLCCapabilities', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DRLCCapabilities')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DRLCCapabilities', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DRLCCapabilities'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DRLCCapabilities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.averageEnergy is not None:
            self.averageEnergy.export(outfile, level, namespace_, name_='averageEnergy', pretty_print=pretty_print)
        if self.maxDemand is not None:
            self.maxDemand.export(outfile, level, namespace_, name_='maxDemand', pretty_print=pretty_print)
        if self.optionsImplemented is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionsImplemented>%s</%soptionsImplemented>%s' % (namespace_, self.gds_format_string(quote_xml(self.optionsImplemented).encode(ExternalEncoding), input_name='optionsImplemented'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DRLCCapabilities'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.averageEnergy is not None:
            showIndent(outfile, level)
            outfile.write('averageEnergy=model_.RealEnergy(\n')
            self.averageEnergy.exportLiteral(outfile, level, name_='averageEnergy')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.maxDemand is not None:
            showIndent(outfile, level)
            outfile.write('maxDemand=model_.ActivePower(\n')
            self.maxDemand.exportLiteral(outfile, level, name_='maxDemand')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.optionsImplemented is not None:
            showIndent(outfile, level)
            outfile.write('optionsImplemented=%s,\n' % quote_python(self.optionsImplemented).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'averageEnergy':
            obj_ = RealEnergy.factory()
            obj_.build(child_)
            self.averageEnergy = obj_
            obj_.original_tagname_ = 'averageEnergy'
        elif nodeName_ == 'maxDemand':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.maxDemand = obj_
            obj_.original_tagname_ = 'maxDemand'
        elif nodeName_ == 'optionsImplemented':
            optionsImplemented_ = child_.text
            optionsImplemented_ = self.gds_validate_string(optionsImplemented_, node, 'optionsImplemented')
            self.optionsImplemented = optionsImplemented_
            self.validate_HexBinary32(self.optionsImplemented)    # validate type HexBinary32
# end class DRLCCapabilities


class PowerSourceType(GeneratedsSuper):
    """0 - none 1 - mains 2 - battery 3 - local generation 4 - emergency 5
    - unknown All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PowerSourceType.subclass:
            return PowerSourceType.subclass(*args_, **kwargs_)
        else:
            return PowerSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PowerSourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerSourceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PowerSourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PowerSourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PowerSourceType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PowerSourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerSourceType


class PEVInfo(GeneratedsSuper):
    """Contains attributes that can be exposed by PEVs and other devices
    that have charging requirements."""
    subclass = None
    superclass = None
    def __init__(self, chargingPowerNow=None, energyRequestNow=None, maxForwardPower=None, minimumChargingDuration=None, targetStateOfCharge=None, timeChargeIsNeeded=None, timeChargingStatusPEV=None):
        self.original_tagname_ = None
        self.chargingPowerNow = chargingPowerNow
        self.energyRequestNow = energyRequestNow
        self.maxForwardPower = maxForwardPower
        self.minimumChargingDuration = minimumChargingDuration
        self.targetStateOfCharge = targetStateOfCharge
        self.timeChargeIsNeeded = timeChargeIsNeeded
        self.timeChargingStatusPEV = timeChargingStatusPEV
    def factory(*args_, **kwargs_):
        if PEVInfo.subclass:
            return PEVInfo.subclass(*args_, **kwargs_)
        else:
            return PEVInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_chargingPowerNow(self): return self.chargingPowerNow
    def set_chargingPowerNow(self, chargingPowerNow): self.chargingPowerNow = chargingPowerNow
    def get_energyRequestNow(self): return self.energyRequestNow
    def set_energyRequestNow(self, energyRequestNow): self.energyRequestNow = energyRequestNow
    def get_maxForwardPower(self): return self.maxForwardPower
    def set_maxForwardPower(self, maxForwardPower): self.maxForwardPower = maxForwardPower
    def get_minimumChargingDuration(self): return self.minimumChargingDuration
    def set_minimumChargingDuration(self, minimumChargingDuration): self.minimumChargingDuration = minimumChargingDuration
    def get_targetStateOfCharge(self): return self.targetStateOfCharge
    def set_targetStateOfCharge(self, targetStateOfCharge): self.targetStateOfCharge = targetStateOfCharge
    def get_timeChargeIsNeeded(self): return self.timeChargeIsNeeded
    def set_timeChargeIsNeeded(self, timeChargeIsNeeded): self.timeChargeIsNeeded = timeChargeIsNeeded
    def get_timeChargingStatusPEV(self): return self.timeChargingStatusPEV
    def set_timeChargingStatusPEV(self, timeChargingStatusPEV): self.timeChargingStatusPEV = timeChargingStatusPEV
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def hasContent_(self):
        if (
            self.chargingPowerNow is not None or
            self.energyRequestNow is not None or
            self.maxForwardPower is not None or
            self.minimumChargingDuration is not None or
            self.targetStateOfCharge is not None or
            self.timeChargeIsNeeded is not None or
            self.timeChargingStatusPEV is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PEVInfo', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PEVInfo')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PEVInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PEVInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PEVInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chargingPowerNow is not None:
            self.chargingPowerNow.export(outfile, level, namespace_, name_='chargingPowerNow', pretty_print=pretty_print)
        if self.energyRequestNow is not None:
            self.energyRequestNow.export(outfile, level, namespace_, name_='energyRequestNow', pretty_print=pretty_print)
        if self.maxForwardPower is not None:
            self.maxForwardPower.export(outfile, level, namespace_, name_='maxForwardPower', pretty_print=pretty_print)
        if self.minimumChargingDuration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumChargingDuration>%s</%sminimumChargingDuration>%s' % (namespace_, self.gds_format_integer(self.minimumChargingDuration, input_name='minimumChargingDuration'), namespace_, eol_))
        if self.targetStateOfCharge is not None:
            self.targetStateOfCharge.export(outfile, level, namespace_, name_='targetStateOfCharge', pretty_print=pretty_print)
        if self.timeChargeIsNeeded is not None:
            self.timeChargeIsNeeded.export(outfile, level, namespace_, name_='timeChargeIsNeeded', pretty_print=pretty_print)
        if self.timeChargingStatusPEV is not None:
            self.timeChargingStatusPEV.export(outfile, level, namespace_, name_='timeChargingStatusPEV', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PEVInfo'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.chargingPowerNow is not None:
            showIndent(outfile, level)
            outfile.write('chargingPowerNow=model_.ActivePower(\n')
            self.chargingPowerNow.exportLiteral(outfile, level, name_='chargingPowerNow')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.energyRequestNow is not None:
            showIndent(outfile, level)
            outfile.write('energyRequestNow=model_.RealEnergy(\n')
            self.energyRequestNow.exportLiteral(outfile, level, name_='energyRequestNow')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.maxForwardPower is not None:
            showIndent(outfile, level)
            outfile.write('maxForwardPower=model_.ActivePower(\n')
            self.maxForwardPower.exportLiteral(outfile, level, name_='maxForwardPower')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.minimumChargingDuration is not None:
            showIndent(outfile, level)
            outfile.write('minimumChargingDuration=%d,\n' % self.minimumChargingDuration)
        if self.targetStateOfCharge is not None:
            showIndent(outfile, level)
            outfile.write('targetStateOfCharge=model_.PerCent(\n')
            self.targetStateOfCharge.exportLiteral(outfile, level, name_='targetStateOfCharge')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timeChargeIsNeeded is not None:
            showIndent(outfile, level)
            outfile.write('timeChargeIsNeeded=model_.TimeType(\n')
            self.timeChargeIsNeeded.exportLiteral(outfile, level, name_='timeChargeIsNeeded')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.timeChargingStatusPEV is not None:
            showIndent(outfile, level)
            outfile.write('timeChargingStatusPEV=model_.TimeType(\n')
            self.timeChargingStatusPEV.exportLiteral(outfile, level, name_='timeChargingStatusPEV')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'chargingPowerNow':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.chargingPowerNow = obj_
            obj_.original_tagname_ = 'chargingPowerNow'
        elif nodeName_ == 'energyRequestNow':
            obj_ = RealEnergy.factory()
            obj_.build(child_)
            self.energyRequestNow = obj_
            obj_.original_tagname_ = 'energyRequestNow'
        elif nodeName_ == 'maxForwardPower':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.maxForwardPower = obj_
            obj_.original_tagname_ = 'maxForwardPower'
        elif nodeName_ == 'minimumChargingDuration':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'minimumChargingDuration')
            self.minimumChargingDuration = ival_
            self.validate_UInt32(self.minimumChargingDuration)    # validate type UInt32
        elif nodeName_ == 'targetStateOfCharge':
            obj_ = PerCent.factory()
            obj_.build(child_)
            self.targetStateOfCharge = obj_
            obj_.original_tagname_ = 'targetStateOfCharge'
        elif nodeName_ == 'timeChargeIsNeeded':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.timeChargeIsNeeded = obj_
            obj_.original_tagname_ = 'timeChargeIsNeeded'
        elif nodeName_ == 'timeChargingStatusPEV':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.timeChargingStatusPEV = obj_
            obj_.original_tagname_ = 'timeChargingStatusPEV'
# end class PEVInfo


class IEEE_802_15_4(GeneratedsSuper):
    """Contains 802.15.4 link layer specific attributes."""
    subclass = None
    superclass = None
    def __init__(self, capabilityInfo=None, NeighborListLink=None, shortAddress=None):
        self.original_tagname_ = None
        self.capabilityInfo = capabilityInfo
        self.NeighborListLink = NeighborListLink
        self.shortAddress = shortAddress
    def factory(*args_, **kwargs_):
        if IEEE_802_15_4.subclass:
            return IEEE_802_15_4.subclass(*args_, **kwargs_)
        else:
            return IEEE_802_15_4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_capabilityInfo(self): return self.capabilityInfo
    def set_capabilityInfo(self, capabilityInfo): self.capabilityInfo = capabilityInfo
    def get_NeighborListLink(self): return self.NeighborListLink
    def set_NeighborListLink(self, NeighborListLink): self.NeighborListLink = NeighborListLink
    def get_shortAddress(self): return self.shortAddress
    def set_shortAddress(self, shortAddress): self.shortAddress = shortAddress
    def validate_HexBinary8(self, value):
        # Validate type HexBinary8, a restriction on xs:hexBinary.
        pass
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.capabilityInfo is not None or
            self.NeighborListLink is not None or
            self.shortAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IEEE_802_15_4', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IEEE_802_15_4')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IEEE_802_15_4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IEEE_802_15_4'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IEEE_802_15_4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.capabilityInfo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapabilityInfo>%s</%scapabilityInfo>%s' % (namespace_, self.gds_format_string(quote_xml(self.capabilityInfo).encode(ExternalEncoding), input_name='capabilityInfo'), namespace_, eol_))
        if self.NeighborListLink is not None:
            self.NeighborListLink.export(outfile, level, namespace_, name_='NeighborListLink', pretty_print=pretty_print)
        if self.shortAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortAddress>%s</%sshortAddress>%s' % (namespace_, self.gds_format_integer(self.shortAddress, input_name='shortAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='IEEE_802_15_4'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.capabilityInfo is not None:
            showIndent(outfile, level)
            outfile.write('capabilityInfo=%s,\n' % quote_python(self.capabilityInfo).encode(ExternalEncoding))
        if self.NeighborListLink is not None:
            showIndent(outfile, level)
            outfile.write('NeighborListLink=model_.NeighborListLink(\n')
            self.NeighborListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.shortAddress is not None:
            showIndent(outfile, level)
            outfile.write('shortAddress=%d,\n' % self.shortAddress)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'capabilityInfo':
            capabilityInfo_ = child_.text
            capabilityInfo_ = self.gds_validate_string(capabilityInfo_, node, 'capabilityInfo')
            self.capabilityInfo = capabilityInfo_
            self.validate_HexBinary8(self.capabilityInfo)    # validate type HexBinary8
        elif nodeName_ == 'NeighborListLink':
            obj_ = NeighborListLink.factory()
            obj_.build(child_)
            self.NeighborListLink = obj_
            obj_.original_tagname_ = 'NeighborListLink'
        elif nodeName_ == 'shortAddress':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'shortAddress')
            self.shortAddress = ival_
            self.validate_UInt16(self.shortAddress)    # validate type UInt16
# end class IEEE_802_15_4


class loWPAN(GeneratedsSuper):
    """Contains information specific to 6LoWPAN."""
    subclass = None
    superclass = None
    def __init__(self, octetsRx=None, octetsTx=None, packetsRx=None, packetsTx=None, rxFragError=None):
        self.original_tagname_ = None
        self.octetsRx = octetsRx
        self.octetsTx = octetsTx
        self.packetsRx = packetsRx
        self.packetsTx = packetsTx
        self.rxFragError = rxFragError
    def factory(*args_, **kwargs_):
        if loWPAN.subclass:
            return loWPAN.subclass(*args_, **kwargs_)
        else:
            return loWPAN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_octetsRx(self): return self.octetsRx
    def set_octetsRx(self, octetsRx): self.octetsRx = octetsRx
    def get_octetsTx(self): return self.octetsTx
    def set_octetsTx(self, octetsTx): self.octetsTx = octetsTx
    def get_packetsRx(self): return self.packetsRx
    def set_packetsRx(self, packetsRx): self.packetsRx = packetsRx
    def get_packetsTx(self): return self.packetsTx
    def set_packetsTx(self, packetsTx): self.packetsTx = packetsTx
    def get_rxFragError(self): return self.rxFragError
    def set_rxFragError(self, rxFragError): self.rxFragError = rxFragError
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def hasContent_(self):
        if (
            self.octetsRx is not None or
            self.octetsTx is not None or
            self.packetsRx is not None or
            self.packetsTx is not None or
            self.rxFragError is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='loWPAN', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='loWPAN')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='loWPAN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='loWPAN'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='loWPAN', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.octetsRx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soctetsRx>%s</%soctetsRx>%s' % (namespace_, self.gds_format_integer(self.octetsRx, input_name='octetsRx'), namespace_, eol_))
        if self.octetsTx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soctetsTx>%s</%soctetsTx>%s' % (namespace_, self.gds_format_integer(self.octetsTx, input_name='octetsTx'), namespace_, eol_))
        if self.packetsRx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spacketsRx>%s</%spacketsRx>%s' % (namespace_, self.gds_format_integer(self.packetsRx, input_name='packetsRx'), namespace_, eol_))
        if self.packetsTx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spacketsTx>%s</%spacketsTx>%s' % (namespace_, self.gds_format_integer(self.packetsTx, input_name='packetsTx'), namespace_, eol_))
        if self.rxFragError is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srxFragError>%s</%srxFragError>%s' % (namespace_, self.gds_format_integer(self.rxFragError, input_name='rxFragError'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='loWPAN'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.octetsRx is not None:
            showIndent(outfile, level)
            outfile.write('octetsRx=%d,\n' % self.octetsRx)
        if self.octetsTx is not None:
            showIndent(outfile, level)
            outfile.write('octetsTx=%d,\n' % self.octetsTx)
        if self.packetsRx is not None:
            showIndent(outfile, level)
            outfile.write('packetsRx=%d,\n' % self.packetsRx)
        if self.packetsTx is not None:
            showIndent(outfile, level)
            outfile.write('packetsTx=%d,\n' % self.packetsTx)
        if self.rxFragError is not None:
            showIndent(outfile, level)
            outfile.write('rxFragError=%d,\n' % self.rxFragError)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'octetsRx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'octetsRx')
            self.octetsRx = ival_
            self.validate_UInt32(self.octetsRx)    # validate type UInt32
        elif nodeName_ == 'octetsTx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'octetsTx')
            self.octetsTx = ival_
            self.validate_UInt32(self.octetsTx)    # validate type UInt32
        elif nodeName_ == 'packetsRx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'packetsRx')
            self.packetsRx = ival_
            self.validate_UInt32(self.packetsRx)    # validate type UInt32
        elif nodeName_ == 'packetsTx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'packetsTx')
            self.packetsTx = ival_
            self.validate_UInt32(self.packetsTx)    # validate type UInt32
        elif nodeName_ == 'rxFragError':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rxFragError')
            self.rxFragError = ival_
            self.validate_UInt32(self.rxFragError)    # validate type UInt32
# end class loWPAN


class PowerConfiguration(GeneratedsSuper):
    """Contains configuration related to the device's power sources"""
    subclass = None
    superclass = None
    def __init__(self, batteryInstallTime=None, lowChargeThreshold=None):
        self.original_tagname_ = None
        self.batteryInstallTime = batteryInstallTime
        self.lowChargeThreshold = lowChargeThreshold
    def factory(*args_, **kwargs_):
        if PowerConfiguration.subclass:
            return PowerConfiguration.subclass(*args_, **kwargs_)
        else:
            return PowerConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_batteryInstallTime(self): return self.batteryInstallTime
    def set_batteryInstallTime(self, batteryInstallTime): self.batteryInstallTime = batteryInstallTime
    def get_lowChargeThreshold(self): return self.lowChargeThreshold
    def set_lowChargeThreshold(self, lowChargeThreshold): self.lowChargeThreshold = lowChargeThreshold
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def hasContent_(self):
        if (
            self.batteryInstallTime is not None or
            self.lowChargeThreshold is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PowerConfiguration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerConfiguration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PowerConfiguration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PowerConfiguration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PowerConfiguration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.batteryInstallTime is not None:
            self.batteryInstallTime.export(outfile, level, namespace_, name_='batteryInstallTime', pretty_print=pretty_print)
        if self.lowChargeThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slowChargeThreshold>%s</%slowChargeThreshold>%s' % (namespace_, self.gds_format_integer(self.lowChargeThreshold, input_name='lowChargeThreshold'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PowerConfiguration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.batteryInstallTime is not None:
            showIndent(outfile, level)
            outfile.write('batteryInstallTime=model_.TimeType(\n')
            self.batteryInstallTime.exportLiteral(outfile, level, name_='batteryInstallTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lowChargeThreshold is not None:
            showIndent(outfile, level)
            outfile.write('lowChargeThreshold=%d,\n' % self.lowChargeThreshold)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'batteryInstallTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.batteryInstallTime = obj_
            obj_.original_tagname_ = 'batteryInstallTime'
        elif nodeName_ == 'lowChargeThreshold':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lowChargeThreshold')
            self.lowChargeThreshold = ival_
            self.validate_UInt32(self.lowChargeThreshold)    # validate type UInt32
# end class PowerConfiguration


class TimeConfiguration(GeneratedsSuper):
    """Contains attributes related to the configuration of the time
    service."""
    subclass = None
    superclass = None
    def __init__(self, dstEndRule=None, dstOffset=None, dstStartRule=None, tzOffset=None):
        self.original_tagname_ = None
        self.dstEndRule = dstEndRule
        self.dstOffset = dstOffset
        self.dstStartRule = dstStartRule
        self.tzOffset = tzOffset
    def factory(*args_, **kwargs_):
        if TimeConfiguration.subclass:
            return TimeConfiguration.subclass(*args_, **kwargs_)
        else:
            return TimeConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dstEndRule(self): return self.dstEndRule
    def set_dstEndRule(self, dstEndRule): self.dstEndRule = dstEndRule
    def get_dstOffset(self): return self.dstOffset
    def set_dstOffset(self, dstOffset): self.dstOffset = dstOffset
    def get_dstStartRule(self): return self.dstStartRule
    def set_dstStartRule(self, dstStartRule): self.dstStartRule = dstStartRule
    def get_tzOffset(self): return self.tzOffset
    def set_tzOffset(self, tzOffset): self.tzOffset = tzOffset
    def hasContent_(self):
        if (
            self.dstEndRule is not None or
            self.dstOffset is not None or
            self.dstStartRule is not None or
            self.tzOffset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeConfiguration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeConfiguration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeConfiguration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeConfiguration'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimeConfiguration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dstEndRule is not None:
            self.dstEndRule.export(outfile, level, namespace_, name_='dstEndRule', pretty_print=pretty_print)
        if self.dstOffset is not None:
            self.dstOffset.export(outfile, level, namespace_, name_='dstOffset', pretty_print=pretty_print)
        if self.dstStartRule is not None:
            self.dstStartRule.export(outfile, level, namespace_, name_='dstStartRule', pretty_print=pretty_print)
        if self.tzOffset is not None:
            self.tzOffset.export(outfile, level, namespace_, name_='tzOffset', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TimeConfiguration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dstEndRule is not None:
            showIndent(outfile, level)
            outfile.write('dstEndRule=model_.DstRuleType(\n')
            self.dstEndRule.exportLiteral(outfile, level, name_='dstEndRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dstOffset is not None:
            showIndent(outfile, level)
            outfile.write('dstOffset=model_.TimeOffsetType(\n')
            self.dstOffset.exportLiteral(outfile, level, name_='dstOffset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dstStartRule is not None:
            showIndent(outfile, level)
            outfile.write('dstStartRule=model_.DstRuleType(\n')
            self.dstStartRule.exportLiteral(outfile, level, name_='dstStartRule')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.tzOffset is not None:
            showIndent(outfile, level)
            outfile.write('tzOffset=model_.TimeOffsetType(\n')
            self.tzOffset.exportLiteral(outfile, level, name_='tzOffset')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dstEndRule':
            obj_ = DstRuleType.factory()
            obj_.build(child_)
            self.dstEndRule = obj_
            obj_.original_tagname_ = 'dstEndRule'
        elif nodeName_ == 'dstOffset':
            obj_ = TimeOffsetType.factory()
            obj_.build(child_)
            self.dstOffset = obj_
            obj_.original_tagname_ = 'dstOffset'
        elif nodeName_ == 'dstStartRule':
            obj_ = DstRuleType.factory()
            obj_.build(child_)
            self.dstStartRule = obj_
            obj_.original_tagname_ = 'dstStartRule'
        elif nodeName_ == 'tzOffset':
            obj_ = TimeOffsetType.factory()
            obj_.build(child_)
            self.tzOffset = obj_
            obj_.original_tagname_ = 'tzOffset'
# end class TimeConfiguration


class ApplianceLoadReduction(GeneratedsSuper):
    """The ApplianceLoadReduction object is used by a Demand Response
    service provider to provide signals for ENERGY STAR compliant
    appliances. See the definition of ApplianceLoadReductionType for
    more information."""
    subclass = None
    superclass = None
    def __init__(self, type_=None):
        self.original_tagname_ = None
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if ApplianceLoadReduction.subclass:
            return ApplianceLoadReduction.subclass(*args_, **kwargs_)
        else:
            return ApplianceLoadReduction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.type_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ApplianceLoadReduction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApplianceLoadReduction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ApplianceLoadReduction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApplianceLoadReduction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ApplianceLoadReduction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ApplianceLoadReduction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.ApplianceLoadReductionType(\n')
            self.type_.exportLiteral(outfile, level, name_='type')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = ApplianceLoadReductionType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
# end class ApplianceLoadReduction


class DutyCycle(GeneratedsSuper):
    """Duty cycle control is a device specific issue and is managed by the
    device. The duty cycle of the device under control should span
    the shortest practical time period in accordance with the nature
    of the device under control and the intent of the request for
    demand reduction. The default factory setting SHOULD be three
    minutes for each 10% of duty cycle. This indicates that the
    default time period over which a duty cycle is applied is 30
    minutes, meaning a 10% duty cycle would cause a device to be ON
    for 3 minutes. The “off state” SHALL precede the “on
    state”."""
    subclass = None
    superclass = None
    def __init__(self, normalValue=None):
        self.original_tagname_ = None
        self.normalValue = normalValue
    def factory(*args_, **kwargs_):
        if DutyCycle.subclass:
            return DutyCycle.subclass(*args_, **kwargs_)
        else:
            return DutyCycle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_normalValue(self): return self.normalValue
    def set_normalValue(self, normalValue): self.normalValue = normalValue
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.normalValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DutyCycle', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DutyCycle')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DutyCycle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DutyCycle'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DutyCycle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.normalValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snormalValue>%s</%snormalValue>%s' % (namespace_, self.gds_format_integer(self.normalValue, input_name='normalValue'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DutyCycle'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.normalValue is not None:
            showIndent(outfile, level)
            outfile.write('normalValue=%d,\n' % self.normalValue)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'normalValue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'normalValue')
            self.normalValue = ival_
            self.validate_UInt8(self.normalValue)    # validate type UInt8
# end class DutyCycle


class Offset(GeneratedsSuper):
    """If a temperature offset is sent that causes the heating or cooling
    temperature set point to exceed the limit boundaries that are
    programmed into the device, the device SHALL respond by setting
    the temperature at the limit. If an EDC is being targeted at
    multiple devices or to a device that controls multiple devices
    (e.g., EMS), it can provide multiple Offset types within one
    EDC. For events with multiple Offset types, a client SHALL
    select the Offset that best fits their operating function.
    Alternatively, an event with a single Offset type can be
    targeted at an EMS in order to request a percentage load
    reduction on the average energy usage of the entire premise. An
    EMS SHOULD use the Metering function set to determine the
    initial load in the premise, reduce energy consumption by
    controlling devices at its disposal, and at the conclusion of
    the event, once again use the Metering function set to determine
    if the desired load reduction was achieved."""
    subclass = None
    superclass = None
    def __init__(self, coolingOffset=None, heatingOffset=None, loadAdjustmentPercentageOffset=None):
        self.original_tagname_ = None
        self.coolingOffset = coolingOffset
        self.heatingOffset = heatingOffset
        self.loadAdjustmentPercentageOffset = loadAdjustmentPercentageOffset
    def factory(*args_, **kwargs_):
        if Offset.subclass:
            return Offset.subclass(*args_, **kwargs_)
        else:
            return Offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coolingOffset(self): return self.coolingOffset
    def set_coolingOffset(self, coolingOffset): self.coolingOffset = coolingOffset
    def get_heatingOffset(self): return self.heatingOffset
    def set_heatingOffset(self, heatingOffset): self.heatingOffset = heatingOffset
    def get_loadAdjustmentPercentageOffset(self): return self.loadAdjustmentPercentageOffset
    def set_loadAdjustmentPercentageOffset(self, loadAdjustmentPercentageOffset): self.loadAdjustmentPercentageOffset = loadAdjustmentPercentageOffset
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.coolingOffset is not None or
            self.heatingOffset is not None or
            self.loadAdjustmentPercentageOffset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Offset', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Offset')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Offset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Offset'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Offset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.coolingOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scoolingOffset>%s</%scoolingOffset>%s' % (namespace_, self.gds_format_integer(self.coolingOffset, input_name='coolingOffset'), namespace_, eol_))
        if self.heatingOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheatingOffset>%s</%sheatingOffset>%s' % (namespace_, self.gds_format_integer(self.heatingOffset, input_name='heatingOffset'), namespace_, eol_))
        if self.loadAdjustmentPercentageOffset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadAdjustmentPercentageOffset>%s</%sloadAdjustmentPercentageOffset>%s' % (namespace_, self.gds_format_integer(self.loadAdjustmentPercentageOffset, input_name='loadAdjustmentPercentageOffset'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Offset'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.coolingOffset is not None:
            showIndent(outfile, level)
            outfile.write('coolingOffset=%d,\n' % self.coolingOffset)
        if self.heatingOffset is not None:
            showIndent(outfile, level)
            outfile.write('heatingOffset=%d,\n' % self.heatingOffset)
        if self.loadAdjustmentPercentageOffset is not None:
            showIndent(outfile, level)
            outfile.write('loadAdjustmentPercentageOffset=%d,\n' % self.loadAdjustmentPercentageOffset)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'coolingOffset':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'coolingOffset')
            self.coolingOffset = ival_
            self.validate_UInt8(self.coolingOffset)    # validate type UInt8
        elif nodeName_ == 'heatingOffset':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'heatingOffset')
            self.heatingOffset = ival_
            self.validate_UInt8(self.heatingOffset)    # validate type UInt8
        elif nodeName_ == 'loadAdjustmentPercentageOffset':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'loadAdjustmentPercentageOffset')
            self.loadAdjustmentPercentageOffset = ival_
            self.validate_UInt8(self.loadAdjustmentPercentageOffset)    # validate type UInt8
# end class Offset


class SetPoint(GeneratedsSuper):
    """The SetPoint object is used to apply specific temperature set points
    to a temperature control device. The values of the
    heatingSetpoint and coolingSetpoint attributes SHALL be
    calculated as follows: Cooling/Heating Temperature Set Point /
    100 = temperature in degrees Celsius where -273.15°C &lt;=
    temperature &lt;= 327.67°C, corresponding to a Cooling and/or
    Heating Temperature Set Point. The maximum resolution this
    format allows is 0.01°C. The field not present in a Response
    indicates that this field has not been used by the end device.
    If a temperature is sent that exceeds the temperature limit
    boundaries that are programmed into the device, the device SHALL
    respond by setting the temperature at the limit."""
    subclass = None
    superclass = None
    def __init__(self, coolingSetpoint=None, heatingSetpoint=None):
        self.original_tagname_ = None
        self.coolingSetpoint = coolingSetpoint
        self.heatingSetpoint = heatingSetpoint
    def factory(*args_, **kwargs_):
        if SetPoint.subclass:
            return SetPoint.subclass(*args_, **kwargs_)
        else:
            return SetPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_coolingSetpoint(self): return self.coolingSetpoint
    def set_coolingSetpoint(self, coolingSetpoint): self.coolingSetpoint = coolingSetpoint
    def get_heatingSetpoint(self): return self.heatingSetpoint
    def set_heatingSetpoint(self, heatingSetpoint): self.heatingSetpoint = heatingSetpoint
    def validate_Int16(self, value):
        # Validate type Int16, a restriction on xs:short.
        pass
    def hasContent_(self):
        if (
            self.coolingSetpoint is not None or
            self.heatingSetpoint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SetPoint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SetPoint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SetPoint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SetPoint'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SetPoint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.coolingSetpoint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scoolingSetpoint>%s</%scoolingSetpoint>%s' % (namespace_, self.gds_format_integer(self.coolingSetpoint, input_name='coolingSetpoint'), namespace_, eol_))
        if self.heatingSetpoint is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheatingSetpoint>%s</%sheatingSetpoint>%s' % (namespace_, self.gds_format_integer(self.heatingSetpoint, input_name='heatingSetpoint'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SetPoint'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.coolingSetpoint is not None:
            showIndent(outfile, level)
            outfile.write('coolingSetpoint=%d,\n' % self.coolingSetpoint)
        if self.heatingSetpoint is not None:
            showIndent(outfile, level)
            outfile.write('heatingSetpoint=%d,\n' % self.heatingSetpoint)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'coolingSetpoint':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'coolingSetpoint')
            self.coolingSetpoint = ival_
            self.validate_Int16(self.coolingSetpoint)    # validate type Int16
        elif nodeName_ == 'heatingSetpoint':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'heatingSetpoint')
            self.heatingSetpoint = ival_
            self.validate_Int16(self.heatingSetpoint)    # validate type Int16
# end class SetPoint


class TargetReduction(GeneratedsSuper):
    """The TargetReduction object is used by a Demand Response service
    provider to provide a RECOMMENDED threshold that a
    device/premises should maintain its consumption below. For
    example, a service provider can provide a RECOMMENDED threshold
    of some kWh for a 3-hour event. This means that the
    device/premises would maintain its consumption below the
    specified limit for the specified period."""
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None):
        self.original_tagname_ = None
        self.type_ = type_
        self.value = value
    def factory(*args_, **kwargs_):
        if TargetReduction.subclass:
            return TargetReduction.subclass(*args_, **kwargs_)
        else:
            return TargetReduction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.type_ is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TargetReduction', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetReduction')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TargetReduction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetReduction'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TargetReduction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TargetReduction'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.UnitType(\n')
            self.type_.exportLiteral(outfile, level, name_='type')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'type':
            obj_ = UnitType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt16(self.value)    # validate type UInt16
# end class TargetReduction


class CostKindType(GeneratedsSuper):
    """0 - Carbon Dioxide emissions, in grams per unit 1 - Sulfur Dioxide
    emissions, in grams per unit 2 - Nitrogen Oxides emissions, in
    grams per unit 3 - Renewable generation, as a percentage of
    overall generation All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CostKindType.subclass:
            return CostKindType.subclass(*args_, **kwargs_)
        else:
            return CostKindType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CostKindType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CostKindType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CostKindType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CostKindType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CostKindType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CostKindType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CostKindType


class EnvironmentalCost(GeneratedsSuper):
    """Provides alternative or secondary price information for the relevant
    RateComponent. Supports jurisdictions that seek to convey the
    environmental price per unit of the specified commodity not
    expressed in currency. Implementers and consumers can use this
    attribute to prioritize operations of their HAN devices (e.g.,
    PEV charging during times of high availability of renewable
    electricity resources)."""
    subclass = None
    superclass = None
    def __init__(self, amount=None, costKind=None, costLevel=None, numCostLevels=None):
        self.original_tagname_ = None
        self.amount = amount
        self.costKind = costKind
        self.costLevel = costLevel
        self.numCostLevels = numCostLevels
    def factory(*args_, **kwargs_):
        if EnvironmentalCost.subclass:
            return EnvironmentalCost.subclass(*args_, **kwargs_)
        else:
            return EnvironmentalCost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_amount(self): return self.amount
    def set_amount(self, amount): self.amount = amount
    def get_costKind(self): return self.costKind
    def set_costKind(self, costKind): self.costKind = costKind
    def get_costLevel(self): return self.costLevel
    def set_costLevel(self, costLevel): self.costLevel = costLevel
    def get_numCostLevels(self): return self.numCostLevels
    def set_numCostLevels(self, numCostLevels): self.numCostLevels = numCostLevels
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.amount is not None or
            self.costKind is not None or
            self.costLevel is not None or
            self.numCostLevels is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EnvironmentalCost', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EnvironmentalCost')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EnvironmentalCost', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EnvironmentalCost'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EnvironmentalCost', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespace_, self.gds_format_integer(self.amount, input_name='amount'), namespace_, eol_))
        if self.costKind is not None:
            self.costKind.export(outfile, level, namespace_, name_='costKind', pretty_print=pretty_print)
        if self.costLevel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scostLevel>%s</%scostLevel>%s' % (namespace_, self.gds_format_integer(self.costLevel, input_name='costLevel'), namespace_, eol_))
        if self.numCostLevels is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumCostLevels>%s</%snumCostLevels>%s' % (namespace_, self.gds_format_integer(self.numCostLevels, input_name='numCostLevels'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='EnvironmentalCost'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.amount is not None:
            showIndent(outfile, level)
            outfile.write('amount=%d,\n' % self.amount)
        if self.costKind is not None:
            showIndent(outfile, level)
            outfile.write('costKind=model_.CostKindType(\n')
            self.costKind.exportLiteral(outfile, level, name_='costKind')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.costLevel is not None:
            showIndent(outfile, level)
            outfile.write('costLevel=%d,\n' % self.costLevel)
        if self.numCostLevels is not None:
            showIndent(outfile, level)
            outfile.write('numCostLevels=%d,\n' % self.numCostLevels)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'amount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'amount')
            self.amount = ival_
            self.validate_UInt32(self.amount)    # validate type UInt32
        elif nodeName_ == 'costKind':
            obj_ = CostKindType.factory()
            obj_.build(child_)
            self.costKind = obj_
            obj_.original_tagname_ = 'costKind'
        elif nodeName_ == 'costLevel':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'costLevel')
            self.costLevel = ival_
            self.validate_UInt8(self.costLevel)    # validate type UInt8
        elif nodeName_ == 'numCostLevels':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numCostLevels')
            self.numCostLevels = ival_
            self.validate_UInt8(self.numCostLevels)    # validate type UInt8
# end class EnvironmentalCost


class PriorityType(GeneratedsSuper):
    """Indicates the priority of a message: 0 - Low 1 - Normal 2 - High 3 -
    Critical All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PriorityType.subclass:
            return PriorityType.subclass(*args_, **kwargs_)
        else:
            return PriorityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PriorityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriorityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PriorityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriorityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PriorityType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PriorityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PriorityType


class Charge(GeneratedsSuper):
    """Charges contain charges on a customer bill. These could be items
    like taxes, levies, surcharges, rebates, or others. This is
    meant to allow the HAN device to retrieve enough information to
    be able to reconstruct an estimate of what the total bill would
    look like. Providers can provide line item billing, including
    multiple charge kinds (e.g. taxes, surcharges) at whatever
    granularity desired, using as many Charges as desired during a
    billing period. There can also be any number of Charges
    associated with different ReadingTypes to distinguish between
    TOU tiers, consumption blocks, or demand charges."""
    subclass = None
    superclass = None
    def __init__(self, description=None, kind=None, value=None):
        self.original_tagname_ = None
        self.description = description
        self.kind = kind
        self.value = value
    def factory(*args_, **kwargs_):
        if Charge.subclass:
            return Charge.subclass(*args_, **kwargs_)
        else:
            return Charge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_String20(self, value):
        # Validate type String20, a restriction on xs:string.
        pass
    def validate_Int32(self, value):
        # Validate type Int32, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.description is not None or
            self.kind is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Charge', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Charge')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Charge', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Charge'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Charge', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.kind is not None:
            self.kind.export(outfile, level, namespace_, name_='kind', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Charge'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.kind is not None:
            showIndent(outfile, level)
            outfile.write('kind=model_.ChargeKind(\n')
            self.kind.exportLiteral(outfile, level, name_='kind')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            self.validate_String20(self.description)    # validate type String20
        elif nodeName_ == 'kind':
            obj_ = ChargeKind.factory()
            obj_.build(child_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_Int32(self.value)    # validate type Int32
# end class Charge


class ChargeKind(GeneratedsSuper):
    """Kind of charge. 0 - Consumption Charge 1 - Rebate 2 - Auxiliary
    Charge 3 - Demand Charge 4 - Tax Charge"""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ChargeKind.subclass:
            return ChargeKind.subclass(*args_, **kwargs_)
        else:
            return ChargeKind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ChargeKind', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ChargeKind')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ChargeKind', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ChargeKind'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ChargeKind', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ChargeKind'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ChargeKind


class AccountingUnit(GeneratedsSuper):
    """Unit for accounting; use either 'energyUnit' or 'currencyUnit' to
    specify the unit for 'value'."""
    subclass = None
    superclass = None
    def __init__(self, energyUnit=None, monetaryUnit=None, multiplier=None, value=None):
        self.original_tagname_ = None
        self.energyUnit = energyUnit
        self.monetaryUnit = monetaryUnit
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if AccountingUnit.subclass:
            return AccountingUnit.subclass(*args_, **kwargs_)
        else:
            return AccountingUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energyUnit(self): return self.energyUnit
    def set_energyUnit(self, energyUnit): self.energyUnit = energyUnit
    def get_monetaryUnit(self): return self.monetaryUnit
    def set_monetaryUnit(self, monetaryUnit): self.monetaryUnit = monetaryUnit
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_Int32(self, value):
        # Validate type Int32, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.energyUnit is not None or
            self.monetaryUnit is not None or
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountingUnit', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountingUnit')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountingUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountingUnit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AccountingUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.energyUnit is not None:
            self.energyUnit.export(outfile, level, namespace_, name_='energyUnit', pretty_print=pretty_print)
        if self.monetaryUnit is not None:
            self.monetaryUnit.export(outfile, level, namespace_, name_='monetaryUnit', pretty_print=pretty_print)
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AccountingUnit'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.energyUnit is not None:
            showIndent(outfile, level)
            outfile.write('energyUnit=model_.RealEnergy(\n')
            self.energyUnit.exportLiteral(outfile, level, name_='energyUnit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.monetaryUnit is not None:
            showIndent(outfile, level)
            outfile.write('monetaryUnit=model_.CurrencyCode(\n')
            self.monetaryUnit.exportLiteral(outfile, level, name_='monetaryUnit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'energyUnit':
            obj_ = RealEnergy.factory()
            obj_.build(child_)
            self.energyUnit = obj_
            obj_.original_tagname_ = 'energyUnit'
        elif nodeName_ == 'monetaryUnit':
            obj_ = CurrencyCode.factory()
            obj_.build(child_)
            self.monetaryUnit = obj_
            obj_.original_tagname_ = 'monetaryUnit'
        elif nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_Int32(self.value)    # validate type Int32
# end class AccountingUnit


class PrepayModeType(GeneratedsSuper):
    """0 - Central Wallet 1 - ESI 2 - Local 3 - Credit All other values
    reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PrepayModeType.subclass:
            return PrepayModeType.subclass(*args_, **kwargs_)
        else:
            return PrepayModeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrepayModeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrepayModeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrepayModeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrepayModeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PrepayModeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PrepayModeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PrepayModeType


class ServiceChange(GeneratedsSuper):
    """Specifies a change to the service status."""
    subclass = None
    superclass = None
    def __init__(self, newStatus=None, startTime=None):
        self.original_tagname_ = None
        self.newStatus = newStatus
        self.startTime = startTime
    def factory(*args_, **kwargs_):
        if ServiceChange.subclass:
            return ServiceChange.subclass(*args_, **kwargs_)
        else:
            return ServiceChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_newStatus(self): return self.newStatus
    def set_newStatus(self, newStatus): self.newStatus = newStatus
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def hasContent_(self):
        if (
            self.newStatus is not None or
            self.startTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceChange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceChange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceChange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceChange'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceChange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.newStatus is not None:
            self.newStatus.export(outfile, level, namespace_, name_='newStatus', pretty_print=pretty_print)
        if self.startTime is not None:
            self.startTime.export(outfile, level, namespace_, name_='startTime', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ServiceChange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.newStatus is not None:
            showIndent(outfile, level)
            outfile.write('newStatus=model_.ServiceStatusType(\n')
            self.newStatus.exportLiteral(outfile, level, name_='newStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.startTime is not None:
            showIndent(outfile, level)
            outfile.write('startTime=model_.TimeType(\n')
            self.startTime.exportLiteral(outfile, level, name_='startTime')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'newStatus':
            obj_ = ServiceStatusType.factory()
            obj_.build(child_)
            self.newStatus = obj_
            obj_.original_tagname_ = 'newStatus'
        elif nodeName_ == 'startTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.startTime = obj_
            obj_.original_tagname_ = 'startTime'
# end class ServiceChange


class CreditStatusType(GeneratedsSuper):
    """0 - Credit Ok 1 - Credit Low 2 - Credit Exhausted 3 - Credit
    Negative All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CreditStatusType.subclass:
            return CreditStatusType.subclass(*args_, **kwargs_)
        else:
            return CreditStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditStatusType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CreditStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditStatusType


class CreditTypeType(GeneratedsSuper):
    """0 - Regular 1 - Emergency 2 - Regular, then Emergency 3 - Emergency,
    then Regular All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CreditTypeType.subclass:
            return CreditTypeType.subclass(*args_, **kwargs_)
        else:
            return CreditTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditTypeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditTypeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditTypeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CreditTypeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CreditTypeType


class CreditTypeChange(GeneratedsSuper):
    """Specifies a change to the credit type."""
    subclass = None
    superclass = None
    def __init__(self, newType=None, startTime=None):
        self.original_tagname_ = None
        self.newType = newType
        self.startTime = startTime
    def factory(*args_, **kwargs_):
        if CreditTypeChange.subclass:
            return CreditTypeChange.subclass(*args_, **kwargs_)
        else:
            return CreditTypeChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_newType(self): return self.newType
    def set_newType(self, newType): self.newType = newType
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def hasContent_(self):
        if (
            self.newType is not None or
            self.startTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditTypeChange', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditTypeChange')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditTypeChange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditTypeChange'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CreditTypeChange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.newType is not None:
            self.newType.export(outfile, level, namespace_, name_='newType', pretty_print=pretty_print)
        if self.startTime is not None:
            self.startTime.export(outfile, level, namespace_, name_='startTime', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CreditTypeChange'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.newType is not None:
            showIndent(outfile, level)
            outfile.write('newType=model_.CreditTypeType(\n')
            self.newType.exportLiteral(outfile, level, name_='newType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.startTime is not None:
            showIndent(outfile, level)
            outfile.write('startTime=model_.TimeType(\n')
            self.startTime.exportLiteral(outfile, level, name_='startTime')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'newType':
            obj_ = CreditTypeType.factory()
            obj_.build(child_)
            self.newType = obj_
            obj_.original_tagname_ = 'newType'
        elif nodeName_ == 'startTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.startTime = obj_
            obj_.original_tagname_ = 'startTime'
# end class CreditTypeChange


class ServiceStatusType(GeneratedsSuper):
    """0 - Connected 1 - Disconnected 2 - Armed for Connect 3 - Armed for
    Disconnect 4 - No Contactor 5 - Load Limited All other values
    reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ServiceStatusType.subclass:
            return ServiceStatusType.subclass(*args_, **kwargs_)
        else:
            return ServiceStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceStatusType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ServiceStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ServiceStatusType


class RequestStatus(GeneratedsSuper):
    """The RequestStatus object is used to indicate the current status of a
    Flow Reservation Request."""
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, requestStatus=None):
        self.original_tagname_ = None
        self.dateTime = dateTime
        self.requestStatus = requestStatus
    def factory(*args_, **kwargs_):
        if RequestStatus.subclass:
            return RequestStatus.subclass(*args_, **kwargs_)
        else:
            return RequestStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_requestStatus(self): return self.requestStatus
    def set_requestStatus(self, requestStatus): self.requestStatus = requestStatus
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.requestStatus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RequestStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RequestStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RequestStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RequestStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RequestStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.requestStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequestStatus>%s</%srequestStatus>%s' % (namespace_, self.gds_format_integer(self.requestStatus, input_name='requestStatus'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RequestStatus'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.TimeType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.requestStatus is not None:
            showIndent(outfile, level)
            outfile.write('requestStatus=%d,\n' % self.requestStatus)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'requestStatus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'requestStatus')
            self.requestStatus = ival_
            self.validate_UInt8(self.requestStatus)    # validate type UInt8
# end class RequestStatus


class DERType(GeneratedsSuper):
    """0 - Not applicable / Unknown 1 - Virtual or mixed DER 2 -
    Reciprocating engine 3 - Fuel cell 4 - Photovoltaic system 5 -
    Combined heat and power 80 - Storage (immobile) 81 - Electric
    vehicle / EVSE 82 - Combined PV and storage All other values
    reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DERType.subclass:
            return DERType.subclass(*args_, **kwargs_)
        else:
            return DERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DERType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DERType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DERType


class DERControlBase(GeneratedsSuper):
    """Distributed Energy Resource (DER) control values."""
    subclass = None
    superclass = None
    def __init__(self, opModFixedFlow=None, opModFixedPF=None, opModFixedVAr=None, opModFixedW=None, opModFreqWatt=None, opModHVRT=None, opModLVRT=None, opModVoltVAr=None, opModVoltWatt=None, opModWattPF=None, rampTms=None):
        self.original_tagname_ = None
        self.opModFixedFlow = opModFixedFlow
        self.opModFixedPF = opModFixedPF
        self.opModFixedVAr = opModFixedVAr
        self.opModFixedW = opModFixedW
        self.opModFreqWatt = opModFreqWatt
        self.opModHVRT = opModHVRT
        self.opModLVRT = opModLVRT
        self.opModVoltVAr = opModVoltVAr
        self.opModVoltWatt = opModVoltWatt
        self.opModWattPF = opModWattPF
        self.rampTms = rampTms
    def factory(*args_, **kwargs_):
        if DERControlBase.subclass:
            return DERControlBase.subclass(*args_, **kwargs_)
        else:
            return DERControlBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_opModFixedFlow(self): return self.opModFixedFlow
    def set_opModFixedFlow(self, opModFixedFlow): self.opModFixedFlow = opModFixedFlow
    def get_opModFixedPF(self): return self.opModFixedPF
    def set_opModFixedPF(self, opModFixedPF): self.opModFixedPF = opModFixedPF
    def get_opModFixedVAr(self): return self.opModFixedVAr
    def set_opModFixedVAr(self, opModFixedVAr): self.opModFixedVAr = opModFixedVAr
    def get_opModFixedW(self): return self.opModFixedW
    def set_opModFixedW(self, opModFixedW): self.opModFixedW = opModFixedW
    def get_opModFreqWatt(self): return self.opModFreqWatt
    def set_opModFreqWatt(self, opModFreqWatt): self.opModFreqWatt = opModFreqWatt
    def get_opModHVRT(self): return self.opModHVRT
    def set_opModHVRT(self, opModHVRT): self.opModHVRT = opModHVRT
    def get_opModLVRT(self): return self.opModLVRT
    def set_opModLVRT(self, opModLVRT): self.opModLVRT = opModLVRT
    def get_opModVoltVAr(self): return self.opModVoltVAr
    def set_opModVoltVAr(self, opModVoltVAr): self.opModVoltVAr = opModVoltVAr
    def get_opModVoltWatt(self): return self.opModVoltWatt
    def set_opModVoltWatt(self, opModVoltWatt): self.opModVoltWatt = opModVoltWatt
    def get_opModWattPF(self): return self.opModWattPF
    def set_opModWattPF(self, opModWattPF): self.opModWattPF = opModWattPF
    def get_rampTms(self): return self.rampTms
    def set_rampTms(self, rampTms): self.rampTms = rampTms
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.opModFixedFlow is not None or
            self.opModFixedPF is not None or
            self.opModFixedVAr is not None or
            self.opModFixedW is not None or
            self.opModFreqWatt is not None or
            self.opModHVRT is not None or
            self.opModLVRT is not None or
            self.opModVoltVAr is not None or
            self.opModVoltWatt is not None or
            self.opModWattPF is not None or
            self.rampTms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERControlBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERControlBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERControlBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERControlBase'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DERControlBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.opModFixedFlow is not None:
            self.opModFixedFlow.export(outfile, level, namespace_, name_='opModFixedFlow', pretty_print=pretty_print)
        if self.opModFixedPF is not None:
            self.opModFixedPF.export(outfile, level, namespace_, name_='opModFixedPF', pretty_print=pretty_print)
        if self.opModFixedVAr is not None:
            self.opModFixedVAr.export(outfile, level, namespace_, name_='opModFixedVAr', pretty_print=pretty_print)
        if self.opModFixedW is not None:
            self.opModFixedW.export(outfile, level, namespace_, name_='opModFixedW', pretty_print=pretty_print)
        if self.opModFreqWatt is not None:
            self.opModFreqWatt.export(outfile, level, namespace_, name_='opModFreqWatt', pretty_print=pretty_print)
        if self.opModHVRT is not None:
            self.opModHVRT.export(outfile, level, namespace_, name_='opModHVRT', pretty_print=pretty_print)
        if self.opModLVRT is not None:
            self.opModLVRT.export(outfile, level, namespace_, name_='opModLVRT', pretty_print=pretty_print)
        if self.opModVoltVAr is not None:
            self.opModVoltVAr.export(outfile, level, namespace_, name_='opModVoltVAr', pretty_print=pretty_print)
        if self.opModVoltWatt is not None:
            self.opModVoltWatt.export(outfile, level, namespace_, name_='opModVoltWatt', pretty_print=pretty_print)
        if self.opModWattPF is not None:
            self.opModWattPF.export(outfile, level, namespace_, name_='opModWattPF', pretty_print=pretty_print)
        if self.rampTms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srampTms>%s</%srampTms>%s' % (namespace_, self.gds_format_integer(self.rampTms, input_name='rampTms'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DERControlBase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.opModFixedFlow is not None:
            showIndent(outfile, level)
            outfile.write('opModFixedFlow=model_.SignedPerCent(\n')
            self.opModFixedFlow.exportLiteral(outfile, level, name_='opModFixedFlow')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.opModFixedPF is not None:
            showIndent(outfile, level)
            outfile.write('opModFixedPF=model_.FixedPowerFactor(\n')
            self.opModFixedPF.exportLiteral(outfile, level, name_='opModFixedPF')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.opModFixedVAr is not None:
            showIndent(outfile, level)
            outfile.write('opModFixedVAr=model_.FixedVAr(\n')
            self.opModFixedVAr.exportLiteral(outfile, level, name_='opModFixedVAr')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.opModFixedW is not None:
            showIndent(outfile, level)
            outfile.write('opModFixedW=model_.PerCent(\n')
            self.opModFixedW.exportLiteral(outfile, level, name_='opModFixedW')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.opModFreqWatt is not None:
            showIndent(outfile, level)
            outfile.write('opModFreqWatt=model_.DERCurveLink(\n')
            self.opModFreqWatt.exportLiteral(outfile, level, name_='opModFreqWatt')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.opModHVRT is not None:
            showIndent(outfile, level)
            outfile.write('opModHVRT=model_.CurvePairType(\n')
            self.opModHVRT.exportLiteral(outfile, level, name_='opModHVRT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.opModLVRT is not None:
            showIndent(outfile, level)
            outfile.write('opModLVRT=model_.CurvePairType(\n')
            self.opModLVRT.exportLiteral(outfile, level, name_='opModLVRT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.opModVoltVAr is not None:
            showIndent(outfile, level)
            outfile.write('opModVoltVAr=model_.DERCurveLink(\n')
            self.opModVoltVAr.exportLiteral(outfile, level, name_='opModVoltVAr')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.opModVoltWatt is not None:
            showIndent(outfile, level)
            outfile.write('opModVoltWatt=model_.DERCurveLink(\n')
            self.opModVoltWatt.exportLiteral(outfile, level, name_='opModVoltWatt')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.opModWattPF is not None:
            showIndent(outfile, level)
            outfile.write('opModWattPF=model_.DERCurveLink(\n')
            self.opModWattPF.exportLiteral(outfile, level, name_='opModWattPF')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rampTms is not None:
            showIndent(outfile, level)
            outfile.write('rampTms=%d,\n' % self.rampTms)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'opModFixedFlow':
            obj_ = SignedPerCent.factory()
            obj_.build(child_)
            self.opModFixedFlow = obj_
            obj_.original_tagname_ = 'opModFixedFlow'
        elif nodeName_ == 'opModFixedPF':
            obj_ = FixedPowerFactor.factory()
            obj_.build(child_)
            self.opModFixedPF = obj_
            obj_.original_tagname_ = 'opModFixedPF'
        elif nodeName_ == 'opModFixedVAr':
            obj_ = FixedVAr.factory()
            obj_.build(child_)
            self.opModFixedVAr = obj_
            obj_.original_tagname_ = 'opModFixedVAr'
        elif nodeName_ == 'opModFixedW':
            obj_ = PerCent.factory()
            obj_.build(child_)
            self.opModFixedW = obj_
            obj_.original_tagname_ = 'opModFixedW'
        elif nodeName_ == 'opModFreqWatt':
            obj_ = DERCurveLink.factory()
            obj_.build(child_)
            self.opModFreqWatt = obj_
            obj_.original_tagname_ = 'opModFreqWatt'
        elif nodeName_ == 'opModHVRT':
            obj_ = CurvePairType.factory()
            obj_.build(child_)
            self.opModHVRT = obj_
            obj_.original_tagname_ = 'opModHVRT'
        elif nodeName_ == 'opModLVRT':
            obj_ = CurvePairType.factory()
            obj_.build(child_)
            self.opModLVRT = obj_
            obj_.original_tagname_ = 'opModLVRT'
        elif nodeName_ == 'opModVoltVAr':
            obj_ = DERCurveLink.factory()
            obj_.build(child_)
            self.opModVoltVAr = obj_
            obj_.original_tagname_ = 'opModVoltVAr'
        elif nodeName_ == 'opModVoltWatt':
            obj_ = DERCurveLink.factory()
            obj_.build(child_)
            self.opModVoltWatt = obj_
            obj_.original_tagname_ = 'opModVoltWatt'
        elif nodeName_ == 'opModWattPF':
            obj_ = DERCurveLink.factory()
            obj_.build(child_)
            self.opModWattPF = obj_
            obj_.original_tagname_ = 'opModWattPF'
        elif nodeName_ == 'rampTms':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rampTms')
            self.rampTms = ival_
            self.validate_UInt16(self.rampTms)    # validate type UInt16
# end class DERControlBase


class DERControlType(GeneratedsSuper):
    """Control modes supported by the DER. Bit positions SHALL be defined
    as follows: 0 - Volt-VAr Mode 1 - Frequency-Watt Mode 2 - Watt-
    PowerFactor Mode 3 - Volt-Watt Mode 4 - Low Voltage Ride Through
    Mode 5 - High Voltage Ride Through Mode 6-9 - reserved 10 -
    setGenConnect 11 - setStorConnect 12 - Fixed W 13 - Fixed VAr 14
    - Fixed PF 15 - Charge mode 16 - Discharge mode All other values
    reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DERControlType.subclass:
            return DERControlType.subclass(*args_, **kwargs_)
        else:
            return DERControlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERControlType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERControlType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERControlType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERControlType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DERControlType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DERControlType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DERControlType


class CurveData(GeneratedsSuper):
    """Data point values for defining a curve or schedule"""
    subclass = None
    superclass = None
    def __init__(self, excitation=None, xvalue=None, yvalue=None):
        self.original_tagname_ = None
        self.excitation = excitation
        self.xvalue = xvalue
        self.yvalue = yvalue
    def factory(*args_, **kwargs_):
        if CurveData.subclass:
            return CurveData.subclass(*args_, **kwargs_)
        else:
            return CurveData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_excitation(self): return self.excitation
    def set_excitation(self, excitation): self.excitation = excitation
    def get_xvalue(self): return self.xvalue
    def set_xvalue(self, xvalue): self.xvalue = xvalue
    def get_yvalue(self): return self.yvalue
    def set_yvalue(self, yvalue): self.yvalue = yvalue
    def validate_Int8(self, value):
        # Validate type Int8, a restriction on xs:byte.
        pass
    def validate_Int32(self, value):
        # Validate type Int32, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.excitation is not None or
            self.xvalue is not None or
            self.yvalue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurveData', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurveData')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurveData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurveData'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurveData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.excitation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexcitation>%s</%sexcitation>%s' % (namespace_, self.gds_format_integer(self.excitation, input_name='excitation'), namespace_, eol_))
        if self.xvalue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxvalue>%s</%sxvalue>%s' % (namespace_, self.gds_format_integer(self.xvalue, input_name='xvalue'), namespace_, eol_))
        if self.yvalue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syvalue>%s</%syvalue>%s' % (namespace_, self.gds_format_integer(self.yvalue, input_name='yvalue'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CurveData'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.excitation is not None:
            showIndent(outfile, level)
            outfile.write('excitation=%d,\n' % self.excitation)
        if self.xvalue is not None:
            showIndent(outfile, level)
            outfile.write('xvalue=%d,\n' % self.xvalue)
        if self.yvalue is not None:
            showIndent(outfile, level)
            outfile.write('yvalue=%d,\n' % self.yvalue)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'excitation':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'excitation')
            self.excitation = ival_
            self.validate_Int8(self.excitation)    # validate type Int8
        elif nodeName_ == 'xvalue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'xvalue')
            self.xvalue = ival_
            self.validate_Int32(self.xvalue)    # validate type Int32
        elif nodeName_ == 'yvalue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'yvalue')
            self.yvalue = ival_
            self.validate_Int32(self.yvalue)    # validate type Int32
# end class CurveData


class DERCurveType(GeneratedsSuper):
    """0 - Volt-VAr Mode 1 - Frequency-Watt Curve Mode 2 - Watt-PowerFactor
    Mode 3 - Volt-Watt Mode 4 - Low Voltage Ride Through Mode 5 -
    High Voltage Ride Through Mode All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DERCurveType.subclass:
            return DERCurveType.subclass(*args_, **kwargs_)
        else:
            return DERCurveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERCurveType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERCurveType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERCurveType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERCurveType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DERCurveType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DERCurveType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DERCurveType


class CurvePairType(GeneratedsSuper):
    """Specifies a pair of DERCurves."""
    subclass = None
    superclass = None
    def __init__(self, lowerLimit=None, upperLimit=None):
        self.original_tagname_ = None
        self.lowerLimit = lowerLimit
        self.upperLimit = upperLimit
    def factory(*args_, **kwargs_):
        if CurvePairType.subclass:
            return CurvePairType.subclass(*args_, **kwargs_)
        else:
            return CurvePairType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lowerLimit(self): return self.lowerLimit
    def set_lowerLimit(self, lowerLimit): self.lowerLimit = lowerLimit
    def get_upperLimit(self): return self.upperLimit
    def set_upperLimit(self, upperLimit): self.upperLimit = upperLimit
    def hasContent_(self):
        if (
            self.lowerLimit is not None or
            self.upperLimit is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurvePairType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurvePairType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurvePairType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurvePairType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurvePairType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lowerLimit is not None:
            self.lowerLimit.export(outfile, level, namespace_, name_='lowerLimit', pretty_print=pretty_print)
        if self.upperLimit is not None:
            self.upperLimit.export(outfile, level, namespace_, name_='upperLimit', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CurvePairType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.lowerLimit is not None:
            showIndent(outfile, level)
            outfile.write('lowerLimit=model_.DERCurveLink(\n')
            self.lowerLimit.exportLiteral(outfile, level, name_='lowerLimit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.upperLimit is not None:
            showIndent(outfile, level)
            outfile.write('upperLimit=model_.DERCurveLink(\n')
            self.upperLimit.exportLiteral(outfile, level, name_='upperLimit')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lowerLimit':
            obj_ = DERCurveLink.factory()
            obj_.build(child_)
            self.lowerLimit = obj_
            obj_.original_tagname_ = 'lowerLimit'
        elif nodeName_ == 'upperLimit':
            obj_ = DERCurveLink.factory()
            obj_.build(child_)
            self.upperLimit = obj_
            obj_.original_tagname_ = 'upperLimit'
# end class CurvePairType


class DERUnitRefType(GeneratedsSuper):
    """Specifies context for interpreting percent values: 0 - N/A 1 -
    %setMaxW 2 - %setMaxVAr 3 - %statVArAvail 4 - %setEffectiveV 5 -
    %setMaxChargeRate 6 - %setMaxDischargeRate All other values
    reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DERUnitRefType.subclass:
            return DERUnitRefType.subclass(*args_, **kwargs_)
        else:
            return DERUnitRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERUnitRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERUnitRefType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERUnitRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERUnitRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DERUnitRefType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DERUnitRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DERUnitRefType


class CurrentRMS(GeneratedsSuper):
    """Average flow of charge through a conductor."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if CurrentRMS.subclass:
            return CurrentRMS.subclass(*args_, **kwargs_)
        else:
            return CurrentRMS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentRMS', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentRMS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentRMS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentRMS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentRMS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CurrentRMS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt16(self.value)    # validate type UInt16
# end class CurrentRMS


class FixedPointType(GeneratedsSuper):
    """Abstract type for specifying a fixed-point value without a given
    unit of measure."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if FixedPointType.subclass:
            return FixedPointType.subclass(*args_, **kwargs_)
        else:
            return FixedPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_Int16(self, value):
        # Validate type Int16, a restriction on xs:short.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FixedPointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FixedPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedPointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FixedPointType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_Int16(self.value)    # validate type Int16
# end class FixedPointType


class UnsignedFixedPointType(GeneratedsSuper):
    """Abstract type for specifying an unsigned fixed-point value without a
    given unit of measure."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if UnsignedFixedPointType.subclass:
            return UnsignedFixedPointType.subclass(*args_, **kwargs_)
        else:
            return UnsignedFixedPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnsignedFixedPointType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnsignedFixedPointType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnsignedFixedPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnsignedFixedPointType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UnsignedFixedPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='UnsignedFixedPointType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt16(self.value)    # validate type UInt16
# end class UnsignedFixedPointType


class ActivePower(GeneratedsSuper):
    """The active (real) power P (in W) is the product of root-mean-square
    (RMS) voltage, RMS current, and cos(theta) where theta is the
    phase angle of current relative to voltage. It is the primary
    measure of the rate of flow of energy."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if ActivePower.subclass:
            return ActivePower.subclass(*args_, **kwargs_)
        else:
            return ActivePower(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_Int16(self, value):
        # Validate type Int16, a restriction on xs:short.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActivePower', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActivePower')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActivePower', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActivePower'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ActivePower', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ActivePower'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_Int16(self.value)    # validate type Int16
# end class ActivePower


class AmpereHour(GeneratedsSuper):
    """Available electric charge"""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if AmpereHour.subclass:
            return AmpereHour.subclass(*args_, **kwargs_)
        else:
            return AmpereHour(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AmpereHour', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AmpereHour')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AmpereHour', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AmpereHour'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AmpereHour', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AmpereHour'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt16(self.value)    # validate type UInt16
# end class AmpereHour


class ApparentPower(GeneratedsSuper):
    """The apparent power S (in VA) is the product of root mean square
    (RMS) voltage and RMS current."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if ApparentPower.subclass:
            return ApparentPower.subclass(*args_, **kwargs_)
        else:
            return ApparentPower(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ApparentPower', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApparentPower')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ApparentPower', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApparentPower'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ApparentPower', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ApparentPower'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt16(self.value)    # validate type UInt16
# end class ApparentPower


class ReactivePower(GeneratedsSuper):
    """The reactive power Q (in var) is the product of root mean square
    (RMS) voltage, RMS current, and sin(theta) where theta is the
    phase angle of current relative to voltage."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if ReactivePower.subclass:
            return ReactivePower.subclass(*args_, **kwargs_)
        else:
            return ReactivePower(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_Int16(self, value):
        # Validate type Int16, a restriction on xs:short.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReactivePower', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReactivePower')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReactivePower', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReactivePower'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReactivePower', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ReactivePower'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_Int16(self.value)    # validate type Int16
# end class ReactivePower


class FixedPowerFactor(GeneratedsSuper):
    """Specifies a setpoint for Displacement Power Factor, the ratio
    between apparent and active powers at the fundamental frequency
    (e.g. 60 Hz)."""
    subclass = None
    superclass = None
    def __init__(self, displacement=None, multiplier=None):
        self.original_tagname_ = None
        self.displacement = displacement
        self.multiplier = multiplier
    def factory(*args_, **kwargs_):
        if FixedPowerFactor.subclass:
            return FixedPowerFactor.subclass(*args_, **kwargs_)
        else:
            return FixedPowerFactor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_displacement(self): return self.displacement
    def set_displacement(self, displacement): self.displacement = displacement
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def validate_Int16(self, value):
        # Validate type Int16, a restriction on xs:short.
        pass
    def hasContent_(self):
        if (
            self.displacement is not None or
            self.multiplier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FixedPowerFactor', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedPowerFactor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FixedPowerFactor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedPowerFactor'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedPowerFactor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.displacement is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplacement>%s</%sdisplacement>%s' % (namespace_, self.gds_format_integer(self.displacement, input_name='displacement'), namespace_, eol_))
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FixedPowerFactor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.displacement is not None:
            showIndent(outfile, level)
            outfile.write('displacement=%d,\n' % self.displacement)
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'displacement':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'displacement')
            self.displacement = ival_
            self.validate_Int16(self.displacement)    # validate type Int16
        elif nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
# end class FixedPowerFactor


class FixedVAr(GeneratedsSuper):
    """Specifies a signed setpoint for reactive power."""
    subclass = None
    superclass = None
    def __init__(self, refType=None, value=None):
        self.original_tagname_ = None
        self.refType = refType
        self.value = value
    def factory(*args_, **kwargs_):
        if FixedVAr.subclass:
            return FixedVAr.subclass(*args_, **kwargs_)
        else:
            return FixedVAr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refType(self): return self.refType
    def set_refType(self, refType): self.refType = refType
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.refType is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FixedVAr', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FixedVAr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FixedVAr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FixedVAr'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FixedVAr', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.refType is not None:
            self.refType.export(outfile, level, namespace_, name_='refType', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FixedVAr'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.refType is not None:
            showIndent(outfile, level)
            outfile.write('refType=model_.DERUnitRefType(\n')
            self.refType.exportLiteral(outfile, level, name_='refType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.SignedPerCent(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'refType':
            obj_ = DERUnitRefType.factory()
            obj_.build(child_)
            self.refType = obj_
            obj_.original_tagname_ = 'refType'
        elif nodeName_ == 'value':
            obj_ = SignedPerCent.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class FixedVAr


class WattHour(GeneratedsSuper):
    """Active (real) energy"""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if WattHour.subclass:
            return WattHour.subclass(*args_, **kwargs_)
        else:
            return WattHour(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='WattHour', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='WattHour')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='WattHour', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='WattHour'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='WattHour', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='WattHour'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt16(self.value)    # validate type UInt16
# end class WattHour


class VoltageRMS(GeneratedsSuper):
    """Average electric potential difference between two points."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if VoltageRMS.subclass:
            return VoltageRMS.subclass(*args_, **kwargs_)
        else:
            return VoltageRMS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VoltageRMS', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VoltageRMS')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VoltageRMS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VoltageRMS'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VoltageRMS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='VoltageRMS'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt16(self.value)    # validate type UInt16
# end class VoltageRMS


class ConnectStatusType(GeneratedsSuper):
    """DER ConnectStatus value: 0 - N/A 1 - disconnected_unavail 2 -
    disconnected_avail 3 - connected_unavail 4 - connected_avail 5 -
    connected_on 6 - test_mode All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None):
        self.original_tagname_ = None
        self.dateTime = dateTime
        self.value = value
    def factory(*args_, **kwargs_):
        if ConnectStatusType.subclass:
            return ConnectStatusType.subclass(*args_, **kwargs_)
        else:
            return ConnectStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConnectStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConnectStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConnectStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConnectStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConnectStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ConnectStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.TimeType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt8(self.value)    # validate type UInt8
# end class ConnectStatusType


class InverterStatusType(GeneratedsSuper):
    """DER InverterStatus value: 0 - N/A 1 - off 2 - sleeping (auto-
    shutdown) or DER is at low output power/voltage 3 - starting up
    or ON but not producing power 4 - tracking MPPT power point 5 -
    forced power reduction/derating 6 - shutting down 7 - one or
    more faults exist 8 - standby (service on unit) - DER may be at
    high output voltage/power 9 - test mode 10 - as defined in
    manufacturer status All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None):
        self.original_tagname_ = None
        self.dateTime = dateTime
        self.value = value
    def factory(*args_, **kwargs_):
        if InverterStatusType.subclass:
            return InverterStatusType.subclass(*args_, **kwargs_)
        else:
            return InverterStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InverterStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InverterStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='InverterStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InverterStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='InverterStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='InverterStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.TimeType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt8(self.value)    # validate type UInt8
# end class InverterStatusType


class LocalControlModeStatusType(GeneratedsSuper):
    """DER LocalControlModeStatus/value: 0 – local control 1 – remote
    control All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None):
        self.original_tagname_ = None
        self.dateTime = dateTime
        self.value = value
    def factory(*args_, **kwargs_):
        if LocalControlModeStatusType.subclass:
            return LocalControlModeStatusType.subclass(*args_, **kwargs_)
        else:
            return LocalControlModeStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LocalControlModeStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocalControlModeStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LocalControlModeStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocalControlModeStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocalControlModeStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LocalControlModeStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.TimeType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt8(self.value)    # validate type UInt8
# end class LocalControlModeStatusType


class ManufacturerStatusType(GeneratedsSuper):
    """DER ManufacturerStatus/value: String data type"""
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None):
        self.original_tagname_ = None
        self.dateTime = dateTime
        self.value = value
    def factory(*args_, **kwargs_):
        if ManufacturerStatusType.subclass:
            return ManufacturerStatusType.subclass(*args_, **kwargs_)
        else:
            return ManufacturerStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_String6(self, value):
        # Validate type String6, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ManufacturerStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ManufacturerStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ManufacturerStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ManufacturerStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ManufacturerStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_string(quote_xml(self.value).encode(ExternalEncoding), input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ManufacturerStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.TimeType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % quote_python(self.value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.validate_String6(self.value)    # validate type String6
# end class ManufacturerStatusType


class OperationalModeStatusType(GeneratedsSuper):
    """DER OperationalModeStatus value: 0 - Not applicable / Unknown 1 -
    Off 2 - Operational mode 3 - Test mode All other values
    reserved."""
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None):
        self.original_tagname_ = None
        self.dateTime = dateTime
        self.value = value
    def factory(*args_, **kwargs_):
        if OperationalModeStatusType.subclass:
            return OperationalModeStatusType.subclass(*args_, **kwargs_)
        else:
            return OperationalModeStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OperationalModeStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OperationalModeStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OperationalModeStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OperationalModeStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OperationalModeStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OperationalModeStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.TimeType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt8(self.value)    # validate type UInt8
# end class OperationalModeStatusType


class StateOfChargeStatusType(GeneratedsSuper):
    """DER StateOfChargeStatus value: Percent data type"""
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None):
        self.original_tagname_ = None
        self.dateTime = dateTime
        self.value = value
    def factory(*args_, **kwargs_):
        if StateOfChargeStatusType.subclass:
            return StateOfChargeStatusType.subclass(*args_, **kwargs_)
        else:
            return StateOfChargeStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StateOfChargeStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StateOfChargeStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StateOfChargeStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StateOfChargeStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StateOfChargeStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            self.value.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StateOfChargeStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.TimeType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=model_.PerCent(\n')
            self.value.exportLiteral(outfile, level, name_='value')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            obj_ = PerCent.factory()
            obj_.build(child_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class StateOfChargeStatusType


class StorageModeStatusType(GeneratedsSuper):
    """DER StorageModeStatus value: 0 – storage charging 1 – storage
    discharging 2 – storage holding All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None):
        self.original_tagname_ = None
        self.dateTime = dateTime
        self.value = value
    def factory(*args_, **kwargs_):
        if StorageModeStatusType.subclass:
            return StorageModeStatusType.subclass(*args_, **kwargs_)
        else:
            return StorageModeStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='StorageModeStatusType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StorageModeStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='StorageModeStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='StorageModeStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='StorageModeStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='StorageModeStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.TimeType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt8(self.value)    # validate type UInt8
# end class StorageModeStatusType


class Link(GeneratedsSuper):
    """Links provide a reference, via URI, to another resource.A URI
    reference."""
    subclass = None
    superclass = None
    def __init__(self, href=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if Link.subclass:
            return Link.subclass(*args_, **kwargs_)
        else:
            return Link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Link', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Link')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Link', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Link'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Link', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Link'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Link


class ListLink(Link):
    """ListLinks provide a reference, via URI, to a List.Indicates the
    total number of items in the referenced list."""
    subclass = None
    superclass = Link
    def __init__(self, all=None):
        self.original_tagname_ = None
        super(ListLink, self).__init__()
        self.all = _cast(None, all)
    def factory(*args_, **kwargs_):
        if ListLink.subclass:
            return ListLink.subclass(*args_, **kwargs_)
        else:
            return ListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_all(self): return self.all
    def set_all(self, all): self.all = all
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            super(ListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ListLink'):
        super(ListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ListLink')
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            outfile.write(' all=%s' % (quote_attrib(self.all), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ListLink', fromsubclass_=False, pretty_print=True):
        super(ListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            showIndent(outfile, level)
            outfile.write('all=%d,\n' % (self.all,))
        super(ListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.add('all')
            try:
                self.all = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_UInt16(self.all)    # validate type UInt16
        super(ListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ListLink


class Resource(GeneratedsSuper):
    """A resource is an addressable unit of information, either a
    collection (List) or instance of an object (identifiedObject, or
    simply, Resource)A reference to the resource address (URI).
    Required in a response to a GET, ignored otherwise."""
    subclass = None
    superclass = None
    def __init__(self, href=None):
        self.original_tagname_ = None
        self.href = _cast(None, href)
    def factory(*args_, **kwargs_):
        if Resource.subclass:
            return Resource.subclass(*args_, **kwargs_)
        else:
            return Resource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_href(self): return self.href
    def set_href(self, href): self.href = href
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Resource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Resource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Resource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Resource'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_format_string(quote_attrib(self.href).encode(ExternalEncoding), input_name='href'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Resource', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Resource'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            showIndent(outfile, level)
            outfile.write('href="%s",\n' % (self.href,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Resource


class RespondableResource(Resource):
    """A Resource to which a Response can be requested.A reference to the
    response resource address (URI). Required on a response to a GET
    if responseRequired is "true".Indicates whether or not a
    response is required upon receipt, creation or update of this
    resource. Responses shall be posted to the collection specified
    in "replyTo". If the resource has a deviceCategory field,
    devices that match one or more of the device types indicated in
    deviceCategory SHALL respond according to the rules listed
    below. If the category does not match, the device SHALL NOT
    respond. If the resource does not have a deviceCategory field, a
    device receiving the resource SHALL respond according to the
    rules listed below. Value encoded as hex according to the
    following bit assignments, any combination is possible. See
    Table 10-10 for the list of appropriate Response status codes to
    be sent for these purposes. 0 - End device shall indicate that
    message was received 1 - End device shall indicate specific
    response. 2 - End user / customer response is required. All
    other values reserved."""
    subclass = None
    superclass = Resource
    def __init__(self, replyTo=None, responseRequired='00'):
        self.original_tagname_ = None
        super(RespondableResource, self).__init__()
        self.replyTo = _cast(None, replyTo)
        self.responseRequired = _cast(None, responseRequired)
    def factory(*args_, **kwargs_):
        if RespondableResource.subclass:
            return RespondableResource.subclass(*args_, **kwargs_)
        else:
            return RespondableResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_replyTo(self): return self.replyTo
    def set_replyTo(self, replyTo): self.replyTo = replyTo
    def get_responseRequired(self): return self.responseRequired
    def set_responseRequired(self, responseRequired): self.responseRequired = responseRequired
    def validate_HexBinary8(self, value):
        # Validate type HexBinary8, a restriction on xs:hexBinary.
        pass
    def hasContent_(self):
        if (
            super(RespondableResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RespondableResource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RespondableResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RespondableResource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RespondableResource'):
        super(RespondableResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RespondableResource')
        if self.replyTo is not None and 'replyTo' not in already_processed:
            already_processed.add('replyTo')
            outfile.write(' replyTo=%s' % (self.gds_format_string(quote_attrib(self.replyTo).encode(ExternalEncoding), input_name='replyTo'), ))
        if self.responseRequired is not None and 'responseRequired' not in already_processed:
            already_processed.add('responseRequired')
            outfile.write(' responseRequired=%s' % (quote_attrib(self.responseRequired), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RespondableResource', fromsubclass_=False, pretty_print=True):
        super(RespondableResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='RespondableResource'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.replyTo is not None and 'replyTo' not in already_processed:
            already_processed.add('replyTo')
            showIndent(outfile, level)
            outfile.write('replyTo="%s",\n' % (self.replyTo,))
        if self.responseRequired is not None and 'responseRequired' not in already_processed:
            already_processed.add('responseRequired')
            showIndent(outfile, level)
            outfile.write('responseRequired="%s",\n' % (self.responseRequired,))
        super(RespondableResource, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RespondableResource, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('replyTo', node)
        if value is not None and 'replyTo' not in already_processed:
            already_processed.add('replyTo')
            self.replyTo = value
        value = find_attr_value_('responseRequired', node)
        if value is not None and 'responseRequired' not in already_processed:
            already_processed.add('responseRequired')
            self.responseRequired = value
            self.validate_HexBinary8(self.responseRequired)    # validate type HexBinary8
        super(RespondableResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RespondableResource, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RespondableResource


class RespondableSubscribableIdentifiedObject(RespondableResource):
    """An IdentifiedObject to which a Response can be requested.Indicates
    whether or not subscriptions are supported for this resource,
    and whether or not conditional (thresholds) are supported. If
    not specified, is "not subscribable" (0)."""
    subclass = None
    superclass = RespondableResource
    def __init__(self, subscribable='0', mRID=None, description=None, version=None):
        self.original_tagname_ = None
        super(RespondableSubscribableIdentifiedObject, self).__init__()
        self.subscribable = _cast(None, subscribable)
        self.mRID = mRID
        self.description = description
        self.version = version
    def factory(*args_, **kwargs_):
        if RespondableSubscribableIdentifiedObject.subclass:
            return RespondableSubscribableIdentifiedObject.subclass(*args_, **kwargs_)
        else:
            return RespondableSubscribableIdentifiedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mRID(self): return self.mRID
    def set_mRID(self, mRID): self.mRID = mRID
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_subscribable(self): return self.subscribable
    def set_subscribable(self, subscribable): self.subscribable = subscribable
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def validate_SubscribableType(self, value):
        # Validate type SubscribableType, a restriction on UInt8.
        pass
    def hasContent_(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(RespondableSubscribableIdentifiedObject, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RespondableSubscribableIdentifiedObject', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RespondableSubscribableIdentifiedObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RespondableSubscribableIdentifiedObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RespondableSubscribableIdentifiedObject'):
        super(RespondableSubscribableIdentifiedObject, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RespondableSubscribableIdentifiedObject')
        if self.subscribable is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            outfile.write(' subscribable=%s' % (quote_attrib(self.subscribable), ))
    def exportChildren(self, outfile, level, namespace_='', name_='RespondableSubscribableIdentifiedObject', fromsubclass_=False, pretty_print=True):
        super(RespondableSubscribableIdentifiedObject, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            self.mRID.export(outfile, level, namespace_, name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RespondableSubscribableIdentifiedObject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.subscribable is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            showIndent(outfile, level)
            outfile.write('subscribable=%d,\n' % (self.subscribable,))
        super(RespondableSubscribableIdentifiedObject, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RespondableSubscribableIdentifiedObject, self).exportLiteralChildren(outfile, level, name_)
        if self.mRID is not None:
            showIndent(outfile, level)
            outfile.write('mRID=model_.mRIDType(\n')
            self.mRID.exportLiteral(outfile, level, name_='mRID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=model_.VersionType(\n')
            self.version.exportLiteral(outfile, level, name_='version')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subscribable', node)
        if value is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            self.subscribable = value
            self.validate_SubscribableType(self.subscribable)    # validate type SubscribableType
        super(RespondableSubscribableIdentifiedObject, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory()
            obj_.build(child_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            self.validate_String32(self.description)    # validate type String32
        elif nodeName_ == 'version':
            obj_ = VersionType.factory()
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(RespondableSubscribableIdentifiedObject, self).buildChildren(child_, node, nodeName_, True)
# end class RespondableSubscribableIdentifiedObject


class SubscribableResource(Resource):
    """A Resource to which a Subscription can be requested.Indicates
    whether or not subscriptions are supported for this resource,
    and whether or not conditional (thresholds) are supported. If
    not specified, is "not subscribable" (0)."""
    subclass = None
    superclass = Resource
    def __init__(self, subscribable='0'):
        self.original_tagname_ = None
        super(SubscribableResource, self).__init__()
        self.subscribable = _cast(None, subscribable)
    def factory(*args_, **kwargs_):
        if SubscribableResource.subclass:
            return SubscribableResource.subclass(*args_, **kwargs_)
        else:
            return SubscribableResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subscribable(self): return self.subscribable
    def set_subscribable(self, subscribable): self.subscribable = subscribable
    def validate_SubscribableType(self, value):
        # Validate type SubscribableType, a restriction on UInt8.
        pass
    def hasContent_(self):
        if (
            super(SubscribableResource, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubscribableResource', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubscribableResource')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubscribableResource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubscribableResource'):
        super(SubscribableResource, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubscribableResource')
        if self.subscribable is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            outfile.write(' subscribable=%s' % (quote_attrib(self.subscribable), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubscribableResource', fromsubclass_=False, pretty_print=True):
        super(SubscribableResource, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SubscribableResource'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.subscribable is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            showIndent(outfile, level)
            outfile.write('subscribable=%d,\n' % (self.subscribable,))
        super(SubscribableResource, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubscribableResource, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subscribable', node)
        if value is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            self.subscribable = value
            self.validate_SubscribableType(self.subscribable)    # validate type SubscribableType
        super(SubscribableResource, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SubscribableResource, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SubscribableResource


class Error(GeneratedsSuper):
    """Contains information about the nature of an error if a request could
    not be completed successfully."""
    subclass = None
    superclass = None
    def __init__(self, maxRetryDuration=None, reasonCode=None):
        self.original_tagname_ = None
        self.maxRetryDuration = maxRetryDuration
        self.reasonCode = reasonCode
    def factory(*args_, **kwargs_):
        if Error.subclass:
            return Error.subclass(*args_, **kwargs_)
        else:
            return Error(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_maxRetryDuration(self): return self.maxRetryDuration
    def set_maxRetryDuration(self, maxRetryDuration): self.maxRetryDuration = maxRetryDuration
    def get_reasonCode(self): return self.reasonCode
    def set_reasonCode(self, reasonCode): self.reasonCode = reasonCode
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.maxRetryDuration is not None or
            self.reasonCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Error', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Error')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Error', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Error'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Error', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.maxRetryDuration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxRetryDuration>%s</%smaxRetryDuration>%s' % (namespace_, self.gds_format_integer(self.maxRetryDuration, input_name='maxRetryDuration'), namespace_, eol_))
        if self.reasonCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreasonCode>%s</%sreasonCode>%s' % (namespace_, self.gds_format_integer(self.reasonCode, input_name='reasonCode'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Error'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.maxRetryDuration is not None:
            showIndent(outfile, level)
            outfile.write('maxRetryDuration=%d,\n' % self.maxRetryDuration)
        if self.reasonCode is not None:
            showIndent(outfile, level)
            outfile.write('reasonCode=%d,\n' % self.reasonCode)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'maxRetryDuration':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maxRetryDuration')
            self.maxRetryDuration = ival_
            self.validate_UInt16(self.maxRetryDuration)    # validate type UInt16
        elif nodeName_ == 'reasonCode':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'reasonCode')
            self.reasonCode = ival_
            self.validate_UInt16(self.reasonCode)    # validate type UInt16
# end class Error


class Event(RespondableSubscribableIdentifiedObject):
    """An Event indicates information that applies to a particular period
    of time. Events SHALL be executed relative to the time of the
    server, as described in the Time function set section 11.1."""
    subclass = None
    superclass = RespondableSubscribableIdentifiedObject
    def __init__(self, creationTime=None, EventStatus=None, interval=None):
        self.original_tagname_ = None
        super(Event, self).__init__()
        self.creationTime = creationTime
        self.EventStatus = EventStatus
        self.interval = interval
    def factory(*args_, **kwargs_):
        if Event.subclass:
            return Event.subclass(*args_, **kwargs_)
        else:
            return Event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creationTime(self): return self.creationTime
    def set_creationTime(self, creationTime): self.creationTime = creationTime
    def get_EventStatus(self): return self.EventStatus
    def set_EventStatus(self, EventStatus): self.EventStatus = EventStatus
    def get_interval(self): return self.interval
    def set_interval(self, interval): self.interval = interval
    def hasContent_(self):
        if (
            self.creationTime is not None or
            self.EventStatus is not None or
            self.interval is not None or
            super(Event, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Event', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Event')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Event'):
        super(Event, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Event')
    def exportChildren(self, outfile, level, namespace_='', name_='Event', fromsubclass_=False, pretty_print=True):
        super(Event, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creationTime is not None:
            self.creationTime.export(outfile, level, namespace_, name_='creationTime', pretty_print=pretty_print)
        if self.EventStatus is not None:
            self.EventStatus.export(outfile, level, namespace_, name_='EventStatus', pretty_print=pretty_print)
        if self.interval is not None:
            self.interval.export(outfile, level, namespace_, name_='interval', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Event'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Event, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Event, self).exportLiteralChildren(outfile, level, name_)
        if self.creationTime is not None:
            showIndent(outfile, level)
            outfile.write('creationTime=model_.TimeType(\n')
            self.creationTime.exportLiteral(outfile, level, name_='creationTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EventStatus is not None:
            showIndent(outfile, level)
            outfile.write('EventStatus=model_.EventStatus(\n')
            self.EventStatus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.interval is not None:
            showIndent(outfile, level)
            outfile.write('interval=model_.DateTimeInterval(\n')
            self.interval.exportLiteral(outfile, level, name_='interval')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Event, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creationTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.creationTime = obj_
            obj_.original_tagname_ = 'creationTime'
        elif nodeName_ == 'EventStatus':
            obj_ = EventStatus.factory()
            obj_.build(child_)
            self.EventStatus = obj_
            obj_.original_tagname_ = 'EventStatus'
        elif nodeName_ == 'interval':
            obj_ = DateTimeInterval.factory()
            obj_.build(child_)
            self.interval = obj_
            obj_.original_tagname_ = 'interval'
        super(Event, self).buildChildren(child_, node, nodeName_, True)
# end class Event


class EventStatus(GeneratedsSuper):
    """Current status information relevant to a specific object. The Status
    object is used to indicate the current status of an Event.
    Devices can read the containing resource (e.g. TextMessage) to
    get the most up to date status of the event. Devices can also
    subscribe to a specific resource instance to get updates when
    any of its attributes change, including the Status object."""
    subclass = None
    superclass = None
    def __init__(self, currentStatus=None, dateTime=None, potentiallySuperseded=None, potentiallySupersededTime=None, reason=None):
        self.original_tagname_ = None
        self.currentStatus = currentStatus
        self.dateTime = dateTime
        self.potentiallySuperseded = potentiallySuperseded
        self.potentiallySupersededTime = potentiallySupersededTime
        self.reason = reason
    def factory(*args_, **kwargs_):
        if EventStatus.subclass:
            return EventStatus.subclass(*args_, **kwargs_)
        else:
            return EventStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currentStatus(self): return self.currentStatus
    def set_currentStatus(self, currentStatus): self.currentStatus = currentStatus
    def get_dateTime(self): return self.dateTime
    def set_dateTime(self, dateTime): self.dateTime = dateTime
    def get_potentiallySuperseded(self): return self.potentiallySuperseded
    def set_potentiallySuperseded(self, potentiallySuperseded): self.potentiallySuperseded = potentiallySuperseded
    def get_potentiallySupersededTime(self): return self.potentiallySupersededTime
    def set_potentiallySupersededTime(self, potentiallySupersededTime): self.potentiallySupersededTime = potentiallySupersededTime
    def get_reason(self): return self.reason
    def set_reason(self, reason): self.reason = reason
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_String192(self, value):
        # Validate type String192, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.currentStatus is not None or
            self.dateTime is not None or
            self.potentiallySuperseded is not None or
            self.potentiallySupersededTime is not None or
            self.reason is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EventStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EventStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EventStatus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EventStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentStatus>%s</%scurrentStatus>%s' % (namespace_, self.gds_format_integer(self.currentStatus, input_name='currentStatus'), namespace_, eol_))
        if self.dateTime is not None:
            self.dateTime.export(outfile, level, namespace_, name_='dateTime', pretty_print=pretty_print)
        if self.potentiallySuperseded is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spotentiallySuperseded>%s</%spotentiallySuperseded>%s' % (namespace_, self.gds_format_boolean(self.potentiallySuperseded, input_name='potentiallySuperseded'), namespace_, eol_))
        if self.potentiallySupersededTime is not None:
            self.potentiallySupersededTime.export(outfile, level, namespace_, name_='potentiallySupersededTime', pretty_print=pretty_print)
        if self.reason is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreason>%s</%sreason>%s' % (namespace_, self.gds_format_string(quote_xml(self.reason).encode(ExternalEncoding), input_name='reason'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='EventStatus'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.currentStatus is not None:
            showIndent(outfile, level)
            outfile.write('currentStatus=%d,\n' % self.currentStatus)
        if self.dateTime is not None:
            showIndent(outfile, level)
            outfile.write('dateTime=model_.TimeType(\n')
            self.dateTime.exportLiteral(outfile, level, name_='dateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.potentiallySuperseded is not None:
            showIndent(outfile, level)
            outfile.write('potentiallySuperseded=%s,\n' % self.potentiallySuperseded)
        if self.potentiallySupersededTime is not None:
            showIndent(outfile, level)
            outfile.write('potentiallySupersededTime=model_.TimeType(\n')
            self.potentiallySupersededTime.exportLiteral(outfile, level, name_='potentiallySupersededTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reason is not None:
            showIndent(outfile, level)
            outfile.write('reason=%s,\n' % quote_python(self.reason).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currentStatus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'currentStatus')
            self.currentStatus = ival_
            self.validate_UInt8(self.currentStatus)    # validate type UInt8
        elif nodeName_ == 'dateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'potentiallySuperseded':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'potentiallySuperseded')
            self.potentiallySuperseded = ival_
        elif nodeName_ == 'potentiallySupersededTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.potentiallySupersededTime = obj_
            obj_.original_tagname_ = 'potentiallySupersededTime'
        elif nodeName_ == 'reason':
            reason_ = child_.text
            reason_ = self.gds_validate_string(reason_, node, 'reason')
            self.reason = reason_
            self.validate_String192(self.reason)    # validate type String192
# end class EventStatus


class RandomizableEvent(Event):
    """An Event that can indicate time ranges over which the start time and
    duration SHALL be randomized."""
    subclass = None
    superclass = Event
    def __init__(self, randomizeDuration=None, randomizeStart=None):
        self.original_tagname_ = None
        super(RandomizableEvent, self).__init__()
        self.randomizeDuration = randomizeDuration
        self.randomizeStart = randomizeStart
    def factory(*args_, **kwargs_):
        if RandomizableEvent.subclass:
            return RandomizableEvent.subclass(*args_, **kwargs_)
        else:
            return RandomizableEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_randomizeDuration(self): return self.randomizeDuration
    def set_randomizeDuration(self, randomizeDuration): self.randomizeDuration = randomizeDuration
    def get_randomizeStart(self): return self.randomizeStart
    def set_randomizeStart(self, randomizeStart): self.randomizeStart = randomizeStart
    def hasContent_(self):
        if (
            self.randomizeDuration is not None or
            self.randomizeStart is not None or
            super(RandomizableEvent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RandomizableEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RandomizableEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RandomizableEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RandomizableEvent'):
        super(RandomizableEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RandomizableEvent')
    def exportChildren(self, outfile, level, namespace_='', name_='RandomizableEvent', fromsubclass_=False, pretty_print=True):
        super(RandomizableEvent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.randomizeDuration is not None:
            self.randomizeDuration.export(outfile, level, namespace_, name_='randomizeDuration', pretty_print=pretty_print)
        if self.randomizeStart is not None:
            self.randomizeStart.export(outfile, level, namespace_, name_='randomizeStart', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RandomizableEvent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RandomizableEvent, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RandomizableEvent, self).exportLiteralChildren(outfile, level, name_)
        if self.randomizeDuration is not None:
            showIndent(outfile, level)
            outfile.write('randomizeDuration=model_.OneHourRangeType(\n')
            self.randomizeDuration.exportLiteral(outfile, level, name_='randomizeDuration')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.randomizeStart is not None:
            showIndent(outfile, level)
            outfile.write('randomizeStart=model_.OneHourRangeType(\n')
            self.randomizeStart.exportLiteral(outfile, level, name_='randomizeStart')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RandomizableEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'randomizeDuration':
            obj_ = OneHourRangeType.factory()
            obj_.build(child_)
            self.randomizeDuration = obj_
            obj_.original_tagname_ = 'randomizeDuration'
        elif nodeName_ == 'randomizeStart':
            obj_ = OneHourRangeType.factory()
            obj_.build(child_)
            self.randomizeStart = obj_
            obj_.original_tagname_ = 'randomizeStart'
        super(RandomizableEvent, self).buildChildren(child_, node, nodeName_, True)
# end class RandomizableEvent


class AccumulationBehaviourType(GeneratedsSuper):
    """0 = Not Applicable (default, if not specified) 3 = Cumulative The
    sum of the previous billing period values. Note:
    “Cumulative” is commonly used in conjunction with
    “demand.” Each demand reset causes the maximum demand value
    for the present billing period (since the last demand reset) to
    accumulate as an accumulative total of all maximum demands. So
    instead of “zeroing” the demand register, a demand reset has
    the affect of adding the present maximum demand to this
    accumulating total. 4 = DeltaData The difference between the
    value at the end of the prescribed interval and the beginning of
    the interval. This is used for incremental interval data. Note:
    One common application would be for load profile data, another
    use might be to report the number of events within an interval
    (such as the number of equipment energizations within the
    specified period of time.) 6 = Indicating As if a needle is
    swung out on the meter face to a value to indicate the current
    value. (Note: An “indicating” value is typically measured
    over hundreds of milliseconds or greater, or may imply a
    “pusher” mechanism to capture a value. Compare this to
    “instantaneous” which is measured over a shorter period of
    time.) 9 = Summation A form of accumulation which is selective
    with respect to time. Note : “Summation” could be considered
    a specialization of “Bulk Quantity” according to the rules
    of inheritance where “Summation” selectively accumulates
    pulses over a timing pattern, and “BulkQuantity” accumulates
    pulses all of the time. 12 = Instantaneous Typically measured
    over the fastest period of time allowed by the definition of the
    metric (usually milliseconds or tens of milliseconds.) (Note:
    “Instantaneous” was moved to attribute #3 in 61968-9Ed2 from
    attribute #1 in 61968-9Ed1.) All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if AccumulationBehaviourType.subclass:
            return AccumulationBehaviourType.subclass(*args_, **kwargs_)
        else:
            return AccumulationBehaviourType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccumulationBehaviourType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccumulationBehaviourType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccumulationBehaviourType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccumulationBehaviourType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AccumulationBehaviourType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='AccumulationBehaviourType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AccumulationBehaviourType


class ApplianceLoadReductionType(GeneratedsSuper):
    """0 - Delay Appliance Load Parameter requesting the appliance to
    respond by providing a moderate load reduction for the duration
    of a delay period. Typically referring to a “non-emergency”
    event in which appliances can continue operating if already in a
    load consuming period. 1 - Temporary Appliance Load Reduction
    Parameter requesting the appliance to respond by providing an
    aggressive load reduction for a short time period. Typically
    referring to an “emergency/spinning reserve” event in which
    an appliance should start shedding load if currently in a load
    consuming period. * Full definition of how appliances react when
    receiving each parameter is document in the EPA document -
    ENERGY STAR® Program Requirements, Product Specification for
    Residential Refrigerators and Freezers, Eligibility Criteria 5,
    Draft 2 Version 5.0. All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ApplianceLoadReductionType.subclass:
            return ApplianceLoadReductionType.subclass(*args_, **kwargs_)
        else:
            return ApplianceLoadReductionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ApplianceLoadReductionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ApplianceLoadReductionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ApplianceLoadReductionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ApplianceLoadReductionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ApplianceLoadReductionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ApplianceLoadReductionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ApplianceLoadReductionType


class CommodityType(GeneratedsSuper):
    """0 = Not Applicable (default, if not specified) 1 = Electricity
    secondary metered value (a premises meter is typically a
    secondary meter) 2 = Electricity primary metered value 4 = Air 7
    = NaturalGas 8 = Propane 9 = PotableWater 10 = Steam 11 =
    WasteWater 12 = HeatingFluid 13 = CoolingFluid All other values
    reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CommodityType.subclass:
            return CommodityType.subclass(*args_, **kwargs_)
        else:
            return CommodityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CommodityType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CommodityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CommodityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CommodityType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CommodityType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CommodityType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CommodityType


class ConsumptionBlockType(GeneratedsSuper):
    """0 = Not Applicable (default, if not specified) 1 = Block 1 2 = Block
    2 3 = Block 3 4 = Block 4 5 = Block 5 6 = Block 6 7 = Block 7 8
    = Block 8 9 = Block 9 10 = Block 10 11 = Block 11 12 = Block 12
    13 = Block 13 14 = Block 14 15 = Block 15 16 = Block 16 All
    other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ConsumptionBlockType.subclass:
            return ConsumptionBlockType.subclass(*args_, **kwargs_)
        else:
            return ConsumptionBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConsumptionBlockType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumptionBlockType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConsumptionBlockType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConsumptionBlockType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ConsumptionBlockType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ConsumptionBlockType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ConsumptionBlockType


class CurrencyCode(GeneratedsSuper):
    """Follows codes defined in [ISO 4217]. 0 - Not Applicable (default, if
    not specified) 36 - Australian Dollar 124 - Canadian Dollar 840
    - US Dollar 978 - Euro This is not a complete list."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrencyCode.subclass:
            return CurrencyCode.subclass(*args_, **kwargs_)
        else:
            return CurrencyCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrencyCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrencyCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrencyCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrencyCode'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CurrencyCode', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CurrencyCode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CurrencyCode


class DataQualifierType(GeneratedsSuper):
    """0 = Not Applicable (default, if not specified) 2 = Average 8 =
    Maximum 9 = Minimum 12 = Normal All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DataQualifierType.subclass:
            return DataQualifierType.subclass(*args_, **kwargs_)
        else:
            return DataQualifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DataQualifierType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataQualifierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DataQualifierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DataQualifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DataQualifierType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DataQualifierType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DataQualifierType


class DateTimeInterval(GeneratedsSuper):
    """Interval of date and time."""
    subclass = None
    superclass = None
    def __init__(self, duration=None, start=None):
        self.original_tagname_ = None
        self.duration = duration
        self.start = start
    def factory(*args_, **kwargs_):
        if DateTimeInterval.subclass:
            return DateTimeInterval.subclass(*args_, **kwargs_)
        else:
            return DateTimeInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_start(self): return self.start
    def set_start(self, start): self.start = start
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def hasContent_(self):
        if (
            self.duration is not None or
            self.start is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DateTimeInterval', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DateTimeInterval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DateTimeInterval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DateTimeInterval'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DateTimeInterval', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.duration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespace_, self.gds_format_integer(self.duration, input_name='duration'), namespace_, eol_))
        if self.start is not None:
            self.start.export(outfile, level, namespace_, name_='start', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DateTimeInterval'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.duration is not None:
            showIndent(outfile, level)
            outfile.write('duration=%d,\n' % self.duration)
        if self.start is not None:
            showIndent(outfile, level)
            outfile.write('start=model_.TimeType(\n')
            self.start.exportLiteral(outfile, level, name_='start')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'duration':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'duration')
            self.duration = ival_
            self.validate_UInt32(self.duration)    # validate type UInt32
        elif nodeName_ == 'start':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.start = obj_
            obj_.original_tagname_ = 'start'
# end class DateTimeInterval


class DeviceCategoryType(GeneratedsSuper):
    """The Device category types defined. Bit positions SHALL be defined as
    follows: 0 - Programmable Communicating Thermostat 1 - Strip
    Heaters 2 - Baseboard Heaters 3 - Water Heater 4 - Pool Pump 5 -
    Sauna 6 - Hot tub 7 - Smart Appliance 8 - Irrigation Pump 9 -
    Managed Commercial and Industrial (C&amp;I) Loads 10 - Simple
    misc. (Residential On/Off) loads 11 - Exterior Lighting 12 -
    Interior Lighting 13 - Electric Vehicle 14 - Generation Systems
    15 - Load Control Switch 16 - Smart Inverter 17 - EVSE 18 - RESU
    19 - Energy Management System 20 - Smart Energy Module All other
    values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DeviceCategoryType.subclass:
            return DeviceCategoryType.subclass(*args_, **kwargs_)
        else:
            return DeviceCategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceCategoryType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceCategoryType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeviceCategoryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceCategoryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceCategoryType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DeviceCategoryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DeviceCategoryType


class DstRuleType(GeneratedsSuper):
    """Bit map encoded rule from which is calculated the start or end time,
    within the current year, to which daylight savings time offset
    must be applied. The rule encoding: Bits 0 - 11: seconds 0 -
    3599 Bits 12 - 16: hours 0 - 23 Bits 17 - 19: day of the week 0
    = not applicable, 1 - 7 (Monday = 1) Bits:20 - 24: day of the
    month 0 = not applicable, 1 - 31 Bits: 25 - 27: operator
    (detailed below) Bits: 28 - 31: month 1 - 12 Rule value of
    0xFFFFFFFF means rule processing/DST correction is disabled. The
    operators: 0: DST starts/ends on the Day of the Month 1: DST
    starts/ends on the Day of the Week that is on or after the Day
    of the Month 2: DST starts/ends on the first occurrence of the
    Day of the Week in a month 3: DST starts/ends on the second
    occurrence of the Day of the Week in a month 4: DST starts/ends
    on the third occurrence of the Day of the Week in a month 5: DST
    starts/ends on the forth occurrence of the Day of the Week in a
    month 6: DST starts/ends on the fifth occurrence of the Day of
    the Week in a month 7: DST starts/ends on the last occurrence of
    the Day of the Week in a month An example: DST starts on third
    Friday in March at 1:45 AM. The rule... Seconds: 2700 Hours: 1
    Day of Week: 5 Day of Month: 0 Operator: 4 Month: 3"""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if DstRuleType.subclass:
            return DstRuleType.subclass(*args_, **kwargs_)
        else:
            return DstRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DstRuleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DstRuleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DstRuleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DstRuleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='DstRuleType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='DstRuleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DstRuleType


class FlowDirectionType(GeneratedsSuper):
    """0 = Not Applicable (default, if not specified) 1 = Forward
    (delivered to customer) 19 = Reverse (received from customer)
    All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if FlowDirectionType.subclass:
            return FlowDirectionType.subclass(*args_, **kwargs_)
        else:
            return FlowDirectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlowDirectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowDirectionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FlowDirectionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlowDirectionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FlowDirectionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='FlowDirectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FlowDirectionType


class KindType(GeneratedsSuper):
    """0 = Not Applicable (default, if not specified) 3 = Currency 8 =
    Demand 12 = Energy 37 = Power All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if KindType.subclass:
            return KindType.subclass(*args_, **kwargs_)
        else:
            return KindType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='KindType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KindType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='KindType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='KindType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='KindType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='KindType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class KindType


class LocaleType(GeneratedsSuper):
    """[RFC 4646] identifier of a language-region"""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if LocaleType.subclass:
            return LocaleType.subclass(*args_, **kwargs_)
        else:
            return LocaleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LocaleType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LocaleType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LocaleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LocaleType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LocaleType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LocaleType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LocaleType


class mRIDType(GeneratedsSuper):
    """A master resource identifier. The IANA PEN [PEN] provider ID SHALL
    be specified in bits 0-31, the least-significant bits, and
    objects created by that provider SHALL be assigned unique IDs
    with the remaining 96 bits.
    0xFFFFFFFFFFFFFFFFFFFFFFFF[XXXXXXXX], where [XXXXXXXX] is the
    PEN, is reserved for a object that is being created (e.g., a
    ReadingSet for the current time that is still accumulating).
    Except for this special reserved identifier, each modification
    of an object (resource) representation MUST have a different
    "version"."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if mRIDType.subclass:
            return mRIDType.subclass(*args_, **kwargs_)
        else:
            return mRIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='mRIDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='mRIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='mRIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='mRIDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='mRIDType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='mRIDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class mRIDType


class OneHourRangeType(GeneratedsSuper):
    """A signed time offset, typically applied to a Time value, expressed
    in seconds, with range -3600 to 3600."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if OneHourRangeType.subclass:
            return OneHourRangeType.subclass(*args_, **kwargs_)
        else:
            return OneHourRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OneHourRangeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OneHourRangeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OneHourRangeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OneHourRangeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OneHourRangeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='OneHourRangeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OneHourRangeType


class PENType(GeneratedsSuper):
    """IANA Private Enterprise Number [PEN]."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PENType.subclass:
            return PENType.subclass(*args_, **kwargs_)
        else:
            return PENType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PENType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PENType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PENType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PENType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PENType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PENType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PENType


class PerCent(GeneratedsSuper):
    """Used for percentages, specified in hundredths of a percent, 0 -
    10000. (10000 = 100%)"""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PerCent.subclass:
            return PerCent.subclass(*args_, **kwargs_)
        else:
            return PerCent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PerCent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PerCent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PerCent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PerCent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PerCent', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PerCent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PerCent


class PhaseCode(GeneratedsSuper):
    """0 = Not Applicable (default, if not specified) 32 = Phase C (and S2)
    33 = Phase CN (and S2N) 40 = Phase CA 64 = Phase B 65 = Phase BN
    66 = Phase BC 128 = Phase A (and S1) 129 = Phase AN (and S1N)
    132 = Phase AB 224 = Phase ABC All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PhaseCode.subclass:
            return PhaseCode.subclass(*args_, **kwargs_)
        else:
            return PhaseCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PhaseCode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PhaseCode')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PhaseCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PhaseCode'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PhaseCode', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PhaseCode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PhaseCode


class PINType(GeneratedsSuper):
    """6 digit unsigned decimal integer (0 - 999999). (Note that this only
    requires 20 bits, if it can be allocated.)"""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PINType.subclass:
            return PINType.subclass(*args_, **kwargs_)
        else:
            return PINType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PINType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PINType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PINType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PINType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PINType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PINType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PINType


class PowerOfTenMultiplierType(GeneratedsSuper):
    """-9 = nano=x10^-9 -6 = micro=x10^-6 -3 = milli=x10^-3 0 = none=x1
    (default, if not specified) 1 = deca=x10 2 = hecto=x100 3 =
    kilo=x1000 6 = Mega=x10^6 9 = Giga=x10^9 This is not a complete
    list. Any integer between -9 and 9 SHALL be supported,
    indicating the power of ten multiplier for the units."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PowerOfTenMultiplierType.subclass:
            return PowerOfTenMultiplierType.subclass(*args_, **kwargs_)
        else:
            return PowerOfTenMultiplierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PowerOfTenMultiplierType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerOfTenMultiplierType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PowerOfTenMultiplierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PowerOfTenMultiplierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PowerOfTenMultiplierType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PowerOfTenMultiplierType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PowerOfTenMultiplierType


class PrimacyType(GeneratedsSuper):
    """Values possible for indication of "Primary" provider: 0: In home
    energy management system 1: Contracted premises service provider
    2: Non-contractual service provider All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if PrimacyType.subclass:
            return PrimacyType.subclass(*args_, **kwargs_)
        else:
            return PrimacyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrimacyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrimacyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrimacyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrimacyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PrimacyType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PrimacyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PrimacyType


class RealEnergy(GeneratedsSuper):
    """Real electrical energy"""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if RealEnergy.subclass:
            return RealEnergy.subclass(*args_, **kwargs_)
        else:
            return RealEnergy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_UInt48(self, value):
        # Validate type UInt48, a restriction on xs:unsignedLong.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RealEnergy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RealEnergy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RealEnergy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RealEnergy'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RealEnergy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RealEnergy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_UInt48(self.value)    # validate type UInt48
# end class RealEnergy


class RoleFlagsType(GeneratedsSuper):
    """Specifies the roles that apply to a usage point. Bit 0 - isMirror -
    SHALL be set if the server is not the measurement device Bit 1 -
    isPremisesAggregationPoint - SHALL be set if the UsagePoint is
    the point of delivery for a premises Bit 2 - isPEV - SHALL be
    set if the usage applies to an electric vehicle Bit 3 - isDER -
    SHALL be set if the usage applies to a distributed energy
    resource, capable of delivering power to the grid. Bit 4 -
    isRevenueQuality - SHALL be set if usage was measured by a
    device certified as revenue quality Bit 5 - isDC - SHALL be set
    if the usage point measures direct current Bit 6 - isSubmeter -
    SHALL be set if the usage point is not a premises aggregation
    point Bit 7-15 - Reserved"""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if RoleFlagsType.subclass:
            return RoleFlagsType.subclass(*args_, **kwargs_)
        else:
            return RoleFlagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RoleFlagsType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RoleFlagsType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RoleFlagsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RoleFlagsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RoleFlagsType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='RoleFlagsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RoleFlagsType


class ServiceKind(GeneratedsSuper):
    """Service kind 0 - electricity 1 - gas 2 - water 3 - time 4 - pressure
    5 - heat 6 - cooling All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ServiceKind.subclass:
            return ServiceKind.subclass(*args_, **kwargs_)
        else:
            return ServiceKind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceKind', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceKind')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceKind', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceKind'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceKind', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ServiceKind'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ServiceKind


class SFDIType(GeneratedsSuper):
    """Unsigned integer, max inclusive 687194767359, which is 2^36-1
    (68719476735), with added check digit. See Section 8.3.2 for
    check digit calculation."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SFDIType.subclass:
            return SFDIType.subclass(*args_, **kwargs_)
        else:
            return SFDIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SFDIType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SFDIType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SFDIType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SFDIType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SFDIType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SFDIType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SFDIType


class SignedPerCent(GeneratedsSuper):
    """Used for signed percentages, specified in hundredths of a percent,
    -10000 - 10000. (10000 = 100%)"""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if SignedPerCent.subclass:
            return SignedPerCent.subclass(*args_, **kwargs_)
        else:
            return SignedPerCent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            # Added by Kisensum so that 0 value will generate element
            self.valueOf_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignedPerCent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignedPerCent')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignedPerCent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignedPerCent'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SignedPerCent', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SignedPerCent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SignedPerCent


class SignedRealEnergy(GeneratedsSuper):
    """Real electrical energy, signed."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.value = value
    def factory(*args_, **kwargs_):
        if SignedRealEnergy.subclass:
            return SignedRealEnergy.subclass(*args_, **kwargs_)
        else:
            return SignedRealEnergy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_Int48(self, value):
        # Validate type Int48, a restriction on xs:long.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SignedRealEnergy', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SignedRealEnergy')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SignedRealEnergy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SignedRealEnergy'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SignedRealEnergy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SignedRealEnergy'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_Int48(self.value)    # validate type Int48
# end class SignedRealEnergy


class TimeOffsetType(GeneratedsSuper):
    """A signed time offset, typically applied to a Time value, expressed
    in seconds."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TimeOffsetType.subclass:
            return TimeOffsetType.subclass(*args_, **kwargs_)
        else:
            return TimeOffsetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeOffsetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeOffsetType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeOffsetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeOffsetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimeOffsetType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TimeOffsetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeOffsetType


class TimeType(GeneratedsSuper):
    """Time is a signed 64 bit value representing the number of seconds
    since 0 hours, 0 minutes, 0 seconds, on the 1st of January,
    1970, in UTC, not counting leap seconds."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TimeType.subclass:
            return TimeType.subclass(*args_, **kwargs_)
        else:
            return TimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TimeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TimeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TimeType


class TOUType(GeneratedsSuper):
    """0 = Not Applicable (default, if not specified) 1 = TOU A 2 = TOU B 3
    = TOU C 4 = TOU D 5 = TOU E 6 = TOU F 7 = TOU G 8 = TOU H 9 =
    TOU I 10 = TOU J 11 = TOU K 12 = TOU L 13 = TOU M 14 = TOU N 15
    = TOU O All other values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TOUType.subclass:
            return TOUType.subclass(*args_, **kwargs_)
        else:
            return TOUType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TOUType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TOUType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TOUType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TOUType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TOUType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TOUType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TOUType


class UnitType(GeneratedsSuper):
    """The unit types defined for end device control target reductions. 0 -
    kWh 1 - kW 2 - Watts 3 - Cubic Meters 4 - Cubic Feet 5 - US
    Gallons 6 - Imperial Gallons 7 - BTUs 8 - Liters 9 - kPA (gauge)
    10 - kPA (absolute) 11 - Mega Joule 12 - Unitless All other
    values reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UnitType.subclass:
            return UnitType.subclass(*args_, **kwargs_)
        else:
            return UnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnitType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnitType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnitType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UnitType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='UnitType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UnitType


class UnitValueType(GeneratedsSuper):
    """Type for specification of a specific value, with units and power of
    ten multiplier."""
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, unit=None, value=None):
        self.original_tagname_ = None
        self.multiplier = multiplier
        self.unit = unit
        self.value = value
    def factory(*args_, **kwargs_):
        if UnitValueType.subclass:
            return UnitValueType.subclass(*args_, **kwargs_)
        else:
            return UnitValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_multiplier(self): return self.multiplier
    def set_multiplier(self, multiplier): self.multiplier = multiplier
    def get_unit(self): return self.unit
    def set_unit(self, unit): self.unit = unit
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_Int32(self, value):
        # Validate type Int32, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.multiplier is not None or
            self.unit is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UnitValueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UnitValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UnitValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UnitValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UnitValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            self.multiplier.export(outfile, level, namespace_, name_='multiplier', pretty_print=pretty_print)
        if self.unit is not None:
            self.unit.export(outfile, level, namespace_, name_='unit', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='UnitValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.multiplier is not None:
            showIndent(outfile, level)
            outfile.write('multiplier=model_.PowerOfTenMultiplierType(\n')
            self.multiplier.exportLiteral(outfile, level, name_='multiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.unit is not None:
            showIndent(outfile, level)
            outfile.write('unit=model_.UomType(\n')
            self.unit.exportLiteral(outfile, level, name_='unit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'unit':
            obj_ = UomType.factory()
            obj_.build(child_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_Int32(self.value)    # validate type Int32
# end class UnitValueType


class UomType(GeneratedsSuper):
    """0 = Not Applicable (default, if not specified) 5 = A (Current in
    Amperes (RMS)) 6 = Kelvin (Temperature) 23 = Degrees Celsius
    (Relative temperature) 29 = Voltage 31 = J (Energy joule) 33 =
    Hz (Frequency) 38 =W (Real power in Watts) 42 = m3 (Cubic Meter)
    61 = VA (Apparent power) 63 = var (Reactive power) 65 = CosTheta
    (Displacement Power Factor) 67 = V² (Volts squared) 69 = A²
    (Amp squared) 71 = VAh (Apparent energy) 72 = Wh (Real energy in
    Watt-hours) 73 = varh (Reactive energy) 106 = Ah (Ampere-hours /
    Available Charge) 119 = ft3 (Cubic Feet) 122 = ft3/h (Cubic Feet
    per Hour) 125 = m3/h (Cubic Meter per Hour) 128 = US gl (US
    Gallons) 129 = US gl/h (US Gallons per Hour) 130 = IMP gl
    (Imperial Gallons) 131 = IMP gl/h (Imperial Gallons per Hour)
    132 = BTU 133 = BTU/h 134 = Liter 137 = L/h (Liters per Hour)
    140 = PA(gauge) 155 = PA(absolute) 169 = Therm All other values
    reserved."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if UomType.subclass:
            return UomType.subclass(*args_, **kwargs_)
        else:
            return UomType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UomType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UomType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UomType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UomType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='UomType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='UomType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class UomType


class VersionType(GeneratedsSuper):
    """Version SHALL indicate a distinct identifier for each revision of an
    IdentifiedObject. If not specified, a default version of "0"
    (initial version) SHALL be assumed. Upon modification of any
    IdentifiedObject, the mRID SHALL remain the same, but the
    version SHALL be incremented. Servers MAY NOT modify objects
    that they did not create, unless they were notified of the
    change from the entity controlling the object's PEN."""
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None):
        self.original_tagname_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if VersionType.subclass:
            return VersionType.subclass(*args_, **kwargs_)
        else:
            return VersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='VersionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VersionType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='VersionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='VersionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='VersionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='VersionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class VersionType


class ReadingBase(Resource):
    """Specific value measured by a meter or other asset. ReadingBase is
    abstract, used to define the elements common to Reading and
    IntervalReading."""
    subclass = None
    superclass = Resource
    def __init__(self, consumptionBlock=None, qualityFlags=None, timePeriod=None, touTier=None, value=None):
        self.original_tagname_ = None
        super(ReadingBase, self).__init__()
        self.consumptionBlock = consumptionBlock
        self.qualityFlags = qualityFlags
        self.timePeriod = timePeriod
        self.touTier = touTier
        self.value = value
    def factory(*args_, **kwargs_):
        if ReadingBase.subclass:
            return ReadingBase.subclass(*args_, **kwargs_)
        else:
            return ReadingBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_consumptionBlock(self): return self.consumptionBlock
    def set_consumptionBlock(self, consumptionBlock): self.consumptionBlock = consumptionBlock
    def get_qualityFlags(self): return self.qualityFlags
    def set_qualityFlags(self, qualityFlags): self.qualityFlags = qualityFlags
    def get_timePeriod(self): return self.timePeriod
    def set_timePeriod(self, timePeriod): self.timePeriod = timePeriod
    def get_touTier(self): return self.touTier
    def set_touTier(self, touTier): self.touTier = touTier
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def validate_HexBinary16(self, value):
        # Validate type HexBinary16, a restriction on xs:hexBinary.
        pass
    def validate_Int48(self, value):
        # Validate type Int48, a restriction on xs:long.
        pass
    def hasContent_(self):
        if (
            self.consumptionBlock is not None or
            self.qualityFlags is not None or
            self.timePeriod is not None or
            self.touTier is not None or
            self.value is not None or
            super(ReadingBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingBase'):
        super(ReadingBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingBase')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingBase', fromsubclass_=False, pretty_print=True):
        super(ReadingBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.consumptionBlock is not None:
            self.consumptionBlock.export(outfile, level, namespace_, name_='consumptionBlock', pretty_print=pretty_print)
        if self.qualityFlags is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squalityFlags>%s</%squalityFlags>%s' % (namespace_, self.gds_format_string(quote_xml(self.qualityFlags).encode(ExternalEncoding), input_name='qualityFlags'), namespace_, eol_))
        if self.timePeriod is not None:
            self.timePeriod.export(outfile, level, namespace_, name_='timePeriod', pretty_print=pretty_print)
        if self.touTier is not None:
            self.touTier.export(outfile, level, namespace_, name_='touTier', pretty_print=pretty_print)
        if self.value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespace_, self.gds_format_integer(self.value, input_name='value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ReadingBase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingBase, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingBase, self).exportLiteralChildren(outfile, level, name_)
        if self.consumptionBlock is not None:
            showIndent(outfile, level)
            outfile.write('consumptionBlock=model_.ConsumptionBlockType(\n')
            self.consumptionBlock.exportLiteral(outfile, level, name_='consumptionBlock')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.qualityFlags is not None:
            showIndent(outfile, level)
            outfile.write('qualityFlags=%s,\n' % quote_python(self.qualityFlags).encode(ExternalEncoding))
        if self.timePeriod is not None:
            showIndent(outfile, level)
            outfile.write('timePeriod=model_.DateTimeInterval(\n')
            self.timePeriod.exportLiteral(outfile, level, name_='timePeriod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.touTier is not None:
            showIndent(outfile, level)
            outfile.write('touTier=model_.TOUType(\n')
            self.touTier.exportLiteral(outfile, level, name_='touTier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.value is not None:
            showIndent(outfile, level)
            outfile.write('value=%d,\n' % self.value)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'consumptionBlock':
            obj_ = ConsumptionBlockType.factory()
            obj_.build(child_)
            self.consumptionBlock = obj_
            obj_.original_tagname_ = 'consumptionBlock'
        elif nodeName_ == 'qualityFlags':
            qualityFlags_ = child_.text
            qualityFlags_ = self.gds_validate_string(qualityFlags_, node, 'qualityFlags')
            self.qualityFlags = qualityFlags_
            self.validate_HexBinary16(self.qualityFlags)    # validate type HexBinary16
        elif nodeName_ == 'timePeriod':
            obj_ = DateTimeInterval.factory()
            obj_.build(child_)
            self.timePeriod = obj_
            obj_.original_tagname_ = 'timePeriod'
        elif nodeName_ == 'touTier':
            obj_ = TOUType.factory()
            obj_.build(child_)
            self.touTier = obj_
            obj_.original_tagname_ = 'touTier'
        elif nodeName_ == 'value':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.validate_Int48(self.value)    # validate type Int48
        super(ReadingBase, self).buildChildren(child_, node, nodeName_, True)
# end class ReadingBase


class SubscribableList(SubscribableResource):
    """A List to which a Subscription can be requested.The number
    specifying "all" of the items in the list. Required on GET,
    ignored otherwise.Indicates the number of items in this page of
    results."""
    subclass = None
    superclass = SubscribableResource
    def __init__(self, all=None, results=None):
        self.original_tagname_ = None
        super(SubscribableList, self).__init__()
        self.all = _cast(None, all)
        self.results = _cast(None, results)
    def factory(*args_, **kwargs_):
        if SubscribableList.subclass:
            return SubscribableList.subclass(*args_, **kwargs_)
        else:
            return SubscribableList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_all(self): return self.all
    def set_all(self, all): self.all = all
    def get_results(self): return self.results
    def set_results(self, results): self.results = results
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            super(SubscribableList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubscribableList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubscribableList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubscribableList', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubscribableList'):
        super(SubscribableList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubscribableList')
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            outfile.write(' all=%s' % (quote_attrib(self.all), ))
        if self.results is not None and 'results' not in already_processed:
            already_processed.add('results')
            outfile.write(' results=%s' % (quote_attrib(self.results), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SubscribableList', fromsubclass_=False, pretty_print=True):
        super(SubscribableList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SubscribableList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            showIndent(outfile, level)
            outfile.write('all=%d,\n' % (self.all,))
        if self.results is not None and 'results' not in already_processed:
            already_processed.add('results')
            showIndent(outfile, level)
            outfile.write('results=%d,\n' % (self.results,))
        super(SubscribableList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubscribableList, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.add('all')
            try:
                self.all = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_UInt16(self.all)    # validate type UInt16
        value = find_attr_value_('results', node)
        if value is not None and 'results' not in already_processed:
            already_processed.add('results')
            try:
                self.results = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_UInt8(self.results)    # validate type UInt8
        super(SubscribableList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SubscribableList, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SubscribableList


class SubscribableIdentifiedObject(SubscribableResource):
    """An IdentifiedObject to which a Subscription can be requested."""
    subclass = None
    superclass = SubscribableResource
    def __init__(self, mRID=None, description=None, version=None):
        self.original_tagname_ = None
        super(SubscribableIdentifiedObject, self).__init__()
        self.mRID = mRID
        self.description = description
        self.version = version
    def factory(*args_, **kwargs_):
        if SubscribableIdentifiedObject.subclass:
            return SubscribableIdentifiedObject.subclass(*args_, **kwargs_)
        else:
            return SubscribableIdentifiedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mRID(self): return self.mRID
    def set_mRID(self, mRID): self.mRID = mRID
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(SubscribableIdentifiedObject, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubscribableIdentifiedObject', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubscribableIdentifiedObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubscribableIdentifiedObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubscribableIdentifiedObject'):
        super(SubscribableIdentifiedObject, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubscribableIdentifiedObject')
    def exportChildren(self, outfile, level, namespace_='', name_='SubscribableIdentifiedObject', fromsubclass_=False, pretty_print=True):
        super(SubscribableIdentifiedObject, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            self.mRID.export(outfile, level, namespace_, name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubscribableIdentifiedObject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubscribableIdentifiedObject, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubscribableIdentifiedObject, self).exportLiteralChildren(outfile, level, name_)
        if self.mRID is not None:
            showIndent(outfile, level)
            outfile.write('mRID=model_.mRIDType(\n')
            self.mRID.exportLiteral(outfile, level, name_='mRID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=model_.VersionType(\n')
            self.version.exportLiteral(outfile, level, name_='version')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubscribableIdentifiedObject, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory()
            obj_.build(child_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            self.validate_String32(self.description)    # validate type String32
        elif nodeName_ == 'version':
            obj_ = VersionType.factory()
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(SubscribableIdentifiedObject, self).buildChildren(child_, node, nodeName_, True)
# end class SubscribableIdentifiedObject


class RespondableIdentifiedObject(RespondableResource):
    """An IdentifiedObject to which a Response can be requested."""
    subclass = None
    superclass = RespondableResource
    def __init__(self, mRID=None, description=None, version=None):
        self.original_tagname_ = None
        super(RespondableIdentifiedObject, self).__init__()
        self.mRID = mRID
        self.description = description
        self.version = version
    def factory(*args_, **kwargs_):
        if RespondableIdentifiedObject.subclass:
            return RespondableIdentifiedObject.subclass(*args_, **kwargs_)
        else:
            return RespondableIdentifiedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mRID(self): return self.mRID
    def set_mRID(self, mRID): self.mRID = mRID
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(RespondableIdentifiedObject, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RespondableIdentifiedObject', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RespondableIdentifiedObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RespondableIdentifiedObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RespondableIdentifiedObject'):
        super(RespondableIdentifiedObject, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RespondableIdentifiedObject')
    def exportChildren(self, outfile, level, namespace_='', name_='RespondableIdentifiedObject', fromsubclass_=False, pretty_print=True):
        super(RespondableIdentifiedObject, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            self.mRID.export(outfile, level, namespace_, name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RespondableIdentifiedObject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RespondableIdentifiedObject, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RespondableIdentifiedObject, self).exportLiteralChildren(outfile, level, name_)
        if self.mRID is not None:
            showIndent(outfile, level)
            outfile.write('mRID=model_.mRIDType(\n')
            self.mRID.exportLiteral(outfile, level, name_='mRID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=model_.VersionType(\n')
            self.version.exportLiteral(outfile, level, name_='version')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RespondableIdentifiedObject, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory()
            obj_.build(child_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            self.validate_String32(self.description)    # validate type String32
        elif nodeName_ == 'version':
            obj_ = VersionType.factory()
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(RespondableIdentifiedObject, self).buildChildren(child_, node, nodeName_, True)
# end class RespondableIdentifiedObject


class List(Resource):
    """Container to hold a collection of object instances or references.
    See [ZB 11-0167] Design Patterns section for additional
    details.The number specifying "all" of the items in the list.
    Required on a response to a GET, ignored otherwise.Indicates the
    number of items in this page of results."""
    subclass = None
    superclass = Resource
    def __init__(self, all=None, results=None):
        self.original_tagname_ = None
        super(List, self).__init__()
        self.all = _cast(None, all)
        self.results = _cast(None, results)
    def factory(*args_, **kwargs_):
        if List.subclass:
            return List.subclass(*args_, **kwargs_)
        else:
            return List(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_all(self): return self.all
    def set_all(self, all): self.all = all
    def get_results(self): return self.results
    def set_results(self, results): self.results = results
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            super(List, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='List', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List'):
        super(List, self).exportAttributes(outfile, level, already_processed, namespace_, name_='List')
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            outfile.write(' all=%s' % (quote_attrib(self.all), ))
        if self.results is not None and 'results' not in already_processed:
            already_processed.add('results')
            outfile.write(' results=%s' % (quote_attrib(self.results), ))
    def exportChildren(self, outfile, level, namespace_='', name_='List', fromsubclass_=False, pretty_print=True):
        super(List, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='List'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            showIndent(outfile, level)
            outfile.write('all=%d,\n' % (self.all,))
        if self.results is not None and 'results' not in already_processed:
            already_processed.add('results')
            showIndent(outfile, level)
            outfile.write('results=%d,\n' % (self.results,))
        super(List, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(List, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.add('all')
            try:
                self.all = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_UInt16(self.all)    # validate type UInt16
        value = find_attr_value_('results', node)
        if value is not None and 'results' not in already_processed:
            already_processed.add('results')
            try:
                self.results = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            self.validate_UInt8(self.results)    # validate type UInt8
        super(List, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(List, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class List


class IdentifiedObject(Resource):
    """This is a root class to provide common naming attributes for all
    classes needing naming attributes"""
    subclass = None
    superclass = Resource
    def __init__(self, mRID=None, description=None, version=None):
        self.original_tagname_ = None
        super(IdentifiedObject, self).__init__()
        self.mRID = mRID
        self.description = description
        self.version = version
    def factory(*args_, **kwargs_):
        if IdentifiedObject.subclass:
            return IdentifiedObject.subclass(*args_, **kwargs_)
        else:
            return IdentifiedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mRID(self): return self.mRID
    def set_mRID(self, mRID): self.mRID = mRID
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(IdentifiedObject, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifiedObject', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedObject')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifiedObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifiedObject'):
        super(IdentifiedObject, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifiedObject')
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifiedObject', fromsubclass_=False, pretty_print=True):
        super(IdentifiedObject, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            self.mRID.export(outfile, level, namespace_, name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IdentifiedObject'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IdentifiedObject, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IdentifiedObject, self).exportLiteralChildren(outfile, level, name_)
        if self.mRID is not None:
            showIndent(outfile, level)
            outfile.write('mRID=model_.mRIDType(\n')
            self.mRID.exportLiteral(outfile, level, name_='mRID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=model_.VersionType(\n')
            self.version.exportLiteral(outfile, level, name_='version')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IdentifiedObject, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory()
            obj_.build(child_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            self.validate_String32(self.description)    # validate type String32
        elif nodeName_ == 'version':
            obj_ = VersionType.factory()
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(IdentifiedObject, self).buildChildren(child_, node, nodeName_, True)
# end class IdentifiedObject


class UsagePointListLink(ListLink):
    """SHALL contain a Link to a List of UsagePoint instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(UsagePointListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if UsagePointListLink.subclass:
            return UsagePointListLink.subclass(*args_, **kwargs_)
        else:
            return UsagePointListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(UsagePointListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UsagePointListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePointListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UsagePointListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UsagePointListLink'):
        super(UsagePointListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePointListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='UsagePointListLink', fromsubclass_=False, pretty_print=True):
        super(UsagePointListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='UsagePointListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UsagePointListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UsagePointListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UsagePointListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(UsagePointListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class UsagePointListLink


class UsagePointLink(Link):
    """SHALL contain a Link to an instance of UsagePoint."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(UsagePointLink, self).__init__()
    def factory(*args_, **kwargs_):
        if UsagePointLink.subclass:
            return UsagePointLink.subclass(*args_, **kwargs_)
        else:
            return UsagePointLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(UsagePointLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UsagePointLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePointLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UsagePointLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UsagePointLink'):
        super(UsagePointLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePointLink')
    def exportChildren(self, outfile, level, namespace_='', name_='UsagePointLink', fromsubclass_=False, pretty_print=True):
        super(UsagePointLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='UsagePointLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UsagePointLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UsagePointLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UsagePointLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(UsagePointLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class UsagePointLink


class TimeTariffIntervalListLink(ListLink):
    """SHALL contain a Link to a List of TimeTariffInterval instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(TimeTariffIntervalListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if TimeTariffIntervalListLink.subclass:
            return TimeTariffIntervalListLink.subclass(*args_, **kwargs_)
        else:
            return TimeTariffIntervalListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(TimeTariffIntervalListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeTariffIntervalListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTariffIntervalListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeTariffIntervalListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeTariffIntervalListLink'):
        super(TimeTariffIntervalListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTariffIntervalListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeTariffIntervalListLink', fromsubclass_=False, pretty_print=True):
        super(TimeTariffIntervalListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TimeTariffIntervalListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeTariffIntervalListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeTariffIntervalListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeTariffIntervalListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TimeTariffIntervalListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TimeTariffIntervalListLink


class TimeLink(Link):
    """SHALL contain a Link to an instance of Time."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(TimeLink, self).__init__()
    def factory(*args_, **kwargs_):
        if TimeLink.subclass:
            return TimeLink.subclass(*args_, **kwargs_)
        else:
            return TimeLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(TimeLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeLink'):
        super(TimeLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeLink')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeLink', fromsubclass_=False, pretty_print=True):
        super(TimeLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TimeLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TimeLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TimeLink


class TextMessageListLink(ListLink):
    """SHALL contain a Link to a List of TextMessage instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(TextMessageListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if TextMessageListLink.subclass:
            return TextMessageListLink.subclass(*args_, **kwargs_)
        else:
            return TextMessageListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(TextMessageListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextMessageListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextMessageListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextMessageListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextMessageListLink'):
        super(TextMessageListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TextMessageListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='TextMessageListLink', fromsubclass_=False, pretty_print=True):
        super(TextMessageListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TextMessageListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TextMessageListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TextMessageListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextMessageListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextMessageListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextMessageListLink


class TariffProfileListLink(ListLink):
    """SHALL contain a Link to a List of TariffProfile instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(TariffProfileListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if TariffProfileListLink.subclass:
            return TariffProfileListLink.subclass(*args_, **kwargs_)
        else:
            return TariffProfileListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(TariffProfileListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TariffProfileListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TariffProfileListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TariffProfileListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TariffProfileListLink'):
        super(TariffProfileListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TariffProfileListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='TariffProfileListLink', fromsubclass_=False, pretty_print=True):
        super(TariffProfileListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TariffProfileListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TariffProfileListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TariffProfileListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TariffProfileListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TariffProfileListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TariffProfileListLink


class TariffProfileLink(Link):
    """SHALL contain a Link to an instance of TariffProfile."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(TariffProfileLink, self).__init__()
    def factory(*args_, **kwargs_):
        if TariffProfileLink.subclass:
            return TariffProfileLink.subclass(*args_, **kwargs_)
        else:
            return TariffProfileLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(TariffProfileLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TariffProfileLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TariffProfileLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TariffProfileLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TariffProfileLink'):
        super(TariffProfileLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TariffProfileLink')
    def exportChildren(self, outfile, level, namespace_='', name_='TariffProfileLink', fromsubclass_=False, pretty_print=True):
        super(TariffProfileLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TariffProfileLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TariffProfileLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TariffProfileLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TariffProfileLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TariffProfileLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TariffProfileLink


class TargetReadingListLink(ListLink):
    """SHALL contain a Link to a List of TargetReading instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(TargetReadingListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if TargetReadingListLink.subclass:
            return TargetReadingListLink.subclass(*args_, **kwargs_)
        else:
            return TargetReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(TargetReadingListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TargetReadingListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetReadingListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TargetReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetReadingListLink'):
        super(TargetReadingListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TargetReadingListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='TargetReadingListLink', fromsubclass_=False, pretty_print=True):
        super(TargetReadingListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TargetReadingListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TargetReadingListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TargetReadingListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TargetReadingListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TargetReadingListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TargetReadingListLink


class SupportedLocaleListLink(ListLink):
    """SHALL contain a Link to a List of SupportedLocale instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(SupportedLocaleListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if SupportedLocaleListLink.subclass:
            return SupportedLocaleListLink.subclass(*args_, **kwargs_)
        else:
            return SupportedLocaleListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SupportedLocaleListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportedLocaleListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedLocaleListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportedLocaleListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportedLocaleListLink'):
        super(SupportedLocaleListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedLocaleListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='SupportedLocaleListLink', fromsubclass_=False, pretty_print=True):
        super(SupportedLocaleListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SupportedLocaleListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SupportedLocaleListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SupportedLocaleListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SupportedLocaleListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SupportedLocaleListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SupportedLocaleListLink


class SupplyInterruptionOverrideListLink(ListLink):
    """SHALL contain a Link to a List of SupplyInterruptionOverride
    instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(SupplyInterruptionOverrideListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if SupplyInterruptionOverrideListLink.subclass:
            return SupplyInterruptionOverrideListLink.subclass(*args_, **kwargs_)
        else:
            return SupplyInterruptionOverrideListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SupplyInterruptionOverrideListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupplyInterruptionOverrideListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupplyInterruptionOverrideListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupplyInterruptionOverrideListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupplyInterruptionOverrideListLink'):
        super(SupplyInterruptionOverrideListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SupplyInterruptionOverrideListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='SupplyInterruptionOverrideListLink', fromsubclass_=False, pretty_print=True):
        super(SupplyInterruptionOverrideListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SupplyInterruptionOverrideListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SupplyInterruptionOverrideListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SupplyInterruptionOverrideListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SupplyInterruptionOverrideListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SupplyInterruptionOverrideListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SupplyInterruptionOverrideListLink


class SubscriptionListLink(ListLink):
    """SHALL contain a Link to a List of Subscription instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(SubscriptionListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if SubscriptionListLink.subclass:
            return SubscriptionListLink.subclass(*args_, **kwargs_)
        else:
            return SubscriptionListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SubscriptionListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubscriptionListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubscriptionListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubscriptionListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubscriptionListLink'):
        super(SubscriptionListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubscriptionListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='SubscriptionListLink', fromsubclass_=False, pretty_print=True):
        super(SubscriptionListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SubscriptionListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubscriptionListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubscriptionListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubscriptionListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SubscriptionListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SubscriptionListLink


class ServiceSupplierLink(Link):
    """SHALL contain a Link to an instance of ServiceSupplier."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(ServiceSupplierLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ServiceSupplierLink.subclass:
            return ServiceSupplierLink.subclass(*args_, **kwargs_)
        else:
            return ServiceSupplierLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ServiceSupplierLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceSupplierLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceSupplierLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceSupplierLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceSupplierLink'):
        super(ServiceSupplierLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceSupplierLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceSupplierLink', fromsubclass_=False, pretty_print=True):
        super(ServiceSupplierLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ServiceSupplierLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ServiceSupplierLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ServiceSupplierLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ServiceSupplierLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ServiceSupplierLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ServiceSupplierLink


class SelfDeviceLink(Link):
    """SHALL contain a Link to an instance of SelfDevice."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(SelfDeviceLink, self).__init__()
    def factory(*args_, **kwargs_):
        if SelfDeviceLink.subclass:
            return SelfDeviceLink.subclass(*args_, **kwargs_)
        else:
            return SelfDeviceLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SelfDeviceLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SelfDeviceLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelfDeviceLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SelfDeviceLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SelfDeviceLink'):
        super(SelfDeviceLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SelfDeviceLink')
    def exportChildren(self, outfile, level, namespace_='', name_='SelfDeviceLink', fromsubclass_=False, pretty_print=True):
        super(SelfDeviceLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SelfDeviceLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SelfDeviceLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SelfDeviceLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SelfDeviceLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelfDeviceLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelfDeviceLink


class RPLSourceRoutesListLink(ListLink):
    """SHALL contain a Link to a List of RPLSourceRoutes instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(RPLSourceRoutesListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if RPLSourceRoutesListLink.subclass:
            return RPLSourceRoutesListLink.subclass(*args_, **kwargs_)
        else:
            return RPLSourceRoutesListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(RPLSourceRoutesListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RPLSourceRoutesListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RPLSourceRoutesListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RPLSourceRoutesListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RPLSourceRoutesListLink'):
        super(RPLSourceRoutesListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RPLSourceRoutesListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='RPLSourceRoutesListLink', fromsubclass_=False, pretty_print=True):
        super(RPLSourceRoutesListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='RPLSourceRoutesListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RPLSourceRoutesListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RPLSourceRoutesListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RPLSourceRoutesListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RPLSourceRoutesListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RPLSourceRoutesListLink


class RPLInstanceListLink(ListLink):
    """SHALL contain a Link to a List of RPLInterface instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(RPLInstanceListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if RPLInstanceListLink.subclass:
            return RPLInstanceListLink.subclass(*args_, **kwargs_)
        else:
            return RPLInstanceListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(RPLInstanceListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RPLInstanceListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RPLInstanceListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RPLInstanceListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RPLInstanceListLink'):
        super(RPLInstanceListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RPLInstanceListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='RPLInstanceListLink', fromsubclass_=False, pretty_print=True):
        super(RPLInstanceListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='RPLInstanceListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RPLInstanceListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RPLInstanceListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RPLInstanceListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RPLInstanceListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RPLInstanceListLink


class ResponseSetListLink(ListLink):
    """SHALL contain a Link to a List of ResponseSet instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ResponseSetListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ResponseSetListLink.subclass:
            return ResponseSetListLink.subclass(*args_, **kwargs_)
        else:
            return ResponseSetListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ResponseSetListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseSetListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseSetListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseSetListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseSetListLink'):
        super(ResponseSetListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseSetListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseSetListLink', fromsubclass_=False, pretty_print=True):
        super(ResponseSetListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ResponseSetListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResponseSetListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResponseSetListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResponseSetListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResponseSetListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResponseSetListLink


class ResponseListLink(ListLink):
    """SHALL contain a Link to a List of Response instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ResponseListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ResponseListLink.subclass:
            return ResponseListLink.subclass(*args_, **kwargs_)
        else:
            return ResponseListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ResponseListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseListLink'):
        super(ResponseListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseListLink', fromsubclass_=False, pretty_print=True):
        super(ResponseListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ResponseListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResponseListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResponseListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResponseListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ResponseListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ResponseListLink


class RegistrationLink(Link):
    """SHALL contain a Link to an instance of Registration."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(RegistrationLink, self).__init__()
    def factory(*args_, **kwargs_):
        if RegistrationLink.subclass:
            return RegistrationLink.subclass(*args_, **kwargs_)
        else:
            return RegistrationLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(RegistrationLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RegistrationLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegistrationLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RegistrationLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RegistrationLink'):
        super(RegistrationLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RegistrationLink')
    def exportChildren(self, outfile, level, namespace_='', name_='RegistrationLink', fromsubclass_=False, pretty_print=True):
        super(RegistrationLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='RegistrationLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RegistrationLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RegistrationLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RegistrationLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RegistrationLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RegistrationLink


class ReadingTypeLink(Link):
    """SHALL contain a Link to an instance of ReadingType."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(ReadingTypeLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ReadingTypeLink.subclass:
            return ReadingTypeLink.subclass(*args_, **kwargs_)
        else:
            return ReadingTypeLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ReadingTypeLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingTypeLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingTypeLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingTypeLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingTypeLink'):
        super(ReadingTypeLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingTypeLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingTypeLink', fromsubclass_=False, pretty_print=True):
        super(ReadingTypeLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ReadingTypeLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingTypeLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingTypeLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingTypeLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReadingTypeLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReadingTypeLink


class ReadingSetListLink(ListLink):
    """SHALL contain a Link to a List of ReadingSet instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ReadingSetListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ReadingSetListLink.subclass:
            return ReadingSetListLink.subclass(*args_, **kwargs_)
        else:
            return ReadingSetListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ReadingSetListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingSetListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingSetListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingSetListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingSetListLink'):
        super(ReadingSetListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingSetListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingSetListLink', fromsubclass_=False, pretty_print=True):
        super(ReadingSetListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ReadingSetListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingSetListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingSetListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingSetListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReadingSetListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReadingSetListLink


class ReadingListLink(ListLink):
    """SHALL contain a Link to a List of Reading instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ReadingListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ReadingListLink.subclass:
            return ReadingListLink.subclass(*args_, **kwargs_)
        else:
            return ReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ReadingListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingListLink'):
        super(ReadingListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingListLink', fromsubclass_=False, pretty_print=True):
        super(ReadingListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ReadingListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReadingListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReadingListLink


class ReadingLink(Link):
    """A Link to a Reading."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(ReadingLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ReadingLink.subclass:
            return ReadingLink.subclass(*args_, **kwargs_)
        else:
            return ReadingLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ReadingLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingLink'):
        super(ReadingLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingLink', fromsubclass_=False, pretty_print=True):
        super(ReadingLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ReadingLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ReadingLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ReadingLink


class RateComponentListLink(ListLink):
    """SHALL contain a Link to a List of RateComponent instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(RateComponentListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if RateComponentListLink.subclass:
            return RateComponentListLink.subclass(*args_, **kwargs_)
        else:
            return RateComponentListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(RateComponentListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateComponentListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateComponentListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateComponentListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateComponentListLink'):
        super(RateComponentListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RateComponentListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='RateComponentListLink', fromsubclass_=False, pretty_print=True):
        super(RateComponentListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='RateComponentListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RateComponentListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RateComponentListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RateComponentListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RateComponentListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RateComponentListLink


class RateComponentLink(Link):
    """SHALL contain a Link to an instance of RateComponent."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(RateComponentLink, self).__init__()
    def factory(*args_, **kwargs_):
        if RateComponentLink.subclass:
            return RateComponentLink.subclass(*args_, **kwargs_)
        else:
            return RateComponentLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(RateComponentLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateComponentLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateComponentLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateComponentLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateComponentLink'):
        super(RateComponentLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RateComponentLink')
    def exportChildren(self, outfile, level, namespace_='', name_='RateComponentLink', fromsubclass_=False, pretty_print=True):
        super(RateComponentLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='RateComponentLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RateComponentLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RateComponentLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RateComponentLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(RateComponentLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class RateComponentLink


class ProjectionReadingListLink(ListLink):
    """SHALL contain a Link to a List of ProjectionReading instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ProjectionReadingListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ProjectionReadingListLink.subclass:
            return ProjectionReadingListLink.subclass(*args_, **kwargs_)
        else:
            return ProjectionReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ProjectionReadingListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProjectionReadingListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectionReadingListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProjectionReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProjectionReadingListLink'):
        super(ProjectionReadingListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectionReadingListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ProjectionReadingListLink', fromsubclass_=False, pretty_print=True):
        super(ProjectionReadingListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ProjectionReadingListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ProjectionReadingListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProjectionReadingListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectionReadingListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProjectionReadingListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProjectionReadingListLink


class PriceResponseCfgListLink(ListLink):
    """SHALL contain a Link to a List of PriceResponseCfg instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(PriceResponseCfgListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if PriceResponseCfgListLink.subclass:
            return PriceResponseCfgListLink.subclass(*args_, **kwargs_)
        else:
            return PriceResponseCfgListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(PriceResponseCfgListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PriceResponseCfgListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriceResponseCfgListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PriceResponseCfgListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriceResponseCfgListLink'):
        super(PriceResponseCfgListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PriceResponseCfgListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='PriceResponseCfgListLink', fromsubclass_=False, pretty_print=True):
        super(PriceResponseCfgListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='PriceResponseCfgListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PriceResponseCfgListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PriceResponseCfgListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PriceResponseCfgListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PriceResponseCfgListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PriceResponseCfgListLink


class PrepayOperationStatusLink(Link):
    """SHALL contain a Link to an instance of PrepayOperationStatus."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(PrepayOperationStatusLink, self).__init__()
    def factory(*args_, **kwargs_):
        if PrepayOperationStatusLink.subclass:
            return PrepayOperationStatusLink.subclass(*args_, **kwargs_)
        else:
            return PrepayOperationStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(PrepayOperationStatusLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrepayOperationStatusLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrepayOperationStatusLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrepayOperationStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrepayOperationStatusLink'):
        super(PrepayOperationStatusLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PrepayOperationStatusLink')
    def exportChildren(self, outfile, level, namespace_='', name_='PrepayOperationStatusLink', fromsubclass_=False, pretty_print=True):
        super(PrepayOperationStatusLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='PrepayOperationStatusLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PrepayOperationStatusLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PrepayOperationStatusLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PrepayOperationStatusLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PrepayOperationStatusLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PrepayOperationStatusLink


class PrepaymentListLink(ListLink):
    """SHALL contain a Link to a List of Prepayment instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(PrepaymentListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if PrepaymentListLink.subclass:
            return PrepaymentListLink.subclass(*args_, **kwargs_)
        else:
            return PrepaymentListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(PrepaymentListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrepaymentListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrepaymentListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrepaymentListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrepaymentListLink'):
        super(PrepaymentListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PrepaymentListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='PrepaymentListLink', fromsubclass_=False, pretty_print=True):
        super(PrepaymentListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='PrepaymentListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PrepaymentListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PrepaymentListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PrepaymentListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PrepaymentListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PrepaymentListLink


class PrepaymentLink(Link):
    """SHALL contain a Link to an instance of Prepayment."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(PrepaymentLink, self).__init__()
    def factory(*args_, **kwargs_):
        if PrepaymentLink.subclass:
            return PrepaymentLink.subclass(*args_, **kwargs_)
        else:
            return PrepaymentLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(PrepaymentLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrepaymentLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrepaymentLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrepaymentLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrepaymentLink'):
        super(PrepaymentLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PrepaymentLink')
    def exportChildren(self, outfile, level, namespace_='', name_='PrepaymentLink', fromsubclass_=False, pretty_print=True):
        super(PrepaymentLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='PrepaymentLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PrepaymentLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PrepaymentLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PrepaymentLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PrepaymentLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PrepaymentLink


class PowerStatusLink(Link):
    """SHALL contain a Link to an instance of PowerStatus."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(PowerStatusLink, self).__init__()
    def factory(*args_, **kwargs_):
        if PowerStatusLink.subclass:
            return PowerStatusLink.subclass(*args_, **kwargs_)
        else:
            return PowerStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(PowerStatusLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PowerStatusLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerStatusLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PowerStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PowerStatusLink'):
        super(PowerStatusLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PowerStatusLink')
    def exportChildren(self, outfile, level, namespace_='', name_='PowerStatusLink', fromsubclass_=False, pretty_print=True):
        super(PowerStatusLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='PowerStatusLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PowerStatusLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PowerStatusLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PowerStatusLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PowerStatusLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PowerStatusLink


class NotificationListLink(ListLink):
    """SHALL contain a Link to a List of Notification instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(NotificationListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if NotificationListLink.subclass:
            return NotificationListLink.subclass(*args_, **kwargs_)
        else:
            return NotificationListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(NotificationListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotificationListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotificationListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotificationListLink'):
        super(NotificationListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='NotificationListLink', fromsubclass_=False, pretty_print=True):
        super(NotificationListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='NotificationListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NotificationListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NotificationListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NotificationListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NotificationListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NotificationListLink


class NeighborListLink(ListLink):
    """SHALL contain a Link to a List of Neighbor instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(NeighborListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if NeighborListLink.subclass:
            return NeighborListLink.subclass(*args_, **kwargs_)
        else:
            return NeighborListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(NeighborListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NeighborListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeighborListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NeighborListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeighborListLink'):
        super(NeighborListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NeighborListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='NeighborListLink', fromsubclass_=False, pretty_print=True):
        super(NeighborListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='NeighborListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NeighborListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NeighborListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NeighborListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(NeighborListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class NeighborListLink


class MirrorUsagePointListLink(ListLink):
    """SHALL contain a Link to a List of MirrorUsagePoint instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(MirrorUsagePointListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if MirrorUsagePointListLink.subclass:
            return MirrorUsagePointListLink.subclass(*args_, **kwargs_)
        else:
            return MirrorUsagePointListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(MirrorUsagePointListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MirrorUsagePointListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorUsagePointListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MirrorUsagePointListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MirrorUsagePointListLink'):
        super(MirrorUsagePointListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorUsagePointListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='MirrorUsagePointListLink', fromsubclass_=False, pretty_print=True):
        super(MirrorUsagePointListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='MirrorUsagePointListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MirrorUsagePointListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MirrorUsagePointListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MirrorUsagePointListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MirrorUsagePointListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MirrorUsagePointListLink


class MeterReadingListLink(ListLink):
    """SHALL contain a Link to a List of MeterReading instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(MeterReadingListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if MeterReadingListLink.subclass:
            return MeterReadingListLink.subclass(*args_, **kwargs_)
        else:
            return MeterReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(MeterReadingListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeterReadingListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReadingListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeterReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeterReadingListLink'):
        super(MeterReadingListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReadingListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='MeterReadingListLink', fromsubclass_=False, pretty_print=True):
        super(MeterReadingListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='MeterReadingListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MeterReadingListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MeterReadingListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MeterReadingListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MeterReadingListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MeterReadingListLink


class MeterReadingLink(Link):
    """SHALL contain a Link to an instance of MeterReading."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(MeterReadingLink, self).__init__()
    def factory(*args_, **kwargs_):
        if MeterReadingLink.subclass:
            return MeterReadingLink.subclass(*args_, **kwargs_)
        else:
            return MeterReadingLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(MeterReadingLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeterReadingLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReadingLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeterReadingLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeterReadingLink'):
        super(MeterReadingLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReadingLink')
    def exportChildren(self, outfile, level, namespace_='', name_='MeterReadingLink', fromsubclass_=False, pretty_print=True):
        super(MeterReadingLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='MeterReadingLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MeterReadingLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MeterReadingLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MeterReadingLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MeterReadingLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MeterReadingLink


class MessagingProgramListLink(ListLink):
    """SHALL contain a Link to a List of MessagingProgram instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(MessagingProgramListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if MessagingProgramListLink.subclass:
            return MessagingProgramListLink.subclass(*args_, **kwargs_)
        else:
            return MessagingProgramListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(MessagingProgramListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MessagingProgramListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessagingProgramListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MessagingProgramListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MessagingProgramListLink'):
        super(MessagingProgramListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MessagingProgramListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='MessagingProgramListLink', fromsubclass_=False, pretty_print=True):
        super(MessagingProgramListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='MessagingProgramListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MessagingProgramListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MessagingProgramListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MessagingProgramListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MessagingProgramListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MessagingProgramListLink


class LogEventListLink(ListLink):
    """SHALL contain a Link to a List of LogEvent instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(LogEventListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if LogEventListLink.subclass:
            return LogEventListLink.subclass(*args_, **kwargs_)
        else:
            return LogEventListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(LogEventListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LogEventListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogEventListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LogEventListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LogEventListLink'):
        super(LogEventListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LogEventListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='LogEventListLink', fromsubclass_=False, pretty_print=True):
        super(LogEventListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='LogEventListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LogEventListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LogEventListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LogEventListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LogEventListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LogEventListLink


class LoadShedAvailabilityLink(Link):
    """SHALL contain a Link to an instance of LoadShedAvailability."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(LoadShedAvailabilityLink, self).__init__()
    def factory(*args_, **kwargs_):
        if LoadShedAvailabilityLink.subclass:
            return LoadShedAvailabilityLink.subclass(*args_, **kwargs_)
        else:
            return LoadShedAvailabilityLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(LoadShedAvailabilityLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LoadShedAvailabilityLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadShedAvailabilityLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LoadShedAvailabilityLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadShedAvailabilityLink'):
        super(LoadShedAvailabilityLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LoadShedAvailabilityLink')
    def exportChildren(self, outfile, level, namespace_='', name_='LoadShedAvailabilityLink', fromsubclass_=False, pretty_print=True):
        super(LoadShedAvailabilityLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='LoadShedAvailabilityLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LoadShedAvailabilityLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LoadShedAvailabilityLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LoadShedAvailabilityLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LoadShedAvailabilityLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LoadShedAvailabilityLink


class LLInterfaceListLink(ListLink):
    """SHALL contain a Link to a List of LLInterface instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(LLInterfaceListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if LLInterfaceListLink.subclass:
            return LLInterfaceListLink.subclass(*args_, **kwargs_)
        else:
            return LLInterfaceListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(LLInterfaceListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LLInterfaceListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LLInterfaceListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LLInterfaceListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LLInterfaceListLink'):
        super(LLInterfaceListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LLInterfaceListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='LLInterfaceListLink', fromsubclass_=False, pretty_print=True):
        super(LLInterfaceListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='LLInterfaceListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LLInterfaceListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LLInterfaceListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LLInterfaceListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LLInterfaceListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LLInterfaceListLink


class IPInterfaceListLink(ListLink):
    """SHALL contain a Link to a List of IPInterface instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(IPInterfaceListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if IPInterfaceListLink.subclass:
            return IPInterfaceListLink.subclass(*args_, **kwargs_)
        else:
            return IPInterfaceListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IPInterfaceListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPInterfaceListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPInterfaceListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPInterfaceListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPInterfaceListLink'):
        super(IPInterfaceListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IPInterfaceListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='IPInterfaceListLink', fromsubclass_=False, pretty_print=True):
        super(IPInterfaceListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='IPInterfaceListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IPInterfaceListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IPInterfaceListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IPInterfaceListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IPInterfaceListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IPInterfaceListLink


class IPAddrListLink(ListLink):
    """SHALL contain a Link to a List of IPAddr instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(IPAddrListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if IPAddrListLink.subclass:
            return IPAddrListLink.subclass(*args_, **kwargs_)
        else:
            return IPAddrListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(IPAddrListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPAddrListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddrListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPAddrListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPAddrListLink'):
        super(IPAddrListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddrListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='IPAddrListLink', fromsubclass_=False, pretty_print=True):
        super(IPAddrListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='IPAddrListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IPAddrListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IPAddrListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IPAddrListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IPAddrListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IPAddrListLink


class HistoricalReadingListLink(ListLink):
    """SHALL contain a Link to a List of HistoricalReading instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(HistoricalReadingListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if HistoricalReadingListLink.subclass:
            return HistoricalReadingListLink.subclass(*args_, **kwargs_)
        else:
            return HistoricalReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(HistoricalReadingListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HistoricalReadingListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HistoricalReadingListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HistoricalReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HistoricalReadingListLink'):
        super(HistoricalReadingListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HistoricalReadingListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='HistoricalReadingListLink', fromsubclass_=False, pretty_print=True):
        super(HistoricalReadingListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='HistoricalReadingListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HistoricalReadingListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HistoricalReadingListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HistoricalReadingListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HistoricalReadingListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HistoricalReadingListLink


class FunctionSetAssignmentsListLink(ListLink):
    """SHALL contain a Link to a List of FunctionSetAssignments instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(FunctionSetAssignmentsListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if FunctionSetAssignmentsListLink.subclass:
            return FunctionSetAssignmentsListLink.subclass(*args_, **kwargs_)
        else:
            return FunctionSetAssignmentsListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FunctionSetAssignmentsListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FunctionSetAssignmentsListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionSetAssignmentsListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FunctionSetAssignmentsListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FunctionSetAssignmentsListLink'):
        super(FunctionSetAssignmentsListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionSetAssignmentsListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='FunctionSetAssignmentsListLink', fromsubclass_=False, pretty_print=True):
        super(FunctionSetAssignmentsListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='FunctionSetAssignmentsListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FunctionSetAssignmentsListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FunctionSetAssignmentsListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FunctionSetAssignmentsListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FunctionSetAssignmentsListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FunctionSetAssignmentsListLink


class FlowReservationResponseListLink(ListLink):
    """SHALL contain a Link to a List of FlowReservationResponse instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(FlowReservationResponseListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if FlowReservationResponseListLink.subclass:
            return FlowReservationResponseListLink.subclass(*args_, **kwargs_)
        else:
            return FlowReservationResponseListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FlowReservationResponseListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlowReservationResponseListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationResponseListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FlowReservationResponseListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlowReservationResponseListLink'):
        super(FlowReservationResponseListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationResponseListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='FlowReservationResponseListLink', fromsubclass_=False, pretty_print=True):
        super(FlowReservationResponseListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='FlowReservationResponseListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FlowReservationResponseListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FlowReservationResponseListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationResponseListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FlowReservationResponseListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FlowReservationResponseListLink


class FlowReservationRequestListLink(ListLink):
    """SHALL contain a Link to a List of FlowReservationRequest instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(FlowReservationRequestListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if FlowReservationRequestListLink.subclass:
            return FlowReservationRequestListLink.subclass(*args_, **kwargs_)
        else:
            return FlowReservationRequestListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FlowReservationRequestListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlowReservationRequestListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationRequestListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FlowReservationRequestListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlowReservationRequestListLink'):
        super(FlowReservationRequestListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationRequestListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='FlowReservationRequestListLink', fromsubclass_=False, pretty_print=True):
        super(FlowReservationRequestListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='FlowReservationRequestListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FlowReservationRequestListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FlowReservationRequestListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationRequestListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FlowReservationRequestListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FlowReservationRequestListLink


class FileStatusLink(Link):
    """SHALL contain a Link to an instance of FileStatus."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(FileStatusLink, self).__init__()
    def factory(*args_, **kwargs_):
        if FileStatusLink.subclass:
            return FileStatusLink.subclass(*args_, **kwargs_)
        else:
            return FileStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FileStatusLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileStatusLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileStatusLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileStatusLink'):
        super(FileStatusLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileStatusLink')
    def exportChildren(self, outfile, level, namespace_='', name_='FileStatusLink', fromsubclass_=False, pretty_print=True):
        super(FileStatusLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='FileStatusLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FileStatusLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileStatusLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FileStatusLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FileStatusLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FileStatusLink


class FileListLink(ListLink):
    """SHALL contain a Link to a List of File instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(FileListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if FileListLink.subclass:
            return FileListLink.subclass(*args_, **kwargs_)
        else:
            return FileListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FileListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileListLink'):
        super(FileListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='FileListLink', fromsubclass_=False, pretty_print=True):
        super(FileListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='FileListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FileListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FileListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FileListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FileListLink


class FileLink(Link):
    """This element MUST be set to the URI of the most recent File being
    loaded/activated by the LD. In the case of file status 0, this
    element MUST be omitted."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(FileLink, self).__init__()
    def factory(*args_, **kwargs_):
        if FileLink.subclass:
            return FileLink.subclass(*args_, **kwargs_)
        else:
            return FileLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(FileLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileLink'):
        super(FileLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileLink')
    def exportChildren(self, outfile, level, namespace_='', name_='FileLink', fromsubclass_=False, pretty_print=True):
        super(FileLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='FileLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FileLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FileLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(FileLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class FileLink


class EndDeviceListLink(ListLink):
    """SHALL contain a Link to a List of EndDevice instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(EndDeviceListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if EndDeviceListLink.subclass:
            return EndDeviceListLink.subclass(*args_, **kwargs_)
        else:
            return EndDeviceListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EndDeviceListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EndDeviceListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EndDeviceListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndDeviceListLink'):
        super(EndDeviceListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='EndDeviceListLink', fromsubclass_=False, pretty_print=True):
        super(EndDeviceListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EndDeviceListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EndDeviceListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EndDeviceListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EndDeviceListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EndDeviceListLink


class EndDeviceLink(Link):
    """SHALL contain a Link to an instance of EndDevice."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(EndDeviceLink, self).__init__()
    def factory(*args_, **kwargs_):
        if EndDeviceLink.subclass:
            return EndDeviceLink.subclass(*args_, **kwargs_)
        else:
            return EndDeviceLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EndDeviceLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EndDeviceLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EndDeviceLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndDeviceLink'):
        super(EndDeviceLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceLink')
    def exportChildren(self, outfile, level, namespace_='', name_='EndDeviceLink', fromsubclass_=False, pretty_print=True):
        super(EndDeviceLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EndDeviceLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EndDeviceLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EndDeviceLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EndDeviceLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EndDeviceLink


class EndDeviceControlListLink(ListLink):
    """SHALL contain a Link to a List of EndDeviceControl instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(EndDeviceControlListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if EndDeviceControlListLink.subclass:
            return EndDeviceControlListLink.subclass(*args_, **kwargs_)
        else:
            return EndDeviceControlListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EndDeviceControlListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EndDeviceControlListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceControlListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EndDeviceControlListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndDeviceControlListLink'):
        super(EndDeviceControlListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceControlListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='EndDeviceControlListLink', fromsubclass_=False, pretty_print=True):
        super(EndDeviceControlListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='EndDeviceControlListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EndDeviceControlListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EndDeviceControlListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceControlListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EndDeviceControlListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EndDeviceControlListLink


class DeviceStatusLink(Link):
    """SHALL contain a Link to an instance of DeviceStatus."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DeviceStatusLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DeviceStatusLink.subclass:
            return DeviceStatusLink.subclass(*args_, **kwargs_)
        else:
            return DeviceStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DeviceStatusLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceStatusLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceStatusLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeviceStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceStatusLink'):
        super(DeviceStatusLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceStatusLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceStatusLink', fromsubclass_=False, pretty_print=True):
        super(DeviceStatusLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DeviceStatusLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DeviceStatusLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeviceStatusLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DeviceStatusLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DeviceStatusLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DeviceStatusLink


class DeviceInformationLink(Link):
    """SHALL contain a Link to an instance of DeviceInformation."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DeviceInformationLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DeviceInformationLink.subclass:
            return DeviceInformationLink.subclass(*args_, **kwargs_)
        else:
            return DeviceInformationLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DeviceInformationLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceInformationLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceInformationLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeviceInformationLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceInformationLink'):
        super(DeviceInformationLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceInformationLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceInformationLink', fromsubclass_=False, pretty_print=True):
        super(DeviceInformationLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DeviceInformationLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DeviceInformationLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeviceInformationLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DeviceInformationLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DeviceInformationLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DeviceInformationLink


class DeviceCapabilityLink(Link):
    """SHALL contain a Link to an instance of DeviceCapability."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DeviceCapabilityLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DeviceCapabilityLink.subclass:
            return DeviceCapabilityLink.subclass(*args_, **kwargs_)
        else:
            return DeviceCapabilityLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DeviceCapabilityLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceCapabilityLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceCapabilityLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeviceCapabilityLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceCapabilityLink'):
        super(DeviceCapabilityLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceCapabilityLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceCapabilityLink', fromsubclass_=False, pretty_print=True):
        super(DeviceCapabilityLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DeviceCapabilityLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DeviceCapabilityLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeviceCapabilityLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DeviceCapabilityLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DeviceCapabilityLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DeviceCapabilityLink


class DERStatusLink(Link):
    """SHALL contain a Link to an instance of DERStatus."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DERStatusLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERStatusLink.subclass:
            return DERStatusLink.subclass(*args_, **kwargs_)
        else:
            return DERStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERStatusLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERStatusLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERStatusLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERStatusLink'):
        super(DERStatusLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERStatusLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERStatusLink', fromsubclass_=False, pretty_print=True):
        super(DERStatusLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERStatusLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERStatusLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERStatusLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERStatusLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERStatusLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERStatusLink


class DERSettingsLink(Link):
    """SHALL contain a Link to an instance of DERSettings."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DERSettingsLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERSettingsLink.subclass:
            return DERSettingsLink.subclass(*args_, **kwargs_)
        else:
            return DERSettingsLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERSettingsLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERSettingsLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERSettingsLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERSettingsLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERSettingsLink'):
        super(DERSettingsLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERSettingsLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERSettingsLink', fromsubclass_=False, pretty_print=True):
        super(DERSettingsLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERSettingsLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERSettingsLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERSettingsLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERSettingsLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERSettingsLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERSettingsLink


class DERProgramListLink(ListLink):
    """SHALL contain a Link to a List of DERProgram instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(DERProgramListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERProgramListLink.subclass:
            return DERProgramListLink.subclass(*args_, **kwargs_)
        else:
            return DERProgramListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERProgramListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERProgramListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERProgramListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERProgramListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERProgramListLink'):
        super(DERProgramListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERProgramListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERProgramListLink', fromsubclass_=False, pretty_print=True):
        super(DERProgramListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERProgramListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERProgramListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERProgramListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERProgramListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERProgramListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERProgramListLink


class DERProgramLink(Link):
    """SHALL contain a Link to an instance of DERProgram."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DERProgramLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERProgramLink.subclass:
            return DERProgramLink.subclass(*args_, **kwargs_)
        else:
            return DERProgramLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERProgramLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERProgramLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERProgramLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERProgramLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERProgramLink'):
        super(DERProgramLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERProgramLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERProgramLink', fromsubclass_=False, pretty_print=True):
        super(DERProgramLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERProgramLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERProgramLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERProgramLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERProgramLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERProgramLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERProgramLink


class DERListLink(ListLink):
    """SHALL contain a Link to a List of DER instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(DERListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERListLink.subclass:
            return DERListLink.subclass(*args_, **kwargs_)
        else:
            return DERListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERListLink'):
        super(DERListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERListLink', fromsubclass_=False, pretty_print=True):
        super(DERListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERListLink


class DERLink(Link):
    """SHALL contain a Link to an instance of DER."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DERLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERLink.subclass:
            return DERLink.subclass(*args_, **kwargs_)
        else:
            return DERLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERLink'):
        super(DERLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERLink', fromsubclass_=False, pretty_print=True):
        super(DERLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERLink


class DERCurveListLink(ListLink):
    """SHALL contain a Link to a List of DERCurve instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(DERCurveListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERCurveListLink.subclass:
            return DERCurveListLink.subclass(*args_, **kwargs_)
        else:
            return DERCurveListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERCurveListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERCurveListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERCurveListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERCurveListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERCurveListLink'):
        super(DERCurveListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERCurveListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERCurveListLink', fromsubclass_=False, pretty_print=True):
        super(DERCurveListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERCurveListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERCurveListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERCurveListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERCurveListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERCurveListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERCurveListLink


class DERCurveLink(Link):
    """SHALL contain a Link to an instance of DERCurve."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DERCurveLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERCurveLink.subclass:
            return DERCurveLink.subclass(*args_, **kwargs_)
        else:
            return DERCurveLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERCurveLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERCurveLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERCurveLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERCurveLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERCurveLink'):
        super(DERCurveLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERCurveLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERCurveLink', fromsubclass_=False, pretty_print=True):
        super(DERCurveLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERCurveLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERCurveLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERCurveLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERCurveLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERCurveLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERCurveLink


class DERControlListLink(ListLink):
    """SHALL contain a Link to a List of DERControl instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(DERControlListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERControlListLink.subclass:
            return DERControlListLink.subclass(*args_, **kwargs_)
        else:
            return DERControlListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERControlListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERControlListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERControlListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERControlListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERControlListLink'):
        super(DERControlListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERControlListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERControlListLink', fromsubclass_=False, pretty_print=True):
        super(DERControlListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERControlListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERControlListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERControlListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERControlListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERControlListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERControlListLink


class DERCapabilityLink(Link):
    """SHALL contain a Link to an instance of DERCapability."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DERCapabilityLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERCapabilityLink.subclass:
            return DERCapabilityLink.subclass(*args_, **kwargs_)
        else:
            return DERCapabilityLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERCapabilityLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERCapabilityLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERCapabilityLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERCapabilityLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERCapabilityLink'):
        super(DERCapabilityLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERCapabilityLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERCapabilityLink', fromsubclass_=False, pretty_print=True):
        super(DERCapabilityLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERCapabilityLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERCapabilityLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERCapabilityLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERCapabilityLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERCapabilityLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERCapabilityLink


class DefaultDERControlLink(Link):
    """SHALL contain a Link to an instance of DefaultDERControl. This is
    the default mode of the DER which MAY be overridden by
    DERControl events."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DefaultDERControlLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DefaultDERControlLink.subclass:
            return DefaultDERControlLink.subclass(*args_, **kwargs_)
        else:
            return DefaultDERControlLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DefaultDERControlLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DefaultDERControlLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultDERControlLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DefaultDERControlLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultDERControlLink'):
        super(DefaultDERControlLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultDERControlLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultDERControlLink', fromsubclass_=False, pretty_print=True):
        super(DefaultDERControlLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DefaultDERControlLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DefaultDERControlLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DefaultDERControlLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DefaultDERControlLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DefaultDERControlLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DefaultDERControlLink


class DERAvailabilityLink(Link):
    """SHALL contain a Link to an instance of DERAvailability."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DERAvailabilityLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DERAvailabilityLink.subclass:
            return DERAvailabilityLink.subclass(*args_, **kwargs_)
        else:
            return DERAvailabilityLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DERAvailabilityLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERAvailabilityLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERAvailabilityLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERAvailabilityLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERAvailabilityLink'):
        super(DERAvailabilityLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERAvailabilityLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DERAvailabilityLink', fromsubclass_=False, pretty_print=True):
        super(DERAvailabilityLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DERAvailabilityLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERAvailabilityLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERAvailabilityLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERAvailabilityLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DERAvailabilityLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DERAvailabilityLink


class DemandResponseProgramListLink(ListLink):
    """SHALL contain a Link to a List of DemandResponseProgram instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(DemandResponseProgramListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DemandResponseProgramListLink.subclass:
            return DemandResponseProgramListLink.subclass(*args_, **kwargs_)
        else:
            return DemandResponseProgramListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DemandResponseProgramListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DemandResponseProgramListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandResponseProgramListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DemandResponseProgramListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DemandResponseProgramListLink'):
        super(DemandResponseProgramListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DemandResponseProgramListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DemandResponseProgramListLink', fromsubclass_=False, pretty_print=True):
        super(DemandResponseProgramListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DemandResponseProgramListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DemandResponseProgramListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DemandResponseProgramListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DemandResponseProgramListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DemandResponseProgramListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DemandResponseProgramListLink


class DemandResponseProgramLink(Link):
    """SHALL contain a Link to an instance of DemandResponseProgram."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(DemandResponseProgramLink, self).__init__()
    def factory(*args_, **kwargs_):
        if DemandResponseProgramLink.subclass:
            return DemandResponseProgramLink.subclass(*args_, **kwargs_)
        else:
            return DemandResponseProgramLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(DemandResponseProgramLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DemandResponseProgramLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandResponseProgramLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DemandResponseProgramLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DemandResponseProgramLink'):
        super(DemandResponseProgramLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DemandResponseProgramLink')
    def exportChildren(self, outfile, level, namespace_='', name_='DemandResponseProgramLink', fromsubclass_=False, pretty_print=True):
        super(DemandResponseProgramLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='DemandResponseProgramLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DemandResponseProgramLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DemandResponseProgramLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DemandResponseProgramLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DemandResponseProgramLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DemandResponseProgramLink


class CustomerAgreementListLink(ListLink):
    """SHALL contain a Link to a List of CustomerAgreement instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(CustomerAgreementListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if CustomerAgreementListLink.subclass:
            return CustomerAgreementListLink.subclass(*args_, **kwargs_)
        else:
            return CustomerAgreementListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CustomerAgreementListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerAgreementListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAgreementListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerAgreementListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerAgreementListLink'):
        super(CustomerAgreementListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAgreementListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerAgreementListLink', fromsubclass_=False, pretty_print=True):
        super(CustomerAgreementListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CustomerAgreementListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomerAgreementListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomerAgreementListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CustomerAgreementListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CustomerAgreementListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CustomerAgreementListLink


class CustomerAccountListLink(ListLink):
    """SHALL contain a Link to a List of CustomerAccount instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(CustomerAccountListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if CustomerAccountListLink.subclass:
            return CustomerAccountListLink.subclass(*args_, **kwargs_)
        else:
            return CustomerAccountListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CustomerAccountListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerAccountListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAccountListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerAccountListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerAccountListLink'):
        super(CustomerAccountListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAccountListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerAccountListLink', fromsubclass_=False, pretty_print=True):
        super(CustomerAccountListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CustomerAccountListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomerAccountListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomerAccountListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CustomerAccountListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CustomerAccountListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CustomerAccountListLink


class CustomerAccountLink(Link):
    """SHALL contain a Link to an instance of CustomerAccount."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(CustomerAccountLink, self).__init__()
    def factory(*args_, **kwargs_):
        if CustomerAccountLink.subclass:
            return CustomerAccountLink.subclass(*args_, **kwargs_)
        else:
            return CustomerAccountLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CustomerAccountLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerAccountLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAccountLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerAccountLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerAccountLink'):
        super(CustomerAccountLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAccountLink')
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerAccountLink', fromsubclass_=False, pretty_print=True):
        super(CustomerAccountLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CustomerAccountLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomerAccountLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomerAccountLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CustomerAccountLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CustomerAccountLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CustomerAccountLink


class CreditRegisterListLink(ListLink):
    """SHALL contain a Link to a List of CreditRegister instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(CreditRegisterListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if CreditRegisterListLink.subclass:
            return CreditRegisterListLink.subclass(*args_, **kwargs_)
        else:
            return CreditRegisterListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CreditRegisterListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRegisterListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRegisterListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRegisterListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRegisterListLink'):
        super(CreditRegisterListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRegisterListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRegisterListLink', fromsubclass_=False, pretty_print=True):
        super(CreditRegisterListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CreditRegisterListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CreditRegisterListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CreditRegisterListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CreditRegisterListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CreditRegisterListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CreditRegisterListLink


class ConsumptionTariffIntervalListLink(ListLink):
    """SHALL contain a Link to a List of ConsumptionTariffInterval
    instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ConsumptionTariffIntervalListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ConsumptionTariffIntervalListLink.subclass:
            return ConsumptionTariffIntervalListLink.subclass(*args_, **kwargs_)
        else:
            return ConsumptionTariffIntervalListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ConsumptionTariffIntervalListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConsumptionTariffIntervalListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumptionTariffIntervalListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConsumptionTariffIntervalListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConsumptionTariffIntervalListLink'):
        super(ConsumptionTariffIntervalListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumptionTariffIntervalListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ConsumptionTariffIntervalListLink', fromsubclass_=False, pretty_print=True):
        super(ConsumptionTariffIntervalListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ConsumptionTariffIntervalListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ConsumptionTariffIntervalListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConsumptionTariffIntervalListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConsumptionTariffIntervalListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ConsumptionTariffIntervalListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ConsumptionTariffIntervalListLink


class ConfigurationLink(Link):
    """SHALL contain a Link to an instance of Configuration."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(ConfigurationLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ConfigurationLink.subclass:
            return ConfigurationLink.subclass(*args_, **kwargs_)
        else:
            return ConfigurationLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ConfigurationLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConfigurationLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigurationLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConfigurationLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConfigurationLink'):
        super(ConfigurationLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConfigurationLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ConfigurationLink', fromsubclass_=False, pretty_print=True):
        super(ConfigurationLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ConfigurationLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ConfigurationLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConfigurationLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConfigurationLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ConfigurationLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ConfigurationLink


class BillingReadingSetListLink(ListLink):
    """SHALL contain a Link to a List of BillingReadingSet instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(BillingReadingSetListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if BillingReadingSetListLink.subclass:
            return BillingReadingSetListLink.subclass(*args_, **kwargs_)
        else:
            return BillingReadingSetListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BillingReadingSetListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingReadingSetListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingSetListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingReadingSetListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingReadingSetListLink'):
        super(BillingReadingSetListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingSetListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingReadingSetListLink', fromsubclass_=False, pretty_print=True):
        super(BillingReadingSetListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='BillingReadingSetListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingReadingSetListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingReadingSetListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingSetListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BillingReadingSetListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BillingReadingSetListLink


class BillingReadingListLink(ListLink):
    """SHALL contain a Link to a List of BillingReading instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(BillingReadingListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if BillingReadingListLink.subclass:
            return BillingReadingListLink.subclass(*args_, **kwargs_)
        else:
            return BillingReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BillingReadingListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingReadingListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingReadingListLink'):
        super(BillingReadingListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingReadingListLink', fromsubclass_=False, pretty_print=True):
        super(BillingReadingListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='BillingReadingListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingReadingListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingReadingListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BillingReadingListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BillingReadingListLink


class BillingPeriodListLink(ListLink):
    """SHALL contain a Link to a List of BillingPeriod instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(BillingPeriodListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if BillingPeriodListLink.subclass:
            return BillingPeriodListLink.subclass(*args_, **kwargs_)
        else:
            return BillingPeriodListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(BillingPeriodListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingPeriodListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingPeriodListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingPeriodListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingPeriodListLink'):
        super(BillingPeriodListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingPeriodListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingPeriodListLink', fromsubclass_=False, pretty_print=True):
        super(BillingPeriodListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='BillingPeriodListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingPeriodListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingPeriodListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingPeriodListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BillingPeriodListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BillingPeriodListLink


class AssociatedUsagePointLink(Link):
    """SHALL contain a Link to an instance of UsagePoint. If present, this
    is the submeter that monitors the DER output."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(AssociatedUsagePointLink, self).__init__()
    def factory(*args_, **kwargs_):
        if AssociatedUsagePointLink.subclass:
            return AssociatedUsagePointLink.subclass(*args_, **kwargs_)
        else:
            return AssociatedUsagePointLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AssociatedUsagePointLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssociatedUsagePointLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedUsagePointLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssociatedUsagePointLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssociatedUsagePointLink'):
        super(AssociatedUsagePointLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedUsagePointLink')
    def exportChildren(self, outfile, level, namespace_='', name_='AssociatedUsagePointLink', fromsubclass_=False, pretty_print=True):
        super(AssociatedUsagePointLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AssociatedUsagePointLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssociatedUsagePointLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssociatedUsagePointLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AssociatedUsagePointLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AssociatedUsagePointLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AssociatedUsagePointLink


class AssociatedDERProgramListLink(ListLink):
    """SHALL contain a Link to a List of DERPrograms having the
    DERControl(s) for this DER."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(AssociatedDERProgramListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if AssociatedDERProgramListLink.subclass:
            return AssociatedDERProgramListLink.subclass(*args_, **kwargs_)
        else:
            return AssociatedDERProgramListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AssociatedDERProgramListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AssociatedDERProgramListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedDERProgramListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AssociatedDERProgramListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AssociatedDERProgramListLink'):
        super(AssociatedDERProgramListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssociatedDERProgramListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='AssociatedDERProgramListLink', fromsubclass_=False, pretty_print=True):
        super(AssociatedDERProgramListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AssociatedDERProgramListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AssociatedDERProgramListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssociatedDERProgramListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AssociatedDERProgramListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AssociatedDERProgramListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AssociatedDERProgramListLink


class ActiveTimeTariffIntervalListLink(ListLink):
    """SHALL contain a Link to a List of active TimeTariffInterval
    instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveTimeTariffIntervalListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveTimeTariffIntervalListLink.subclass:
            return ActiveTimeTariffIntervalListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveTimeTariffIntervalListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveTimeTariffIntervalListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveTimeTariffIntervalListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveTimeTariffIntervalListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveTimeTariffIntervalListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveTimeTariffIntervalListLink'):
        super(ActiveTimeTariffIntervalListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveTimeTariffIntervalListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveTimeTariffIntervalListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveTimeTariffIntervalListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveTimeTariffIntervalListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveTimeTariffIntervalListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveTimeTariffIntervalListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveTimeTariffIntervalListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveTimeTariffIntervalListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveTimeTariffIntervalListLink


class ActiveTextMessageListLink(ListLink):
    """SHALL contain a Link to a List of active TextMessage instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveTextMessageListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveTextMessageListLink.subclass:
            return ActiveTextMessageListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveTextMessageListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveTextMessageListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveTextMessageListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveTextMessageListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveTextMessageListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveTextMessageListLink'):
        super(ActiveTextMessageListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveTextMessageListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveTextMessageListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveTextMessageListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveTextMessageListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveTextMessageListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveTextMessageListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveTextMessageListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveTextMessageListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveTextMessageListLink


class ActiveTargetReadingListLink(ListLink):
    """SHALL contain a Link to a List of active TargetReading instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveTargetReadingListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveTargetReadingListLink.subclass:
            return ActiveTargetReadingListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveTargetReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveTargetReadingListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveTargetReadingListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveTargetReadingListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveTargetReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveTargetReadingListLink'):
        super(ActiveTargetReadingListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveTargetReadingListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveTargetReadingListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveTargetReadingListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveTargetReadingListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveTargetReadingListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveTargetReadingListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveTargetReadingListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveTargetReadingListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveTargetReadingListLink


class ActiveSupplyInterruptionOverrideListLink(ListLink):
    """SHALL contain a Link to a List of active SupplyInterruptionOverride
    instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveSupplyInterruptionOverrideListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveSupplyInterruptionOverrideListLink.subclass:
            return ActiveSupplyInterruptionOverrideListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveSupplyInterruptionOverrideListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveSupplyInterruptionOverrideListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveSupplyInterruptionOverrideListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveSupplyInterruptionOverrideListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveSupplyInterruptionOverrideListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveSupplyInterruptionOverrideListLink'):
        super(ActiveSupplyInterruptionOverrideListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveSupplyInterruptionOverrideListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveSupplyInterruptionOverrideListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveSupplyInterruptionOverrideListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveSupplyInterruptionOverrideListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveSupplyInterruptionOverrideListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveSupplyInterruptionOverrideListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveSupplyInterruptionOverrideListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveSupplyInterruptionOverrideListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveSupplyInterruptionOverrideListLink


class ActiveProjectionReadingListLink(ListLink):
    """SHALL contain a Link to a List of active ProjectionReading
    instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveProjectionReadingListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveProjectionReadingListLink.subclass:
            return ActiveProjectionReadingListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveProjectionReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveProjectionReadingListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveProjectionReadingListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveProjectionReadingListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveProjectionReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveProjectionReadingListLink'):
        super(ActiveProjectionReadingListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveProjectionReadingListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveProjectionReadingListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveProjectionReadingListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveProjectionReadingListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveProjectionReadingListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveProjectionReadingListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveProjectionReadingListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveProjectionReadingListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveProjectionReadingListLink


class ActiveFlowReservationListLink(ListLink):
    """SHALL contain a Link to a List of active FlowReservation instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveFlowReservationListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveFlowReservationListLink.subclass:
            return ActiveFlowReservationListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveFlowReservationListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveFlowReservationListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveFlowReservationListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveFlowReservationListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveFlowReservationListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveFlowReservationListLink'):
        super(ActiveFlowReservationListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveFlowReservationListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveFlowReservationListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveFlowReservationListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveFlowReservationListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveFlowReservationListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveFlowReservationListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveFlowReservationListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveFlowReservationListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveFlowReservationListLink


class ActiveEndDeviceControlListLink(ListLink):
    """SHALL contain a Link to a List of active EndDeviceControl instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveEndDeviceControlListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveEndDeviceControlListLink.subclass:
            return ActiveEndDeviceControlListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveEndDeviceControlListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveEndDeviceControlListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveEndDeviceControlListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveEndDeviceControlListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveEndDeviceControlListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveEndDeviceControlListLink'):
        super(ActiveEndDeviceControlListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveEndDeviceControlListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveEndDeviceControlListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveEndDeviceControlListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveEndDeviceControlListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveEndDeviceControlListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveEndDeviceControlListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveEndDeviceControlListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveEndDeviceControlListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveEndDeviceControlListLink


class ActiveDERControlListLink(ListLink):
    """SHALL contain a Link to a List of active DERControl instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveDERControlListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveDERControlListLink.subclass:
            return ActiveDERControlListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveDERControlListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveDERControlListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveDERControlListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveDERControlListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveDERControlListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveDERControlListLink'):
        super(ActiveDERControlListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveDERControlListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveDERControlListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveDERControlListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveDERControlListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveDERControlListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveDERControlListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveDERControlListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveDERControlListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveDERControlListLink


class ActiveCreditRegisterListLink(ListLink):
    """SHALL contain a Link to a List of active CreditRegister instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveCreditRegisterListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveCreditRegisterListLink.subclass:
            return ActiveCreditRegisterListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveCreditRegisterListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveCreditRegisterListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveCreditRegisterListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveCreditRegisterListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveCreditRegisterListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveCreditRegisterListLink'):
        super(ActiveCreditRegisterListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveCreditRegisterListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveCreditRegisterListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveCreditRegisterListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveCreditRegisterListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveCreditRegisterListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveCreditRegisterListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveCreditRegisterListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveCreditRegisterListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveCreditRegisterListLink


class ActiveBillingPeriodListLink(ListLink):
    """SHALL contain a Link to a List of active BillingPeriod instances."""
    subclass = None
    superclass = ListLink
    def __init__(self):
        self.original_tagname_ = None
        super(ActiveBillingPeriodListLink, self).__init__()
    def factory(*args_, **kwargs_):
        if ActiveBillingPeriodListLink.subclass:
            return ActiveBillingPeriodListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveBillingPeriodListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ActiveBillingPeriodListLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ActiveBillingPeriodListLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveBillingPeriodListLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ActiveBillingPeriodListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ActiveBillingPeriodListLink'):
        super(ActiveBillingPeriodListLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ActiveBillingPeriodListLink')
    def exportChildren(self, outfile, level, namespace_='', name_='ActiveBillingPeriodListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveBillingPeriodListLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ActiveBillingPeriodListLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ActiveBillingPeriodListLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ActiveBillingPeriodListLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ActiveBillingPeriodListLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ActiveBillingPeriodListLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveBillingPeriodListLink


class AccountBalanceLink(Link):
    """SHALL contain a Link to an instance of AccountBalance."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(AccountBalanceLink, self).__init__()
    def factory(*args_, **kwargs_):
        if AccountBalanceLink.subclass:
            return AccountBalanceLink.subclass(*args_, **kwargs_)
        else:
            return AccountBalanceLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AccountBalanceLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountBalanceLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountBalanceLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountBalanceLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountBalanceLink'):
        super(AccountBalanceLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccountBalanceLink')
    def exportChildren(self, outfile, level, namespace_='', name_='AccountBalanceLink', fromsubclass_=False, pretty_print=True):
        super(AccountBalanceLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AccountBalanceLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AccountBalanceLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AccountBalanceLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AccountBalanceLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AccountBalanceLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AccountBalanceLink


class DERStatus(SubscribableResource):
    """DER status information."""
    subclass = None
    superclass = SubscribableResource
    def __init__(self, genConnectStatus=None, inverterStatus=None, localControlModeStatus=None, manufacturerStatus=None, operationalModeStatus=None, readingTime=None, stateOfChargeStatus=None, storageModeStatus=None, storConnectStatus=None):
        self.original_tagname_ = None
        super(DERStatus, self).__init__()
        self.genConnectStatus = genConnectStatus
        self.inverterStatus = inverterStatus
        self.localControlModeStatus = localControlModeStatus
        self.manufacturerStatus = manufacturerStatus
        self.operationalModeStatus = operationalModeStatus
        self.readingTime = readingTime
        self.stateOfChargeStatus = stateOfChargeStatus
        self.storageModeStatus = storageModeStatus
        self.storConnectStatus = storConnectStatus
    def factory(*args_, **kwargs_):
        if DERStatus.subclass:
            return DERStatus.subclass(*args_, **kwargs_)
        else:
            return DERStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_genConnectStatus(self): return self.genConnectStatus
    def set_genConnectStatus(self, genConnectStatus): self.genConnectStatus = genConnectStatus
    def get_inverterStatus(self): return self.inverterStatus
    def set_inverterStatus(self, inverterStatus): self.inverterStatus = inverterStatus
    def get_localControlModeStatus(self): return self.localControlModeStatus
    def set_localControlModeStatus(self, localControlModeStatus): self.localControlModeStatus = localControlModeStatus
    def get_manufacturerStatus(self): return self.manufacturerStatus
    def set_manufacturerStatus(self, manufacturerStatus): self.manufacturerStatus = manufacturerStatus
    def get_operationalModeStatus(self): return self.operationalModeStatus
    def set_operationalModeStatus(self, operationalModeStatus): self.operationalModeStatus = operationalModeStatus
    def get_readingTime(self): return self.readingTime
    def set_readingTime(self, readingTime): self.readingTime = readingTime
    def get_stateOfChargeStatus(self): return self.stateOfChargeStatus
    def set_stateOfChargeStatus(self, stateOfChargeStatus): self.stateOfChargeStatus = stateOfChargeStatus
    def get_storageModeStatus(self): return self.storageModeStatus
    def set_storageModeStatus(self, storageModeStatus): self.storageModeStatus = storageModeStatus
    def get_storConnectStatus(self): return self.storConnectStatus
    def set_storConnectStatus(self, storConnectStatus): self.storConnectStatus = storConnectStatus
    def hasContent_(self):
        if (
            self.genConnectStatus is not None or
            self.inverterStatus is not None or
            self.localControlModeStatus is not None or
            self.manufacturerStatus is not None or
            self.operationalModeStatus is not None or
            self.readingTime is not None or
            self.stateOfChargeStatus is not None or
            self.storageModeStatus is not None or
            self.storConnectStatus is not None or
            super(DERStatus, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERStatus'):
        super(DERStatus, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERStatus')
    def exportChildren(self, outfile, level, namespace_='', name_='DERStatus', fromsubclass_=False, pretty_print=True):
        super(DERStatus, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.genConnectStatus is not None:
            self.genConnectStatus.export(outfile, level, namespace_, name_='genConnectStatus', pretty_print=pretty_print)
        if self.inverterStatus is not None:
            self.inverterStatus.export(outfile, level, namespace_, name_='inverterStatus', pretty_print=pretty_print)
        if self.localControlModeStatus is not None:
            self.localControlModeStatus.export(outfile, level, namespace_, name_='localControlModeStatus', pretty_print=pretty_print)
        if self.manufacturerStatus is not None:
            self.manufacturerStatus.export(outfile, level, namespace_, name_='manufacturerStatus', pretty_print=pretty_print)
        if self.operationalModeStatus is not None:
            self.operationalModeStatus.export(outfile, level, namespace_, name_='operationalModeStatus', pretty_print=pretty_print)
        if self.readingTime is not None:
            self.readingTime.export(outfile, level, namespace_, name_='readingTime', pretty_print=pretty_print)
        if self.stateOfChargeStatus is not None:
            self.stateOfChargeStatus.export(outfile, level, namespace_, name_='stateOfChargeStatus', pretty_print=pretty_print)
        if self.storageModeStatus is not None:
            self.storageModeStatus.export(outfile, level, namespace_, name_='storageModeStatus', pretty_print=pretty_print)
        if self.storConnectStatus is not None:
            self.storConnectStatus.export(outfile, level, namespace_, name_='storConnectStatus', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERStatus'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERStatus, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERStatus, self).exportLiteralChildren(outfile, level, name_)
        if self.genConnectStatus is not None:
            showIndent(outfile, level)
            outfile.write('genConnectStatus=model_.ConnectStatusType(\n')
            self.genConnectStatus.exportLiteral(outfile, level, name_='genConnectStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.inverterStatus is not None:
            showIndent(outfile, level)
            outfile.write('inverterStatus=model_.InverterStatusType(\n')
            self.inverterStatus.exportLiteral(outfile, level, name_='inverterStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.localControlModeStatus is not None:
            showIndent(outfile, level)
            outfile.write('localControlModeStatus=model_.LocalControlModeStatusType(\n')
            self.localControlModeStatus.exportLiteral(outfile, level, name_='localControlModeStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.manufacturerStatus is not None:
            showIndent(outfile, level)
            outfile.write('manufacturerStatus=model_.ManufacturerStatusType(\n')
            self.manufacturerStatus.exportLiteral(outfile, level, name_='manufacturerStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.operationalModeStatus is not None:
            showIndent(outfile, level)
            outfile.write('operationalModeStatus=model_.OperationalModeStatusType(\n')
            self.operationalModeStatus.exportLiteral(outfile, level, name_='operationalModeStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.readingTime is not None:
            showIndent(outfile, level)
            outfile.write('readingTime=model_.TimeType(\n')
            self.readingTime.exportLiteral(outfile, level, name_='readingTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.stateOfChargeStatus is not None:
            showIndent(outfile, level)
            outfile.write('stateOfChargeStatus=model_.StateOfChargeStatusType(\n')
            self.stateOfChargeStatus.exportLiteral(outfile, level, name_='stateOfChargeStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.storageModeStatus is not None:
            showIndent(outfile, level)
            outfile.write('storageModeStatus=model_.StorageModeStatusType(\n')
            self.storageModeStatus.exportLiteral(outfile, level, name_='storageModeStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.storConnectStatus is not None:
            showIndent(outfile, level)
            outfile.write('storConnectStatus=model_.ConnectStatusType(\n')
            self.storConnectStatus.exportLiteral(outfile, level, name_='storConnectStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERStatus, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'genConnectStatus':
            obj_ = ConnectStatusType.factory()
            obj_.build(child_)
            self.genConnectStatus = obj_
            obj_.original_tagname_ = 'genConnectStatus'
        elif nodeName_ == 'inverterStatus':
            obj_ = InverterStatusType.factory()
            obj_.build(child_)
            self.inverterStatus = obj_
            obj_.original_tagname_ = 'inverterStatus'
        elif nodeName_ == 'localControlModeStatus':
            obj_ = LocalControlModeStatusType.factory()
            obj_.build(child_)
            self.localControlModeStatus = obj_
            obj_.original_tagname_ = 'localControlModeStatus'
        elif nodeName_ == 'manufacturerStatus':
            obj_ = ManufacturerStatusType.factory()
            obj_.build(child_)
            self.manufacturerStatus = obj_
            obj_.original_tagname_ = 'manufacturerStatus'
        elif nodeName_ == 'operationalModeStatus':
            obj_ = OperationalModeStatusType.factory()
            obj_.build(child_)
            self.operationalModeStatus = obj_
            obj_.original_tagname_ = 'operationalModeStatus'
        elif nodeName_ == 'readingTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.readingTime = obj_
            obj_.original_tagname_ = 'readingTime'
        elif nodeName_ == 'stateOfChargeStatus':
            obj_ = StateOfChargeStatusType.factory()
            obj_.build(child_)
            self.stateOfChargeStatus = obj_
            obj_.original_tagname_ = 'stateOfChargeStatus'
        elif nodeName_ == 'storageModeStatus':
            obj_ = StorageModeStatusType.factory()
            obj_.build(child_)
            self.storageModeStatus = obj_
            obj_.original_tagname_ = 'storageModeStatus'
        elif nodeName_ == 'storConnectStatus':
            obj_ = ConnectStatusType.factory()
            obj_.build(child_)
            self.storConnectStatus = obj_
            obj_.original_tagname_ = 'storConnectStatus'
        super(DERStatus, self).buildChildren(child_, node, nodeName_, True)
# end class DERStatus


class DERProgramList(List):
    """A List element to hold DERProgram objects."""
    subclass = None
    superclass = List
    def __init__(self, DERProgram=None):
        self.original_tagname_ = None
        super(DERProgramList, self).__init__()
        if DERProgram is None:
            self.DERProgram = []
        else:
            self.DERProgram = DERProgram
    def factory(*args_, **kwargs_):
        if DERProgramList.subclass:
            return DERProgramList.subclass(*args_, **kwargs_)
        else:
            return DERProgramList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DERProgram(self): return self.DERProgram
    def set_DERProgram(self, DERProgram): self.DERProgram = DERProgram
    def add_DERProgram(self, value): self.DERProgram.append(value)
    def insert_DERProgram_at(self, index, value): self.DERProgram.insert(index, value)
    def replace_DERProgram_at(self, index, value): self.DERProgram[index] = value
    def hasContent_(self):
        if (
            self.DERProgram or
            super(DERProgramList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERProgramList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERProgramList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERProgramList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERProgramList'):
        super(DERProgramList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERProgramList')
    def exportChildren(self, outfile, level, namespace_='', name_='DERProgramList', fromsubclass_=False, pretty_print=True):
        super(DERProgramList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DERProgram_ in self.DERProgram:
            DERProgram_.export(outfile, level, namespace_, name_='DERProgram', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERProgramList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERProgramList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERProgramList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('DERProgram=[\n')
        level += 1
        for DERProgram_ in self.DERProgram:
            showIndent(outfile, level)
            outfile.write('model_.DERProgram(\n')
            DERProgram_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERProgramList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DERProgram':
            obj_ = DERProgram.factory()
            obj_.build(child_)
            self.DERProgram.append(obj_)
            obj_.original_tagname_ = 'DERProgram'
        super(DERProgramList, self).buildChildren(child_, node, nodeName_, True)
# end class DERProgramList


class DERProgram(IdentifiedObject):
    """Distributed Energy Resource program."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, ActiveDERControlListLink=None, DefaultDERControlLink=None, DERControlListLink=None, DERCurveListLink=None, primacy=None):
        self.original_tagname_ = None
        super(DERProgram, self).__init__()
        self.ActiveDERControlListLink = ActiveDERControlListLink
        self.DefaultDERControlLink = DefaultDERControlLink
        self.DERControlListLink = DERControlListLink
        self.DERCurveListLink = DERCurveListLink
        self.primacy = primacy
    def factory(*args_, **kwargs_):
        if DERProgram.subclass:
            return DERProgram.subclass(*args_, **kwargs_)
        else:
            return DERProgram(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActiveDERControlListLink(self): return self.ActiveDERControlListLink
    def set_ActiveDERControlListLink(self, ActiveDERControlListLink): self.ActiveDERControlListLink = ActiveDERControlListLink
    def get_DefaultDERControlLink(self): return self.DefaultDERControlLink
    def set_DefaultDERControlLink(self, DefaultDERControlLink): self.DefaultDERControlLink = DefaultDERControlLink
    def get_DERControlListLink(self): return self.DERControlListLink
    def set_DERControlListLink(self, DERControlListLink): self.DERControlListLink = DERControlListLink
    def get_DERCurveListLink(self): return self.DERCurveListLink
    def set_DERCurveListLink(self, DERCurveListLink): self.DERCurveListLink = DERCurveListLink
    def get_primacy(self): return self.primacy
    def set_primacy(self, primacy): self.primacy = primacy
    def hasContent_(self):
        if (
            self.ActiveDERControlListLink is not None or
            self.DefaultDERControlLink is not None or
            self.DERControlListLink is not None or
            self.DERCurveListLink is not None or
            self.primacy is not None or
            super(DERProgram, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERProgram', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERProgram')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERProgram', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERProgram'):
        super(DERProgram, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERProgram')
    def exportChildren(self, outfile, level, namespace_='', name_='DERProgram', fromsubclass_=False, pretty_print=True):
        super(DERProgram, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveDERControlListLink is not None:
            self.ActiveDERControlListLink.export(outfile, level, namespace_, name_='ActiveDERControlListLink', pretty_print=pretty_print)
        if self.DefaultDERControlLink is not None:
            self.DefaultDERControlLink.export(outfile, level, namespace_, name_='DefaultDERControlLink', pretty_print=pretty_print)
        if self.DERControlListLink is not None:
            self.DERControlListLink.export(outfile, level, namespace_, name_='DERControlListLink', pretty_print=pretty_print)
        if self.DERCurveListLink is not None:
            self.DERCurveListLink.export(outfile, level, namespace_, name_='DERCurveListLink', pretty_print=pretty_print)
        if self.primacy is not None:
            self.primacy.export(outfile, level, namespace_, name_='primacy', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERProgram'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERProgram, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERProgram, self).exportLiteralChildren(outfile, level, name_)
        if self.ActiveDERControlListLink is not None:
            showIndent(outfile, level)
            outfile.write('ActiveDERControlListLink=model_.ActiveDERControlListLink(\n')
            self.ActiveDERControlListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DefaultDERControlLink is not None:
            showIndent(outfile, level)
            outfile.write('DefaultDERControlLink=model_.DefaultDERControlLink(\n')
            self.DefaultDERControlLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DERControlListLink is not None:
            showIndent(outfile, level)
            outfile.write('DERControlListLink=model_.DERControlListLink(\n')
            self.DERControlListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DERCurveListLink is not None:
            showIndent(outfile, level)
            outfile.write('DERCurveListLink=model_.DERCurveListLink(\n')
            self.DERCurveListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.primacy is not None:
            showIndent(outfile, level)
            outfile.write('primacy=model_.PrimacyType(\n')
            self.primacy.exportLiteral(outfile, level, name_='primacy')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERProgram, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActiveDERControlListLink':
            obj_ = ActiveDERControlListLink.factory()
            obj_.build(child_)
            self.ActiveDERControlListLink = obj_
            obj_.original_tagname_ = 'ActiveDERControlListLink'
        elif nodeName_ == 'DefaultDERControlLink':
            obj_ = DefaultDERControlLink.factory()
            obj_.build(child_)
            self.DefaultDERControlLink = obj_
            obj_.original_tagname_ = 'DefaultDERControlLink'
        elif nodeName_ == 'DERControlListLink':
            obj_ = DERControlListLink.factory()
            obj_.build(child_)
            self.DERControlListLink = obj_
            obj_.original_tagname_ = 'DERControlListLink'
        elif nodeName_ == 'DERCurveListLink':
            obj_ = DERCurveListLink.factory()
            obj_.build(child_)
            self.DERCurveListLink = obj_
            obj_.original_tagname_ = 'DERCurveListLink'
        elif nodeName_ == 'primacy':
            obj_ = PrimacyType.factory()
            obj_.build(child_)
            self.primacy = obj_
            obj_.original_tagname_ = 'primacy'
        super(DERProgram, self).buildChildren(child_, node, nodeName_, True)
# end class DERProgram


class DERCurveList(List):
    """A List element to hold DERCurve objects."""
    subclass = None
    superclass = List
    def __init__(self, DERCurve=None):
        self.original_tagname_ = None
        super(DERCurveList, self).__init__()
        if DERCurve is None:
            self.DERCurve = []
        else:
            self.DERCurve = DERCurve
    def factory(*args_, **kwargs_):
        if DERCurveList.subclass:
            return DERCurveList.subclass(*args_, **kwargs_)
        else:
            return DERCurveList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DERCurve(self): return self.DERCurve
    def set_DERCurve(self, DERCurve): self.DERCurve = DERCurve
    def add_DERCurve(self, value): self.DERCurve.append(value)
    def insert_DERCurve_at(self, index, value): self.DERCurve.insert(index, value)
    def replace_DERCurve_at(self, index, value): self.DERCurve[index] = value
    def hasContent_(self):
        if (
            self.DERCurve or
            super(DERCurveList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERCurveList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERCurveList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERCurveList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERCurveList'):
        super(DERCurveList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERCurveList')
    def exportChildren(self, outfile, level, namespace_='', name_='DERCurveList', fromsubclass_=False, pretty_print=True):
        super(DERCurveList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DERCurve_ in self.DERCurve:
            DERCurve_.export(outfile, level, namespace_, name_='DERCurve', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERCurveList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERCurveList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERCurveList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('DERCurve=[\n')
        level += 1
        for DERCurve_ in self.DERCurve:
            showIndent(outfile, level)
            outfile.write('model_.DERCurve(\n')
            DERCurve_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERCurveList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DERCurve':
            obj_ = DERCurve.factory()
            obj_.build(child_)
            self.DERCurve.append(obj_)
            obj_.original_tagname_ = 'DERCurve'
        super(DERCurveList, self).buildChildren(child_, node, nodeName_, True)
# end class DERCurveList


class CurrentDERProgramLink(Link):
    """SHALL contain a Link to an instance of DERProgram. If present, this
    is the DERProgram containing the currently active DERControl."""
    subclass = None
    superclass = Link
    def __init__(self):
        self.original_tagname_ = None
        super(CurrentDERProgramLink, self).__init__()
    def factory(*args_, **kwargs_):
        if CurrentDERProgramLink.subclass:
            return CurrentDERProgramLink.subclass(*args_, **kwargs_)
        else:
            return CurrentDERProgramLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(CurrentDERProgramLink, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CurrentDERProgramLink', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentDERProgramLink')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CurrentDERProgramLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CurrentDERProgramLink'):
        super(CurrentDERProgramLink, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CurrentDERProgramLink')
    def exportChildren(self, outfile, level, namespace_='', name_='CurrentDERProgramLink', fromsubclass_=False, pretty_print=True):
        super(CurrentDERProgramLink, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='CurrentDERProgramLink'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CurrentDERProgramLink, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CurrentDERProgramLink, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CurrentDERProgramLink, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(CurrentDERProgramLink, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class CurrentDERProgramLink


class DERCurve(IdentifiedObject):
    """DER related curves such as Volt-VAr mode curves. Relationship
    between an independent variable (X-axis) and one or two
    dependent variables (Y-axis and excitation)."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, creationTime=None, CurveData=None, curveType=None, rampDecTms=None, rampIncTms=None, rampPT1Tms=None, xMultiplier=None, yMultiplier=None, yRefType=None):
        self.original_tagname_ = None
        super(DERCurve, self).__init__()
        self.creationTime = creationTime
        if CurveData is None:
            self.CurveData = []
        else:
            self.CurveData = CurveData
        self.curveType = curveType
        self.rampDecTms = rampDecTms
        self.rampIncTms = rampIncTms
        self.rampPT1Tms = rampPT1Tms
        self.xMultiplier = xMultiplier
        self.yMultiplier = yMultiplier
        self.yRefType = yRefType
    def factory(*args_, **kwargs_):
        if DERCurve.subclass:
            return DERCurve.subclass(*args_, **kwargs_)
        else:
            return DERCurve(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creationTime(self): return self.creationTime
    def set_creationTime(self, creationTime): self.creationTime = creationTime
    def get_CurveData(self): return self.CurveData
    def set_CurveData(self, CurveData): self.CurveData = CurveData
    def add_CurveData(self, value): self.CurveData.append(value)
    def insert_CurveData_at(self, index, value): self.CurveData.insert(index, value)
    def replace_CurveData_at(self, index, value): self.CurveData[index] = value
    def get_curveType(self): return self.curveType
    def set_curveType(self, curveType): self.curveType = curveType
    def get_rampDecTms(self): return self.rampDecTms
    def set_rampDecTms(self, rampDecTms): self.rampDecTms = rampDecTms
    def get_rampIncTms(self): return self.rampIncTms
    def set_rampIncTms(self, rampIncTms): self.rampIncTms = rampIncTms
    def get_rampPT1Tms(self): return self.rampPT1Tms
    def set_rampPT1Tms(self, rampPT1Tms): self.rampPT1Tms = rampPT1Tms
    def get_xMultiplier(self): return self.xMultiplier
    def set_xMultiplier(self, xMultiplier): self.xMultiplier = xMultiplier
    def get_yMultiplier(self): return self.yMultiplier
    def set_yMultiplier(self, yMultiplier): self.yMultiplier = yMultiplier
    def get_yRefType(self): return self.yRefType
    def set_yRefType(self, yRefType): self.yRefType = yRefType
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.creationTime is not None or
            self.CurveData or
            self.curveType is not None or
            self.rampDecTms is not None or
            self.rampIncTms is not None or
            self.rampPT1Tms is not None or
            self.xMultiplier is not None or
            self.yMultiplier is not None or
            self.yRefType is not None or
            super(DERCurve, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERCurve', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERCurve')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERCurve', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERCurve'):
        super(DERCurve, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERCurve')
    def exportChildren(self, outfile, level, namespace_='', name_='DERCurve', fromsubclass_=False, pretty_print=True):
        super(DERCurve, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creationTime is not None:
            self.creationTime.export(outfile, level, namespace_, name_='creationTime', pretty_print=pretty_print)
        for CurveData_ in self.CurveData:
            CurveData_.export(outfile, level, namespace_, name_='CurveData', pretty_print=pretty_print)
        if self.curveType is not None:
            self.curveType.export(outfile, level, namespace_, name_='curveType', pretty_print=pretty_print)
        if self.rampDecTms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srampDecTms>%s</%srampDecTms>%s' % (namespace_, self.gds_format_integer(self.rampDecTms, input_name='rampDecTms'), namespace_, eol_))
        if self.rampIncTms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srampIncTms>%s</%srampIncTms>%s' % (namespace_, self.gds_format_integer(self.rampIncTms, input_name='rampIncTms'), namespace_, eol_))
        if self.rampPT1Tms is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srampPT1Tms>%s</%srampPT1Tms>%s' % (namespace_, self.gds_format_integer(self.rampPT1Tms, input_name='rampPT1Tms'), namespace_, eol_))
        if self.xMultiplier is not None:
            self.xMultiplier.export(outfile, level, namespace_, name_='xMultiplier', pretty_print=pretty_print)
        if self.yMultiplier is not None:
            self.yMultiplier.export(outfile, level, namespace_, name_='yMultiplier', pretty_print=pretty_print)
        if self.yRefType is not None:
            self.yRefType.export(outfile, level, namespace_, name_='yRefType', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERCurve'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERCurve, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERCurve, self).exportLiteralChildren(outfile, level, name_)
        if self.creationTime is not None:
            showIndent(outfile, level)
            outfile.write('creationTime=model_.TimeType(\n')
            self.creationTime.exportLiteral(outfile, level, name_='creationTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CurveData=[\n')
        level += 1
        for CurveData_ in self.CurveData:
            showIndent(outfile, level)
            outfile.write('model_.CurveData(\n')
            CurveData_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.curveType is not None:
            showIndent(outfile, level)
            outfile.write('curveType=model_.DERCurveType(\n')
            self.curveType.exportLiteral(outfile, level, name_='curveType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rampDecTms is not None:
            showIndent(outfile, level)
            outfile.write('rampDecTms=%d,\n' % self.rampDecTms)
        if self.rampIncTms is not None:
            showIndent(outfile, level)
            outfile.write('rampIncTms=%d,\n' % self.rampIncTms)
        if self.rampPT1Tms is not None:
            showIndent(outfile, level)
            outfile.write('rampPT1Tms=%d,\n' % self.rampPT1Tms)
        if self.xMultiplier is not None:
            showIndent(outfile, level)
            outfile.write('xMultiplier=model_.PowerOfTenMultiplierType(\n')
            self.xMultiplier.exportLiteral(outfile, level, name_='xMultiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.yMultiplier is not None:
            showIndent(outfile, level)
            outfile.write('yMultiplier=model_.PowerOfTenMultiplierType(\n')
            self.yMultiplier.exportLiteral(outfile, level, name_='yMultiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.yRefType is not None:
            showIndent(outfile, level)
            outfile.write('yRefType=model_.DERUnitRefType(\n')
            self.yRefType.exportLiteral(outfile, level, name_='yRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERCurve, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creationTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.creationTime = obj_
            obj_.original_tagname_ = 'creationTime'
        elif nodeName_ == 'CurveData':
            obj_ = CurveData.factory()
            obj_.build(child_)
            self.CurveData.append(obj_)
            obj_.original_tagname_ = 'CurveData'
        elif nodeName_ == 'curveType':
            obj_ = DERCurveType.factory()
            obj_.build(child_)
            self.curveType = obj_
            obj_.original_tagname_ = 'curveType'
        elif nodeName_ == 'rampDecTms':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rampDecTms')
            self.rampDecTms = ival_
            self.validate_UInt16(self.rampDecTms)    # validate type UInt16
        elif nodeName_ == 'rampIncTms':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rampIncTms')
            self.rampIncTms = ival_
            self.validate_UInt16(self.rampIncTms)    # validate type UInt16
        elif nodeName_ == 'rampPT1Tms':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rampPT1Tms')
            self.rampPT1Tms = ival_
            self.validate_UInt16(self.rampPT1Tms)    # validate type UInt16
        elif nodeName_ == 'xMultiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.xMultiplier = obj_
            obj_.original_tagname_ = 'xMultiplier'
        elif nodeName_ == 'yMultiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.yMultiplier = obj_
            obj_.original_tagname_ = 'yMultiplier'
        elif nodeName_ == 'yRefType':
            obj_ = DERUnitRefType.factory()
            obj_.build(child_)
            self.yRefType = obj_
            obj_.original_tagname_ = 'yRefType'
        super(DERCurve, self).buildChildren(child_, node, nodeName_, True)
# end class DERCurve


class DERControlList(SubscribableList):
    """A List element to hold DERControl objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, DERControl=None):
        self.original_tagname_ = None
        super(DERControlList, self).__init__()
        if DERControl is None:
            self.DERControl = []
        else:
            self.DERControl = DERControl
    def factory(*args_, **kwargs_):
        if DERControlList.subclass:
            return DERControlList.subclass(*args_, **kwargs_)
        else:
            return DERControlList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DERControl(self): return self.DERControl
    def set_DERControl(self, DERControl): self.DERControl = DERControl
    def add_DERControl(self, value): self.DERControl.append(value)
    def insert_DERControl_at(self, index, value): self.DERControl.insert(index, value)
    def replace_DERControl_at(self, index, value): self.DERControl[index] = value
    def hasContent_(self):
        if (
            self.DERControl or
            super(DERControlList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERControlList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERControlList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERControlList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERControlList'):
        super(DERControlList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERControlList')
    def exportChildren(self, outfile, level, namespace_='', name_='DERControlList', fromsubclass_=False, pretty_print=True):
        super(DERControlList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DERControl_ in self.DERControl:
            DERControl_.export(outfile, level, namespace_, name_='DERControl', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERControlList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERControlList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERControlList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('DERControl=[\n')
        level += 1
        for DERControl_ in self.DERControl:
            showIndent(outfile, level)
            outfile.write('model_.DERControl(\n')
            DERControl_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERControlList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DERControl':
            obj_ = DERControl.factory()
            obj_.build(child_)
            self.DERControl.append(obj_)
            obj_.original_tagname_ = 'DERControl'
        super(DERControlList, self).buildChildren(child_, node, nodeName_, True)
# end class DERControlList


class DERControl(RandomizableEvent):
    """Distributed Energy Resource (DER) time/event-based control."""
    subclass = None
    superclass = RandomizableEvent
    def __init__(self, DERControlBase=None):
        self.original_tagname_ = None
        super(DERControl, self).__init__()
        self.DERControlBase = DERControlBase
    def factory(*args_, **kwargs_):
        if DERControl.subclass:
            return DERControl.subclass(*args_, **kwargs_)
        else:
            return DERControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DERControlBase(self): return self.DERControlBase
    def set_DERControlBase(self, DERControlBase): self.DERControlBase = DERControlBase
    def hasContent_(self):
        if (
            self.DERControlBase is not None or
            super(DERControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERControl', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERControl'):
        super(DERControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERControl')
    def exportChildren(self, outfile, level, namespace_='', name_='DERControl', fromsubclass_=False, pretty_print=True):
        super(DERControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DERControlBase is not None:
            self.DERControlBase.export(outfile, level, namespace_, name_='DERControlBase', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERControl'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERControl, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERControl, self).exportLiteralChildren(outfile, level, name_)
        if self.DERControlBase is not None:
            showIndent(outfile, level)
            outfile.write('DERControlBase=model_.DERControlBase(\n')
            self.DERControlBase.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DERControlBase':
            obj_ = DERControlBase.factory()
            obj_.build(child_)
            self.DERControlBase = obj_
            obj_.original_tagname_ = 'DERControlBase'
        super(DERControl, self).buildChildren(child_, node, nodeName_, True)
# end class DERControl


class DERCapability(Resource):
    """Distributed energy resource type and nameplate ratings."""
    subclass = None
    superclass = Resource
    def __init__(self, modesSupported=None, rtgA=None, rtgAh=None, rtgMaxChargeRate=None, rtgMaxDischargeRate=None, rtgMinPF=None, rtgMinPFNeg=None, rtgVA=None, rtgVAr=None, rtgVArNeg=None, rtgW=None, rtgWh=None, type_=None):
        self.original_tagname_ = None
        super(DERCapability, self).__init__()
        self.modesSupported = modesSupported
        self.rtgA = rtgA
        self.rtgAh = rtgAh
        self.rtgMaxChargeRate = rtgMaxChargeRate
        self.rtgMaxDischargeRate = rtgMaxDischargeRate
        self.rtgMinPF = rtgMinPF
        self.rtgMinPFNeg = rtgMinPFNeg
        self.rtgVA = rtgVA
        self.rtgVAr = rtgVAr
        self.rtgVArNeg = rtgVArNeg
        self.rtgW = rtgW
        self.rtgWh = rtgWh
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if DERCapability.subclass:
            return DERCapability.subclass(*args_, **kwargs_)
        else:
            return DERCapability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_modesSupported(self): return self.modesSupported
    def set_modesSupported(self, modesSupported): self.modesSupported = modesSupported
    def get_rtgA(self): return self.rtgA
    def set_rtgA(self, rtgA): self.rtgA = rtgA
    def get_rtgAh(self): return self.rtgAh
    def set_rtgAh(self, rtgAh): self.rtgAh = rtgAh
    def get_rtgMaxChargeRate(self): return self.rtgMaxChargeRate
    def set_rtgMaxChargeRate(self, rtgMaxChargeRate): self.rtgMaxChargeRate = rtgMaxChargeRate
    def get_rtgMaxDischargeRate(self): return self.rtgMaxDischargeRate
    def set_rtgMaxDischargeRate(self, rtgMaxDischargeRate): self.rtgMaxDischargeRate = rtgMaxDischargeRate
    def get_rtgMinPF(self): return self.rtgMinPF
    def set_rtgMinPF(self, rtgMinPF): self.rtgMinPF = rtgMinPF
    def get_rtgMinPFNeg(self): return self.rtgMinPFNeg
    def set_rtgMinPFNeg(self, rtgMinPFNeg): self.rtgMinPFNeg = rtgMinPFNeg
    def get_rtgVA(self): return self.rtgVA
    def set_rtgVA(self, rtgVA): self.rtgVA = rtgVA
    def get_rtgVAr(self): return self.rtgVAr
    def set_rtgVAr(self, rtgVAr): self.rtgVAr = rtgVAr
    def get_rtgVArNeg(self): return self.rtgVArNeg
    def set_rtgVArNeg(self, rtgVArNeg): self.rtgVArNeg = rtgVArNeg
    def get_rtgW(self): return self.rtgW
    def set_rtgW(self, rtgW): self.rtgW = rtgW
    def get_rtgWh(self): return self.rtgWh
    def set_rtgWh(self, rtgWh): self.rtgWh = rtgWh
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.modesSupported is not None or
            self.rtgA is not None or
            self.rtgAh is not None or
            self.rtgMaxChargeRate is not None or
            self.rtgMaxDischargeRate is not None or
            self.rtgMinPF is not None or
            self.rtgMinPFNeg is not None or
            self.rtgVA is not None or
            self.rtgVAr is not None or
            self.rtgVArNeg is not None or
            self.rtgW is not None or
            self.rtgWh is not None or
            self.type_ is not None or
            super(DERCapability, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERCapability', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERCapability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERCapability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERCapability'):
        super(DERCapability, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERCapability')
    def exportChildren(self, outfile, level, namespace_='', name_='DERCapability', fromsubclass_=False, pretty_print=True):
        super(DERCapability, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.modesSupported is not None:
            self.modesSupported.export(outfile, level, namespace_, name_='modesSupported', pretty_print=pretty_print)
        if self.rtgA is not None:
            self.rtgA.export(outfile, level, namespace_, name_='rtgA', pretty_print=pretty_print)
        if self.rtgAh is not None:
            self.rtgAh.export(outfile, level, namespace_, name_='rtgAh', pretty_print=pretty_print)
        if self.rtgMaxChargeRate is not None:
            self.rtgMaxChargeRate.export(outfile, level, namespace_, name_='rtgMaxChargeRate', pretty_print=pretty_print)
        if self.rtgMaxDischargeRate is not None:
            self.rtgMaxDischargeRate.export(outfile, level, namespace_, name_='rtgMaxDischargeRate', pretty_print=pretty_print)
        if self.rtgMinPF is not None:
            self.rtgMinPF.export(outfile, level, namespace_, name_='rtgMinPF', pretty_print=pretty_print)
        if self.rtgMinPFNeg is not None:
            self.rtgMinPFNeg.export(outfile, level, namespace_, name_='rtgMinPFNeg', pretty_print=pretty_print)
        if self.rtgVA is not None:
            self.rtgVA.export(outfile, level, namespace_, name_='rtgVA', pretty_print=pretty_print)
        if self.rtgVAr is not None:
            self.rtgVAr.export(outfile, level, namespace_, name_='rtgVAr', pretty_print=pretty_print)
        if self.rtgVArNeg is not None:
            self.rtgVArNeg.export(outfile, level, namespace_, name_='rtgVArNeg', pretty_print=pretty_print)
        if self.rtgW is not None:
            self.rtgW.export(outfile, level, namespace_, name_='rtgW', pretty_print=pretty_print)
        if self.rtgWh is not None:
            self.rtgWh.export(outfile, level, namespace_, name_='rtgWh', pretty_print=pretty_print)
        if self.type_ is not None:
            self.type_.export(outfile, level, namespace_, name_='type', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERCapability'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERCapability, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERCapability, self).exportLiteralChildren(outfile, level, name_)
        if self.modesSupported is not None:
            showIndent(outfile, level)
            outfile.write('modesSupported=model_.DERControlType(\n')
            self.modesSupported.exportLiteral(outfile, level, name_='modesSupported')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgA is not None:
            showIndent(outfile, level)
            outfile.write('rtgA=model_.CurrentRMS(\n')
            self.rtgA.exportLiteral(outfile, level, name_='rtgA')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgAh is not None:
            showIndent(outfile, level)
            outfile.write('rtgAh=model_.AmpereHour(\n')
            self.rtgAh.exportLiteral(outfile, level, name_='rtgAh')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgMaxChargeRate is not None:
            showIndent(outfile, level)
            outfile.write('rtgMaxChargeRate=model_.ActivePower(\n')
            self.rtgMaxChargeRate.exportLiteral(outfile, level, name_='rtgMaxChargeRate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgMaxDischargeRate is not None:
            showIndent(outfile, level)
            outfile.write('rtgMaxDischargeRate=model_.ActivePower(\n')
            self.rtgMaxDischargeRate.exportLiteral(outfile, level, name_='rtgMaxDischargeRate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgMinPF is not None:
            showIndent(outfile, level)
            outfile.write('rtgMinPF=model_.UnsignedFixedPointType(\n')
            self.rtgMinPF.exportLiteral(outfile, level, name_='rtgMinPF')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgMinPFNeg is not None:
            showIndent(outfile, level)
            outfile.write('rtgMinPFNeg=model_.FixedPointType(\n')
            self.rtgMinPFNeg.exportLiteral(outfile, level, name_='rtgMinPFNeg')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgVA is not None:
            showIndent(outfile, level)
            outfile.write('rtgVA=model_.ApparentPower(\n')
            self.rtgVA.exportLiteral(outfile, level, name_='rtgVA')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgVAr is not None:
            showIndent(outfile, level)
            outfile.write('rtgVAr=model_.ReactivePower(\n')
            self.rtgVAr.exportLiteral(outfile, level, name_='rtgVAr')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgVArNeg is not None:
            showIndent(outfile, level)
            outfile.write('rtgVArNeg=model_.ReactivePower(\n')
            self.rtgVArNeg.exportLiteral(outfile, level, name_='rtgVArNeg')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgW is not None:
            showIndent(outfile, level)
            outfile.write('rtgW=model_.ActivePower(\n')
            self.rtgW.exportLiteral(outfile, level, name_='rtgW')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rtgWh is not None:
            showIndent(outfile, level)
            outfile.write('rtgWh=model_.WattHour(\n')
            self.rtgWh.exportLiteral(outfile, level, name_='rtgWh')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=model_.DERType(\n')
            self.type_.exportLiteral(outfile, level, name_='type')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERCapability, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'modesSupported':
            obj_ = DERControlType.factory()
            obj_.build(child_)
            self.modesSupported = obj_
            obj_.original_tagname_ = 'modesSupported'
        elif nodeName_ == 'rtgA':
            obj_ = CurrentRMS.factory()
            obj_.build(child_)
            self.rtgA = obj_
            obj_.original_tagname_ = 'rtgA'
        elif nodeName_ == 'rtgAh':
            obj_ = AmpereHour.factory()
            obj_.build(child_)
            self.rtgAh = obj_
            obj_.original_tagname_ = 'rtgAh'
        elif nodeName_ == 'rtgMaxChargeRate':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.rtgMaxChargeRate = obj_
            obj_.original_tagname_ = 'rtgMaxChargeRate'
        elif nodeName_ == 'rtgMaxDischargeRate':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.rtgMaxDischargeRate = obj_
            obj_.original_tagname_ = 'rtgMaxDischargeRate'
        elif nodeName_ == 'rtgMinPF':
            obj_ = UnsignedFixedPointType.factory()
            obj_.build(child_)
            self.rtgMinPF = obj_
            obj_.original_tagname_ = 'rtgMinPF'
        elif nodeName_ == 'rtgMinPFNeg':
            obj_ = FixedPointType.factory()
            obj_.build(child_)
            self.rtgMinPFNeg = obj_
            obj_.original_tagname_ = 'rtgMinPFNeg'
        elif nodeName_ == 'rtgVA':
            obj_ = ApparentPower.factory()
            obj_.build(child_)
            self.rtgVA = obj_
            obj_.original_tagname_ = 'rtgVA'
        elif nodeName_ == 'rtgVAr':
            obj_ = ReactivePower.factory()
            obj_.build(child_)
            self.rtgVAr = obj_
            obj_.original_tagname_ = 'rtgVAr'
        elif nodeName_ == 'rtgVArNeg':
            obj_ = ReactivePower.factory()
            obj_.build(child_)
            self.rtgVArNeg = obj_
            obj_.original_tagname_ = 'rtgVArNeg'
        elif nodeName_ == 'rtgW':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.rtgW = obj_
            obj_.original_tagname_ = 'rtgW'
        elif nodeName_ == 'rtgWh':
            obj_ = WattHour.factory()
            obj_.build(child_)
            self.rtgWh = obj_
            obj_.original_tagname_ = 'rtgWh'
        elif nodeName_ == 'type':
            obj_ = DERType.factory()
            obj_.build(child_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        super(DERCapability, self).buildChildren(child_, node, nodeName_, True)
# end class DERCapability


class DERAvailability(SubscribableResource):
    """Indicates current reserve generation status"""
    subclass = None
    superclass = SubscribableResource
    def __init__(self, availabilityDuration=None, maxChargeDuration=None, readingTime=None, reserveChargePercent=None, reservePercent=None, statVArAvail=None, statWAvail=None):
        self.original_tagname_ = None
        super(DERAvailability, self).__init__()
        self.availabilityDuration = availabilityDuration
        self.maxChargeDuration = maxChargeDuration
        self.readingTime = readingTime
        self.reserveChargePercent = reserveChargePercent
        self.reservePercent = reservePercent
        self.statVArAvail = statVArAvail
        self.statWAvail = statWAvail
    def factory(*args_, **kwargs_):
        if DERAvailability.subclass:
            return DERAvailability.subclass(*args_, **kwargs_)
        else:
            return DERAvailability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_availabilityDuration(self): return self.availabilityDuration
    def set_availabilityDuration(self, availabilityDuration): self.availabilityDuration = availabilityDuration
    def get_maxChargeDuration(self): return self.maxChargeDuration
    def set_maxChargeDuration(self, maxChargeDuration): self.maxChargeDuration = maxChargeDuration
    def get_readingTime(self): return self.readingTime
    def set_readingTime(self, readingTime): self.readingTime = readingTime
    def get_reserveChargePercent(self): return self.reserveChargePercent
    def set_reserveChargePercent(self, reserveChargePercent): self.reserveChargePercent = reserveChargePercent
    def get_reservePercent(self): return self.reservePercent
    def set_reservePercent(self, reservePercent): self.reservePercent = reservePercent
    def get_statVArAvail(self): return self.statVArAvail
    def set_statVArAvail(self, statVArAvail): self.statVArAvail = statVArAvail
    def get_statWAvail(self): return self.statWAvail
    def set_statWAvail(self, statWAvail): self.statWAvail = statWAvail
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def hasContent_(self):
        if (
            self.availabilityDuration is not None or
            self.maxChargeDuration is not None or
            self.readingTime is not None or
            self.reserveChargePercent is not None or
            self.reservePercent is not None or
            self.statVArAvail is not None or
            self.statWAvail is not None or
            super(DERAvailability, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERAvailability', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERAvailability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERAvailability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERAvailability'):
        super(DERAvailability, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERAvailability')
    def exportChildren(self, outfile, level, namespace_='', name_='DERAvailability', fromsubclass_=False, pretty_print=True):
        super(DERAvailability, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.availabilityDuration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailabilityDuration>%s</%savailabilityDuration>%s' % (namespace_, self.gds_format_integer(self.availabilityDuration, input_name='availabilityDuration'), namespace_, eol_))
        if self.maxChargeDuration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxChargeDuration>%s</%smaxChargeDuration>%s' % (namespace_, self.gds_format_integer(self.maxChargeDuration, input_name='maxChargeDuration'), namespace_, eol_))
        if self.readingTime is not None:
            self.readingTime.export(outfile, level, namespace_, name_='readingTime', pretty_print=pretty_print)
        if self.reserveChargePercent is not None:
            self.reserveChargePercent.export(outfile, level, namespace_, name_='reserveChargePercent', pretty_print=pretty_print)
        if self.reservePercent is not None:
            self.reservePercent.export(outfile, level, namespace_, name_='reservePercent', pretty_print=pretty_print)
        if self.statVArAvail is not None:
            self.statVArAvail.export(outfile, level, namespace_, name_='statVArAvail', pretty_print=pretty_print)
        if self.statWAvail is not None:
            self.statWAvail.export(outfile, level, namespace_, name_='statWAvail', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERAvailability'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERAvailability, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERAvailability, self).exportLiteralChildren(outfile, level, name_)
        if self.availabilityDuration is not None:
            showIndent(outfile, level)
            outfile.write('availabilityDuration=%d,\n' % self.availabilityDuration)
        if self.maxChargeDuration is not None:
            showIndent(outfile, level)
            outfile.write('maxChargeDuration=%d,\n' % self.maxChargeDuration)
        if self.readingTime is not None:
            showIndent(outfile, level)
            outfile.write('readingTime=model_.TimeType(\n')
            self.readingTime.exportLiteral(outfile, level, name_='readingTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reserveChargePercent is not None:
            showIndent(outfile, level)
            outfile.write('reserveChargePercent=model_.PerCent(\n')
            self.reserveChargePercent.exportLiteral(outfile, level, name_='reserveChargePercent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.reservePercent is not None:
            showIndent(outfile, level)
            outfile.write('reservePercent=model_.PerCent(\n')
            self.reservePercent.exportLiteral(outfile, level, name_='reservePercent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.statVArAvail is not None:
            showIndent(outfile, level)
            outfile.write('statVArAvail=model_.ReactivePower(\n')
            self.statVArAvail.exportLiteral(outfile, level, name_='statVArAvail')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.statWAvail is not None:
            showIndent(outfile, level)
            outfile.write('statWAvail=model_.ActivePower(\n')
            self.statWAvail.exportLiteral(outfile, level, name_='statWAvail')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERAvailability, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'availabilityDuration':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'availabilityDuration')
            self.availabilityDuration = ival_
            self.validate_UInt32(self.availabilityDuration)    # validate type UInt32
        elif nodeName_ == 'maxChargeDuration':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maxChargeDuration')
            self.maxChargeDuration = ival_
            self.validate_UInt32(self.maxChargeDuration)    # validate type UInt32
        elif nodeName_ == 'readingTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.readingTime = obj_
            obj_.original_tagname_ = 'readingTime'
        elif nodeName_ == 'reserveChargePercent':
            obj_ = PerCent.factory()
            obj_.build(child_)
            self.reserveChargePercent = obj_
            obj_.original_tagname_ = 'reserveChargePercent'
        elif nodeName_ == 'reservePercent':
            obj_ = PerCent.factory()
            obj_.build(child_)
            self.reservePercent = obj_
            obj_.original_tagname_ = 'reservePercent'
        elif nodeName_ == 'statVArAvail':
            obj_ = ReactivePower.factory()
            obj_.build(child_)
            self.statVArAvail = obj_
            obj_.original_tagname_ = 'statVArAvail'
        elif nodeName_ == 'statWAvail':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.statWAvail = obj_
            obj_.original_tagname_ = 'statWAvail'
        super(DERAvailability, self).buildChildren(child_, node, nodeName_, True)
# end class DERAvailability


class DERSettings(SubscribableResource):
    """Distributed energy resource settings"""
    subclass = None
    superclass = SubscribableResource
    def __init__(self, setGenConnect=None, setGradW=None, setMaxChargeRate=None, setMaxDischargeRate=None, setMaxVA=None, setMaxVAr=None, setMaxVArNeg=None, setMaxW=None, setMinPF=None, setMinPFNeg=None, setStorConnect=None, setVRef=None, setVRefOfs=None, updatedTime=None):
        self.original_tagname_ = None
        super(DERSettings, self).__init__()
        self.setGenConnect = setGenConnect
        self.setGradW = setGradW
        self.setMaxChargeRate = setMaxChargeRate
        self.setMaxDischargeRate = setMaxDischargeRate
        self.setMaxVA = setMaxVA
        self.setMaxVAr = setMaxVAr
        self.setMaxVArNeg = setMaxVArNeg
        self.setMaxW = setMaxW
        self.setMinPF = setMinPF
        self.setMinPFNeg = setMinPFNeg
        self.setStorConnect = setStorConnect
        self.setVRef = setVRef
        self.setVRefOfs = setVRefOfs
        self.updatedTime = updatedTime
    def factory(*args_, **kwargs_):
        if DERSettings.subclass:
            return DERSettings.subclass(*args_, **kwargs_)
        else:
            return DERSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_setGenConnect(self): return self.setGenConnect
    def set_setGenConnect(self, setGenConnect): self.setGenConnect = setGenConnect
    def get_setGradW(self): return self.setGradW
    def set_setGradW(self, setGradW): self.setGradW = setGradW
    def get_setMaxChargeRate(self): return self.setMaxChargeRate
    def set_setMaxChargeRate(self, setMaxChargeRate): self.setMaxChargeRate = setMaxChargeRate
    def get_setMaxDischargeRate(self): return self.setMaxDischargeRate
    def set_setMaxDischargeRate(self, setMaxDischargeRate): self.setMaxDischargeRate = setMaxDischargeRate
    def get_setMaxVA(self): return self.setMaxVA
    def set_setMaxVA(self, setMaxVA): self.setMaxVA = setMaxVA
    def get_setMaxVAr(self): return self.setMaxVAr
    def set_setMaxVAr(self, setMaxVAr): self.setMaxVAr = setMaxVAr
    def get_setMaxVArNeg(self): return self.setMaxVArNeg
    def set_setMaxVArNeg(self, setMaxVArNeg): self.setMaxVArNeg = setMaxVArNeg
    def get_setMaxW(self): return self.setMaxW
    def set_setMaxW(self, setMaxW): self.setMaxW = setMaxW
    def get_setMinPF(self): return self.setMinPF
    def set_setMinPF(self, setMinPF): self.setMinPF = setMinPF
    def get_setMinPFNeg(self): return self.setMinPFNeg
    def set_setMinPFNeg(self, setMinPFNeg): self.setMinPFNeg = setMinPFNeg
    def get_setStorConnect(self): return self.setStorConnect
    def set_setStorConnect(self, setStorConnect): self.setStorConnect = setStorConnect
    def get_setVRef(self): return self.setVRef
    def set_setVRef(self, setVRef): self.setVRef = setVRef
    def get_setVRefOfs(self): return self.setVRefOfs
    def set_setVRefOfs(self, setVRefOfs): self.setVRefOfs = setVRefOfs
    def get_updatedTime(self): return self.updatedTime
    def set_updatedTime(self, updatedTime): self.updatedTime = updatedTime
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.setGenConnect is not None or
            self.setGradW is not None or
            self.setMaxChargeRate is not None or
            self.setMaxDischargeRate is not None or
            self.setMaxVA is not None or
            self.setMaxVAr is not None or
            self.setMaxVArNeg is not None or
            self.setMaxW is not None or
            self.setMinPF is not None or
            self.setMinPFNeg is not None or
            self.setStorConnect is not None or
            self.setVRef is not None or
            self.setVRefOfs is not None or
            self.updatedTime is not None or
            super(DERSettings, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERSettings', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERSettings')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERSettings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERSettings'):
        super(DERSettings, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERSettings')
    def exportChildren(self, outfile, level, namespace_='', name_='DERSettings', fromsubclass_=False, pretty_print=True):
        super(DERSettings, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.setGenConnect is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetGenConnect>%s</%ssetGenConnect>%s' % (namespace_, self.gds_format_boolean(self.setGenConnect, input_name='setGenConnect'), namespace_, eol_))
        if self.setGradW is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetGradW>%s</%ssetGradW>%s' % (namespace_, self.gds_format_integer(self.setGradW, input_name='setGradW'), namespace_, eol_))
        if self.setMaxChargeRate is not None:
            self.setMaxChargeRate.export(outfile, level, namespace_, name_='setMaxChargeRate', pretty_print=pretty_print)
        if self.setMaxDischargeRate is not None:
            self.setMaxDischargeRate.export(outfile, level, namespace_, name_='setMaxDischargeRate', pretty_print=pretty_print)
        if self.setMaxVA is not None:
            self.setMaxVA.export(outfile, level, namespace_, name_='setMaxVA', pretty_print=pretty_print)
        if self.setMaxVAr is not None:
            self.setMaxVAr.export(outfile, level, namespace_, name_='setMaxVAr', pretty_print=pretty_print)
        if self.setMaxVArNeg is not None:
            self.setMaxVArNeg.export(outfile, level, namespace_, name_='setMaxVArNeg', pretty_print=pretty_print)
        if self.setMaxW is not None:
            self.setMaxW.export(outfile, level, namespace_, name_='setMaxW', pretty_print=pretty_print)
        if self.setMinPF is not None:
            self.setMinPF.export(outfile, level, namespace_, name_='setMinPF', pretty_print=pretty_print)
        if self.setMinPFNeg is not None:
            self.setMinPFNeg.export(outfile, level, namespace_, name_='setMinPFNeg', pretty_print=pretty_print)
        if self.setStorConnect is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetStorConnect>%s</%ssetStorConnect>%s' % (namespace_, self.gds_format_boolean(self.setStorConnect, input_name='setStorConnect'), namespace_, eol_))
        if self.setVRef is not None:
            self.setVRef.export(outfile, level, namespace_, name_='setVRef', pretty_print=pretty_print)
        if self.setVRefOfs is not None:
            self.setVRefOfs.export(outfile, level, namespace_, name_='setVRefOfs', pretty_print=pretty_print)
        if self.updatedTime is not None:
            self.updatedTime.export(outfile, level, namespace_, name_='updatedTime', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERSettings'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERSettings, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERSettings, self).exportLiteralChildren(outfile, level, name_)
        if self.setGenConnect is not None:
            showIndent(outfile, level)
            outfile.write('setGenConnect=%s,\n' % self.setGenConnect)
        if self.setGradW is not None:
            showIndent(outfile, level)
            outfile.write('setGradW=%d,\n' % self.setGradW)
        if self.setMaxChargeRate is not None:
            showIndent(outfile, level)
            outfile.write('setMaxChargeRate=model_.ActivePower(\n')
            self.setMaxChargeRate.exportLiteral(outfile, level, name_='setMaxChargeRate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setMaxDischargeRate is not None:
            showIndent(outfile, level)
            outfile.write('setMaxDischargeRate=model_.ActivePower(\n')
            self.setMaxDischargeRate.exportLiteral(outfile, level, name_='setMaxDischargeRate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setMaxVA is not None:
            showIndent(outfile, level)
            outfile.write('setMaxVA=model_.ApparentPower(\n')
            self.setMaxVA.exportLiteral(outfile, level, name_='setMaxVA')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setMaxVAr is not None:
            showIndent(outfile, level)
            outfile.write('setMaxVAr=model_.ReactivePower(\n')
            self.setMaxVAr.exportLiteral(outfile, level, name_='setMaxVAr')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setMaxVArNeg is not None:
            showIndent(outfile, level)
            outfile.write('setMaxVArNeg=model_.ReactivePower(\n')
            self.setMaxVArNeg.exportLiteral(outfile, level, name_='setMaxVArNeg')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setMaxW is not None:
            showIndent(outfile, level)
            outfile.write('setMaxW=model_.ActivePower(\n')
            self.setMaxW.exportLiteral(outfile, level, name_='setMaxW')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setMinPF is not None:
            showIndent(outfile, level)
            outfile.write('setMinPF=model_.UnsignedFixedPointType(\n')
            self.setMinPF.exportLiteral(outfile, level, name_='setMinPF')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setMinPFNeg is not None:
            showIndent(outfile, level)
            outfile.write('setMinPFNeg=model_.FixedPointType(\n')
            self.setMinPFNeg.exportLiteral(outfile, level, name_='setMinPFNeg')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setStorConnect is not None:
            showIndent(outfile, level)
            outfile.write('setStorConnect=%s,\n' % self.setStorConnect)
        if self.setVRef is not None:
            showIndent(outfile, level)
            outfile.write('setVRef=model_.VoltageRMS(\n')
            self.setVRef.exportLiteral(outfile, level, name_='setVRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.setVRefOfs is not None:
            showIndent(outfile, level)
            outfile.write('setVRefOfs=model_.VoltageRMS(\n')
            self.setVRefOfs.exportLiteral(outfile, level, name_='setVRefOfs')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.updatedTime is not None:
            showIndent(outfile, level)
            outfile.write('updatedTime=model_.TimeType(\n')
            self.updatedTime.exportLiteral(outfile, level, name_='updatedTime')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERSettings, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'setGenConnect':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'setGenConnect')
            self.setGenConnect = ival_
        elif nodeName_ == 'setGradW':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'setGradW')
            self.setGradW = ival_
            self.validate_UInt16(self.setGradW)    # validate type UInt16
        elif nodeName_ == 'setMaxChargeRate':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.setMaxChargeRate = obj_
            obj_.original_tagname_ = 'setMaxChargeRate'
        elif nodeName_ == 'setMaxDischargeRate':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.setMaxDischargeRate = obj_
            obj_.original_tagname_ = 'setMaxDischargeRate'
        elif nodeName_ == 'setMaxVA':
            obj_ = ApparentPower.factory()
            obj_.build(child_)
            self.setMaxVA = obj_
            obj_.original_tagname_ = 'setMaxVA'
        elif nodeName_ == 'setMaxVAr':
            obj_ = ReactivePower.factory()
            obj_.build(child_)
            self.setMaxVAr = obj_
            obj_.original_tagname_ = 'setMaxVAr'
        elif nodeName_ == 'setMaxVArNeg':
            obj_ = ReactivePower.factory()
            obj_.build(child_)
            self.setMaxVArNeg = obj_
            obj_.original_tagname_ = 'setMaxVArNeg'
        elif nodeName_ == 'setMaxW':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.setMaxW = obj_
            obj_.original_tagname_ = 'setMaxW'
        elif nodeName_ == 'setMinPF':
            obj_ = UnsignedFixedPointType.factory()
            obj_.build(child_)
            self.setMinPF = obj_
            obj_.original_tagname_ = 'setMinPF'
        elif nodeName_ == 'setMinPFNeg':
            obj_ = FixedPointType.factory()
            obj_.build(child_)
            self.setMinPFNeg = obj_
            obj_.original_tagname_ = 'setMinPFNeg'
        elif nodeName_ == 'setStorConnect':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'setStorConnect')
            self.setStorConnect = ival_
        elif nodeName_ == 'setVRef':
            obj_ = VoltageRMS.factory()
            obj_.build(child_)
            self.setVRef = obj_
            obj_.original_tagname_ = 'setVRef'
        elif nodeName_ == 'setVRefOfs':
            obj_ = VoltageRMS.factory()
            obj_.build(child_)
            self.setVRefOfs = obj_
            obj_.original_tagname_ = 'setVRefOfs'
        elif nodeName_ == 'updatedTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.updatedTime = obj_
            obj_.original_tagname_ = 'updatedTime'
        super(DERSettings, self).buildChildren(child_, node, nodeName_, True)
# end class DERSettings


class DERList(List):
    """A List element to hold DER objects."""
    subclass = None
    superclass = List
    def __init__(self, DER=None):
        self.original_tagname_ = None
        super(DERList, self).__init__()
        if DER is None:
            self.DER = []
        else:
            self.DER = DER
    def factory(*args_, **kwargs_):
        if DERList.subclass:
            return DERList.subclass(*args_, **kwargs_)
        else:
            return DERList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DER(self): return self.DER
    def set_DER(self, DER): self.DER = DER
    def add_DER(self, value): self.DER.append(value)
    def insert_DER_at(self, index, value): self.DER.insert(index, value)
    def replace_DER_at(self, index, value): self.DER[index] = value
    def hasContent_(self):
        if (
            self.DER or
            super(DERList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DERList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DERList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DERList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DERList'):
        super(DERList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DERList')
    def exportChildren(self, outfile, level, namespace_='', name_='DERList', fromsubclass_=False, pretty_print=True):
        super(DERList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DER_ in self.DER:
            DER_.export(outfile, level, namespace_, name_='DER', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DERList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DERList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DERList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('DER=[\n')
        level += 1
        for DER_ in self.DER:
            showIndent(outfile, level)
            outfile.write('model_.DER(\n')
            DER_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DERList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DER':
            obj_ = DER.factory()
            obj_.build(child_)
            self.DER.append(obj_)
            obj_.original_tagname_ = 'DER'
        super(DERList, self).buildChildren(child_, node, nodeName_, True)
# end class DERList


class DER(SubscribableResource):
    """Contains links to DER resources."""
    subclass = None
    superclass = SubscribableResource
    def __init__(self, AssociatedDERProgramListLink=None, AssociatedUsagePointLink=None, CurrentDERProgramLink=None, DERAvailabilityLink=None, DERCapabilityLink=None, DERSettingsLink=None, DERStatusLink=None):
        self.original_tagname_ = None
        super(DER, self).__init__()
        self.AssociatedDERProgramListLink = AssociatedDERProgramListLink
        self.AssociatedUsagePointLink = AssociatedUsagePointLink
        self.CurrentDERProgramLink = CurrentDERProgramLink
        self.DERAvailabilityLink = DERAvailabilityLink
        self.DERCapabilityLink = DERCapabilityLink
        self.DERSettingsLink = DERSettingsLink
        self.DERStatusLink = DERStatusLink
    def factory(*args_, **kwargs_):
        if DER.subclass:
            return DER.subclass(*args_, **kwargs_)
        else:
            return DER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssociatedDERProgramListLink(self): return self.AssociatedDERProgramListLink
    def set_AssociatedDERProgramListLink(self, AssociatedDERProgramListLink): self.AssociatedDERProgramListLink = AssociatedDERProgramListLink
    def get_AssociatedUsagePointLink(self): return self.AssociatedUsagePointLink
    def set_AssociatedUsagePointLink(self, AssociatedUsagePointLink): self.AssociatedUsagePointLink = AssociatedUsagePointLink
    def get_CurrentDERProgramLink(self): return self.CurrentDERProgramLink
    def set_CurrentDERProgramLink(self, CurrentDERProgramLink): self.CurrentDERProgramLink = CurrentDERProgramLink
    def get_DERAvailabilityLink(self): return self.DERAvailabilityLink
    def set_DERAvailabilityLink(self, DERAvailabilityLink): self.DERAvailabilityLink = DERAvailabilityLink
    def get_DERCapabilityLink(self): return self.DERCapabilityLink
    def set_DERCapabilityLink(self, DERCapabilityLink): self.DERCapabilityLink = DERCapabilityLink
    def get_DERSettingsLink(self): return self.DERSettingsLink
    def set_DERSettingsLink(self, DERSettingsLink): self.DERSettingsLink = DERSettingsLink
    def get_DERStatusLink(self): return self.DERStatusLink
    def set_DERStatusLink(self, DERStatusLink): self.DERStatusLink = DERStatusLink
    def hasContent_(self):
        if (
            self.AssociatedDERProgramListLink is not None or
            self.AssociatedUsagePointLink is not None or
            self.CurrentDERProgramLink is not None or
            self.DERAvailabilityLink is not None or
            self.DERCapabilityLink is not None or
            self.DERSettingsLink is not None or
            self.DERStatusLink is not None or
            super(DER, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DER', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DER')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DER', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DER'):
        super(DER, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DER')
    def exportChildren(self, outfile, level, namespace_='', name_='DER', fromsubclass_=False, pretty_print=True):
        super(DER, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AssociatedDERProgramListLink is not None:
            self.AssociatedDERProgramListLink.export(outfile, level, namespace_, name_='AssociatedDERProgramListLink', pretty_print=pretty_print)
        if self.AssociatedUsagePointLink is not None:
            self.AssociatedUsagePointLink.export(outfile, level, namespace_, name_='AssociatedUsagePointLink', pretty_print=pretty_print)
        if self.CurrentDERProgramLink is not None:
            self.CurrentDERProgramLink.export(outfile, level, namespace_, name_='CurrentDERProgramLink', pretty_print=pretty_print)
        if self.DERAvailabilityLink is not None:
            self.DERAvailabilityLink.export(outfile, level, namespace_, name_='DERAvailabilityLink', pretty_print=pretty_print)
        if self.DERCapabilityLink is not None:
            self.DERCapabilityLink.export(outfile, level, namespace_, name_='DERCapabilityLink', pretty_print=pretty_print)
        if self.DERSettingsLink is not None:
            self.DERSettingsLink.export(outfile, level, namespace_, name_='DERSettingsLink', pretty_print=pretty_print)
        if self.DERStatusLink is not None:
            self.DERStatusLink.export(outfile, level, namespace_, name_='DERStatusLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DER'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DER, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DER, self).exportLiteralChildren(outfile, level, name_)
        if self.AssociatedDERProgramListLink is not None:
            showIndent(outfile, level)
            outfile.write('AssociatedDERProgramListLink=model_.AssociatedDERProgramListLink(\n')
            self.AssociatedDERProgramListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AssociatedUsagePointLink is not None:
            showIndent(outfile, level)
            outfile.write('AssociatedUsagePointLink=model_.AssociatedUsagePointLink(\n')
            self.AssociatedUsagePointLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CurrentDERProgramLink is not None:
            showIndent(outfile, level)
            outfile.write('CurrentDERProgramLink=model_.CurrentDERProgramLink(\n')
            self.CurrentDERProgramLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DERAvailabilityLink is not None:
            showIndent(outfile, level)
            outfile.write('DERAvailabilityLink=model_.DERAvailabilityLink(\n')
            self.DERAvailabilityLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DERCapabilityLink is not None:
            showIndent(outfile, level)
            outfile.write('DERCapabilityLink=model_.DERCapabilityLink(\n')
            self.DERCapabilityLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DERSettingsLink is not None:
            showIndent(outfile, level)
            outfile.write('DERSettingsLink=model_.DERSettingsLink(\n')
            self.DERSettingsLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DERStatusLink is not None:
            showIndent(outfile, level)
            outfile.write('DERStatusLink=model_.DERStatusLink(\n')
            self.DERStatusLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DER, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssociatedDERProgramListLink':
            obj_ = AssociatedDERProgramListLink.factory()
            obj_.build(child_)
            self.AssociatedDERProgramListLink = obj_
            obj_.original_tagname_ = 'AssociatedDERProgramListLink'
        elif nodeName_ == 'AssociatedUsagePointLink':
            obj_ = AssociatedUsagePointLink.factory()
            obj_.build(child_)
            self.AssociatedUsagePointLink = obj_
            obj_.original_tagname_ = 'AssociatedUsagePointLink'
        elif nodeName_ == 'CurrentDERProgramLink':
            obj_ = CurrentDERProgramLink.factory()
            obj_.build(child_)
            self.CurrentDERProgramLink = obj_
            obj_.original_tagname_ = 'CurrentDERProgramLink'
        elif nodeName_ == 'DERAvailabilityLink':
            obj_ = DERAvailabilityLink.factory()
            obj_.build(child_)
            self.DERAvailabilityLink = obj_
            obj_.original_tagname_ = 'DERAvailabilityLink'
        elif nodeName_ == 'DERCapabilityLink':
            obj_ = DERCapabilityLink.factory()
            obj_.build(child_)
            self.DERCapabilityLink = obj_
            obj_.original_tagname_ = 'DERCapabilityLink'
        elif nodeName_ == 'DERSettingsLink':
            obj_ = DERSettingsLink.factory()
            obj_.build(child_)
            self.DERSettingsLink = obj_
            obj_.original_tagname_ = 'DERSettingsLink'
        elif nodeName_ == 'DERStatusLink':
            obj_ = DERStatusLink.factory()
            obj_.build(child_)
            self.DERStatusLink = obj_
            obj_.original_tagname_ = 'DERStatusLink'
        super(DER, self).buildChildren(child_, node, nodeName_, True)
# end class DER


class DefaultDERControl(SubscribableIdentifiedObject):
    """Contains control mode information to be used if no active DERControl
    is found."""
    subclass = None
    superclass = SubscribableIdentifiedObject
    def __init__(self, DERControlBase=None):
        self.original_tagname_ = None
        super(DefaultDERControl, self).__init__()
        self.DERControlBase = DERControlBase
    def factory(*args_, **kwargs_):
        if DefaultDERControl.subclass:
            return DefaultDERControl.subclass(*args_, **kwargs_)
        else:
            return DefaultDERControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DERControlBase(self): return self.DERControlBase
    def set_DERControlBase(self, DERControlBase): self.DERControlBase = DERControlBase
    def hasContent_(self):
        if (
            self.DERControlBase is not None or
            super(DefaultDERControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DefaultDERControl', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultDERControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DefaultDERControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DefaultDERControl'):
        super(DefaultDERControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DefaultDERControl')
    def exportChildren(self, outfile, level, namespace_='', name_='DefaultDERControl', fromsubclass_=False, pretty_print=True):
        super(DefaultDERControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DERControlBase is not None:
            self.DERControlBase.export(outfile, level, namespace_, name_='DERControlBase', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DefaultDERControl'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DefaultDERControl, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DefaultDERControl, self).exportLiteralChildren(outfile, level, name_)
        if self.DERControlBase is not None:
            showIndent(outfile, level)
            outfile.write('DERControlBase=model_.DERControlBase(\n')
            self.DERControlBase.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DefaultDERControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DERControlBase':
            obj_ = DERControlBase.factory()
            obj_.build(child_)
            self.DERControlBase = obj_
            obj_.original_tagname_ = 'DERControlBase'
        super(DefaultDERControl, self).buildChildren(child_, node, nodeName_, True)
# end class DefaultDERControl


class FlowReservationResponseList(SubscribableList):
    """A List element to hold FlowReservationResponse objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, FlowReservationResponse=None):
        self.original_tagname_ = None
        super(FlowReservationResponseList, self).__init__()
        if FlowReservationResponse is None:
            self.FlowReservationResponse = []
        else:
            self.FlowReservationResponse = FlowReservationResponse
    def factory(*args_, **kwargs_):
        if FlowReservationResponseList.subclass:
            return FlowReservationResponseList.subclass(*args_, **kwargs_)
        else:
            return FlowReservationResponseList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FlowReservationResponse(self): return self.FlowReservationResponse
    def set_FlowReservationResponse(self, FlowReservationResponse): self.FlowReservationResponse = FlowReservationResponse
    def add_FlowReservationResponse(self, value): self.FlowReservationResponse.append(value)
    def insert_FlowReservationResponse_at(self, index, value): self.FlowReservationResponse.insert(index, value)
    def replace_FlowReservationResponse_at(self, index, value): self.FlowReservationResponse[index] = value
    def hasContent_(self):
        if (
            self.FlowReservationResponse or
            super(FlowReservationResponseList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlowReservationResponseList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationResponseList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FlowReservationResponseList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlowReservationResponseList'):
        super(FlowReservationResponseList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationResponseList')
    def exportChildren(self, outfile, level, namespace_='', name_='FlowReservationResponseList', fromsubclass_=False, pretty_print=True):
        super(FlowReservationResponseList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FlowReservationResponse_ in self.FlowReservationResponse:
            FlowReservationResponse_.export(outfile, level, namespace_, name_='FlowReservationResponse', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FlowReservationResponseList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FlowReservationResponseList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FlowReservationResponseList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('FlowReservationResponse=[\n')
        level += 1
        for FlowReservationResponse_ in self.FlowReservationResponse:
            showIndent(outfile, level)
            outfile.write('model_.FlowReservationResponse(\n')
            FlowReservationResponse_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationResponseList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FlowReservationResponse':
            obj_ = FlowReservationResponse.factory()
            obj_.build(child_)
            self.FlowReservationResponse.append(obj_)
            obj_.original_tagname_ = 'FlowReservationResponse'
        super(FlowReservationResponseList, self).buildChildren(child_, node, nodeName_, True)
# end class FlowReservationResponseList


class FlowReservationResponse(Event):
    """The server may modify the charging or discharging parameters and
    interval to provide a lower aggregated demand at the premises,
    or within a larger part of the distribution system."""
    subclass = None
    superclass = Event
    def __init__(self, energyAvailable=None, powerAvailable=None, subject=None):
        self.original_tagname_ = None
        super(FlowReservationResponse, self).__init__()
        self.energyAvailable = energyAvailable
        self.powerAvailable = powerAvailable
        self.subject = subject
    def factory(*args_, **kwargs_):
        if FlowReservationResponse.subclass:
            return FlowReservationResponse.subclass(*args_, **kwargs_)
        else:
            return FlowReservationResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_energyAvailable(self): return self.energyAvailable
    def set_energyAvailable(self, energyAvailable): self.energyAvailable = energyAvailable
    def get_powerAvailable(self): return self.powerAvailable
    def set_powerAvailable(self, powerAvailable): self.powerAvailable = powerAvailable
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def hasContent_(self):
        if (
            self.energyAvailable is not None or
            self.powerAvailable is not None or
            self.subject is not None or
            super(FlowReservationResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlowReservationResponse', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FlowReservationResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlowReservationResponse'):
        super(FlowReservationResponse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationResponse')
    def exportChildren(self, outfile, level, namespace_='', name_='FlowReservationResponse', fromsubclass_=False, pretty_print=True):
        super(FlowReservationResponse, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.energyAvailable is not None:
            self.energyAvailable.export(outfile, level, namespace_, name_='energyAvailable', pretty_print=pretty_print)
        if self.powerAvailable is not None:
            self.powerAvailable.export(outfile, level, namespace_, name_='powerAvailable', pretty_print=pretty_print)
        if self.subject is not None:
            self.subject.export(outfile, level, namespace_, name_='subject', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FlowReservationResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FlowReservationResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FlowReservationResponse, self).exportLiteralChildren(outfile, level, name_)
        if self.energyAvailable is not None:
            showIndent(outfile, level)
            outfile.write('energyAvailable=model_.RealEnergy(\n')
            self.energyAvailable.exportLiteral(outfile, level, name_='energyAvailable')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.powerAvailable is not None:
            showIndent(outfile, level)
            outfile.write('powerAvailable=model_.ActivePower(\n')
            self.powerAvailable.exportLiteral(outfile, level, name_='powerAvailable')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subject is not None:
            showIndent(outfile, level)
            outfile.write('subject=model_.mRIDType(\n')
            self.subject.exportLiteral(outfile, level, name_='subject')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'energyAvailable':
            obj_ = RealEnergy.factory()
            obj_.build(child_)
            self.energyAvailable = obj_
            obj_.original_tagname_ = 'energyAvailable'
        elif nodeName_ == 'powerAvailable':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.powerAvailable = obj_
            obj_.original_tagname_ = 'powerAvailable'
        elif nodeName_ == 'subject':
            obj_ = mRIDType.factory()
            obj_.build(child_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        super(FlowReservationResponse, self).buildChildren(child_, node, nodeName_, True)
# end class FlowReservationResponse


class FlowReservationRequestList(List):
    """A List element to hold FlowReservationRequest objects."""
    subclass = None
    superclass = List
    def __init__(self, FlowReservationRequest=None):
        self.original_tagname_ = None
        super(FlowReservationRequestList, self).__init__()
        if FlowReservationRequest is None:
            self.FlowReservationRequest = []
        else:
            self.FlowReservationRequest = FlowReservationRequest
    def factory(*args_, **kwargs_):
        if FlowReservationRequestList.subclass:
            return FlowReservationRequestList.subclass(*args_, **kwargs_)
        else:
            return FlowReservationRequestList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FlowReservationRequest(self): return self.FlowReservationRequest
    def set_FlowReservationRequest(self, FlowReservationRequest): self.FlowReservationRequest = FlowReservationRequest
    def add_FlowReservationRequest(self, value): self.FlowReservationRequest.append(value)
    def insert_FlowReservationRequest_at(self, index, value): self.FlowReservationRequest.insert(index, value)
    def replace_FlowReservationRequest_at(self, index, value): self.FlowReservationRequest[index] = value
    def hasContent_(self):
        if (
            self.FlowReservationRequest or
            super(FlowReservationRequestList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlowReservationRequestList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationRequestList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FlowReservationRequestList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlowReservationRequestList'):
        super(FlowReservationRequestList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationRequestList')
    def exportChildren(self, outfile, level, namespace_='', name_='FlowReservationRequestList', fromsubclass_=False, pretty_print=True):
        super(FlowReservationRequestList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FlowReservationRequest_ in self.FlowReservationRequest:
            FlowReservationRequest_.export(outfile, level, namespace_, name_='FlowReservationRequest', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FlowReservationRequestList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FlowReservationRequestList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FlowReservationRequestList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('FlowReservationRequest=[\n')
        level += 1
        for FlowReservationRequest_ in self.FlowReservationRequest:
            showIndent(outfile, level)
            outfile.write('model_.FlowReservationRequest(\n')
            FlowReservationRequest_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationRequestList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FlowReservationRequest':
            obj_ = FlowReservationRequest.factory()
            obj_.build(child_)
            self.FlowReservationRequest.append(obj_)
            obj_.original_tagname_ = 'FlowReservationRequest'
        super(FlowReservationRequestList, self).buildChildren(child_, node, nodeName_, True)
# end class FlowReservationRequestList


class FlowReservationRequest(IdentifiedObject):
    """Used to request flow transactions. Client EndDevices submit a
    request for charging or discharging from the server. The server
    creates an associated FlowReservationResponse containing the
    charging parameters and interval to provide a lower aggregated
    demand at the premises, or within a larger part of the
    distribution system."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, creationTime=None, durationRequested=None, energyRequested=None, intervalRequested=None, powerRequested=None, RequestStatus=None):
        self.original_tagname_ = None
        super(FlowReservationRequest, self).__init__()
        self.creationTime = creationTime
        self.durationRequested = durationRequested
        self.energyRequested = energyRequested
        self.intervalRequested = intervalRequested
        self.powerRequested = powerRequested
        self.RequestStatus = RequestStatus
    def factory(*args_, **kwargs_):
        if FlowReservationRequest.subclass:
            return FlowReservationRequest.subclass(*args_, **kwargs_)
        else:
            return FlowReservationRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creationTime(self): return self.creationTime
    def set_creationTime(self, creationTime): self.creationTime = creationTime
    def get_durationRequested(self): return self.durationRequested
    def set_durationRequested(self, durationRequested): self.durationRequested = durationRequested
    def get_energyRequested(self): return self.energyRequested
    def set_energyRequested(self, energyRequested): self.energyRequested = energyRequested
    def get_intervalRequested(self): return self.intervalRequested
    def set_intervalRequested(self, intervalRequested): self.intervalRequested = intervalRequested
    def get_powerRequested(self): return self.powerRequested
    def set_powerRequested(self, powerRequested): self.powerRequested = powerRequested
    def get_RequestStatus(self): return self.RequestStatus
    def set_RequestStatus(self, RequestStatus): self.RequestStatus = RequestStatus
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.creationTime is not None or
            self.durationRequested is not None or
            self.energyRequested is not None or
            self.intervalRequested is not None or
            self.powerRequested is not None or
            self.RequestStatus is not None or
            super(FlowReservationRequest, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FlowReservationRequest', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationRequest')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FlowReservationRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FlowReservationRequest'):
        super(FlowReservationRequest, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FlowReservationRequest')
    def exportChildren(self, outfile, level, namespace_='', name_='FlowReservationRequest', fromsubclass_=False, pretty_print=True):
        super(FlowReservationRequest, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creationTime is not None:
            self.creationTime.export(outfile, level, namespace_, name_='creationTime', pretty_print=pretty_print)
        if self.durationRequested is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdurationRequested>%s</%sdurationRequested>%s' % (namespace_, self.gds_format_integer(self.durationRequested, input_name='durationRequested'), namespace_, eol_))
        if self.energyRequested is not None:
            self.energyRequested.export(outfile, level, namespace_, name_='energyRequested', pretty_print=pretty_print)
        if self.intervalRequested is not None:
            self.intervalRequested.export(outfile, level, namespace_, name_='intervalRequested', pretty_print=pretty_print)
        if self.powerRequested is not None:
            self.powerRequested.export(outfile, level, namespace_, name_='powerRequested', pretty_print=pretty_print)
        if self.RequestStatus is not None:
            self.RequestStatus.export(outfile, level, namespace_, name_='RequestStatus', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FlowReservationRequest'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FlowReservationRequest, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FlowReservationRequest, self).exportLiteralChildren(outfile, level, name_)
        if self.creationTime is not None:
            showIndent(outfile, level)
            outfile.write('creationTime=model_.TimeType(\n')
            self.creationTime.exportLiteral(outfile, level, name_='creationTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.durationRequested is not None:
            showIndent(outfile, level)
            outfile.write('durationRequested=%d,\n' % self.durationRequested)
        if self.energyRequested is not None:
            showIndent(outfile, level)
            outfile.write('energyRequested=model_.SignedRealEnergy(\n')
            self.energyRequested.exportLiteral(outfile, level, name_='energyRequested')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.intervalRequested is not None:
            showIndent(outfile, level)
            outfile.write('intervalRequested=model_.DateTimeInterval(\n')
            self.intervalRequested.exportLiteral(outfile, level, name_='intervalRequested')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.powerRequested is not None:
            showIndent(outfile, level)
            outfile.write('powerRequested=model_.ActivePower(\n')
            self.powerRequested.exportLiteral(outfile, level, name_='powerRequested')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RequestStatus is not None:
            showIndent(outfile, level)
            outfile.write('RequestStatus=model_.RequestStatus(\n')
            self.RequestStatus.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationRequest, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creationTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.creationTime = obj_
            obj_.original_tagname_ = 'creationTime'
        elif nodeName_ == 'durationRequested':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'durationRequested')
            self.durationRequested = ival_
            self.validate_UInt16(self.durationRequested)    # validate type UInt16
        elif nodeName_ == 'energyRequested':
            obj_ = SignedRealEnergy.factory()
            obj_.build(child_)
            self.energyRequested = obj_
            obj_.original_tagname_ = 'energyRequested'
        elif nodeName_ == 'intervalRequested':
            obj_ = DateTimeInterval.factory()
            obj_.build(child_)
            self.intervalRequested = obj_
            obj_.original_tagname_ = 'intervalRequested'
        elif nodeName_ == 'powerRequested':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.powerRequested = obj_
            obj_.original_tagname_ = 'powerRequested'
        elif nodeName_ == 'RequestStatus':
            obj_ = RequestStatus.factory()
            obj_.build(child_)
            self.RequestStatus = obj_
            obj_.original_tagname_ = 'RequestStatus'
        super(FlowReservationRequest, self).buildChildren(child_, node, nodeName_, True)
# end class FlowReservationRequest


class AbstractFlowReservation(Event):
    """Provides definition of FlowReservation elements in common between
    Requests and Responses."""
    subclass = None
    superclass = Event
    def __init__(self):
        self.original_tagname_ = None
        super(AbstractFlowReservation, self).__init__()
    def factory(*args_, **kwargs_):
        if AbstractFlowReservation.subclass:
            return AbstractFlowReservation.subclass(*args_, **kwargs_)
        else:
            return AbstractFlowReservation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(AbstractFlowReservation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AbstractFlowReservation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFlowReservation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AbstractFlowReservation', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractFlowReservation'):
        super(AbstractFlowReservation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractFlowReservation')
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractFlowReservation', fromsubclass_=False, pretty_print=True):
        super(AbstractFlowReservation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='AbstractFlowReservation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractFlowReservation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractFlowReservation, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractFlowReservation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AbstractFlowReservation, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AbstractFlowReservation


class SupplyInterruptionOverrideList(List):
    """A List element to hold SupplyInterruptionOverride objects."""
    subclass = None
    superclass = List
    def __init__(self, SupplyInterruptionOverride=None):
        self.original_tagname_ = None
        super(SupplyInterruptionOverrideList, self).__init__()
        if SupplyInterruptionOverride is None:
            self.SupplyInterruptionOverride = []
        else:
            self.SupplyInterruptionOverride = SupplyInterruptionOverride
    def factory(*args_, **kwargs_):
        if SupplyInterruptionOverrideList.subclass:
            return SupplyInterruptionOverrideList.subclass(*args_, **kwargs_)
        else:
            return SupplyInterruptionOverrideList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SupplyInterruptionOverride(self): return self.SupplyInterruptionOverride
    def set_SupplyInterruptionOverride(self, SupplyInterruptionOverride): self.SupplyInterruptionOverride = SupplyInterruptionOverride
    def add_SupplyInterruptionOverride(self, value): self.SupplyInterruptionOverride.append(value)
    def insert_SupplyInterruptionOverride_at(self, index, value): self.SupplyInterruptionOverride.insert(index, value)
    def replace_SupplyInterruptionOverride_at(self, index, value): self.SupplyInterruptionOverride[index] = value
    def hasContent_(self):
        if (
            self.SupplyInterruptionOverride or
            super(SupplyInterruptionOverrideList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupplyInterruptionOverrideList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupplyInterruptionOverrideList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupplyInterruptionOverrideList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupplyInterruptionOverrideList'):
        super(SupplyInterruptionOverrideList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SupplyInterruptionOverrideList')
    def exportChildren(self, outfile, level, namespace_='', name_='SupplyInterruptionOverrideList', fromsubclass_=False, pretty_print=True):
        super(SupplyInterruptionOverrideList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SupplyInterruptionOverride_ in self.SupplyInterruptionOverride:
            SupplyInterruptionOverride_.export(outfile, level, namespace_, name_='SupplyInterruptionOverride', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SupplyInterruptionOverrideList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SupplyInterruptionOverrideList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SupplyInterruptionOverrideList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SupplyInterruptionOverride=[\n')
        level += 1
        for SupplyInterruptionOverride_ in self.SupplyInterruptionOverride:
            showIndent(outfile, level)
            outfile.write('model_.SupplyInterruptionOverride(\n')
            SupplyInterruptionOverride_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SupplyInterruptionOverrideList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SupplyInterruptionOverride':
            obj_ = SupplyInterruptionOverride.factory()
            obj_.build(child_)
            self.SupplyInterruptionOverride.append(obj_)
            obj_.original_tagname_ = 'SupplyInterruptionOverride'
        super(SupplyInterruptionOverrideList, self).buildChildren(child_, node, nodeName_, True)
# end class SupplyInterruptionOverrideList


class SupplyInterruptionOverride(Resource):
    """SupplyInterruptionOverride: There may be periods of time when
    social, regulatory or other concerns mean that service should
    not be interrupted, even when available credit has been
    exhausted. Each Prepayment instance links to a List of
    SupplyInterruptionOverride instances. Each
    SupplyInterruptionOverride defines a contiguous period of time
    during which supply SHALL NOT be interrupted."""
    subclass = None
    superclass = Resource
    def __init__(self, description=None, interval=None):
        self.original_tagname_ = None
        super(SupplyInterruptionOverride, self).__init__()
        self.description = description
        self.interval = interval
    def factory(*args_, **kwargs_):
        if SupplyInterruptionOverride.subclass:
            return SupplyInterruptionOverride.subclass(*args_, **kwargs_)
        else:
            return SupplyInterruptionOverride(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_interval(self): return self.interval
    def set_interval(self, interval): self.interval = interval
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.description is not None or
            self.interval is not None or
            super(SupplyInterruptionOverride, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupplyInterruptionOverride', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupplyInterruptionOverride')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupplyInterruptionOverride', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupplyInterruptionOverride'):
        super(SupplyInterruptionOverride, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SupplyInterruptionOverride')
    def exportChildren(self, outfile, level, namespace_='', name_='SupplyInterruptionOverride', fromsubclass_=False, pretty_print=True):
        super(SupplyInterruptionOverride, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.interval is not None:
            self.interval.export(outfile, level, namespace_, name_='interval', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SupplyInterruptionOverride'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SupplyInterruptionOverride, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SupplyInterruptionOverride, self).exportLiteralChildren(outfile, level, name_)
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.interval is not None:
            showIndent(outfile, level)
            outfile.write('interval=model_.DateTimeInterval(\n')
            self.interval.exportLiteral(outfile, level, name_='interval')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SupplyInterruptionOverride, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            self.validate_String32(self.description)    # validate type String32
        elif nodeName_ == 'interval':
            obj_ = DateTimeInterval.factory()
            obj_.build(child_)
            self.interval = obj_
            obj_.original_tagname_ = 'interval'
        super(SupplyInterruptionOverride, self).buildChildren(child_, node, nodeName_, True)
# end class SupplyInterruptionOverride


class PrepayOperationStatus(Resource):
    """PrepayOperationStatus describes the status of the service or
    commodity being conditionally controlled by the Prepayment
    function set."""
    subclass = None
    superclass = Resource
    def __init__(self, creditTypeChange=None, creditTypeInUse=None, serviceChange=None, serviceStatus=None):
        self.original_tagname_ = None
        super(PrepayOperationStatus, self).__init__()
        self.creditTypeChange = creditTypeChange
        self.creditTypeInUse = creditTypeInUse
        self.serviceChange = serviceChange
        self.serviceStatus = serviceStatus
    def factory(*args_, **kwargs_):
        if PrepayOperationStatus.subclass:
            return PrepayOperationStatus.subclass(*args_, **kwargs_)
        else:
            return PrepayOperationStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditTypeChange(self): return self.creditTypeChange
    def set_creditTypeChange(self, creditTypeChange): self.creditTypeChange = creditTypeChange
    def get_creditTypeInUse(self): return self.creditTypeInUse
    def set_creditTypeInUse(self, creditTypeInUse): self.creditTypeInUse = creditTypeInUse
    def get_serviceChange(self): return self.serviceChange
    def set_serviceChange(self, serviceChange): self.serviceChange = serviceChange
    def get_serviceStatus(self): return self.serviceStatus
    def set_serviceStatus(self, serviceStatus): self.serviceStatus = serviceStatus
    def hasContent_(self):
        if (
            self.creditTypeChange is not None or
            self.creditTypeInUse is not None or
            self.serviceChange is not None or
            self.serviceStatus is not None or
            super(PrepayOperationStatus, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrepayOperationStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrepayOperationStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrepayOperationStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrepayOperationStatus'):
        super(PrepayOperationStatus, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PrepayOperationStatus')
    def exportChildren(self, outfile, level, namespace_='', name_='PrepayOperationStatus', fromsubclass_=False, pretty_print=True):
        super(PrepayOperationStatus, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creditTypeChange is not None:
            self.creditTypeChange.export(outfile, level, namespace_, name_='creditTypeChange', pretty_print=pretty_print)
        if self.creditTypeInUse is not None:
            self.creditTypeInUse.export(outfile, level, namespace_, name_='creditTypeInUse', pretty_print=pretty_print)
        if self.serviceChange is not None:
            self.serviceChange.export(outfile, level, namespace_, name_='serviceChange', pretty_print=pretty_print)
        if self.serviceStatus is not None:
            self.serviceStatus.export(outfile, level, namespace_, name_='serviceStatus', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PrepayOperationStatus'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PrepayOperationStatus, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PrepayOperationStatus, self).exportLiteralChildren(outfile, level, name_)
        if self.creditTypeChange is not None:
            showIndent(outfile, level)
            outfile.write('creditTypeChange=model_.CreditTypeChange(\n')
            self.creditTypeChange.exportLiteral(outfile, level, name_='creditTypeChange')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.creditTypeInUse is not None:
            showIndent(outfile, level)
            outfile.write('creditTypeInUse=model_.CreditTypeType(\n')
            self.creditTypeInUse.exportLiteral(outfile, level, name_='creditTypeInUse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serviceChange is not None:
            showIndent(outfile, level)
            outfile.write('serviceChange=model_.ServiceChange(\n')
            self.serviceChange.exportLiteral(outfile, level, name_='serviceChange')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serviceStatus is not None:
            showIndent(outfile, level)
            outfile.write('serviceStatus=model_.ServiceStatusType(\n')
            self.serviceStatus.exportLiteral(outfile, level, name_='serviceStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PrepayOperationStatus, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creditTypeChange':
            obj_ = CreditTypeChange.factory()
            obj_.build(child_)
            self.creditTypeChange = obj_
            obj_.original_tagname_ = 'creditTypeChange'
        elif nodeName_ == 'creditTypeInUse':
            obj_ = CreditTypeType.factory()
            obj_.build(child_)
            self.creditTypeInUse = obj_
            obj_.original_tagname_ = 'creditTypeInUse'
        elif nodeName_ == 'serviceChange':
            obj_ = ServiceChange.factory()
            obj_.build(child_)
            self.serviceChange = obj_
            obj_.original_tagname_ = 'serviceChange'
        elif nodeName_ == 'serviceStatus':
            obj_ = ServiceStatusType.factory()
            obj_.build(child_)
            self.serviceStatus = obj_
            obj_.original_tagname_ = 'serviceStatus'
        super(PrepayOperationStatus, self).buildChildren(child_, node, nodeName_, True)
# end class PrepayOperationStatus


class PrepaymentList(SubscribableList):
    """A List element to hold Prepayment objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, Prepayment=None):
        self.original_tagname_ = None
        super(PrepaymentList, self).__init__()
        if Prepayment is None:
            self.Prepayment = []
        else:
            self.Prepayment = Prepayment
    def factory(*args_, **kwargs_):
        if PrepaymentList.subclass:
            return PrepaymentList.subclass(*args_, **kwargs_)
        else:
            return PrepaymentList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Prepayment(self): return self.Prepayment
    def set_Prepayment(self, Prepayment): self.Prepayment = Prepayment
    def add_Prepayment(self, value): self.Prepayment.append(value)
    def insert_Prepayment_at(self, index, value): self.Prepayment.insert(index, value)
    def replace_Prepayment_at(self, index, value): self.Prepayment[index] = value
    def hasContent_(self):
        if (
            self.Prepayment or
            super(PrepaymentList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PrepaymentList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrepaymentList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PrepaymentList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PrepaymentList'):
        super(PrepaymentList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PrepaymentList')
    def exportChildren(self, outfile, level, namespace_='', name_='PrepaymentList', fromsubclass_=False, pretty_print=True):
        super(PrepaymentList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Prepayment_ in self.Prepayment:
            Prepayment_.export(outfile, level, namespace_, name_='Prepayment', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PrepaymentList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PrepaymentList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PrepaymentList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Prepayment=[\n')
        level += 1
        for Prepayment_ in self.Prepayment:
            showIndent(outfile, level)
            outfile.write('model_.Prepayment(\n')
            Prepayment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PrepaymentList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Prepayment':
            obj_ = Prepayment.factory()
            obj_.build(child_)
            self.Prepayment.append(obj_)
            obj_.original_tagname_ = 'Prepayment'
        super(PrepaymentList, self).buildChildren(child_, node, nodeName_, True)
# end class PrepaymentList


class Prepayment(IdentifiedObject):
    """Prepayment (inherited from CIM SDPAccountingFunction)"""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, AccountBalanceLink=None, ActiveCreditRegisterListLink=None, ActiveSupplyInterruptionOverrideListLink=None, creditExpiryLevel=None, CreditRegisterListLink=None, lowCreditWarningLevel=None, lowEmergencyCreditWarningLevel=None, prepayMode=None, PrepayOperationStatusLink=None, SupplyInterruptionOverrideListLink=None, UsagePoint=None, UsagePointLink=None):
        self.original_tagname_ = None
        super(Prepayment, self).__init__()
        self.AccountBalanceLink = AccountBalanceLink
        self.ActiveCreditRegisterListLink = ActiveCreditRegisterListLink
        self.ActiveSupplyInterruptionOverrideListLink = ActiveSupplyInterruptionOverrideListLink
        self.creditExpiryLevel = creditExpiryLevel
        self.CreditRegisterListLink = CreditRegisterListLink
        self.lowCreditWarningLevel = lowCreditWarningLevel
        self.lowEmergencyCreditWarningLevel = lowEmergencyCreditWarningLevel
        self.prepayMode = prepayMode
        self.PrepayOperationStatusLink = PrepayOperationStatusLink
        self.SupplyInterruptionOverrideListLink = SupplyInterruptionOverrideListLink
        if UsagePoint is None:
            self.UsagePoint = []
        else:
            self.UsagePoint = UsagePoint
        self.UsagePointLink = UsagePointLink
    def factory(*args_, **kwargs_):
        if Prepayment.subclass:
            return Prepayment.subclass(*args_, **kwargs_)
        else:
            return Prepayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AccountBalanceLink(self): return self.AccountBalanceLink
    def set_AccountBalanceLink(self, AccountBalanceLink): self.AccountBalanceLink = AccountBalanceLink
    def get_ActiveCreditRegisterListLink(self): return self.ActiveCreditRegisterListLink
    def set_ActiveCreditRegisterListLink(self, ActiveCreditRegisterListLink): self.ActiveCreditRegisterListLink = ActiveCreditRegisterListLink
    def get_ActiveSupplyInterruptionOverrideListLink(self): return self.ActiveSupplyInterruptionOverrideListLink
    def set_ActiveSupplyInterruptionOverrideListLink(self, ActiveSupplyInterruptionOverrideListLink): self.ActiveSupplyInterruptionOverrideListLink = ActiveSupplyInterruptionOverrideListLink
    def get_creditExpiryLevel(self): return self.creditExpiryLevel
    def set_creditExpiryLevel(self, creditExpiryLevel): self.creditExpiryLevel = creditExpiryLevel
    def get_CreditRegisterListLink(self): return self.CreditRegisterListLink
    def set_CreditRegisterListLink(self, CreditRegisterListLink): self.CreditRegisterListLink = CreditRegisterListLink
    def get_lowCreditWarningLevel(self): return self.lowCreditWarningLevel
    def set_lowCreditWarningLevel(self, lowCreditWarningLevel): self.lowCreditWarningLevel = lowCreditWarningLevel
    def get_lowEmergencyCreditWarningLevel(self): return self.lowEmergencyCreditWarningLevel
    def set_lowEmergencyCreditWarningLevel(self, lowEmergencyCreditWarningLevel): self.lowEmergencyCreditWarningLevel = lowEmergencyCreditWarningLevel
    def get_prepayMode(self): return self.prepayMode
    def set_prepayMode(self, prepayMode): self.prepayMode = prepayMode
    def get_PrepayOperationStatusLink(self): return self.PrepayOperationStatusLink
    def set_PrepayOperationStatusLink(self, PrepayOperationStatusLink): self.PrepayOperationStatusLink = PrepayOperationStatusLink
    def get_SupplyInterruptionOverrideListLink(self): return self.SupplyInterruptionOverrideListLink
    def set_SupplyInterruptionOverrideListLink(self, SupplyInterruptionOverrideListLink): self.SupplyInterruptionOverrideListLink = SupplyInterruptionOverrideListLink
    def get_UsagePoint(self): return self.UsagePoint
    def set_UsagePoint(self, UsagePoint): self.UsagePoint = UsagePoint
    def add_UsagePoint(self, value): self.UsagePoint.append(value)
    def insert_UsagePoint_at(self, index, value): self.UsagePoint.insert(index, value)
    def replace_UsagePoint_at(self, index, value): self.UsagePoint[index] = value
    def get_UsagePointLink(self): return self.UsagePointLink
    def set_UsagePointLink(self, UsagePointLink): self.UsagePointLink = UsagePointLink
    def hasContent_(self):
        if (
            self.AccountBalanceLink is not None or
            self.ActiveCreditRegisterListLink is not None or
            self.ActiveSupplyInterruptionOverrideListLink is not None or
            self.creditExpiryLevel is not None or
            self.CreditRegisterListLink is not None or
            self.lowCreditWarningLevel is not None or
            self.lowEmergencyCreditWarningLevel is not None or
            self.prepayMode is not None or
            self.PrepayOperationStatusLink is not None or
            self.SupplyInterruptionOverrideListLink is not None or
            self.UsagePoint or
            self.UsagePointLink is not None or
            super(Prepayment, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Prepayment', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Prepayment')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Prepayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Prepayment'):
        super(Prepayment, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Prepayment')
    def exportChildren(self, outfile, level, namespace_='', name_='Prepayment', fromsubclass_=False, pretty_print=True):
        super(Prepayment, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccountBalanceLink is not None:
            self.AccountBalanceLink.export(outfile, level, namespace_, name_='AccountBalanceLink', pretty_print=pretty_print)
        if self.ActiveCreditRegisterListLink is not None:
            self.ActiveCreditRegisterListLink.export(outfile, level, namespace_, name_='ActiveCreditRegisterListLink', pretty_print=pretty_print)
        if self.ActiveSupplyInterruptionOverrideListLink is not None:
            self.ActiveSupplyInterruptionOverrideListLink.export(outfile, level, namespace_, name_='ActiveSupplyInterruptionOverrideListLink', pretty_print=pretty_print)
        if self.creditExpiryLevel is not None:
            self.creditExpiryLevel.export(outfile, level, namespace_, name_='creditExpiryLevel', pretty_print=pretty_print)
        if self.CreditRegisterListLink is not None:
            self.CreditRegisterListLink.export(outfile, level, namespace_, name_='CreditRegisterListLink', pretty_print=pretty_print)
        if self.lowCreditWarningLevel is not None:
            self.lowCreditWarningLevel.export(outfile, level, namespace_, name_='lowCreditWarningLevel', pretty_print=pretty_print)
        if self.lowEmergencyCreditWarningLevel is not None:
            self.lowEmergencyCreditWarningLevel.export(outfile, level, namespace_, name_='lowEmergencyCreditWarningLevel', pretty_print=pretty_print)
        if self.prepayMode is not None:
            self.prepayMode.export(outfile, level, namespace_, name_='prepayMode', pretty_print=pretty_print)
        if self.PrepayOperationStatusLink is not None:
            self.PrepayOperationStatusLink.export(outfile, level, namespace_, name_='PrepayOperationStatusLink', pretty_print=pretty_print)
        if self.SupplyInterruptionOverrideListLink is not None:
            self.SupplyInterruptionOverrideListLink.export(outfile, level, namespace_, name_='SupplyInterruptionOverrideListLink', pretty_print=pretty_print)
        for UsagePoint_ in self.UsagePoint:
            UsagePoint_.export(outfile, level, namespace_, name_='UsagePoint', pretty_print=pretty_print)
        if self.UsagePointLink is not None:
            self.UsagePointLink.export(outfile, level, namespace_, name_='UsagePointLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Prepayment'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Prepayment, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Prepayment, self).exportLiteralChildren(outfile, level, name_)
        if self.AccountBalanceLink is not None:
            showIndent(outfile, level)
            outfile.write('AccountBalanceLink=model_.AccountBalanceLink(\n')
            self.AccountBalanceLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ActiveCreditRegisterListLink is not None:
            showIndent(outfile, level)
            outfile.write('ActiveCreditRegisterListLink=model_.ActiveCreditRegisterListLink(\n')
            self.ActiveCreditRegisterListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ActiveSupplyInterruptionOverrideListLink is not None:
            showIndent(outfile, level)
            outfile.write('ActiveSupplyInterruptionOverrideListLink=model_.ActiveSupplyInterruptionOverrideListLink(\n')
            self.ActiveSupplyInterruptionOverrideListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.creditExpiryLevel is not None:
            showIndent(outfile, level)
            outfile.write('creditExpiryLevel=model_.AccountingUnit(\n')
            self.creditExpiryLevel.exportLiteral(outfile, level, name_='creditExpiryLevel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CreditRegisterListLink is not None:
            showIndent(outfile, level)
            outfile.write('CreditRegisterListLink=model_.CreditRegisterListLink(\n')
            self.CreditRegisterListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lowCreditWarningLevel is not None:
            showIndent(outfile, level)
            outfile.write('lowCreditWarningLevel=model_.AccountingUnit(\n')
            self.lowCreditWarningLevel.exportLiteral(outfile, level, name_='lowCreditWarningLevel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lowEmergencyCreditWarningLevel is not None:
            showIndent(outfile, level)
            outfile.write('lowEmergencyCreditWarningLevel=model_.AccountingUnit(\n')
            self.lowEmergencyCreditWarningLevel.exportLiteral(outfile, level, name_='lowEmergencyCreditWarningLevel')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.prepayMode is not None:
            showIndent(outfile, level)
            outfile.write('prepayMode=model_.PrepayModeType(\n')
            self.prepayMode.exportLiteral(outfile, level, name_='prepayMode')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PrepayOperationStatusLink is not None:
            showIndent(outfile, level)
            outfile.write('PrepayOperationStatusLink=model_.PrepayOperationStatusLink(\n')
            self.PrepayOperationStatusLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SupplyInterruptionOverrideListLink is not None:
            showIndent(outfile, level)
            outfile.write('SupplyInterruptionOverrideListLink=model_.SupplyInterruptionOverrideListLink(\n')
            self.SupplyInterruptionOverrideListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('UsagePoint=[\n')
        level += 1
        for UsagePoint_ in self.UsagePoint:
            showIndent(outfile, level)
            outfile.write('model_.UsagePoint(\n')
            UsagePoint_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.UsagePointLink is not None:
            showIndent(outfile, level)
            outfile.write('UsagePointLink=model_.UsagePointLink(\n')
            self.UsagePointLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Prepayment, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AccountBalanceLink':
            obj_ = AccountBalanceLink.factory()
            obj_.build(child_)
            self.AccountBalanceLink = obj_
            obj_.original_tagname_ = 'AccountBalanceLink'
        elif nodeName_ == 'ActiveCreditRegisterListLink':
            obj_ = ActiveCreditRegisterListLink.factory()
            obj_.build(child_)
            self.ActiveCreditRegisterListLink = obj_
            obj_.original_tagname_ = 'ActiveCreditRegisterListLink'
        elif nodeName_ == 'ActiveSupplyInterruptionOverrideListLink':
            obj_ = ActiveSupplyInterruptionOverrideListLink.factory()
            obj_.build(child_)
            self.ActiveSupplyInterruptionOverrideListLink = obj_
            obj_.original_tagname_ = 'ActiveSupplyInterruptionOverrideListLink'
        elif nodeName_ == 'creditExpiryLevel':
            obj_ = AccountingUnit.factory()
            obj_.build(child_)
            self.creditExpiryLevel = obj_
            obj_.original_tagname_ = 'creditExpiryLevel'
        elif nodeName_ == 'CreditRegisterListLink':
            obj_ = CreditRegisterListLink.factory()
            obj_.build(child_)
            self.CreditRegisterListLink = obj_
            obj_.original_tagname_ = 'CreditRegisterListLink'
        elif nodeName_ == 'lowCreditWarningLevel':
            obj_ = AccountingUnit.factory()
            obj_.build(child_)
            self.lowCreditWarningLevel = obj_
            obj_.original_tagname_ = 'lowCreditWarningLevel'
        elif nodeName_ == 'lowEmergencyCreditWarningLevel':
            obj_ = AccountingUnit.factory()
            obj_.build(child_)
            self.lowEmergencyCreditWarningLevel = obj_
            obj_.original_tagname_ = 'lowEmergencyCreditWarningLevel'
        elif nodeName_ == 'prepayMode':
            obj_ = PrepayModeType.factory()
            obj_.build(child_)
            self.prepayMode = obj_
            obj_.original_tagname_ = 'prepayMode'
        elif nodeName_ == 'PrepayOperationStatusLink':
            obj_ = PrepayOperationStatusLink.factory()
            obj_.build(child_)
            self.PrepayOperationStatusLink = obj_
            obj_.original_tagname_ = 'PrepayOperationStatusLink'
        elif nodeName_ == 'SupplyInterruptionOverrideListLink':
            obj_ = SupplyInterruptionOverrideListLink.factory()
            obj_.build(child_)
            self.SupplyInterruptionOverrideListLink = obj_
            obj_.original_tagname_ = 'SupplyInterruptionOverrideListLink'
        elif nodeName_ == 'UsagePoint':
            obj_ = UsagePoint.factory()
            obj_.build(child_)
            self.UsagePoint.append(obj_)
            obj_.original_tagname_ = 'UsagePoint'
        elif nodeName_ == 'UsagePointLink':
            obj_ = UsagePointLink.factory()
            obj_.build(child_)
            self.UsagePointLink = obj_
            obj_.original_tagname_ = 'UsagePointLink'
        super(Prepayment, self).buildChildren(child_, node, nodeName_, True)
# end class Prepayment


class CreditRegisterList(List):
    """A List element to hold CreditRegister objects."""
    subclass = None
    superclass = List
    def __init__(self, CreditRegister=None):
        self.original_tagname_ = None
        super(CreditRegisterList, self).__init__()
        if CreditRegister is None:
            self.CreditRegister = []
        else:
            self.CreditRegister = CreditRegister
    def factory(*args_, **kwargs_):
        if CreditRegisterList.subclass:
            return CreditRegisterList.subclass(*args_, **kwargs_)
        else:
            return CreditRegisterList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CreditRegister(self): return self.CreditRegister
    def set_CreditRegister(self, CreditRegister): self.CreditRegister = CreditRegister
    def add_CreditRegister(self, value): self.CreditRegister.append(value)
    def insert_CreditRegister_at(self, index, value): self.CreditRegister.insert(index, value)
    def replace_CreditRegister_at(self, index, value): self.CreditRegister[index] = value
    def hasContent_(self):
        if (
            self.CreditRegister or
            super(CreditRegisterList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRegisterList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRegisterList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRegisterList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRegisterList'):
        super(CreditRegisterList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRegisterList')
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRegisterList', fromsubclass_=False, pretty_print=True):
        super(CreditRegisterList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CreditRegister_ in self.CreditRegister:
            CreditRegister_.export(outfile, level, namespace_, name_='CreditRegister', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CreditRegisterList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CreditRegisterList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CreditRegisterList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('CreditRegister=[\n')
        level += 1
        for CreditRegister_ in self.CreditRegister:
            showIndent(outfile, level)
            outfile.write('model_.CreditRegister(\n')
            CreditRegister_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CreditRegisterList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CreditRegister':
            obj_ = CreditRegister.factory()
            obj_.build(child_)
            self.CreditRegister.append(obj_)
            obj_.original_tagname_ = 'CreditRegister'
        super(CreditRegisterList, self).buildChildren(child_, node, nodeName_, True)
# end class CreditRegisterList


class CreditRegister(IdentifiedObject):
    """CreditRegister instances define a credit-modifying transaction.
    Typically this would be a credit-adding transaction, but may be
    a subtracting transaction (perhaps in response to an out-of-band
    debt signal)."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, creditAmount=None, creditType=None, effectiveTime=None, token=None):
        self.original_tagname_ = None
        super(CreditRegister, self).__init__()
        self.creditAmount = creditAmount
        self.creditType = creditType
        self.effectiveTime = effectiveTime
        self.token = token
    def factory(*args_, **kwargs_):
        if CreditRegister.subclass:
            return CreditRegister.subclass(*args_, **kwargs_)
        else:
            return CreditRegister(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_creditAmount(self): return self.creditAmount
    def set_creditAmount(self, creditAmount): self.creditAmount = creditAmount
    def get_creditType(self): return self.creditType
    def set_creditType(self, creditType): self.creditType = creditType
    def get_effectiveTime(self): return self.effectiveTime
    def set_effectiveTime(self, effectiveTime): self.effectiveTime = effectiveTime
    def get_token(self): return self.token
    def set_token(self, token): self.token = token
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.creditAmount is not None or
            self.creditType is not None or
            self.effectiveTime is not None or
            self.token is not None or
            super(CreditRegister, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CreditRegister', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRegister')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CreditRegister', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CreditRegister'):
        super(CreditRegister, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CreditRegister')
    def exportChildren(self, outfile, level, namespace_='', name_='CreditRegister', fromsubclass_=False, pretty_print=True):
        super(CreditRegister, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creditAmount is not None:
            self.creditAmount.export(outfile, level, namespace_, name_='creditAmount', pretty_print=pretty_print)
        if self.creditType is not None:
            self.creditType.export(outfile, level, namespace_, name_='creditType', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            self.effectiveTime.export(outfile, level, namespace_, name_='effectiveTime', pretty_print=pretty_print)
        if self.token is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoken>%s</%stoken>%s' % (namespace_, self.gds_format_string(quote_xml(self.token).encode(ExternalEncoding), input_name='token'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CreditRegister'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CreditRegister, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CreditRegister, self).exportLiteralChildren(outfile, level, name_)
        if self.creditAmount is not None:
            showIndent(outfile, level)
            outfile.write('creditAmount=model_.AccountingUnit(\n')
            self.creditAmount.exportLiteral(outfile, level, name_='creditAmount')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.creditType is not None:
            showIndent(outfile, level)
            outfile.write('creditType=model_.CreditTypeType(\n')
            self.creditType.exportLiteral(outfile, level, name_='creditType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.effectiveTime is not None:
            showIndent(outfile, level)
            outfile.write('effectiveTime=model_.TimeType(\n')
            self.effectiveTime.exportLiteral(outfile, level, name_='effectiveTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.token is not None:
            showIndent(outfile, level)
            outfile.write('token=%s,\n' % quote_python(self.token).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CreditRegister, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'creditAmount':
            obj_ = AccountingUnit.factory()
            obj_.build(child_)
            self.creditAmount = obj_
            obj_.original_tagname_ = 'creditAmount'
        elif nodeName_ == 'creditType':
            obj_ = CreditTypeType.factory()
            obj_.build(child_)
            self.creditType = obj_
            obj_.original_tagname_ = 'creditType'
        elif nodeName_ == 'effectiveTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'token':
            token_ = child_.text
            token_ = self.gds_validate_string(token_, node, 'token')
            self.token = token_
            self.validate_String32(self.token)    # validate type String32
        super(CreditRegister, self).buildChildren(child_, node, nodeName_, True)
# end class CreditRegister


class AccountBalance(Resource):
    """AccountBalance contains the regular credit and emergency credit
    balance for this given service or commodity prepay instance. It
    may also contain status information concerning the balance data."""
    subclass = None
    superclass = Resource
    def __init__(self, availableCredit=None, creditStatus=None, emergencyCredit=None, emergencyCreditStatus=None):
        self.original_tagname_ = None
        super(AccountBalance, self).__init__()
        self.availableCredit = availableCredit
        self.creditStatus = creditStatus
        self.emergencyCredit = emergencyCredit
        self.emergencyCreditStatus = emergencyCreditStatus
    def factory(*args_, **kwargs_):
        if AccountBalance.subclass:
            return AccountBalance.subclass(*args_, **kwargs_)
        else:
            return AccountBalance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_availableCredit(self): return self.availableCredit
    def set_availableCredit(self, availableCredit): self.availableCredit = availableCredit
    def get_creditStatus(self): return self.creditStatus
    def set_creditStatus(self, creditStatus): self.creditStatus = creditStatus
    def get_emergencyCredit(self): return self.emergencyCredit
    def set_emergencyCredit(self, emergencyCredit): self.emergencyCredit = emergencyCredit
    def get_emergencyCreditStatus(self): return self.emergencyCreditStatus
    def set_emergencyCreditStatus(self, emergencyCreditStatus): self.emergencyCreditStatus = emergencyCreditStatus
    def hasContent_(self):
        if (
            self.availableCredit is not None or
            self.creditStatus is not None or
            self.emergencyCredit is not None or
            self.emergencyCreditStatus is not None or
            super(AccountBalance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AccountBalance', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AccountBalance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AccountBalance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AccountBalance'):
        super(AccountBalance, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AccountBalance')
    def exportChildren(self, outfile, level, namespace_='', name_='AccountBalance', fromsubclass_=False, pretty_print=True):
        super(AccountBalance, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.availableCredit is not None:
            self.availableCredit.export(outfile, level, namespace_, name_='availableCredit', pretty_print=pretty_print)
        if self.creditStatus is not None:
            self.creditStatus.export(outfile, level, namespace_, name_='creditStatus', pretty_print=pretty_print)
        if self.emergencyCredit is not None:
            self.emergencyCredit.export(outfile, level, namespace_, name_='emergencyCredit', pretty_print=pretty_print)
        if self.emergencyCreditStatus is not None:
            self.emergencyCreditStatus.export(outfile, level, namespace_, name_='emergencyCreditStatus', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AccountBalance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AccountBalance, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AccountBalance, self).exportLiteralChildren(outfile, level, name_)
        if self.availableCredit is not None:
            showIndent(outfile, level)
            outfile.write('availableCredit=model_.AccountingUnit(\n')
            self.availableCredit.exportLiteral(outfile, level, name_='availableCredit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.creditStatus is not None:
            showIndent(outfile, level)
            outfile.write('creditStatus=model_.CreditStatusType(\n')
            self.creditStatus.exportLiteral(outfile, level, name_='creditStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.emergencyCredit is not None:
            showIndent(outfile, level)
            outfile.write('emergencyCredit=model_.AccountingUnit(\n')
            self.emergencyCredit.exportLiteral(outfile, level, name_='emergencyCredit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.emergencyCreditStatus is not None:
            showIndent(outfile, level)
            outfile.write('emergencyCreditStatus=model_.CreditStatusType(\n')
            self.emergencyCreditStatus.exportLiteral(outfile, level, name_='emergencyCreditStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AccountBalance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'availableCredit':
            obj_ = AccountingUnit.factory()
            obj_.build(child_)
            self.availableCredit = obj_
            obj_.original_tagname_ = 'availableCredit'
        elif nodeName_ == 'creditStatus':
            obj_ = CreditStatusType.factory()
            obj_.build(child_)
            self.creditStatus = obj_
            obj_.original_tagname_ = 'creditStatus'
        elif nodeName_ == 'emergencyCredit':
            obj_ = AccountingUnit.factory()
            obj_.build(child_)
            self.emergencyCredit = obj_
            obj_.original_tagname_ = 'emergencyCredit'
        elif nodeName_ == 'emergencyCreditStatus':
            obj_ = CreditStatusType.factory()
            obj_.build(child_)
            self.emergencyCreditStatus = obj_
            obj_.original_tagname_ = 'emergencyCreditStatus'
        super(AccountBalance, self).buildChildren(child_, node, nodeName_, True)
# end class AccountBalance


class ServiceSupplierList(List):
    """A List element to hold ServiceSupplier objects."""
    subclass = None
    superclass = List
    def __init__(self, ServiceSupplier=None):
        self.original_tagname_ = None
        super(ServiceSupplierList, self).__init__()
        if ServiceSupplier is None:
            self.ServiceSupplier = []
        else:
            self.ServiceSupplier = ServiceSupplier
    def factory(*args_, **kwargs_):
        if ServiceSupplierList.subclass:
            return ServiceSupplierList.subclass(*args_, **kwargs_)
        else:
            return ServiceSupplierList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ServiceSupplier(self): return self.ServiceSupplier
    def set_ServiceSupplier(self, ServiceSupplier): self.ServiceSupplier = ServiceSupplier
    def add_ServiceSupplier(self, value): self.ServiceSupplier.append(value)
    def insert_ServiceSupplier_at(self, index, value): self.ServiceSupplier.insert(index, value)
    def replace_ServiceSupplier_at(self, index, value): self.ServiceSupplier[index] = value
    def hasContent_(self):
        if (
            self.ServiceSupplier or
            super(ServiceSupplierList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceSupplierList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceSupplierList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceSupplierList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceSupplierList'):
        super(ServiceSupplierList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceSupplierList')
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceSupplierList', fromsubclass_=False, pretty_print=True):
        super(ServiceSupplierList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ServiceSupplier_ in self.ServiceSupplier:
            ServiceSupplier_.export(outfile, level, namespace_, name_='ServiceSupplier', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ServiceSupplierList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ServiceSupplierList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ServiceSupplierList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ServiceSupplier=[\n')
        level += 1
        for ServiceSupplier_ in self.ServiceSupplier:
            showIndent(outfile, level)
            outfile.write('model_.ServiceSupplier(\n')
            ServiceSupplier_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ServiceSupplierList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ServiceSupplier':
            obj_ = ServiceSupplier.factory()
            obj_.build(child_)
            self.ServiceSupplier.append(obj_)
            obj_.original_tagname_ = 'ServiceSupplier'
        super(ServiceSupplierList, self).buildChildren(child_, node, nodeName_, True)
# end class ServiceSupplierList


class ServiceSupplier(IdentifiedObject):
    """Organisation that provides services to Customers."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, email=None, phone=None, providerID=None, web=None):
        self.original_tagname_ = None
        super(ServiceSupplier, self).__init__()
        self.email = email
        self.phone = phone
        self.providerID = providerID
        self.web = web
    def factory(*args_, **kwargs_):
        if ServiceSupplier.subclass:
            return ServiceSupplier.subclass(*args_, **kwargs_)
        else:
            return ServiceSupplier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def get_phone(self): return self.phone
    def set_phone(self, phone): self.phone = phone
    def get_providerID(self): return self.providerID
    def set_providerID(self, providerID): self.providerID = providerID
    def get_web(self): return self.web
    def set_web(self, web): self.web = web
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def validate_String20(self, value):
        # Validate type String20, a restriction on xs:string.
        pass
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def validate_String42(self, value):
        # Validate type String42, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.email is not None or
            self.phone is not None or
            self.providerID is not None or
            self.web is not None or
            super(ServiceSupplier, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ServiceSupplier', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceSupplier')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ServiceSupplier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ServiceSupplier'):
        super(ServiceSupplier, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ServiceSupplier')
    def exportChildren(self, outfile, level, namespace_='', name_='ServiceSupplier', fromsubclass_=False, pretty_print=True):
        super(ServiceSupplier, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.email is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespace_, self.gds_format_string(quote_xml(self.email).encode(ExternalEncoding), input_name='email'), namespace_, eol_))
        if self.phone is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphone>%s</%sphone>%s' % (namespace_, self.gds_format_string(quote_xml(self.phone).encode(ExternalEncoding), input_name='phone'), namespace_, eol_))
        if self.providerID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproviderID>%s</%sproviderID>%s' % (namespace_, self.gds_format_integer(self.providerID, input_name='providerID'), namespace_, eol_))
        if self.web is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweb>%s</%sweb>%s' % (namespace_, self.gds_format_string(quote_xml(self.web).encode(ExternalEncoding), input_name='web'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ServiceSupplier'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ServiceSupplier, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ServiceSupplier, self).exportLiteralChildren(outfile, level, name_)
        if self.email is not None:
            showIndent(outfile, level)
            outfile.write('email=%s,\n' % quote_python(self.email).encode(ExternalEncoding))
        if self.phone is not None:
            showIndent(outfile, level)
            outfile.write('phone=%s,\n' % quote_python(self.phone).encode(ExternalEncoding))
        if self.providerID is not None:
            showIndent(outfile, level)
            outfile.write('providerID=%d,\n' % self.providerID)
        if self.web is not None:
            showIndent(outfile, level)
            outfile.write('web=%s,\n' % quote_python(self.web).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ServiceSupplier, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'email':
            email_ = child_.text
            email_ = self.gds_validate_string(email_, node, 'email')
            self.email = email_
            self.validate_String32(self.email)    # validate type String32
        elif nodeName_ == 'phone':
            phone_ = child_.text
            phone_ = self.gds_validate_string(phone_, node, 'phone')
            self.phone = phone_
            self.validate_String20(self.phone)    # validate type String20
        elif nodeName_ == 'providerID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'providerID')
            self.providerID = ival_
            self.validate_UInt32(self.providerID)    # validate type UInt32
        elif nodeName_ == 'web':
            web_ = child_.text
            web_ = self.gds_validate_string(web_, node, 'web')
            self.web = web_
            self.validate_String42(self.web)    # validate type String42
        super(ServiceSupplier, self).buildChildren(child_, node, nodeName_, True)
# end class ServiceSupplier


class TargetReadingList(List):
    """A List element to hold TargetReading objects."""
    subclass = None
    superclass = List
    def __init__(self, TargetReading=None):
        self.original_tagname_ = None
        super(TargetReadingList, self).__init__()
        if TargetReading is None:
            self.TargetReading = []
        else:
            self.TargetReading = TargetReading
    def factory(*args_, **kwargs_):
        if TargetReadingList.subclass:
            return TargetReadingList.subclass(*args_, **kwargs_)
        else:
            return TargetReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TargetReading(self): return self.TargetReading
    def set_TargetReading(self, TargetReading): self.TargetReading = TargetReading
    def add_TargetReading(self, value): self.TargetReading.append(value)
    def insert_TargetReading_at(self, index, value): self.TargetReading.insert(index, value)
    def replace_TargetReading_at(self, index, value): self.TargetReading[index] = value
    def hasContent_(self):
        if (
            self.TargetReading or
            super(TargetReadingList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TargetReadingList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetReadingList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TargetReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetReadingList'):
        super(TargetReadingList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TargetReadingList')
    def exportChildren(self, outfile, level, namespace_='', name_='TargetReadingList', fromsubclass_=False, pretty_print=True):
        super(TargetReadingList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TargetReading_ in self.TargetReading:
            TargetReading_.export(outfile, level, namespace_, name_='TargetReading', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TargetReadingList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TargetReadingList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TargetReadingList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('TargetReading=[\n')
        level += 1
        for TargetReading_ in self.TargetReading:
            showIndent(outfile, level)
            outfile.write('model_.TargetReading(\n')
            TargetReading_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TargetReadingList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TargetReading':
            obj_ = TargetReading.factory()
            obj_.build(child_)
            self.TargetReading.append(obj_)
            obj_.original_tagname_ = 'TargetReading'
        super(TargetReadingList, self).buildChildren(child_, node, nodeName_, True)
# end class TargetReadingList


class ProjectionReadingList(List):
    """A List element to hold ProjectionReading objects."""
    subclass = None
    superclass = List
    def __init__(self, ProjectionReading=None):
        self.original_tagname_ = None
        super(ProjectionReadingList, self).__init__()
        if ProjectionReading is None:
            self.ProjectionReading = []
        else:
            self.ProjectionReading = ProjectionReading
    def factory(*args_, **kwargs_):
        if ProjectionReadingList.subclass:
            return ProjectionReadingList.subclass(*args_, **kwargs_)
        else:
            return ProjectionReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProjectionReading(self): return self.ProjectionReading
    def set_ProjectionReading(self, ProjectionReading): self.ProjectionReading = ProjectionReading
    def add_ProjectionReading(self, value): self.ProjectionReading.append(value)
    def insert_ProjectionReading_at(self, index, value): self.ProjectionReading.insert(index, value)
    def replace_ProjectionReading_at(self, index, value): self.ProjectionReading[index] = value
    def hasContent_(self):
        if (
            self.ProjectionReading or
            super(ProjectionReadingList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProjectionReadingList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectionReadingList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProjectionReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProjectionReadingList'):
        super(ProjectionReadingList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectionReadingList')
    def exportChildren(self, outfile, level, namespace_='', name_='ProjectionReadingList', fromsubclass_=False, pretty_print=True):
        super(ProjectionReadingList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProjectionReading_ in self.ProjectionReading:
            ProjectionReading_.export(outfile, level, namespace_, name_='ProjectionReading', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProjectionReadingList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ProjectionReadingList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProjectionReadingList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ProjectionReading=[\n')
        level += 1
        for ProjectionReading_ in self.ProjectionReading:
            showIndent(outfile, level)
            outfile.write('model_.ProjectionReading(\n')
            ProjectionReading_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectionReadingList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProjectionReading':
            obj_ = ProjectionReading.factory()
            obj_.build(child_)
            self.ProjectionReading.append(obj_)
            obj_.original_tagname_ = 'ProjectionReading'
        super(ProjectionReadingList, self).buildChildren(child_, node, nodeName_, True)
# end class ProjectionReadingList


class HistoricalReadingList(List):
    """A List element to hold HistoricalReading objects."""
    subclass = None
    superclass = List
    def __init__(self, HistoricalReading=None):
        self.original_tagname_ = None
        super(HistoricalReadingList, self).__init__()
        if HistoricalReading is None:
            self.HistoricalReading = []
        else:
            self.HistoricalReading = HistoricalReading
    def factory(*args_, **kwargs_):
        if HistoricalReadingList.subclass:
            return HistoricalReadingList.subclass(*args_, **kwargs_)
        else:
            return HistoricalReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HistoricalReading(self): return self.HistoricalReading
    def set_HistoricalReading(self, HistoricalReading): self.HistoricalReading = HistoricalReading
    def add_HistoricalReading(self, value): self.HistoricalReading.append(value)
    def insert_HistoricalReading_at(self, index, value): self.HistoricalReading.insert(index, value)
    def replace_HistoricalReading_at(self, index, value): self.HistoricalReading[index] = value
    def hasContent_(self):
        if (
            self.HistoricalReading or
            super(HistoricalReadingList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HistoricalReadingList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HistoricalReadingList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HistoricalReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HistoricalReadingList'):
        super(HistoricalReadingList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HistoricalReadingList')
    def exportChildren(self, outfile, level, namespace_='', name_='HistoricalReadingList', fromsubclass_=False, pretty_print=True):
        super(HistoricalReadingList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HistoricalReading_ in self.HistoricalReading:
            HistoricalReading_.export(outfile, level, namespace_, name_='HistoricalReading', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HistoricalReadingList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HistoricalReadingList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HistoricalReadingList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('HistoricalReading=[\n')
        level += 1
        for HistoricalReading_ in self.HistoricalReading:
            showIndent(outfile, level)
            outfile.write('model_.HistoricalReading(\n')
            HistoricalReading_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HistoricalReadingList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HistoricalReading':
            obj_ = HistoricalReading.factory()
            obj_.build(child_)
            self.HistoricalReading.append(obj_)
            obj_.original_tagname_ = 'HistoricalReading'
        super(HistoricalReadingList, self).buildChildren(child_, node, nodeName_, True)
# end class HistoricalReadingList


class CustomerAgreementList(SubscribableList):
    """A List element to hold CustomerAgreement objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, CustomerAgreement=None):
        self.original_tagname_ = None
        super(CustomerAgreementList, self).__init__()
        if CustomerAgreement is None:
            self.CustomerAgreement = []
        else:
            self.CustomerAgreement = CustomerAgreement
    def factory(*args_, **kwargs_):
        if CustomerAgreementList.subclass:
            return CustomerAgreementList.subclass(*args_, **kwargs_)
        else:
            return CustomerAgreementList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerAgreement(self): return self.CustomerAgreement
    def set_CustomerAgreement(self, CustomerAgreement): self.CustomerAgreement = CustomerAgreement
    def add_CustomerAgreement(self, value): self.CustomerAgreement.append(value)
    def insert_CustomerAgreement_at(self, index, value): self.CustomerAgreement.insert(index, value)
    def replace_CustomerAgreement_at(self, index, value): self.CustomerAgreement[index] = value
    def hasContent_(self):
        if (
            self.CustomerAgreement or
            super(CustomerAgreementList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerAgreementList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAgreementList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerAgreementList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerAgreementList'):
        super(CustomerAgreementList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAgreementList')
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerAgreementList', fromsubclass_=False, pretty_print=True):
        super(CustomerAgreementList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CustomerAgreement_ in self.CustomerAgreement:
            CustomerAgreement_.export(outfile, level, namespace_, name_='CustomerAgreement', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustomerAgreementList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomerAgreementList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomerAgreementList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('CustomerAgreement=[\n')
        level += 1
        for CustomerAgreement_ in self.CustomerAgreement:
            showIndent(outfile, level)
            outfile.write('model_.CustomerAgreement(\n')
            CustomerAgreement_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CustomerAgreementList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerAgreement':
            obj_ = CustomerAgreement.factory()
            obj_.build(child_)
            self.CustomerAgreement.append(obj_)
            obj_.original_tagname_ = 'CustomerAgreement'
        super(CustomerAgreementList, self).buildChildren(child_, node, nodeName_, True)
# end class CustomerAgreementList


class CustomerAgreement(IdentifiedObject):
    """Agreement between the customer and the service supplier to pay for
    service at a specific service location. It records certain
    billing information about the type of service provided at the
    service location and is used during charge creation to determine
    the type of service."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, ActiveBillingPeriodListLink=None, ActiveProjectionReadingListLink=None, ActiveTargetReadingListLink=None, BillingPeriodListLink=None, HistoricalReadingListLink=None, PrepaymentLink=None, ProjectionReadingListLink=None, serviceAccount=None, serviceLocation=None, TargetReadingListLink=None, TariffProfileLink=None, UsagePointLink=None):
        self.original_tagname_ = None
        super(CustomerAgreement, self).__init__()
        self.ActiveBillingPeriodListLink = ActiveBillingPeriodListLink
        self.ActiveProjectionReadingListLink = ActiveProjectionReadingListLink
        self.ActiveTargetReadingListLink = ActiveTargetReadingListLink
        self.BillingPeriodListLink = BillingPeriodListLink
        self.HistoricalReadingListLink = HistoricalReadingListLink
        self.PrepaymentLink = PrepaymentLink
        self.ProjectionReadingListLink = ProjectionReadingListLink
        self.serviceAccount = serviceAccount
        self.serviceLocation = serviceLocation
        self.TargetReadingListLink = TargetReadingListLink
        self.TariffProfileLink = TariffProfileLink
        self.UsagePointLink = UsagePointLink
    def factory(*args_, **kwargs_):
        if CustomerAgreement.subclass:
            return CustomerAgreement.subclass(*args_, **kwargs_)
        else:
            return CustomerAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActiveBillingPeriodListLink(self): return self.ActiveBillingPeriodListLink
    def set_ActiveBillingPeriodListLink(self, ActiveBillingPeriodListLink): self.ActiveBillingPeriodListLink = ActiveBillingPeriodListLink
    def get_ActiveProjectionReadingListLink(self): return self.ActiveProjectionReadingListLink
    def set_ActiveProjectionReadingListLink(self, ActiveProjectionReadingListLink): self.ActiveProjectionReadingListLink = ActiveProjectionReadingListLink
    def get_ActiveTargetReadingListLink(self): return self.ActiveTargetReadingListLink
    def set_ActiveTargetReadingListLink(self, ActiveTargetReadingListLink): self.ActiveTargetReadingListLink = ActiveTargetReadingListLink
    def get_BillingPeriodListLink(self): return self.BillingPeriodListLink
    def set_BillingPeriodListLink(self, BillingPeriodListLink): self.BillingPeriodListLink = BillingPeriodListLink
    def get_HistoricalReadingListLink(self): return self.HistoricalReadingListLink
    def set_HistoricalReadingListLink(self, HistoricalReadingListLink): self.HistoricalReadingListLink = HistoricalReadingListLink
    def get_PrepaymentLink(self): return self.PrepaymentLink
    def set_PrepaymentLink(self, PrepaymentLink): self.PrepaymentLink = PrepaymentLink
    def get_ProjectionReadingListLink(self): return self.ProjectionReadingListLink
    def set_ProjectionReadingListLink(self, ProjectionReadingListLink): self.ProjectionReadingListLink = ProjectionReadingListLink
    def get_serviceAccount(self): return self.serviceAccount
    def set_serviceAccount(self, serviceAccount): self.serviceAccount = serviceAccount
    def get_serviceLocation(self): return self.serviceLocation
    def set_serviceLocation(self, serviceLocation): self.serviceLocation = serviceLocation
    def get_TargetReadingListLink(self): return self.TargetReadingListLink
    def set_TargetReadingListLink(self, TargetReadingListLink): self.TargetReadingListLink = TargetReadingListLink
    def get_TariffProfileLink(self): return self.TariffProfileLink
    def set_TariffProfileLink(self, TariffProfileLink): self.TariffProfileLink = TariffProfileLink
    def get_UsagePointLink(self): return self.UsagePointLink
    def set_UsagePointLink(self, UsagePointLink): self.UsagePointLink = UsagePointLink
    def validate_String42(self, value):
        # Validate type String42, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ActiveBillingPeriodListLink is not None or
            self.ActiveProjectionReadingListLink is not None or
            self.ActiveTargetReadingListLink is not None or
            self.BillingPeriodListLink is not None or
            self.HistoricalReadingListLink is not None or
            self.PrepaymentLink is not None or
            self.ProjectionReadingListLink is not None or
            self.serviceAccount is not None or
            self.serviceLocation is not None or
            self.TargetReadingListLink is not None or
            self.TariffProfileLink is not None or
            self.UsagePointLink is not None or
            super(CustomerAgreement, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerAgreement', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAgreement')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerAgreement'):
        super(CustomerAgreement, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAgreement')
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerAgreement', fromsubclass_=False, pretty_print=True):
        super(CustomerAgreement, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveBillingPeriodListLink is not None:
            self.ActiveBillingPeriodListLink.export(outfile, level, namespace_, name_='ActiveBillingPeriodListLink', pretty_print=pretty_print)
        if self.ActiveProjectionReadingListLink is not None:
            self.ActiveProjectionReadingListLink.export(outfile, level, namespace_, name_='ActiveProjectionReadingListLink', pretty_print=pretty_print)
        if self.ActiveTargetReadingListLink is not None:
            self.ActiveTargetReadingListLink.export(outfile, level, namespace_, name_='ActiveTargetReadingListLink', pretty_print=pretty_print)
        if self.BillingPeriodListLink is not None:
            self.BillingPeriodListLink.export(outfile, level, namespace_, name_='BillingPeriodListLink', pretty_print=pretty_print)
        if self.HistoricalReadingListLink is not None:
            self.HistoricalReadingListLink.export(outfile, level, namespace_, name_='HistoricalReadingListLink', pretty_print=pretty_print)
        if self.PrepaymentLink is not None:
            self.PrepaymentLink.export(outfile, level, namespace_, name_='PrepaymentLink', pretty_print=pretty_print)
        if self.ProjectionReadingListLink is not None:
            self.ProjectionReadingListLink.export(outfile, level, namespace_, name_='ProjectionReadingListLink', pretty_print=pretty_print)
        if self.serviceAccount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserviceAccount>%s</%sserviceAccount>%s' % (namespace_, self.gds_format_string(quote_xml(self.serviceAccount).encode(ExternalEncoding), input_name='serviceAccount'), namespace_, eol_))
        if self.serviceLocation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserviceLocation>%s</%sserviceLocation>%s' % (namespace_, self.gds_format_string(quote_xml(self.serviceLocation).encode(ExternalEncoding), input_name='serviceLocation'), namespace_, eol_))
        if self.TargetReadingListLink is not None:
            self.TargetReadingListLink.export(outfile, level, namespace_, name_='TargetReadingListLink', pretty_print=pretty_print)
        if self.TariffProfileLink is not None:
            self.TariffProfileLink.export(outfile, level, namespace_, name_='TariffProfileLink', pretty_print=pretty_print)
        if self.UsagePointLink is not None:
            self.UsagePointLink.export(outfile, level, namespace_, name_='UsagePointLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustomerAgreement'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomerAgreement, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomerAgreement, self).exportLiteralChildren(outfile, level, name_)
        if self.ActiveBillingPeriodListLink is not None:
            showIndent(outfile, level)
            outfile.write('ActiveBillingPeriodListLink=model_.ActiveBillingPeriodListLink(\n')
            self.ActiveBillingPeriodListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ActiveProjectionReadingListLink is not None:
            showIndent(outfile, level)
            outfile.write('ActiveProjectionReadingListLink=model_.ActiveProjectionReadingListLink(\n')
            self.ActiveProjectionReadingListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ActiveTargetReadingListLink is not None:
            showIndent(outfile, level)
            outfile.write('ActiveTargetReadingListLink=model_.ActiveTargetReadingListLink(\n')
            self.ActiveTargetReadingListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BillingPeriodListLink is not None:
            showIndent(outfile, level)
            outfile.write('BillingPeriodListLink=model_.BillingPeriodListLink(\n')
            self.BillingPeriodListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HistoricalReadingListLink is not None:
            showIndent(outfile, level)
            outfile.write('HistoricalReadingListLink=model_.HistoricalReadingListLink(\n')
            self.HistoricalReadingListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PrepaymentLink is not None:
            showIndent(outfile, level)
            outfile.write('PrepaymentLink=model_.PrepaymentLink(\n')
            self.PrepaymentLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProjectionReadingListLink is not None:
            showIndent(outfile, level)
            outfile.write('ProjectionReadingListLink=model_.ProjectionReadingListLink(\n')
            self.ProjectionReadingListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serviceAccount is not None:
            showIndent(outfile, level)
            outfile.write('serviceAccount=%s,\n' % quote_python(self.serviceAccount).encode(ExternalEncoding))
        if self.serviceLocation is not None:
            showIndent(outfile, level)
            outfile.write('serviceLocation=%s,\n' % quote_python(self.serviceLocation).encode(ExternalEncoding))
        if self.TargetReadingListLink is not None:
            showIndent(outfile, level)
            outfile.write('TargetReadingListLink=model_.TargetReadingListLink(\n')
            self.TargetReadingListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TariffProfileLink is not None:
            showIndent(outfile, level)
            outfile.write('TariffProfileLink=model_.TariffProfileLink(\n')
            self.TariffProfileLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UsagePointLink is not None:
            showIndent(outfile, level)
            outfile.write('UsagePointLink=model_.UsagePointLink(\n')
            self.UsagePointLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CustomerAgreement, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActiveBillingPeriodListLink':
            obj_ = ActiveBillingPeriodListLink.factory()
            obj_.build(child_)
            self.ActiveBillingPeriodListLink = obj_
            obj_.original_tagname_ = 'ActiveBillingPeriodListLink'
        elif nodeName_ == 'ActiveProjectionReadingListLink':
            obj_ = ActiveProjectionReadingListLink.factory()
            obj_.build(child_)
            self.ActiveProjectionReadingListLink = obj_
            obj_.original_tagname_ = 'ActiveProjectionReadingListLink'
        elif nodeName_ == 'ActiveTargetReadingListLink':
            obj_ = ActiveTargetReadingListLink.factory()
            obj_.build(child_)
            self.ActiveTargetReadingListLink = obj_
            obj_.original_tagname_ = 'ActiveTargetReadingListLink'
        elif nodeName_ == 'BillingPeriodListLink':
            obj_ = BillingPeriodListLink.factory()
            obj_.build(child_)
            self.BillingPeriodListLink = obj_
            obj_.original_tagname_ = 'BillingPeriodListLink'
        elif nodeName_ == 'HistoricalReadingListLink':
            obj_ = HistoricalReadingListLink.factory()
            obj_.build(child_)
            self.HistoricalReadingListLink = obj_
            obj_.original_tagname_ = 'HistoricalReadingListLink'
        elif nodeName_ == 'PrepaymentLink':
            obj_ = PrepaymentLink.factory()
            obj_.build(child_)
            self.PrepaymentLink = obj_
            obj_.original_tagname_ = 'PrepaymentLink'
        elif nodeName_ == 'ProjectionReadingListLink':
            obj_ = ProjectionReadingListLink.factory()
            obj_.build(child_)
            self.ProjectionReadingListLink = obj_
            obj_.original_tagname_ = 'ProjectionReadingListLink'
        elif nodeName_ == 'serviceAccount':
            serviceAccount_ = child_.text
            serviceAccount_ = self.gds_validate_string(serviceAccount_, node, 'serviceAccount')
            self.serviceAccount = serviceAccount_
            self.validate_String42(self.serviceAccount)    # validate type String42
        elif nodeName_ == 'serviceLocation':
            serviceLocation_ = child_.text
            serviceLocation_ = self.gds_validate_string(serviceLocation_, node, 'serviceLocation')
            self.serviceLocation = serviceLocation_
            self.validate_String42(self.serviceLocation)    # validate type String42
        elif nodeName_ == 'TargetReadingListLink':
            obj_ = TargetReadingListLink.factory()
            obj_.build(child_)
            self.TargetReadingListLink = obj_
            obj_.original_tagname_ = 'TargetReadingListLink'
        elif nodeName_ == 'TariffProfileLink':
            obj_ = TariffProfileLink.factory()
            obj_.build(child_)
            self.TariffProfileLink = obj_
            obj_.original_tagname_ = 'TariffProfileLink'
        elif nodeName_ == 'UsagePointLink':
            obj_ = UsagePointLink.factory()
            obj_.build(child_)
            self.UsagePointLink = obj_
            obj_.original_tagname_ = 'UsagePointLink'
        super(CustomerAgreement, self).buildChildren(child_, node, nodeName_, True)
# end class CustomerAgreement


class CustomerAccountList(SubscribableList):
    """A List element to hold CustomerAccount objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, CustomerAccount=None):
        self.original_tagname_ = None
        super(CustomerAccountList, self).__init__()
        if CustomerAccount is None:
            self.CustomerAccount = []
        else:
            self.CustomerAccount = CustomerAccount
    def factory(*args_, **kwargs_):
        if CustomerAccountList.subclass:
            return CustomerAccountList.subclass(*args_, **kwargs_)
        else:
            return CustomerAccountList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerAccount(self): return self.CustomerAccount
    def set_CustomerAccount(self, CustomerAccount): self.CustomerAccount = CustomerAccount
    def add_CustomerAccount(self, value): self.CustomerAccount.append(value)
    def insert_CustomerAccount_at(self, index, value): self.CustomerAccount.insert(index, value)
    def replace_CustomerAccount_at(self, index, value): self.CustomerAccount[index] = value
    def hasContent_(self):
        if (
            self.CustomerAccount or
            super(CustomerAccountList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerAccountList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAccountList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerAccountList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerAccountList'):
        super(CustomerAccountList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAccountList')
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerAccountList', fromsubclass_=False, pretty_print=True):
        super(CustomerAccountList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CustomerAccount_ in self.CustomerAccount:
            CustomerAccount_.export(outfile, level, namespace_, name_='CustomerAccount', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustomerAccountList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomerAccountList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomerAccountList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('CustomerAccount=[\n')
        level += 1
        for CustomerAccount_ in self.CustomerAccount:
            showIndent(outfile, level)
            outfile.write('model_.CustomerAccount(\n')
            CustomerAccount_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CustomerAccountList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerAccount':
            obj_ = CustomerAccount.factory()
            obj_.build(child_)
            self.CustomerAccount.append(obj_)
            obj_.original_tagname_ = 'CustomerAccount'
        super(CustomerAccountList, self).buildChildren(child_, node, nodeName_, True)
# end class CustomerAccountList


class CustomerAccount(IdentifiedObject):
    """Assignment of a group of products and services purchased by the
    Customer through a CustomerAgreement, used as a mechanism for
    customer billing and payment. It contains common information
    from the various types of CustomerAgreements to create billings
    (invoices) for a Customer and receive payment."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, currency=None, customerAccount=None, CustomerAgreementListLink=None, customerName=None, pricePowerOfTenMultiplier=None, ServiceSupplierLink=None):
        self.original_tagname_ = None
        super(CustomerAccount, self).__init__()
        self.currency = currency
        self.customerAccount = customerAccount
        self.CustomerAgreementListLink = CustomerAgreementListLink
        self.customerName = customerName
        self.pricePowerOfTenMultiplier = pricePowerOfTenMultiplier
        self.ServiceSupplierLink = ServiceSupplierLink
    def factory(*args_, **kwargs_):
        if CustomerAccount.subclass:
            return CustomerAccount.subclass(*args_, **kwargs_)
        else:
            return CustomerAccount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_customerAccount(self): return self.customerAccount
    def set_customerAccount(self, customerAccount): self.customerAccount = customerAccount
    def get_CustomerAgreementListLink(self): return self.CustomerAgreementListLink
    def set_CustomerAgreementListLink(self, CustomerAgreementListLink): self.CustomerAgreementListLink = CustomerAgreementListLink
    def get_customerName(self): return self.customerName
    def set_customerName(self, customerName): self.customerName = customerName
    def get_pricePowerOfTenMultiplier(self): return self.pricePowerOfTenMultiplier
    def set_pricePowerOfTenMultiplier(self, pricePowerOfTenMultiplier): self.pricePowerOfTenMultiplier = pricePowerOfTenMultiplier
    def get_ServiceSupplierLink(self): return self.ServiceSupplierLink
    def set_ServiceSupplierLink(self, ServiceSupplierLink): self.ServiceSupplierLink = ServiceSupplierLink
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def validate_String42(self, value):
        # Validate type String42, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.currency is not None or
            self.customerAccount is not None or
            self.CustomerAgreementListLink is not None or
            self.customerName is not None or
            self.pricePowerOfTenMultiplier is not None or
            self.ServiceSupplierLink is not None or
            super(CustomerAccount, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CustomerAccount', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAccount')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CustomerAccount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CustomerAccount'):
        super(CustomerAccount, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CustomerAccount')
    def exportChildren(self, outfile, level, namespace_='', name_='CustomerAccount', fromsubclass_=False, pretty_print=True):
        super(CustomerAccount, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrency>%s</%scurrency>%s' % (namespace_, self.gds_format_integer(self.currency, input_name='currency'), namespace_, eol_))
        if self.customerAccount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerAccount>%s</%scustomerAccount>%s' % (namespace_, self.gds_format_string(quote_xml(self.customerAccount).encode(ExternalEncoding), input_name='customerAccount'), namespace_, eol_))
        if self.CustomerAgreementListLink is not None:
            self.CustomerAgreementListLink.export(outfile, level, namespace_, name_='CustomerAgreementListLink', pretty_print=pretty_print)
        if self.customerName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerName>%s</%scustomerName>%s' % (namespace_, self.gds_format_string(quote_xml(self.customerName).encode(ExternalEncoding), input_name='customerName'), namespace_, eol_))
        if self.pricePowerOfTenMultiplier is not None:
            self.pricePowerOfTenMultiplier.export(outfile, level, namespace_, name_='pricePowerOfTenMultiplier', pretty_print=pretty_print)
        if self.ServiceSupplierLink is not None:
            self.ServiceSupplierLink.export(outfile, level, namespace_, name_='ServiceSupplierLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CustomerAccount'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CustomerAccount, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CustomerAccount, self).exportLiteralChildren(outfile, level, name_)
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=%d,\n' % self.currency)
        if self.customerAccount is not None:
            showIndent(outfile, level)
            outfile.write('customerAccount=%s,\n' % quote_python(self.customerAccount).encode(ExternalEncoding))
        if self.CustomerAgreementListLink is not None:
            showIndent(outfile, level)
            outfile.write('CustomerAgreementListLink=model_.CustomerAgreementListLink(\n')
            self.CustomerAgreementListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.customerName is not None:
            showIndent(outfile, level)
            outfile.write('customerName=%s,\n' % quote_python(self.customerName).encode(ExternalEncoding))
        if self.pricePowerOfTenMultiplier is not None:
            showIndent(outfile, level)
            outfile.write('pricePowerOfTenMultiplier=model_.PowerOfTenMultiplierType(\n')
            self.pricePowerOfTenMultiplier.exportLiteral(outfile, level, name_='pricePowerOfTenMultiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ServiceSupplierLink is not None:
            showIndent(outfile, level)
            outfile.write('ServiceSupplierLink=model_.ServiceSupplierLink(\n')
            self.ServiceSupplierLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CustomerAccount, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'currency')
            self.currency = ival_
            self.validate_UInt16(self.currency)    # validate type UInt16
        elif nodeName_ == 'customerAccount':
            customerAccount_ = child_.text
            customerAccount_ = self.gds_validate_string(customerAccount_, node, 'customerAccount')
            self.customerAccount = customerAccount_
            self.validate_String42(self.customerAccount)    # validate type String42
        elif nodeName_ == 'CustomerAgreementListLink':
            obj_ = CustomerAgreementListLink.factory()
            obj_.build(child_)
            self.CustomerAgreementListLink = obj_
            obj_.original_tagname_ = 'CustomerAgreementListLink'
        elif nodeName_ == 'customerName':
            customerName_ = child_.text
            customerName_ = self.gds_validate_string(customerName_, node, 'customerName')
            self.customerName = customerName_
            self.validate_String42(self.customerName)    # validate type String42
        elif nodeName_ == 'pricePowerOfTenMultiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.pricePowerOfTenMultiplier = obj_
            obj_.original_tagname_ = 'pricePowerOfTenMultiplier'
        elif nodeName_ == 'ServiceSupplierLink':
            obj_ = ServiceSupplierLink.factory()
            obj_.build(child_)
            self.ServiceSupplierLink = obj_
            obj_.original_tagname_ = 'ServiceSupplierLink'
        super(CustomerAccount, self).buildChildren(child_, node, nodeName_, True)
# end class CustomerAccount


class BillingReadingSetList(SubscribableList):
    """A List element to hold BillingReadingSet objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, BillingReadingSet=None):
        self.original_tagname_ = None
        super(BillingReadingSetList, self).__init__()
        if BillingReadingSet is None:
            self.BillingReadingSet = []
        else:
            self.BillingReadingSet = BillingReadingSet
    def factory(*args_, **kwargs_):
        if BillingReadingSetList.subclass:
            return BillingReadingSetList.subclass(*args_, **kwargs_)
        else:
            return BillingReadingSetList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BillingReadingSet(self): return self.BillingReadingSet
    def set_BillingReadingSet(self, BillingReadingSet): self.BillingReadingSet = BillingReadingSet
    def add_BillingReadingSet(self, value): self.BillingReadingSet.append(value)
    def insert_BillingReadingSet_at(self, index, value): self.BillingReadingSet.insert(index, value)
    def replace_BillingReadingSet_at(self, index, value): self.BillingReadingSet[index] = value
    def hasContent_(self):
        if (
            self.BillingReadingSet or
            super(BillingReadingSetList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingReadingSetList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingSetList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingReadingSetList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingReadingSetList'):
        super(BillingReadingSetList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingSetList')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingReadingSetList', fromsubclass_=False, pretty_print=True):
        super(BillingReadingSetList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BillingReadingSet_ in self.BillingReadingSet:
            BillingReadingSet_.export(outfile, level, namespace_, name_='BillingReadingSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillingReadingSetList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingReadingSetList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingReadingSetList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('BillingReadingSet=[\n')
        level += 1
        for BillingReadingSet_ in self.BillingReadingSet:
            showIndent(outfile, level)
            outfile.write('model_.BillingReadingSet(\n')
            BillingReadingSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingSetList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BillingReadingSet':
            obj_ = BillingReadingSet.factory()
            obj_.build(child_)
            self.BillingReadingSet.append(obj_)
            obj_.original_tagname_ = 'BillingReadingSet'
        super(BillingReadingSetList, self).buildChildren(child_, node, nodeName_, True)
# end class BillingReadingSetList


class BillingReadingList(List):
    """A List element to hold BillingReading objects."""
    subclass = None
    superclass = List
    def __init__(self, BillingReading=None):
        self.original_tagname_ = None
        super(BillingReadingList, self).__init__()
        if BillingReading is None:
            self.BillingReading = []
        else:
            self.BillingReading = BillingReading
    def factory(*args_, **kwargs_):
        if BillingReadingList.subclass:
            return BillingReadingList.subclass(*args_, **kwargs_)
        else:
            return BillingReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BillingReading(self): return self.BillingReading
    def set_BillingReading(self, BillingReading): self.BillingReading = BillingReading
    def add_BillingReading(self, value): self.BillingReading.append(value)
    def insert_BillingReading_at(self, index, value): self.BillingReading.insert(index, value)
    def replace_BillingReading_at(self, index, value): self.BillingReading[index] = value
    def hasContent_(self):
        if (
            self.BillingReading or
            super(BillingReadingList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingReadingList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingReadingList'):
        super(BillingReadingList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingList')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingReadingList', fromsubclass_=False, pretty_print=True):
        super(BillingReadingList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BillingReading_ in self.BillingReading:
            BillingReading_.export(outfile, level, namespace_, name_='BillingReading', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillingReadingList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingReadingList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingReadingList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('BillingReading=[\n')
        level += 1
        for BillingReading_ in self.BillingReading:
            showIndent(outfile, level)
            outfile.write('model_.BillingReading(\n')
            BillingReading_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BillingReading':
            obj_ = BillingReading.factory()
            obj_.build(child_)
            self.BillingReading.append(obj_)
            obj_.original_tagname_ = 'BillingReading'
        super(BillingReadingList, self).buildChildren(child_, node, nodeName_, True)
# end class BillingReadingList


class BillingReading(ReadingBase):
    """Data captured at regular intervals of time. Interval data could be
    captured as incremental data, absolute data, or relative data.
    The source for the data is usually a tariff quantity or an
    engineering quantity. Data is typically captured in time-tagged,
    uniform, fixed-length intervals of 5 min, 10 min, 15 min, 30
    min, or 60 min. However, consumption aggregations can also be
    represented with this class."""
    subclass = None
    superclass = ReadingBase
    def __init__(self, Charge=None):
        self.original_tagname_ = None
        super(BillingReading, self).__init__()
        if Charge is None:
            self.Charge = []
        else:
            self.Charge = Charge
    def factory(*args_, **kwargs_):
        if BillingReading.subclass:
            return BillingReading.subclass(*args_, **kwargs_)
        else:
            return BillingReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Charge(self): return self.Charge
    def set_Charge(self, Charge): self.Charge = Charge
    def add_Charge(self, value): self.Charge.append(value)
    def insert_Charge_at(self, index, value): self.Charge.insert(index, value)
    def replace_Charge_at(self, index, value): self.Charge[index] = value
    def hasContent_(self):
        if (
            self.Charge or
            super(BillingReading, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingReading', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReading')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingReading', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingReading'):
        super(BillingReading, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReading')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingReading', fromsubclass_=False, pretty_print=True):
        super(BillingReading, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Charge_ in self.Charge:
            Charge_.export(outfile, level, namespace_, name_='Charge', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillingReading'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingReading, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingReading, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Charge=[\n')
        level += 1
        for Charge_ in self.Charge:
            showIndent(outfile, level)
            outfile.write('model_.Charge(\n')
            Charge_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingReading, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Charge':
            obj_ = Charge.factory()
            obj_.build(child_)
            self.Charge.append(obj_)
            obj_.original_tagname_ = 'Charge'
        super(BillingReading, self).buildChildren(child_, node, nodeName_, True)
# end class BillingReading


class BillingPeriodList(SubscribableList):
    """A List element to hold BillingPeriod objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, BillingPeriod=None):
        self.original_tagname_ = None
        super(BillingPeriodList, self).__init__()
        if BillingPeriod is None:
            self.BillingPeriod = []
        else:
            self.BillingPeriod = BillingPeriod
    def factory(*args_, **kwargs_):
        if BillingPeriodList.subclass:
            return BillingPeriodList.subclass(*args_, **kwargs_)
        else:
            return BillingPeriodList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BillingPeriod(self): return self.BillingPeriod
    def set_BillingPeriod(self, BillingPeriod): self.BillingPeriod = BillingPeriod
    def add_BillingPeriod(self, value): self.BillingPeriod.append(value)
    def insert_BillingPeriod_at(self, index, value): self.BillingPeriod.insert(index, value)
    def replace_BillingPeriod_at(self, index, value): self.BillingPeriod[index] = value
    def hasContent_(self):
        if (
            self.BillingPeriod or
            super(BillingPeriodList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingPeriodList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingPeriodList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingPeriodList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingPeriodList'):
        super(BillingPeriodList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingPeriodList')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingPeriodList', fromsubclass_=False, pretty_print=True):
        super(BillingPeriodList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BillingPeriod_ in self.BillingPeriod:
            BillingPeriod_.export(outfile, level, namespace_, name_='BillingPeriod', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillingPeriodList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingPeriodList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingPeriodList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('BillingPeriod=[\n')
        level += 1
        for BillingPeriod_ in self.BillingPeriod:
            showIndent(outfile, level)
            outfile.write('model_.BillingPeriod(\n')
            BillingPeriod_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingPeriodList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BillingPeriod':
            obj_ = BillingPeriod.factory()
            obj_.build(child_)
            self.BillingPeriod.append(obj_)
            obj_.original_tagname_ = 'BillingPeriod'
        super(BillingPeriodList, self).buildChildren(child_, node, nodeName_, True)
# end class BillingPeriodList


class BillingPeriod(Resource):
    """A Billing Period relates to the period of time on which a customer
    is billed. As an example the billing period interval for a
    particular customer might be 31 days starting on July 1, 2011.
    The start date and interval can change on each billing period.
    There may also be multiple billing periods related to a customer
    agreement to support different tariff structures."""
    subclass = None
    superclass = Resource
    def __init__(self, billLastPeriod=None, billToDate=None, interval=None, statusTimeStamp=None):
        self.original_tagname_ = None
        super(BillingPeriod, self).__init__()
        self.billLastPeriod = billLastPeriod
        self.billToDate = billToDate
        self.interval = interval
        self.statusTimeStamp = statusTimeStamp
    def factory(*args_, **kwargs_):
        if BillingPeriod.subclass:
            return BillingPeriod.subclass(*args_, **kwargs_)
        else:
            return BillingPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_billLastPeriod(self): return self.billLastPeriod
    def set_billLastPeriod(self, billLastPeriod): self.billLastPeriod = billLastPeriod
    def get_billToDate(self): return self.billToDate
    def set_billToDate(self, billToDate): self.billToDate = billToDate
    def get_interval(self): return self.interval
    def set_interval(self, interval): self.interval = interval
    def get_statusTimeStamp(self): return self.statusTimeStamp
    def set_statusTimeStamp(self, statusTimeStamp): self.statusTimeStamp = statusTimeStamp
    def validate_Int48(self, value):
        # Validate type Int48, a restriction on xs:long.
        pass
    def hasContent_(self):
        if (
            self.billLastPeriod is not None or
            self.billToDate is not None or
            self.interval is not None or
            self.statusTimeStamp is not None or
            super(BillingPeriod, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingPeriod', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingPeriod')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingPeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingPeriod'):
        super(BillingPeriod, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingPeriod')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingPeriod', fromsubclass_=False, pretty_print=True):
        super(BillingPeriod, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.billLastPeriod is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbillLastPeriod>%s</%sbillLastPeriod>%s' % (namespace_, self.gds_format_integer(self.billLastPeriod, input_name='billLastPeriod'), namespace_, eol_))
        if self.billToDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbillToDate>%s</%sbillToDate>%s' % (namespace_, self.gds_format_integer(self.billToDate, input_name='billToDate'), namespace_, eol_))
        if self.interval is not None:
            self.interval.export(outfile, level, namespace_, name_='interval', pretty_print=pretty_print)
        if self.statusTimeStamp is not None:
            self.statusTimeStamp.export(outfile, level, namespace_, name_='statusTimeStamp', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillingPeriod'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingPeriod, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingPeriod, self).exportLiteralChildren(outfile, level, name_)
        if self.billLastPeriod is not None:
            showIndent(outfile, level)
            outfile.write('billLastPeriod=%d,\n' % self.billLastPeriod)
        if self.billToDate is not None:
            showIndent(outfile, level)
            outfile.write('billToDate=%d,\n' % self.billToDate)
        if self.interval is not None:
            showIndent(outfile, level)
            outfile.write('interval=model_.DateTimeInterval(\n')
            self.interval.exportLiteral(outfile, level, name_='interval')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.statusTimeStamp is not None:
            showIndent(outfile, level)
            outfile.write('statusTimeStamp=model_.TimeType(\n')
            self.statusTimeStamp.exportLiteral(outfile, level, name_='statusTimeStamp')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingPeriod, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'billLastPeriod':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'billLastPeriod')
            self.billLastPeriod = ival_
            self.validate_Int48(self.billLastPeriod)    # validate type Int48
        elif nodeName_ == 'billToDate':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'billToDate')
            self.billToDate = ival_
            self.validate_Int48(self.billToDate)    # validate type Int48
        elif nodeName_ == 'interval':
            obj_ = DateTimeInterval.factory()
            obj_.build(child_)
            self.interval = obj_
            obj_.original_tagname_ = 'interval'
        elif nodeName_ == 'statusTimeStamp':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.statusTimeStamp = obj_
            obj_.original_tagname_ = 'statusTimeStamp'
        super(BillingPeriod, self).buildChildren(child_, node, nodeName_, True)
# end class BillingPeriod


class TextMessageList(SubscribableList):
    """A List element to hold TextMessage objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, TextMessage=None):
        self.original_tagname_ = None
        super(TextMessageList, self).__init__()
        if TextMessage is None:
            self.TextMessage = []
        else:
            self.TextMessage = TextMessage
    def factory(*args_, **kwargs_):
        if TextMessageList.subclass:
            return TextMessageList.subclass(*args_, **kwargs_)
        else:
            return TextMessageList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextMessage(self): return self.TextMessage
    def set_TextMessage(self, TextMessage): self.TextMessage = TextMessage
    def add_TextMessage(self, value): self.TextMessage.append(value)
    def insert_TextMessage_at(self, index, value): self.TextMessage.insert(index, value)
    def replace_TextMessage_at(self, index, value): self.TextMessage[index] = value
    def hasContent_(self):
        if (
            self.TextMessage or
            super(TextMessageList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextMessageList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextMessageList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextMessageList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextMessageList'):
        super(TextMessageList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TextMessageList')
    def exportChildren(self, outfile, level, namespace_='', name_='TextMessageList', fromsubclass_=False, pretty_print=True):
        super(TextMessageList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TextMessage_ in self.TextMessage:
            TextMessage_.export(outfile, level, namespace_, name_='TextMessage', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TextMessageList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TextMessageList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TextMessageList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('TextMessage=[\n')
        level += 1
        for TextMessage_ in self.TextMessage:
            showIndent(outfile, level)
            outfile.write('model_.TextMessage(\n')
            TextMessage_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextMessageList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextMessage':
            obj_ = TextMessage.factory()
            obj_.build(child_)
            self.TextMessage.append(obj_)
            obj_.original_tagname_ = 'TextMessage'
        super(TextMessageList, self).buildChildren(child_, node, nodeName_, True)
# end class TextMessageList


class TextMessage(Event):
    """Text message such as a notification."""
    subclass = None
    superclass = Event
    def __init__(self, originator=None, priority=None, textMessage=None):
        self.original_tagname_ = None
        super(TextMessage, self).__init__()
        self.originator = originator
        self.priority = priority
        self.textMessage = textMessage
    def factory(*args_, **kwargs_):
        if TextMessage.subclass:
            return TextMessage.subclass(*args_, **kwargs_)
        else:
            return TextMessage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_originator(self): return self.originator
    def set_originator(self, originator): self.originator = originator
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def get_textMessage(self): return self.textMessage
    def set_textMessage(self, textMessage): self.textMessage = textMessage
    def validate_String20(self, value):
        # Validate type String20, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.originator is not None or
            self.priority is not None or
            self.textMessage is not None or
            super(TextMessage, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextMessage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextMessage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextMessage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextMessage'):
        super(TextMessage, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TextMessage')
    def exportChildren(self, outfile, level, namespace_='', name_='TextMessage', fromsubclass_=False, pretty_print=True):
        super(TextMessage, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginator>%s</%soriginator>%s' % (namespace_, self.gds_format_string(quote_xml(self.originator).encode(ExternalEncoding), input_name='originator'), namespace_, eol_))
        if self.priority is not None:
            self.priority.export(outfile, level, namespace_, name_='priority', pretty_print=pretty_print)
        if self.textMessage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stextMessage>%s</%stextMessage>%s' % (namespace_, self.gds_format_string(quote_xml(self.textMessage).encode(ExternalEncoding), input_name='textMessage'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TextMessage'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TextMessage, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TextMessage, self).exportLiteralChildren(outfile, level, name_)
        if self.originator is not None:
            showIndent(outfile, level)
            outfile.write('originator=%s,\n' % quote_python(self.originator).encode(ExternalEncoding))
        if self.priority is not None:
            showIndent(outfile, level)
            outfile.write('priority=model_.PriorityType(\n')
            self.priority.exportLiteral(outfile, level, name_='priority')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.textMessage is not None:
            showIndent(outfile, level)
            outfile.write('textMessage=%s,\n' % quote_python(self.textMessage).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextMessage, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'originator':
            originator_ = child_.text
            originator_ = self.gds_validate_string(originator_, node, 'originator')
            self.originator = originator_
            self.validate_String20(self.originator)    # validate type String20
        elif nodeName_ == 'priority':
            obj_ = PriorityType.factory()
            obj_.build(child_)
            self.priority = obj_
            obj_.original_tagname_ = 'priority'
        elif nodeName_ == 'textMessage':
            textMessage_ = child_.text
            textMessage_ = self.gds_validate_string(textMessage_, node, 'textMessage')
            self.textMessage = textMessage_
        super(TextMessage, self).buildChildren(child_, node, nodeName_, True)
# end class TextMessage


class MessagingProgramList(SubscribableList):
    """A List element to hold MessagingProgram objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, MessagingProgram=None):
        self.original_tagname_ = None
        super(MessagingProgramList, self).__init__()
        if MessagingProgram is None:
            self.MessagingProgram = []
        else:
            self.MessagingProgram = MessagingProgram
    def factory(*args_, **kwargs_):
        if MessagingProgramList.subclass:
            return MessagingProgramList.subclass(*args_, **kwargs_)
        else:
            return MessagingProgramList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MessagingProgram(self): return self.MessagingProgram
    def set_MessagingProgram(self, MessagingProgram): self.MessagingProgram = MessagingProgram
    def add_MessagingProgram(self, value): self.MessagingProgram.append(value)
    def insert_MessagingProgram_at(self, index, value): self.MessagingProgram.insert(index, value)
    def replace_MessagingProgram_at(self, index, value): self.MessagingProgram[index] = value
    def hasContent_(self):
        if (
            self.MessagingProgram or
            super(MessagingProgramList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MessagingProgramList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessagingProgramList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MessagingProgramList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MessagingProgramList'):
        super(MessagingProgramList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MessagingProgramList')
    def exportChildren(self, outfile, level, namespace_='', name_='MessagingProgramList', fromsubclass_=False, pretty_print=True):
        super(MessagingProgramList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MessagingProgram_ in self.MessagingProgram:
            MessagingProgram_.export(outfile, level, namespace_, name_='MessagingProgram', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MessagingProgramList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MessagingProgramList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MessagingProgramList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('MessagingProgram=[\n')
        level += 1
        for MessagingProgram_ in self.MessagingProgram:
            showIndent(outfile, level)
            outfile.write('model_.MessagingProgram(\n')
            MessagingProgram_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MessagingProgramList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MessagingProgram':
            obj_ = MessagingProgram.factory()
            obj_.build(child_)
            self.MessagingProgram.append(obj_)
            obj_.original_tagname_ = 'MessagingProgram'
        super(MessagingProgramList, self).buildChildren(child_, node, nodeName_, True)
# end class MessagingProgramList


class MessagingProgram(SubscribableIdentifiedObject):
    """Provides a container for collections of text messages."""
    subclass = None
    superclass = SubscribableIdentifiedObject
    def __init__(self, ActiveTextMessageListLink=None, locale=None, primacy=None, TextMessageListLink=None):
        self.original_tagname_ = None
        super(MessagingProgram, self).__init__()
        self.ActiveTextMessageListLink = ActiveTextMessageListLink
        self.locale = locale
        self.primacy = primacy
        self.TextMessageListLink = TextMessageListLink
    def factory(*args_, **kwargs_):
        if MessagingProgram.subclass:
            return MessagingProgram.subclass(*args_, **kwargs_)
        else:
            return MessagingProgram(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActiveTextMessageListLink(self): return self.ActiveTextMessageListLink
    def set_ActiveTextMessageListLink(self, ActiveTextMessageListLink): self.ActiveTextMessageListLink = ActiveTextMessageListLink
    def get_locale(self): return self.locale
    def set_locale(self, locale): self.locale = locale
    def get_primacy(self): return self.primacy
    def set_primacy(self, primacy): self.primacy = primacy
    def get_TextMessageListLink(self): return self.TextMessageListLink
    def set_TextMessageListLink(self, TextMessageListLink): self.TextMessageListLink = TextMessageListLink
    def hasContent_(self):
        if (
            self.ActiveTextMessageListLink is not None or
            self.locale is not None or
            self.primacy is not None or
            self.TextMessageListLink is not None or
            super(MessagingProgram, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MessagingProgram', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessagingProgram')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MessagingProgram', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MessagingProgram'):
        super(MessagingProgram, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MessagingProgram')
    def exportChildren(self, outfile, level, namespace_='', name_='MessagingProgram', fromsubclass_=False, pretty_print=True):
        super(MessagingProgram, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveTextMessageListLink is not None:
            self.ActiveTextMessageListLink.export(outfile, level, namespace_, name_='ActiveTextMessageListLink', pretty_print=pretty_print)
        if self.locale is not None:
            self.locale.export(outfile, level, namespace_, name_='locale', pretty_print=pretty_print)
        if self.primacy is not None:
            self.primacy.export(outfile, level, namespace_, name_='primacy', pretty_print=pretty_print)
        if self.TextMessageListLink is not None:
            self.TextMessageListLink.export(outfile, level, namespace_, name_='TextMessageListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MessagingProgram'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MessagingProgram, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MessagingProgram, self).exportLiteralChildren(outfile, level, name_)
        if self.ActiveTextMessageListLink is not None:
            showIndent(outfile, level)
            outfile.write('ActiveTextMessageListLink=model_.ActiveTextMessageListLink(\n')
            self.ActiveTextMessageListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.locale is not None:
            showIndent(outfile, level)
            outfile.write('locale=model_.LocaleType(\n')
            self.locale.exportLiteral(outfile, level, name_='locale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.primacy is not None:
            showIndent(outfile, level)
            outfile.write('primacy=model_.PrimacyType(\n')
            self.primacy.exportLiteral(outfile, level, name_='primacy')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TextMessageListLink is not None:
            showIndent(outfile, level)
            outfile.write('TextMessageListLink=model_.TextMessageListLink(\n')
            self.TextMessageListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MessagingProgram, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActiveTextMessageListLink':
            obj_ = ActiveTextMessageListLink.factory()
            obj_.build(child_)
            self.ActiveTextMessageListLink = obj_
            obj_.original_tagname_ = 'ActiveTextMessageListLink'
        elif nodeName_ == 'locale':
            obj_ = LocaleType.factory()
            obj_.build(child_)
            self.locale = obj_
            obj_.original_tagname_ = 'locale'
        elif nodeName_ == 'primacy':
            obj_ = PrimacyType.factory()
            obj_.build(child_)
            self.primacy = obj_
            obj_.original_tagname_ = 'primacy'
        elif nodeName_ == 'TextMessageListLink':
            obj_ = TextMessageListLink.factory()
            obj_.build(child_)
            self.TextMessageListLink = obj_
            obj_.original_tagname_ = 'TextMessageListLink'
        super(MessagingProgram, self).buildChildren(child_, node, nodeName_, True)
# end class MessagingProgram


class TimeTariffIntervalList(SubscribableList):
    """A List element to hold TimeTariffInterval objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, TimeTariffInterval=None):
        self.original_tagname_ = None
        super(TimeTariffIntervalList, self).__init__()
        if TimeTariffInterval is None:
            self.TimeTariffInterval = []
        else:
            self.TimeTariffInterval = TimeTariffInterval
    def factory(*args_, **kwargs_):
        if TimeTariffIntervalList.subclass:
            return TimeTariffIntervalList.subclass(*args_, **kwargs_)
        else:
            return TimeTariffIntervalList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TimeTariffInterval(self): return self.TimeTariffInterval
    def set_TimeTariffInterval(self, TimeTariffInterval): self.TimeTariffInterval = TimeTariffInterval
    def add_TimeTariffInterval(self, value): self.TimeTariffInterval.append(value)
    def insert_TimeTariffInterval_at(self, index, value): self.TimeTariffInterval.insert(index, value)
    def replace_TimeTariffInterval_at(self, index, value): self.TimeTariffInterval[index] = value
    def hasContent_(self):
        if (
            self.TimeTariffInterval or
            super(TimeTariffIntervalList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeTariffIntervalList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTariffIntervalList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeTariffIntervalList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeTariffIntervalList'):
        super(TimeTariffIntervalList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTariffIntervalList')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeTariffIntervalList', fromsubclass_=False, pretty_print=True):
        super(TimeTariffIntervalList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TimeTariffInterval_ in self.TimeTariffInterval:
            TimeTariffInterval_.export(outfile, level, namespace_, name_='TimeTariffInterval', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TimeTariffIntervalList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeTariffIntervalList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeTariffIntervalList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('TimeTariffInterval=[\n')
        level += 1
        for TimeTariffInterval_ in self.TimeTariffInterval:
            showIndent(outfile, level)
            outfile.write('model_.TimeTariffInterval(\n')
            TimeTariffInterval_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeTariffIntervalList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TimeTariffInterval':
            obj_ = TimeTariffInterval.factory()
            obj_.build(child_)
            self.TimeTariffInterval.append(obj_)
            obj_.original_tagname_ = 'TimeTariffInterval'
        super(TimeTariffIntervalList, self).buildChildren(child_, node, nodeName_, True)
# end class TimeTariffIntervalList


class TimeTariffInterval(RandomizableEvent):
    """Describes the time-differentiated portion of the RateComponent, if
    applicable, and provides the ability to specify multiple time
    intervals, each with its own consumption-based components and
    other attributes."""
    subclass = None
    superclass = RandomizableEvent
    def __init__(self, ConsumptionTariffIntervalListLink=None, touTier=None):
        self.original_tagname_ = None
        super(TimeTariffInterval, self).__init__()
        self.ConsumptionTariffIntervalListLink = ConsumptionTariffIntervalListLink
        self.touTier = touTier
    def factory(*args_, **kwargs_):
        if TimeTariffInterval.subclass:
            return TimeTariffInterval.subclass(*args_, **kwargs_)
        else:
            return TimeTariffInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConsumptionTariffIntervalListLink(self): return self.ConsumptionTariffIntervalListLink
    def set_ConsumptionTariffIntervalListLink(self, ConsumptionTariffIntervalListLink): self.ConsumptionTariffIntervalListLink = ConsumptionTariffIntervalListLink
    def get_touTier(self): return self.touTier
    def set_touTier(self, touTier): self.touTier = touTier
    def hasContent_(self):
        if (
            self.ConsumptionTariffIntervalListLink is not None or
            self.touTier is not None or
            super(TimeTariffInterval, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TimeTariffInterval', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTariffInterval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TimeTariffInterval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TimeTariffInterval'):
        super(TimeTariffInterval, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TimeTariffInterval')
    def exportChildren(self, outfile, level, namespace_='', name_='TimeTariffInterval', fromsubclass_=False, pretty_print=True):
        super(TimeTariffInterval, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConsumptionTariffIntervalListLink is not None:
            self.ConsumptionTariffIntervalListLink.export(outfile, level, namespace_, name_='ConsumptionTariffIntervalListLink', pretty_print=pretty_print)
        if self.touTier is not None:
            self.touTier.export(outfile, level, namespace_, name_='touTier', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TimeTariffInterval'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TimeTariffInterval, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TimeTariffInterval, self).exportLiteralChildren(outfile, level, name_)
        if self.ConsumptionTariffIntervalListLink is not None:
            showIndent(outfile, level)
            outfile.write('ConsumptionTariffIntervalListLink=model_.ConsumptionTariffIntervalListLink(\n')
            self.ConsumptionTariffIntervalListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.touTier is not None:
            showIndent(outfile, level)
            outfile.write('touTier=model_.TOUType(\n')
            self.touTier.exportLiteral(outfile, level, name_='touTier')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TimeTariffInterval, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConsumptionTariffIntervalListLink':
            obj_ = ConsumptionTariffIntervalListLink.factory()
            obj_.build(child_)
            self.ConsumptionTariffIntervalListLink = obj_
            obj_.original_tagname_ = 'ConsumptionTariffIntervalListLink'
        elif nodeName_ == 'touTier':
            obj_ = TOUType.factory()
            obj_.build(child_)
            self.touTier = obj_
            obj_.original_tagname_ = 'touTier'
        super(TimeTariffInterval, self).buildChildren(child_, node, nodeName_, True)
# end class TimeTariffInterval


class TariffProfileList(SubscribableList):
    """A List element to hold TariffProfile objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, TariffProfile=None):
        self.original_tagname_ = None
        super(TariffProfileList, self).__init__()
        if TariffProfile is None:
            self.TariffProfile = []
        else:
            self.TariffProfile = TariffProfile
    def factory(*args_, **kwargs_):
        if TariffProfileList.subclass:
            return TariffProfileList.subclass(*args_, **kwargs_)
        else:
            return TariffProfileList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TariffProfile(self): return self.TariffProfile
    def set_TariffProfile(self, TariffProfile): self.TariffProfile = TariffProfile
    def add_TariffProfile(self, value): self.TariffProfile.append(value)
    def insert_TariffProfile_at(self, index, value): self.TariffProfile.insert(index, value)
    def replace_TariffProfile_at(self, index, value): self.TariffProfile[index] = value
    def hasContent_(self):
        if (
            self.TariffProfile or
            super(TariffProfileList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TariffProfileList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TariffProfileList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TariffProfileList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TariffProfileList'):
        super(TariffProfileList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TariffProfileList')
    def exportChildren(self, outfile, level, namespace_='', name_='TariffProfileList', fromsubclass_=False, pretty_print=True):
        super(TariffProfileList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TariffProfile_ in self.TariffProfile:
            TariffProfile_.export(outfile, level, namespace_, name_='TariffProfile', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TariffProfileList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TariffProfileList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TariffProfileList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('TariffProfile=[\n')
        level += 1
        for TariffProfile_ in self.TariffProfile:
            showIndent(outfile, level)
            outfile.write('model_.TariffProfile(\n')
            TariffProfile_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TariffProfileList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TariffProfile':
            obj_ = TariffProfile.factory()
            obj_.build(child_)
            self.TariffProfile.append(obj_)
            obj_.original_tagname_ = 'TariffProfile'
        super(TariffProfileList, self).buildChildren(child_, node, nodeName_, True)
# end class TariffProfileList


class TariffProfile(IdentifiedObject):
    """A schedule of charges; structure that allows the definition of
    tariff structures such as step (block) and time of use (tier)
    when used in conjunction with TimeTariffInterval and
    ConsumptionTariffInterval."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, currency=None, pricePowerOfTenMultiplier=None, primacy=None, rateCode=None, RateComponentListLink=None, serviceCategoryKind=None):
        self.original_tagname_ = None
        super(TariffProfile, self).__init__()
        self.currency = currency
        self.pricePowerOfTenMultiplier = pricePowerOfTenMultiplier
        self.primacy = primacy
        self.rateCode = rateCode
        self.RateComponentListLink = RateComponentListLink
        self.serviceCategoryKind = serviceCategoryKind
    def factory(*args_, **kwargs_):
        if TariffProfile.subclass:
            return TariffProfile.subclass(*args_, **kwargs_)
        else:
            return TariffProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currency(self): return self.currency
    def set_currency(self, currency): self.currency = currency
    def get_pricePowerOfTenMultiplier(self): return self.pricePowerOfTenMultiplier
    def set_pricePowerOfTenMultiplier(self, pricePowerOfTenMultiplier): self.pricePowerOfTenMultiplier = pricePowerOfTenMultiplier
    def get_primacy(self): return self.primacy
    def set_primacy(self, primacy): self.primacy = primacy
    def get_rateCode(self): return self.rateCode
    def set_rateCode(self, rateCode): self.rateCode = rateCode
    def get_RateComponentListLink(self): return self.RateComponentListLink
    def set_RateComponentListLink(self, RateComponentListLink): self.RateComponentListLink = RateComponentListLink
    def get_serviceCategoryKind(self): return self.serviceCategoryKind
    def set_serviceCategoryKind(self, serviceCategoryKind): self.serviceCategoryKind = serviceCategoryKind
    def validate_String20(self, value):
        # Validate type String20, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.currency is not None or
            self.pricePowerOfTenMultiplier is not None or
            self.primacy is not None or
            self.rateCode is not None or
            self.RateComponentListLink is not None or
            self.serviceCategoryKind is not None or
            super(TariffProfile, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TariffProfile', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TariffProfile')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TariffProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TariffProfile'):
        super(TariffProfile, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TariffProfile')
    def exportChildren(self, outfile, level, namespace_='', name_='TariffProfile', fromsubclass_=False, pretty_print=True):
        super(TariffProfile, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            self.currency.export(outfile, level, namespace_, name_='currency', pretty_print=pretty_print)
        if self.pricePowerOfTenMultiplier is not None:
            self.pricePowerOfTenMultiplier.export(outfile, level, namespace_, name_='pricePowerOfTenMultiplier', pretty_print=pretty_print)
        if self.primacy is not None:
            self.primacy.export(outfile, level, namespace_, name_='primacy', pretty_print=pretty_print)
        if self.rateCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateCode>%s</%srateCode>%s' % (namespace_, self.gds_format_string(quote_xml(self.rateCode).encode(ExternalEncoding), input_name='rateCode'), namespace_, eol_))
        if self.RateComponentListLink is not None:
            self.RateComponentListLink.export(outfile, level, namespace_, name_='RateComponentListLink', pretty_print=pretty_print)
        if self.serviceCategoryKind is not None:
            self.serviceCategoryKind.export(outfile, level, namespace_, name_='serviceCategoryKind', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TariffProfile'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TariffProfile, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TariffProfile, self).exportLiteralChildren(outfile, level, name_)
        if self.currency is not None:
            showIndent(outfile, level)
            outfile.write('currency=model_.CurrencyCode(\n')
            self.currency.exportLiteral(outfile, level, name_='currency')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pricePowerOfTenMultiplier is not None:
            showIndent(outfile, level)
            outfile.write('pricePowerOfTenMultiplier=model_.PowerOfTenMultiplierType(\n')
            self.pricePowerOfTenMultiplier.exportLiteral(outfile, level, name_='pricePowerOfTenMultiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.primacy is not None:
            showIndent(outfile, level)
            outfile.write('primacy=model_.PrimacyType(\n')
            self.primacy.exportLiteral(outfile, level, name_='primacy')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.rateCode is not None:
            showIndent(outfile, level)
            outfile.write('rateCode=%s,\n' % quote_python(self.rateCode).encode(ExternalEncoding))
        if self.RateComponentListLink is not None:
            showIndent(outfile, level)
            outfile.write('RateComponentListLink=model_.RateComponentListLink(\n')
            self.RateComponentListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serviceCategoryKind is not None:
            showIndent(outfile, level)
            outfile.write('serviceCategoryKind=model_.ServiceKind(\n')
            self.serviceCategoryKind.exportLiteral(outfile, level, name_='serviceCategoryKind')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TariffProfile, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currency':
            obj_ = CurrencyCode.factory()
            obj_.build(child_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'pricePowerOfTenMultiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.pricePowerOfTenMultiplier = obj_
            obj_.original_tagname_ = 'pricePowerOfTenMultiplier'
        elif nodeName_ == 'primacy':
            obj_ = PrimacyType.factory()
            obj_.build(child_)
            self.primacy = obj_
            obj_.original_tagname_ = 'primacy'
        elif nodeName_ == 'rateCode':
            rateCode_ = child_.text
            rateCode_ = self.gds_validate_string(rateCode_, node, 'rateCode')
            self.rateCode = rateCode_
            self.validate_String20(self.rateCode)    # validate type String20
        elif nodeName_ == 'RateComponentListLink':
            obj_ = RateComponentListLink.factory()
            obj_.build(child_)
            self.RateComponentListLink = obj_
            obj_.original_tagname_ = 'RateComponentListLink'
        elif nodeName_ == 'serviceCategoryKind':
            obj_ = ServiceKind.factory()
            obj_.build(child_)
            self.serviceCategoryKind = obj_
            obj_.original_tagname_ = 'serviceCategoryKind'
        super(TariffProfile, self).buildChildren(child_, node, nodeName_, True)
# end class TariffProfile


class RateComponentList(List):
    """A List element to hold RateComponent objects."""
    subclass = None
    superclass = List
    def __init__(self, RateComponent=None):
        self.original_tagname_ = None
        super(RateComponentList, self).__init__()
        if RateComponent is None:
            self.RateComponent = []
        else:
            self.RateComponent = RateComponent
    def factory(*args_, **kwargs_):
        if RateComponentList.subclass:
            return RateComponentList.subclass(*args_, **kwargs_)
        else:
            return RateComponentList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RateComponent(self): return self.RateComponent
    def set_RateComponent(self, RateComponent): self.RateComponent = RateComponent
    def add_RateComponent(self, value): self.RateComponent.append(value)
    def insert_RateComponent_at(self, index, value): self.RateComponent.insert(index, value)
    def replace_RateComponent_at(self, index, value): self.RateComponent[index] = value
    def hasContent_(self):
        if (
            self.RateComponent or
            super(RateComponentList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateComponentList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateComponentList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateComponentList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateComponentList'):
        super(RateComponentList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RateComponentList')
    def exportChildren(self, outfile, level, namespace_='', name_='RateComponentList', fromsubclass_=False, pretty_print=True):
        super(RateComponentList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RateComponent_ in self.RateComponent:
            RateComponent_.export(outfile, level, namespace_, name_='RateComponent', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RateComponentList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RateComponentList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RateComponentList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('RateComponent=[\n')
        level += 1
        for RateComponent_ in self.RateComponent:
            showIndent(outfile, level)
            outfile.write('model_.RateComponent(\n')
            RateComponent_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RateComponentList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RateComponent':
            obj_ = RateComponent.factory()
            obj_.build(child_)
            self.RateComponent.append(obj_)
            obj_.original_tagname_ = 'RateComponent'
        super(RateComponentList, self).buildChildren(child_, node, nodeName_, True)
# end class RateComponentList


class RateComponent(IdentifiedObject):
    """Specifies the applicable charges for a single component of the rate,
    which could be generation price or consumption price, for
    example."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, ActiveTimeTariffIntervalListLink=None, flowRateEndLimit=None, flowRateStartLimit=None, ReadingTypeLink=None, roleFlags=None, TimeTariffIntervalListLink=None):
        self.original_tagname_ = None
        super(RateComponent, self).__init__()
        self.ActiveTimeTariffIntervalListLink = ActiveTimeTariffIntervalListLink
        self.flowRateEndLimit = flowRateEndLimit
        self.flowRateStartLimit = flowRateStartLimit
        self.ReadingTypeLink = ReadingTypeLink
        self.roleFlags = roleFlags
        self.TimeTariffIntervalListLink = TimeTariffIntervalListLink
    def factory(*args_, **kwargs_):
        if RateComponent.subclass:
            return RateComponent.subclass(*args_, **kwargs_)
        else:
            return RateComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActiveTimeTariffIntervalListLink(self): return self.ActiveTimeTariffIntervalListLink
    def set_ActiveTimeTariffIntervalListLink(self, ActiveTimeTariffIntervalListLink): self.ActiveTimeTariffIntervalListLink = ActiveTimeTariffIntervalListLink
    def get_flowRateEndLimit(self): return self.flowRateEndLimit
    def set_flowRateEndLimit(self, flowRateEndLimit): self.flowRateEndLimit = flowRateEndLimit
    def get_flowRateStartLimit(self): return self.flowRateStartLimit
    def set_flowRateStartLimit(self, flowRateStartLimit): self.flowRateStartLimit = flowRateStartLimit
    def get_ReadingTypeLink(self): return self.ReadingTypeLink
    def set_ReadingTypeLink(self, ReadingTypeLink): self.ReadingTypeLink = ReadingTypeLink
    def get_roleFlags(self): return self.roleFlags
    def set_roleFlags(self, roleFlags): self.roleFlags = roleFlags
    def get_TimeTariffIntervalListLink(self): return self.TimeTariffIntervalListLink
    def set_TimeTariffIntervalListLink(self, TimeTariffIntervalListLink): self.TimeTariffIntervalListLink = TimeTariffIntervalListLink
    def hasContent_(self):
        if (
            self.ActiveTimeTariffIntervalListLink is not None or
            self.flowRateEndLimit is not None or
            self.flowRateStartLimit is not None or
            self.ReadingTypeLink is not None or
            self.roleFlags is not None or
            self.TimeTariffIntervalListLink is not None or
            super(RateComponent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RateComponent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RateComponent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RateComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RateComponent'):
        super(RateComponent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RateComponent')
    def exportChildren(self, outfile, level, namespace_='', name_='RateComponent', fromsubclass_=False, pretty_print=True):
        super(RateComponent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveTimeTariffIntervalListLink is not None:
            self.ActiveTimeTariffIntervalListLink.export(outfile, level, namespace_, name_='ActiveTimeTariffIntervalListLink', pretty_print=pretty_print)
        if self.flowRateEndLimit is not None:
            self.flowRateEndLimit.export(outfile, level, namespace_, name_='flowRateEndLimit', pretty_print=pretty_print)
        if self.flowRateStartLimit is not None:
            self.flowRateStartLimit.export(outfile, level, namespace_, name_='flowRateStartLimit', pretty_print=pretty_print)
        if self.ReadingTypeLink is not None:
            self.ReadingTypeLink.export(outfile, level, namespace_, name_='ReadingTypeLink', pretty_print=pretty_print)
        if self.roleFlags is not None:
            self.roleFlags.export(outfile, level, namespace_, name_='roleFlags', pretty_print=pretty_print)
        if self.TimeTariffIntervalListLink is not None:
            self.TimeTariffIntervalListLink.export(outfile, level, namespace_, name_='TimeTariffIntervalListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RateComponent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RateComponent, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RateComponent, self).exportLiteralChildren(outfile, level, name_)
        if self.ActiveTimeTariffIntervalListLink is not None:
            showIndent(outfile, level)
            outfile.write('ActiveTimeTariffIntervalListLink=model_.ActiveTimeTariffIntervalListLink(\n')
            self.ActiveTimeTariffIntervalListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flowRateEndLimit is not None:
            showIndent(outfile, level)
            outfile.write('flowRateEndLimit=model_.UnitValueType(\n')
            self.flowRateEndLimit.exportLiteral(outfile, level, name_='flowRateEndLimit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flowRateStartLimit is not None:
            showIndent(outfile, level)
            outfile.write('flowRateStartLimit=model_.UnitValueType(\n')
            self.flowRateStartLimit.exportLiteral(outfile, level, name_='flowRateStartLimit')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReadingTypeLink is not None:
            showIndent(outfile, level)
            outfile.write('ReadingTypeLink=model_.ReadingTypeLink(\n')
            self.ReadingTypeLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.roleFlags is not None:
            showIndent(outfile, level)
            outfile.write('roleFlags=model_.RoleFlagsType(\n')
            self.roleFlags.exportLiteral(outfile, level, name_='roleFlags')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TimeTariffIntervalListLink is not None:
            showIndent(outfile, level)
            outfile.write('TimeTariffIntervalListLink=model_.TimeTariffIntervalListLink(\n')
            self.TimeTariffIntervalListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RateComponent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActiveTimeTariffIntervalListLink':
            obj_ = ActiveTimeTariffIntervalListLink.factory()
            obj_.build(child_)
            self.ActiveTimeTariffIntervalListLink = obj_
            obj_.original_tagname_ = 'ActiveTimeTariffIntervalListLink'
        elif nodeName_ == 'flowRateEndLimit':
            obj_ = UnitValueType.factory()
            obj_.build(child_)
            self.flowRateEndLimit = obj_
            obj_.original_tagname_ = 'flowRateEndLimit'
        elif nodeName_ == 'flowRateStartLimit':
            obj_ = UnitValueType.factory()
            obj_.build(child_)
            self.flowRateStartLimit = obj_
            obj_.original_tagname_ = 'flowRateStartLimit'
        elif nodeName_ == 'ReadingTypeLink':
            obj_ = ReadingTypeLink.factory()
            obj_.build(child_)
            self.ReadingTypeLink = obj_
            obj_.original_tagname_ = 'ReadingTypeLink'
        elif nodeName_ == 'roleFlags':
            obj_ = RoleFlagsType.factory()
            obj_.build(child_)
            self.roleFlags = obj_
            obj_.original_tagname_ = 'roleFlags'
        elif nodeName_ == 'TimeTariffIntervalListLink':
            obj_ = TimeTariffIntervalListLink.factory()
            obj_.build(child_)
            self.TimeTariffIntervalListLink = obj_
            obj_.original_tagname_ = 'TimeTariffIntervalListLink'
        super(RateComponent, self).buildChildren(child_, node, nodeName_, True)
# end class RateComponent


class ConsumptionTariffIntervalList(List):
    """A List element to hold ConsumptionTariffInterval objects."""
    subclass = None
    superclass = List
    def __init__(self, ConsumptionTariffInterval=None):
        self.original_tagname_ = None
        super(ConsumptionTariffIntervalList, self).__init__()
        if ConsumptionTariffInterval is None:
            self.ConsumptionTariffInterval = []
        else:
            self.ConsumptionTariffInterval = ConsumptionTariffInterval
    def factory(*args_, **kwargs_):
        if ConsumptionTariffIntervalList.subclass:
            return ConsumptionTariffIntervalList.subclass(*args_, **kwargs_)
        else:
            return ConsumptionTariffIntervalList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConsumptionTariffInterval(self): return self.ConsumptionTariffInterval
    def set_ConsumptionTariffInterval(self, ConsumptionTariffInterval): self.ConsumptionTariffInterval = ConsumptionTariffInterval
    def add_ConsumptionTariffInterval(self, value): self.ConsumptionTariffInterval.append(value)
    def insert_ConsumptionTariffInterval_at(self, index, value): self.ConsumptionTariffInterval.insert(index, value)
    def replace_ConsumptionTariffInterval_at(self, index, value): self.ConsumptionTariffInterval[index] = value
    def hasContent_(self):
        if (
            self.ConsumptionTariffInterval or
            super(ConsumptionTariffIntervalList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConsumptionTariffIntervalList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumptionTariffIntervalList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConsumptionTariffIntervalList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConsumptionTariffIntervalList'):
        super(ConsumptionTariffIntervalList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumptionTariffIntervalList')
    def exportChildren(self, outfile, level, namespace_='', name_='ConsumptionTariffIntervalList', fromsubclass_=False, pretty_print=True):
        super(ConsumptionTariffIntervalList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ConsumptionTariffInterval_ in self.ConsumptionTariffInterval:
            ConsumptionTariffInterval_.export(outfile, level, namespace_, name_='ConsumptionTariffInterval', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConsumptionTariffIntervalList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ConsumptionTariffIntervalList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConsumptionTariffIntervalList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ConsumptionTariffInterval=[\n')
        level += 1
        for ConsumptionTariffInterval_ in self.ConsumptionTariffInterval:
            showIndent(outfile, level)
            outfile.write('model_.ConsumptionTariffInterval(\n')
            ConsumptionTariffInterval_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConsumptionTariffIntervalList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConsumptionTariffInterval':
            obj_ = ConsumptionTariffInterval.factory()
            obj_.build(child_)
            self.ConsumptionTariffInterval.append(obj_)
            obj_.original_tagname_ = 'ConsumptionTariffInterval'
        super(ConsumptionTariffIntervalList, self).buildChildren(child_, node, nodeName_, True)
# end class ConsumptionTariffIntervalList


class ConsumptionTariffInterval(Resource):
    """One of a sequence of thresholds defined in terms of consumption
    quantity of a service such as electricity, water, gas, etc. It
    defines the steps or blocks in a step tariff structure, where
    startValue simultaneously defines the entry value of this step
    and the closing value of the previous step. Where consumption is
    greater than startValue, it falls within this block and where
    consumption is less than or equal to startValue, it falls within
    one of the previous blocks."""
    subclass = None
    superclass = Resource
    def __init__(self, consumptionBlock=None, EnvironmentalCost=None, price=None, startValue=None):
        self.original_tagname_ = None
        super(ConsumptionTariffInterval, self).__init__()
        self.consumptionBlock = consumptionBlock
        if EnvironmentalCost is None:
            self.EnvironmentalCost = []
        else:
            self.EnvironmentalCost = EnvironmentalCost
        self.price = price
        self.startValue = startValue
    def factory(*args_, **kwargs_):
        if ConsumptionTariffInterval.subclass:
            return ConsumptionTariffInterval.subclass(*args_, **kwargs_)
        else:
            return ConsumptionTariffInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_consumptionBlock(self): return self.consumptionBlock
    def set_consumptionBlock(self, consumptionBlock): self.consumptionBlock = consumptionBlock
    def get_EnvironmentalCost(self): return self.EnvironmentalCost
    def set_EnvironmentalCost(self, EnvironmentalCost): self.EnvironmentalCost = EnvironmentalCost
    def add_EnvironmentalCost(self, value): self.EnvironmentalCost.append(value)
    def insert_EnvironmentalCost_at(self, index, value): self.EnvironmentalCost.insert(index, value)
    def replace_EnvironmentalCost_at(self, index, value): self.EnvironmentalCost[index] = value
    def get_price(self): return self.price
    def set_price(self, price): self.price = price
    def get_startValue(self): return self.startValue
    def set_startValue(self, startValue): self.startValue = startValue
    def validate_Int32(self, value):
        # Validate type Int32, a restriction on xs:int.
        pass
    def validate_UInt48(self, value):
        # Validate type UInt48, a restriction on xs:unsignedLong.
        pass
    def hasContent_(self):
        if (
            self.consumptionBlock is not None or
            self.EnvironmentalCost or
            self.price is not None or
            self.startValue is not None or
            super(ConsumptionTariffInterval, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ConsumptionTariffInterval', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumptionTariffInterval')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ConsumptionTariffInterval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ConsumptionTariffInterval'):
        super(ConsumptionTariffInterval, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConsumptionTariffInterval')
    def exportChildren(self, outfile, level, namespace_='', name_='ConsumptionTariffInterval', fromsubclass_=False, pretty_print=True):
        super(ConsumptionTariffInterval, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.consumptionBlock is not None:
            self.consumptionBlock.export(outfile, level, namespace_, name_='consumptionBlock', pretty_print=pretty_print)
        for EnvironmentalCost_ in self.EnvironmentalCost:
            EnvironmentalCost_.export(outfile, level, namespace_, name_='EnvironmentalCost', pretty_print=pretty_print)
        if self.price is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprice>%s</%sprice>%s' % (namespace_, self.gds_format_integer(self.price, input_name='price'), namespace_, eol_))
        if self.startValue is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartValue>%s</%sstartValue>%s' % (namespace_, self.gds_format_integer(self.startValue, input_name='startValue'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ConsumptionTariffInterval'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ConsumptionTariffInterval, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConsumptionTariffInterval, self).exportLiteralChildren(outfile, level, name_)
        if self.consumptionBlock is not None:
            showIndent(outfile, level)
            outfile.write('consumptionBlock=model_.ConsumptionBlockType(\n')
            self.consumptionBlock.exportLiteral(outfile, level, name_='consumptionBlock')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('EnvironmentalCost=[\n')
        level += 1
        for EnvironmentalCost_ in self.EnvironmentalCost:
            showIndent(outfile, level)
            outfile.write('model_.EnvironmentalCost(\n')
            EnvironmentalCost_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.price is not None:
            showIndent(outfile, level)
            outfile.write('price=%d,\n' % self.price)
        if self.startValue is not None:
            showIndent(outfile, level)
            outfile.write('startValue=%d,\n' % self.startValue)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ConsumptionTariffInterval, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'consumptionBlock':
            obj_ = ConsumptionBlockType.factory()
            obj_.build(child_)
            self.consumptionBlock = obj_
            obj_.original_tagname_ = 'consumptionBlock'
        elif nodeName_ == 'EnvironmentalCost':
            obj_ = EnvironmentalCost.factory()
            obj_.build(child_)
            self.EnvironmentalCost.append(obj_)
            obj_.original_tagname_ = 'EnvironmentalCost'
        elif nodeName_ == 'price':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'price')
            self.price = ival_
            self.validate_Int32(self.price)    # validate type Int32
        elif nodeName_ == 'startValue':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'startValue')
            self.startValue = ival_
            self.validate_UInt48(self.startValue)    # validate type UInt48
        super(ConsumptionTariffInterval, self).buildChildren(child_, node, nodeName_, True)
# end class ConsumptionTariffInterval


class UsagePointList(SubscribableList):
    """A List element to hold UsagePoint objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, UsagePoint=None):
        self.original_tagname_ = None
        super(UsagePointList, self).__init__()
        if UsagePoint is None:
            self.UsagePoint = []
        else:
            self.UsagePoint = UsagePoint
    def factory(*args_, **kwargs_):
        if UsagePointList.subclass:
            return UsagePointList.subclass(*args_, **kwargs_)
        else:
            return UsagePointList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_UsagePoint(self): return self.UsagePoint
    def set_UsagePoint(self, UsagePoint): self.UsagePoint = UsagePoint
    def add_UsagePoint(self, value): self.UsagePoint.append(value)
    def insert_UsagePoint_at(self, index, value): self.UsagePoint.insert(index, value)
    def replace_UsagePoint_at(self, index, value): self.UsagePoint[index] = value
    def hasContent_(self):
        if (
            self.UsagePoint or
            super(UsagePointList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UsagePointList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePointList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UsagePointList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UsagePointList'):
        super(UsagePointList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePointList')
    def exportChildren(self, outfile, level, namespace_='', name_='UsagePointList', fromsubclass_=False, pretty_print=True):
        super(UsagePointList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UsagePoint_ in self.UsagePoint:
            UsagePoint_.export(outfile, level, namespace_, name_='UsagePoint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='UsagePointList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UsagePointList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UsagePointList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('UsagePoint=[\n')
        level += 1
        for UsagePoint_ in self.UsagePoint:
            showIndent(outfile, level)
            outfile.write('model_.UsagePoint(\n')
            UsagePoint_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UsagePointList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'UsagePoint':
            obj_ = UsagePoint.factory()
            obj_.build(child_)
            self.UsagePoint.append(obj_)
            obj_.original_tagname_ = 'UsagePoint'
        super(UsagePointList, self).buildChildren(child_, node, nodeName_, True)
# end class UsagePointList


class ReadingType(Resource):
    """Type of data conveyed by a specific Reading. See IEC 61968 Part 9
    Annex C for full definitions of these values."""
    subclass = None
    superclass = Resource
    def __init__(self, accumulationBehaviour=None, calorificValue=None, commodity=None, conversionFactor=None, dataQualifier=None, flowDirection=None, intervalLength=None, kind=None, maxNumberOfIntervals=None, numberOfConsumptionBlocks=None, numberOfTouTiers=None, phase=None, powerOfTenMultiplier=None, subIntervalLength=None, supplyLimit=None, tieredConsumptionBlocks=None, uom=None):
        self.original_tagname_ = None
        super(ReadingType, self).__init__()
        self.accumulationBehaviour = accumulationBehaviour
        self.calorificValue = calorificValue
        self.commodity = commodity
        self.conversionFactor = conversionFactor
        self.dataQualifier = dataQualifier
        self.flowDirection = flowDirection
        self.intervalLength = intervalLength
        self.kind = kind
        self.maxNumberOfIntervals = maxNumberOfIntervals
        self.numberOfConsumptionBlocks = numberOfConsumptionBlocks
        self.numberOfTouTiers = numberOfTouTiers
        self.phase = phase
        self.powerOfTenMultiplier = powerOfTenMultiplier
        self.subIntervalLength = subIntervalLength
        self.supplyLimit = supplyLimit
        self.tieredConsumptionBlocks = tieredConsumptionBlocks
        self.uom = uom
    def factory(*args_, **kwargs_):
        if ReadingType.subclass:
            return ReadingType.subclass(*args_, **kwargs_)
        else:
            return ReadingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_accumulationBehaviour(self): return self.accumulationBehaviour
    def set_accumulationBehaviour(self, accumulationBehaviour): self.accumulationBehaviour = accumulationBehaviour
    def get_calorificValue(self): return self.calorificValue
    def set_calorificValue(self, calorificValue): self.calorificValue = calorificValue
    def get_commodity(self): return self.commodity
    def set_commodity(self, commodity): self.commodity = commodity
    def get_conversionFactor(self): return self.conversionFactor
    def set_conversionFactor(self, conversionFactor): self.conversionFactor = conversionFactor
    def get_dataQualifier(self): return self.dataQualifier
    def set_dataQualifier(self, dataQualifier): self.dataQualifier = dataQualifier
    def get_flowDirection(self): return self.flowDirection
    def set_flowDirection(self, flowDirection): self.flowDirection = flowDirection
    def get_intervalLength(self): return self.intervalLength
    def set_intervalLength(self, intervalLength): self.intervalLength = intervalLength
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def get_maxNumberOfIntervals(self): return self.maxNumberOfIntervals
    def set_maxNumberOfIntervals(self, maxNumberOfIntervals): self.maxNumberOfIntervals = maxNumberOfIntervals
    def get_numberOfConsumptionBlocks(self): return self.numberOfConsumptionBlocks
    def set_numberOfConsumptionBlocks(self, numberOfConsumptionBlocks): self.numberOfConsumptionBlocks = numberOfConsumptionBlocks
    def get_numberOfTouTiers(self): return self.numberOfTouTiers
    def set_numberOfTouTiers(self, numberOfTouTiers): self.numberOfTouTiers = numberOfTouTiers
    def get_phase(self): return self.phase
    def set_phase(self, phase): self.phase = phase
    def get_powerOfTenMultiplier(self): return self.powerOfTenMultiplier
    def set_powerOfTenMultiplier(self, powerOfTenMultiplier): self.powerOfTenMultiplier = powerOfTenMultiplier
    def get_subIntervalLength(self): return self.subIntervalLength
    def set_subIntervalLength(self, subIntervalLength): self.subIntervalLength = subIntervalLength
    def get_supplyLimit(self): return self.supplyLimit
    def set_supplyLimit(self, supplyLimit): self.supplyLimit = supplyLimit
    def get_tieredConsumptionBlocks(self): return self.tieredConsumptionBlocks
    def set_tieredConsumptionBlocks(self, tieredConsumptionBlocks): self.tieredConsumptionBlocks = tieredConsumptionBlocks
    def get_uom(self): return self.uom
    def set_uom(self, uom): self.uom = uom
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_UInt48(self, value):
        # Validate type UInt48, a restriction on xs:unsignedLong.
        pass
    def hasContent_(self):
        if (
            self.accumulationBehaviour is not None or
            self.calorificValue is not None or
            self.commodity is not None or
            self.conversionFactor is not None or
            self.dataQualifier is not None or
            self.flowDirection is not None or
            self.intervalLength is not None or
            self.kind is not None or
            self.maxNumberOfIntervals is not None or
            self.numberOfConsumptionBlocks is not None or
            self.numberOfTouTiers is not None or
            self.phase is not None or
            self.powerOfTenMultiplier is not None or
            self.subIntervalLength is not None or
            self.supplyLimit is not None or
            self.tieredConsumptionBlocks is not None or
            self.uom is not None or
            super(ReadingType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingType'):
        super(ReadingType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingType')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingType', fromsubclass_=False, pretty_print=True):
        super(ReadingType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accumulationBehaviour is not None:
            self.accumulationBehaviour.export(outfile, level, namespace_, name_='accumulationBehaviour', pretty_print=pretty_print)
        if self.calorificValue is not None:
            self.calorificValue.export(outfile, level, namespace_, name_='calorificValue', pretty_print=pretty_print)
        if self.commodity is not None:
            self.commodity.export(outfile, level, namespace_, name_='commodity', pretty_print=pretty_print)
        if self.conversionFactor is not None:
            self.conversionFactor.export(outfile, level, namespace_, name_='conversionFactor', pretty_print=pretty_print)
        if self.dataQualifier is not None:
            self.dataQualifier.export(outfile, level, namespace_, name_='dataQualifier', pretty_print=pretty_print)
        if self.flowDirection is not None:
            self.flowDirection.export(outfile, level, namespace_, name_='flowDirection', pretty_print=pretty_print)
        if self.intervalLength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintervalLength>%s</%sintervalLength>%s' % (namespace_, self.gds_format_integer(self.intervalLength, input_name='intervalLength'), namespace_, eol_))
        if self.kind is not None:
            self.kind.export(outfile, level, namespace_, name_='kind', pretty_print=pretty_print)
        if self.maxNumberOfIntervals is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxNumberOfIntervals>%s</%smaxNumberOfIntervals>%s' % (namespace_, self.gds_format_integer(self.maxNumberOfIntervals, input_name='maxNumberOfIntervals'), namespace_, eol_))
        if self.numberOfConsumptionBlocks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfConsumptionBlocks>%s</%snumberOfConsumptionBlocks>%s' % (namespace_, self.gds_format_integer(self.numberOfConsumptionBlocks, input_name='numberOfConsumptionBlocks'), namespace_, eol_))
        if self.numberOfTouTiers is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfTouTiers>%s</%snumberOfTouTiers>%s' % (namespace_, self.gds_format_integer(self.numberOfTouTiers, input_name='numberOfTouTiers'), namespace_, eol_))
        if self.phase is not None:
            self.phase.export(outfile, level, namespace_, name_='phase', pretty_print=pretty_print)
        if self.powerOfTenMultiplier is not None:
            self.powerOfTenMultiplier.export(outfile, level, namespace_, name_='powerOfTenMultiplier', pretty_print=pretty_print)
        if self.subIntervalLength is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubIntervalLength>%s</%ssubIntervalLength>%s' % (namespace_, self.gds_format_integer(self.subIntervalLength, input_name='subIntervalLength'), namespace_, eol_))
        if self.supplyLimit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplyLimit>%s</%ssupplyLimit>%s' % (namespace_, self.gds_format_integer(self.supplyLimit, input_name='supplyLimit'), namespace_, eol_))
        if self.tieredConsumptionBlocks is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stieredConsumptionBlocks>%s</%stieredConsumptionBlocks>%s' % (namespace_, self.gds_format_boolean(self.tieredConsumptionBlocks, input_name='tieredConsumptionBlocks'), namespace_, eol_))
        if self.uom is not None:
            self.uom.export(outfile, level, namespace_, name_='uom', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReadingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingType, self).exportLiteralChildren(outfile, level, name_)
        if self.accumulationBehaviour is not None:
            showIndent(outfile, level)
            outfile.write('accumulationBehaviour=model_.AccumulationBehaviourType(\n')
            self.accumulationBehaviour.exportLiteral(outfile, level, name_='accumulationBehaviour')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.calorificValue is not None:
            showIndent(outfile, level)
            outfile.write('calorificValue=model_.UnitValueType(\n')
            self.calorificValue.exportLiteral(outfile, level, name_='calorificValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.commodity is not None:
            showIndent(outfile, level)
            outfile.write('commodity=model_.CommodityType(\n')
            self.commodity.exportLiteral(outfile, level, name_='commodity')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.conversionFactor is not None:
            showIndent(outfile, level)
            outfile.write('conversionFactor=model_.UnitValueType(\n')
            self.conversionFactor.exportLiteral(outfile, level, name_='conversionFactor')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dataQualifier is not None:
            showIndent(outfile, level)
            outfile.write('dataQualifier=model_.DataQualifierType(\n')
            self.dataQualifier.exportLiteral(outfile, level, name_='dataQualifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.flowDirection is not None:
            showIndent(outfile, level)
            outfile.write('flowDirection=model_.FlowDirectionType(\n')
            self.flowDirection.exportLiteral(outfile, level, name_='flowDirection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.intervalLength is not None:
            showIndent(outfile, level)
            outfile.write('intervalLength=%d,\n' % self.intervalLength)
        if self.kind is not None:
            showIndent(outfile, level)
            outfile.write('kind=model_.KindType(\n')
            self.kind.exportLiteral(outfile, level, name_='kind')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.maxNumberOfIntervals is not None:
            showIndent(outfile, level)
            outfile.write('maxNumberOfIntervals=%d,\n' % self.maxNumberOfIntervals)
        if self.numberOfConsumptionBlocks is not None:
            showIndent(outfile, level)
            outfile.write('numberOfConsumptionBlocks=%d,\n' % self.numberOfConsumptionBlocks)
        if self.numberOfTouTiers is not None:
            showIndent(outfile, level)
            outfile.write('numberOfTouTiers=%d,\n' % self.numberOfTouTiers)
        if self.phase is not None:
            showIndent(outfile, level)
            outfile.write('phase=model_.PhaseCode(\n')
            self.phase.exportLiteral(outfile, level, name_='phase')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.powerOfTenMultiplier is not None:
            showIndent(outfile, level)
            outfile.write('powerOfTenMultiplier=model_.PowerOfTenMultiplierType(\n')
            self.powerOfTenMultiplier.exportLiteral(outfile, level, name_='powerOfTenMultiplier')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.subIntervalLength is not None:
            showIndent(outfile, level)
            outfile.write('subIntervalLength=%d,\n' % self.subIntervalLength)
        if self.supplyLimit is not None:
            showIndent(outfile, level)
            outfile.write('supplyLimit=%d,\n' % self.supplyLimit)
        if self.tieredConsumptionBlocks is not None:
            showIndent(outfile, level)
            outfile.write('tieredConsumptionBlocks=%s,\n' % self.tieredConsumptionBlocks)
        if self.uom is not None:
            showIndent(outfile, level)
            outfile.write('uom=model_.UomType(\n')
            self.uom.exportLiteral(outfile, level, name_='uom')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'accumulationBehaviour':
            obj_ = AccumulationBehaviourType.factory()
            obj_.build(child_)
            self.accumulationBehaviour = obj_
            obj_.original_tagname_ = 'accumulationBehaviour'
        elif nodeName_ == 'calorificValue':
            obj_ = UnitValueType.factory()
            obj_.build(child_)
            self.calorificValue = obj_
            obj_.original_tagname_ = 'calorificValue'
        elif nodeName_ == 'commodity':
            obj_ = CommodityType.factory()
            obj_.build(child_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'conversionFactor':
            obj_ = UnitValueType.factory()
            obj_.build(child_)
            self.conversionFactor = obj_
            obj_.original_tagname_ = 'conversionFactor'
        elif nodeName_ == 'dataQualifier':
            obj_ = DataQualifierType.factory()
            obj_.build(child_)
            self.dataQualifier = obj_
            obj_.original_tagname_ = 'dataQualifier'
        elif nodeName_ == 'flowDirection':
            obj_ = FlowDirectionType.factory()
            obj_.build(child_)
            self.flowDirection = obj_
            obj_.original_tagname_ = 'flowDirection'
        elif nodeName_ == 'intervalLength':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'intervalLength')
            self.intervalLength = ival_
            self.validate_UInt32(self.intervalLength)    # validate type UInt32
        elif nodeName_ == 'kind':
            obj_ = KindType.factory()
            obj_.build(child_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'maxNumberOfIntervals':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maxNumberOfIntervals')
            self.maxNumberOfIntervals = ival_
            self.validate_UInt8(self.maxNumberOfIntervals)    # validate type UInt8
        elif nodeName_ == 'numberOfConsumptionBlocks':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfConsumptionBlocks')
            self.numberOfConsumptionBlocks = ival_
            self.validate_UInt8(self.numberOfConsumptionBlocks)    # validate type UInt8
        elif nodeName_ == 'numberOfTouTiers':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfTouTiers')
            self.numberOfTouTiers = ival_
            self.validate_UInt8(self.numberOfTouTiers)    # validate type UInt8
        elif nodeName_ == 'phase':
            obj_ = PhaseCode.factory()
            obj_.build(child_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
        elif nodeName_ == 'powerOfTenMultiplier':
            obj_ = PowerOfTenMultiplierType.factory()
            obj_.build(child_)
            self.powerOfTenMultiplier = obj_
            obj_.original_tagname_ = 'powerOfTenMultiplier'
        elif nodeName_ == 'subIntervalLength':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'subIntervalLength')
            self.subIntervalLength = ival_
            self.validate_UInt32(self.subIntervalLength)    # validate type UInt32
        elif nodeName_ == 'supplyLimit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'supplyLimit')
            self.supplyLimit = ival_
            self.validate_UInt48(self.supplyLimit)    # validate type UInt48
        elif nodeName_ == 'tieredConsumptionBlocks':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'tieredConsumptionBlocks')
            self.tieredConsumptionBlocks = ival_
        elif nodeName_ == 'uom':
            obj_ = UomType.factory()
            obj_.build(child_)
            self.uom = obj_
            obj_.original_tagname_ = 'uom'
        super(ReadingType, self).buildChildren(child_, node, nodeName_, True)
# end class ReadingType


class ReadingSetList(SubscribableList):
    """A List element to hold ReadingSet objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, ReadingSet=None):
        self.original_tagname_ = None
        super(ReadingSetList, self).__init__()
        if ReadingSet is None:
            self.ReadingSet = []
        else:
            self.ReadingSet = ReadingSet
    def factory(*args_, **kwargs_):
        if ReadingSetList.subclass:
            return ReadingSetList.subclass(*args_, **kwargs_)
        else:
            return ReadingSetList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReadingSet(self): return self.ReadingSet
    def set_ReadingSet(self, ReadingSet): self.ReadingSet = ReadingSet
    def add_ReadingSet(self, value): self.ReadingSet.append(value)
    def insert_ReadingSet_at(self, index, value): self.ReadingSet.insert(index, value)
    def replace_ReadingSet_at(self, index, value): self.ReadingSet[index] = value
    def hasContent_(self):
        if (
            self.ReadingSet or
            super(ReadingSetList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingSetList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingSetList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingSetList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingSetList'):
        super(ReadingSetList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingSetList')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingSetList', fromsubclass_=False, pretty_print=True):
        super(ReadingSetList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ReadingSet_ in self.ReadingSet:
            ReadingSet_.export(outfile, level, namespace_, name_='ReadingSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReadingSetList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingSetList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingSetList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ReadingSet=[\n')
        level += 1
        for ReadingSet_ in self.ReadingSet:
            showIndent(outfile, level)
            outfile.write('model_.ReadingSet(\n')
            ReadingSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingSetList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReadingSet':
            obj_ = ReadingSet.factory()
            obj_.build(child_)
            self.ReadingSet.append(obj_)
            obj_.original_tagname_ = 'ReadingSet'
        super(ReadingSetList, self).buildChildren(child_, node, nodeName_, True)
# end class ReadingSetList


class ReadingList(SubscribableList):
    """A List element to hold Reading objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, Reading=None):
        self.original_tagname_ = None
        super(ReadingList, self).__init__()
        if Reading is None:
            self.Reading = []
        else:
            self.Reading = Reading
    def factory(*args_, **kwargs_):
        if ReadingList.subclass:
            return ReadingList.subclass(*args_, **kwargs_)
        else:
            return ReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reading(self): return self.Reading
    def set_Reading(self, Reading): self.Reading = Reading
    def add_Reading(self, value): self.Reading.append(value)
    def insert_Reading_at(self, index, value): self.Reading.insert(index, value)
    def replace_Reading_at(self, index, value): self.Reading[index] = value
    def hasContent_(self):
        if (
            self.Reading or
            super(ReadingList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingList'):
        super(ReadingList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingList')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingList', fromsubclass_=False, pretty_print=True):
        super(ReadingList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reading_ in self.Reading:
            Reading_.export(outfile, level, namespace_, name_='Reading', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReadingList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Reading=[\n')
        level += 1
        for Reading_ in self.Reading:
            showIndent(outfile, level)
            outfile.write('model_.Reading(\n')
            Reading_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reading':
            obj_ = Reading.factory()
            obj_.build(child_)
            self.Reading.append(obj_)
            obj_.original_tagname_ = 'Reading'
        super(ReadingList, self).buildChildren(child_, node, nodeName_, True)
# end class ReadingList


class Reading(ReadingBase):
    """Specific value measured by a meter or other asset.Indicates whether
    or not subscriptions are supported for this resource, and
    whether or not conditional (thresholds) are supported. If not
    specified, is "not subscribable" (0)."""
    subclass = None
    superclass = ReadingBase
    def __init__(self, subscribable='0', localID=None):
        self.original_tagname_ = None
        super(Reading, self).__init__()
        self.subscribable = _cast(None, subscribable)
        self.localID = localID
    def factory(*args_, **kwargs_):
        if Reading.subclass:
            return Reading.subclass(*args_, **kwargs_)
        else:
            return Reading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_localID(self): return self.localID
    def set_localID(self, localID): self.localID = localID
    def get_subscribable(self): return self.subscribable
    def set_subscribable(self, subscribable): self.subscribable = subscribable
    def validate_HexBinary16(self, value):
        # Validate type HexBinary16, a restriction on xs:hexBinary.
        pass
    def validate_SubscribableType(self, value):
        # Validate type SubscribableType, a restriction on UInt8.
        pass
    def hasContent_(self):
        if (
            self.localID is not None or
            super(Reading, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Reading', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Reading')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Reading', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Reading'):
        super(Reading, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Reading')
        if self.subscribable is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            outfile.write(' subscribable=%s' % (quote_attrib(self.subscribable), ))
    def exportChildren(self, outfile, level, namespace_='', name_='Reading', fromsubclass_=False, pretty_print=True):
        super(Reading, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.localID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocalID>%s</%slocalID>%s' % (namespace_, self.gds_format_string(quote_xml(self.localID).encode(ExternalEncoding), input_name='localID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Reading'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.subscribable is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            showIndent(outfile, level)
            outfile.write('subscribable=%d,\n' % (self.subscribable,))
        super(Reading, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Reading, self).exportLiteralChildren(outfile, level, name_)
        if self.localID is not None:
            showIndent(outfile, level)
            outfile.write('localID=%s,\n' % quote_python(self.localID).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subscribable', node)
        if value is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            self.subscribable = value
            self.validate_SubscribableType(self.subscribable)    # validate type SubscribableType
        super(Reading, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'localID':
            localID_ = child_.text
            localID_ = self.gds_validate_string(localID_, node, 'localID')
            self.localID = localID_
            self.validate_HexBinary16(self.localID)    # validate type HexBinary16
        super(Reading, self).buildChildren(child_, node, nodeName_, True)
# end class Reading


class MeterReadingList(SubscribableList):
    """A List element to hold MeterReading objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, MeterReading=None):
        self.original_tagname_ = None
        super(MeterReadingList, self).__init__()
        if MeterReading is None:
            self.MeterReading = []
        else:
            self.MeterReading = MeterReading
    def factory(*args_, **kwargs_):
        if MeterReadingList.subclass:
            return MeterReadingList.subclass(*args_, **kwargs_)
        else:
            return MeterReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MeterReading(self): return self.MeterReading
    def set_MeterReading(self, MeterReading): self.MeterReading = MeterReading
    def add_MeterReading(self, value): self.MeterReading.append(value)
    def insert_MeterReading_at(self, index, value): self.MeterReading.insert(index, value)
    def replace_MeterReading_at(self, index, value): self.MeterReading[index] = value
    def hasContent_(self):
        if (
            self.MeterReading or
            super(MeterReadingList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeterReadingList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReadingList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeterReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeterReadingList'):
        super(MeterReadingList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReadingList')
    def exportChildren(self, outfile, level, namespace_='', name_='MeterReadingList', fromsubclass_=False, pretty_print=True):
        super(MeterReadingList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeterReading_ in self.MeterReading:
            MeterReading_.export(outfile, level, namespace_, name_='MeterReading', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MeterReadingList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MeterReadingList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MeterReadingList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('MeterReading=[\n')
        level += 1
        for MeterReading_ in self.MeterReading:
            showIndent(outfile, level)
            outfile.write('model_.MeterReading(\n')
            MeterReading_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MeterReadingList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeterReading':
            obj_ = MeterReading.factory()
            obj_.build(child_)
            self.MeterReading.append(obj_)
            obj_.original_tagname_ = 'MeterReading'
        super(MeterReadingList, self).buildChildren(child_, node, nodeName_, True)
# end class MeterReadingList


class LoadShedAvailability(Resource):
    """Indicates current consumption status and ability to shed load."""
    subclass = None
    superclass = Resource
    def __init__(self, availabilityDuration=None, DemandResponseProgramLink=None, sheddablePercent=None, sheddablePower=None):
        self.original_tagname_ = None
        super(LoadShedAvailability, self).__init__()
        self.availabilityDuration = availabilityDuration
        self.DemandResponseProgramLink = DemandResponseProgramLink
        self.sheddablePercent = sheddablePercent
        self.sheddablePower = sheddablePower
    def factory(*args_, **kwargs_):
        if LoadShedAvailability.subclass:
            return LoadShedAvailability.subclass(*args_, **kwargs_)
        else:
            return LoadShedAvailability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_availabilityDuration(self): return self.availabilityDuration
    def set_availabilityDuration(self, availabilityDuration): self.availabilityDuration = availabilityDuration
    def get_DemandResponseProgramLink(self): return self.DemandResponseProgramLink
    def set_DemandResponseProgramLink(self, DemandResponseProgramLink): self.DemandResponseProgramLink = DemandResponseProgramLink
    def get_sheddablePercent(self): return self.sheddablePercent
    def set_sheddablePercent(self, sheddablePercent): self.sheddablePercent = sheddablePercent
    def get_sheddablePower(self): return self.sheddablePower
    def set_sheddablePower(self, sheddablePower): self.sheddablePower = sheddablePower
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def hasContent_(self):
        if (
            self.availabilityDuration is not None or
            self.DemandResponseProgramLink is not None or
            self.sheddablePercent is not None or
            self.sheddablePower is not None or
            super(LoadShedAvailability, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LoadShedAvailability', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LoadShedAvailability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LoadShedAvailability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LoadShedAvailability'):
        super(LoadShedAvailability, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LoadShedAvailability')
    def exportChildren(self, outfile, level, namespace_='', name_='LoadShedAvailability', fromsubclass_=False, pretty_print=True):
        super(LoadShedAvailability, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.availabilityDuration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailabilityDuration>%s</%savailabilityDuration>%s' % (namespace_, self.gds_format_integer(self.availabilityDuration, input_name='availabilityDuration'), namespace_, eol_))
        if self.DemandResponseProgramLink is not None:
            self.DemandResponseProgramLink.export(outfile, level, namespace_, name_='DemandResponseProgramLink', pretty_print=pretty_print)
        if self.sheddablePercent is not None:
            self.sheddablePercent.export(outfile, level, namespace_, name_='sheddablePercent', pretty_print=pretty_print)
        if self.sheddablePower is not None:
            self.sheddablePower.export(outfile, level, namespace_, name_='sheddablePower', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LoadShedAvailability'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LoadShedAvailability, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LoadShedAvailability, self).exportLiteralChildren(outfile, level, name_)
        if self.availabilityDuration is not None:
            showIndent(outfile, level)
            outfile.write('availabilityDuration=%d,\n' % self.availabilityDuration)
        if self.DemandResponseProgramLink is not None:
            showIndent(outfile, level)
            outfile.write('DemandResponseProgramLink=model_.DemandResponseProgramLink(\n')
            self.DemandResponseProgramLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sheddablePercent is not None:
            showIndent(outfile, level)
            outfile.write('sheddablePercent=model_.PerCent(\n')
            self.sheddablePercent.exportLiteral(outfile, level, name_='sheddablePercent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sheddablePower is not None:
            showIndent(outfile, level)
            outfile.write('sheddablePower=model_.ActivePower(\n')
            self.sheddablePower.exportLiteral(outfile, level, name_='sheddablePower')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LoadShedAvailability, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'availabilityDuration':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'availabilityDuration')
            self.availabilityDuration = ival_
            self.validate_UInt32(self.availabilityDuration)    # validate type UInt32
        elif nodeName_ == 'DemandResponseProgramLink':
            obj_ = DemandResponseProgramLink.factory()
            obj_.build(child_)
            self.DemandResponseProgramLink = obj_
            obj_.original_tagname_ = 'DemandResponseProgramLink'
        elif nodeName_ == 'sheddablePercent':
            obj_ = PerCent.factory()
            obj_.build(child_)
            self.sheddablePercent = obj_
            obj_.original_tagname_ = 'sheddablePercent'
        elif nodeName_ == 'sheddablePower':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.sheddablePower = obj_
            obj_.original_tagname_ = 'sheddablePower'
        super(LoadShedAvailability, self).buildChildren(child_, node, nodeName_, True)
# end class LoadShedAvailability


class EndDeviceControlList(SubscribableList):
    """A List element to hold EndDeviceControl objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, EndDeviceControl=None):
        self.original_tagname_ = None
        super(EndDeviceControlList, self).__init__()
        if EndDeviceControl is None:
            self.EndDeviceControl = []
        else:
            self.EndDeviceControl = EndDeviceControl
    def factory(*args_, **kwargs_):
        if EndDeviceControlList.subclass:
            return EndDeviceControlList.subclass(*args_, **kwargs_)
        else:
            return EndDeviceControlList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EndDeviceControl(self): return self.EndDeviceControl
    def set_EndDeviceControl(self, EndDeviceControl): self.EndDeviceControl = EndDeviceControl
    def add_EndDeviceControl(self, value): self.EndDeviceControl.append(value)
    def insert_EndDeviceControl_at(self, index, value): self.EndDeviceControl.insert(index, value)
    def replace_EndDeviceControl_at(self, index, value): self.EndDeviceControl[index] = value
    def hasContent_(self):
        if (
            self.EndDeviceControl or
            super(EndDeviceControlList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EndDeviceControlList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceControlList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EndDeviceControlList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndDeviceControlList'):
        super(EndDeviceControlList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceControlList')
    def exportChildren(self, outfile, level, namespace_='', name_='EndDeviceControlList', fromsubclass_=False, pretty_print=True):
        super(EndDeviceControlList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EndDeviceControl_ in self.EndDeviceControl:
            EndDeviceControl_.export(outfile, level, namespace_, name_='EndDeviceControl', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EndDeviceControlList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EndDeviceControlList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EndDeviceControlList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('EndDeviceControl=[\n')
        level += 1
        for EndDeviceControl_ in self.EndDeviceControl:
            showIndent(outfile, level)
            outfile.write('model_.EndDeviceControl(\n')
            EndDeviceControl_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceControlList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EndDeviceControl':
            obj_ = EndDeviceControl.factory()
            obj_.build(child_)
            self.EndDeviceControl.append(obj_)
            obj_.original_tagname_ = 'EndDeviceControl'
        super(EndDeviceControlList, self).buildChildren(child_, node, nodeName_, True)
# end class EndDeviceControlList


class EndDeviceControl(RandomizableEvent):
    """Instructs an EndDevice to perform a specified action."""
    subclass = None
    superclass = RandomizableEvent
    def __init__(self, ApplianceLoadReduction=None, deviceCategory=None, drProgramMandatory=None, DutyCycle=None, loadShiftForward=None, Offset=None, overrideDuration=None, SetPoint=None, TargetReduction=None):
        self.original_tagname_ = None
        super(EndDeviceControl, self).__init__()
        self.ApplianceLoadReduction = ApplianceLoadReduction
        self.deviceCategory = deviceCategory
        self.drProgramMandatory = drProgramMandatory
        self.DutyCycle = DutyCycle
        self.loadShiftForward = loadShiftForward
        self.Offset = Offset
        self.overrideDuration = overrideDuration
        self.SetPoint = SetPoint
        self.TargetReduction = TargetReduction
    def factory(*args_, **kwargs_):
        if EndDeviceControl.subclass:
            return EndDeviceControl.subclass(*args_, **kwargs_)
        else:
            return EndDeviceControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ApplianceLoadReduction(self): return self.ApplianceLoadReduction
    def set_ApplianceLoadReduction(self, ApplianceLoadReduction): self.ApplianceLoadReduction = ApplianceLoadReduction
    def get_deviceCategory(self): return self.deviceCategory
    def set_deviceCategory(self, deviceCategory): self.deviceCategory = deviceCategory
    def get_drProgramMandatory(self): return self.drProgramMandatory
    def set_drProgramMandatory(self, drProgramMandatory): self.drProgramMandatory = drProgramMandatory
    def get_DutyCycle(self): return self.DutyCycle
    def set_DutyCycle(self, DutyCycle): self.DutyCycle = DutyCycle
    def get_loadShiftForward(self): return self.loadShiftForward
    def set_loadShiftForward(self, loadShiftForward): self.loadShiftForward = loadShiftForward
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def get_overrideDuration(self): return self.overrideDuration
    def set_overrideDuration(self, overrideDuration): self.overrideDuration = overrideDuration
    def get_SetPoint(self): return self.SetPoint
    def set_SetPoint(self, SetPoint): self.SetPoint = SetPoint
    def get_TargetReduction(self): return self.TargetReduction
    def set_TargetReduction(self, TargetReduction): self.TargetReduction = TargetReduction
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.ApplianceLoadReduction is not None or
            self.deviceCategory is not None or
            self.drProgramMandatory is not None or
            self.DutyCycle is not None or
            self.loadShiftForward is not None or
            self.Offset is not None or
            self.overrideDuration is not None or
            self.SetPoint is not None or
            self.TargetReduction is not None or
            super(EndDeviceControl, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EndDeviceControl', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceControl')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EndDeviceControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndDeviceControl'):
        super(EndDeviceControl, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceControl')
    def exportChildren(self, outfile, level, namespace_='', name_='EndDeviceControl', fromsubclass_=False, pretty_print=True):
        super(EndDeviceControl, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ApplianceLoadReduction is not None:
            self.ApplianceLoadReduction.export(outfile, level, namespace_, name_='ApplianceLoadReduction', pretty_print=pretty_print)
        if self.deviceCategory is not None:
            self.deviceCategory.export(outfile, level, namespace_, name_='deviceCategory', pretty_print=pretty_print)
        if self.drProgramMandatory is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdrProgramMandatory>%s</%sdrProgramMandatory>%s' % (namespace_, self.gds_format_boolean(self.drProgramMandatory, input_name='drProgramMandatory'), namespace_, eol_))
        if self.DutyCycle is not None:
            self.DutyCycle.export(outfile, level, namespace_, name_='DutyCycle', pretty_print=pretty_print)
        if self.loadShiftForward is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadShiftForward>%s</%sloadShiftForward>%s' % (namespace_, self.gds_format_boolean(self.loadShiftForward, input_name='loadShiftForward'), namespace_, eol_))
        if self.Offset is not None:
            self.Offset.export(outfile, level, namespace_, name_='Offset', pretty_print=pretty_print)
        if self.overrideDuration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverrideDuration>%s</%soverrideDuration>%s' % (namespace_, self.gds_format_integer(self.overrideDuration, input_name='overrideDuration'), namespace_, eol_))
        if self.SetPoint is not None:
            self.SetPoint.export(outfile, level, namespace_, name_='SetPoint', pretty_print=pretty_print)
        if self.TargetReduction is not None:
            self.TargetReduction.export(outfile, level, namespace_, name_='TargetReduction', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EndDeviceControl'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EndDeviceControl, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EndDeviceControl, self).exportLiteralChildren(outfile, level, name_)
        if self.ApplianceLoadReduction is not None:
            showIndent(outfile, level)
            outfile.write('ApplianceLoadReduction=model_.ApplianceLoadReduction(\n')
            self.ApplianceLoadReduction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.deviceCategory is not None:
            showIndent(outfile, level)
            outfile.write('deviceCategory=model_.DeviceCategoryType(\n')
            self.deviceCategory.exportLiteral(outfile, level, name_='deviceCategory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.drProgramMandatory is not None:
            showIndent(outfile, level)
            outfile.write('drProgramMandatory=%s,\n' % self.drProgramMandatory)
        if self.DutyCycle is not None:
            showIndent(outfile, level)
            outfile.write('DutyCycle=model_.DutyCycle(\n')
            self.DutyCycle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.loadShiftForward is not None:
            showIndent(outfile, level)
            outfile.write('loadShiftForward=%s,\n' % self.loadShiftForward)
        if self.Offset is not None:
            showIndent(outfile, level)
            outfile.write('Offset=model_.Offset(\n')
            self.Offset.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.overrideDuration is not None:
            showIndent(outfile, level)
            outfile.write('overrideDuration=%d,\n' % self.overrideDuration)
        if self.SetPoint is not None:
            showIndent(outfile, level)
            outfile.write('SetPoint=model_.SetPoint(\n')
            self.SetPoint.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetReduction is not None:
            showIndent(outfile, level)
            outfile.write('TargetReduction=model_.TargetReduction(\n')
            self.TargetReduction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceControl, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ApplianceLoadReduction':
            obj_ = ApplianceLoadReduction.factory()
            obj_.build(child_)
            self.ApplianceLoadReduction = obj_
            obj_.original_tagname_ = 'ApplianceLoadReduction'
        elif nodeName_ == 'deviceCategory':
            obj_ = DeviceCategoryType.factory()
            obj_.build(child_)
            self.deviceCategory = obj_
            obj_.original_tagname_ = 'deviceCategory'
        elif nodeName_ == 'drProgramMandatory':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'drProgramMandatory')
            self.drProgramMandatory = ival_
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory()
            obj_.build(child_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'loadShiftForward':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'loadShiftForward')
            self.loadShiftForward = ival_
        elif nodeName_ == 'Offset':
            obj_ = Offset.factory()
            obj_.build(child_)
            self.Offset = obj_
            obj_.original_tagname_ = 'Offset'
        elif nodeName_ == 'overrideDuration':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'overrideDuration')
            self.overrideDuration = ival_
            self.validate_UInt16(self.overrideDuration)    # validate type UInt16
        elif nodeName_ == 'SetPoint':
            obj_ = SetPoint.factory()
            obj_.build(child_)
            self.SetPoint = obj_
            obj_.original_tagname_ = 'SetPoint'
        elif nodeName_ == 'TargetReduction':
            obj_ = TargetReduction.factory()
            obj_.build(child_)
            self.TargetReduction = obj_
            obj_.original_tagname_ = 'TargetReduction'
        super(EndDeviceControl, self).buildChildren(child_, node, nodeName_, True)
# end class EndDeviceControl


class DemandResponseProgramList(SubscribableList):
    """A List element to hold DemandResponseProgram objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, DemandResponseProgram=None):
        self.original_tagname_ = None
        super(DemandResponseProgramList, self).__init__()
        if DemandResponseProgram is None:
            self.DemandResponseProgram = []
        else:
            self.DemandResponseProgram = DemandResponseProgram
    def factory(*args_, **kwargs_):
        if DemandResponseProgramList.subclass:
            return DemandResponseProgramList.subclass(*args_, **kwargs_)
        else:
            return DemandResponseProgramList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DemandResponseProgram(self): return self.DemandResponseProgram
    def set_DemandResponseProgram(self, DemandResponseProgram): self.DemandResponseProgram = DemandResponseProgram
    def add_DemandResponseProgram(self, value): self.DemandResponseProgram.append(value)
    def insert_DemandResponseProgram_at(self, index, value): self.DemandResponseProgram.insert(index, value)
    def replace_DemandResponseProgram_at(self, index, value): self.DemandResponseProgram[index] = value
    def hasContent_(self):
        if (
            self.DemandResponseProgram or
            super(DemandResponseProgramList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DemandResponseProgramList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandResponseProgramList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DemandResponseProgramList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DemandResponseProgramList'):
        super(DemandResponseProgramList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DemandResponseProgramList')
    def exportChildren(self, outfile, level, namespace_='', name_='DemandResponseProgramList', fromsubclass_=False, pretty_print=True):
        super(DemandResponseProgramList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DemandResponseProgram_ in self.DemandResponseProgram:
            DemandResponseProgram_.export(outfile, level, namespace_, name_='DemandResponseProgram', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DemandResponseProgramList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DemandResponseProgramList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DemandResponseProgramList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('DemandResponseProgram=[\n')
        level += 1
        for DemandResponseProgram_ in self.DemandResponseProgram:
            showIndent(outfile, level)
            outfile.write('model_.DemandResponseProgram(\n')
            DemandResponseProgram_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DemandResponseProgramList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DemandResponseProgram':
            obj_ = DemandResponseProgram.factory()
            obj_.build(child_)
            self.DemandResponseProgram.append(obj_)
            obj_.original_tagname_ = 'DemandResponseProgram'
        super(DemandResponseProgramList, self).buildChildren(child_, node, nodeName_, True)
# end class DemandResponseProgramList


class DemandResponseProgram(IdentifiedObject):
    """Demand response program."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, ActiveEndDeviceControlListLink=None, availabilityUpdatePercentChangeThreshold=None, availabilityUpdatePowerChangeThreshold=None, EndDeviceControlListLink=None, primacy=None):
        self.original_tagname_ = None
        super(DemandResponseProgram, self).__init__()
        self.ActiveEndDeviceControlListLink = ActiveEndDeviceControlListLink
        self.availabilityUpdatePercentChangeThreshold = availabilityUpdatePercentChangeThreshold
        self.availabilityUpdatePowerChangeThreshold = availabilityUpdatePowerChangeThreshold
        self.EndDeviceControlListLink = EndDeviceControlListLink
        self.primacy = primacy
    def factory(*args_, **kwargs_):
        if DemandResponseProgram.subclass:
            return DemandResponseProgram.subclass(*args_, **kwargs_)
        else:
            return DemandResponseProgram(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ActiveEndDeviceControlListLink(self): return self.ActiveEndDeviceControlListLink
    def set_ActiveEndDeviceControlListLink(self, ActiveEndDeviceControlListLink): self.ActiveEndDeviceControlListLink = ActiveEndDeviceControlListLink
    def get_availabilityUpdatePercentChangeThreshold(self): return self.availabilityUpdatePercentChangeThreshold
    def set_availabilityUpdatePercentChangeThreshold(self, availabilityUpdatePercentChangeThreshold): self.availabilityUpdatePercentChangeThreshold = availabilityUpdatePercentChangeThreshold
    def get_availabilityUpdatePowerChangeThreshold(self): return self.availabilityUpdatePowerChangeThreshold
    def set_availabilityUpdatePowerChangeThreshold(self, availabilityUpdatePowerChangeThreshold): self.availabilityUpdatePowerChangeThreshold = availabilityUpdatePowerChangeThreshold
    def get_EndDeviceControlListLink(self): return self.EndDeviceControlListLink
    def set_EndDeviceControlListLink(self, EndDeviceControlListLink): self.EndDeviceControlListLink = EndDeviceControlListLink
    def get_primacy(self): return self.primacy
    def set_primacy(self, primacy): self.primacy = primacy
    def hasContent_(self):
        if (
            self.ActiveEndDeviceControlListLink is not None or
            self.availabilityUpdatePercentChangeThreshold is not None or
            self.availabilityUpdatePowerChangeThreshold is not None or
            self.EndDeviceControlListLink is not None or
            self.primacy is not None or
            super(DemandResponseProgram, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DemandResponseProgram', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DemandResponseProgram')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DemandResponseProgram', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DemandResponseProgram'):
        super(DemandResponseProgram, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DemandResponseProgram')
    def exportChildren(self, outfile, level, namespace_='', name_='DemandResponseProgram', fromsubclass_=False, pretty_print=True):
        super(DemandResponseProgram, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveEndDeviceControlListLink is not None:
            self.ActiveEndDeviceControlListLink.export(outfile, level, namespace_, name_='ActiveEndDeviceControlListLink', pretty_print=pretty_print)
        if self.availabilityUpdatePercentChangeThreshold is not None:
            self.availabilityUpdatePercentChangeThreshold.export(outfile, level, namespace_, name_='availabilityUpdatePercentChangeThreshold', pretty_print=pretty_print)
        if self.availabilityUpdatePowerChangeThreshold is not None:
            self.availabilityUpdatePowerChangeThreshold.export(outfile, level, namespace_, name_='availabilityUpdatePowerChangeThreshold', pretty_print=pretty_print)
        if self.EndDeviceControlListLink is not None:
            self.EndDeviceControlListLink.export(outfile, level, namespace_, name_='EndDeviceControlListLink', pretty_print=pretty_print)
        if self.primacy is not None:
            self.primacy.export(outfile, level, namespace_, name_='primacy', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DemandResponseProgram'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DemandResponseProgram, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DemandResponseProgram, self).exportLiteralChildren(outfile, level, name_)
        if self.ActiveEndDeviceControlListLink is not None:
            showIndent(outfile, level)
            outfile.write('ActiveEndDeviceControlListLink=model_.ActiveEndDeviceControlListLink(\n')
            self.ActiveEndDeviceControlListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.availabilityUpdatePercentChangeThreshold is not None:
            showIndent(outfile, level)
            outfile.write('availabilityUpdatePercentChangeThreshold=model_.PerCent(\n')
            self.availabilityUpdatePercentChangeThreshold.exportLiteral(outfile, level, name_='availabilityUpdatePercentChangeThreshold')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.availabilityUpdatePowerChangeThreshold is not None:
            showIndent(outfile, level)
            outfile.write('availabilityUpdatePowerChangeThreshold=model_.ActivePower(\n')
            self.availabilityUpdatePowerChangeThreshold.exportLiteral(outfile, level, name_='availabilityUpdatePowerChangeThreshold')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EndDeviceControlListLink is not None:
            showIndent(outfile, level)
            outfile.write('EndDeviceControlListLink=model_.EndDeviceControlListLink(\n')
            self.EndDeviceControlListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.primacy is not None:
            showIndent(outfile, level)
            outfile.write('primacy=model_.PrimacyType(\n')
            self.primacy.exportLiteral(outfile, level, name_='primacy')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DemandResponseProgram, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ActiveEndDeviceControlListLink':
            obj_ = ActiveEndDeviceControlListLink.factory()
            obj_.build(child_)
            self.ActiveEndDeviceControlListLink = obj_
            obj_.original_tagname_ = 'ActiveEndDeviceControlListLink'
        elif nodeName_ == 'availabilityUpdatePercentChangeThreshold':
            obj_ = PerCent.factory()
            obj_.build(child_)
            self.availabilityUpdatePercentChangeThreshold = obj_
            obj_.original_tagname_ = 'availabilityUpdatePercentChangeThreshold'
        elif nodeName_ == 'availabilityUpdatePowerChangeThreshold':
            obj_ = ActivePower.factory()
            obj_.build(child_)
            self.availabilityUpdatePowerChangeThreshold = obj_
            obj_.original_tagname_ = 'availabilityUpdatePowerChangeThreshold'
        elif nodeName_ == 'EndDeviceControlListLink':
            obj_ = EndDeviceControlListLink.factory()
            obj_.build(child_)
            self.EndDeviceControlListLink = obj_
            obj_.original_tagname_ = 'EndDeviceControlListLink'
        elif nodeName_ == 'primacy':
            obj_ = PrimacyType.factory()
            obj_.build(child_)
            self.primacy = obj_
            obj_.original_tagname_ = 'primacy'
        super(DemandResponseProgram, self).buildChildren(child_, node, nodeName_, True)
# end class DemandResponseProgram


class FileStatus(Resource):
    """This object provides status of device file load and activation
    operations."""
    subclass = None
    superclass = Resource
    def __init__(self, activateTime=None, FileLink=None, loadPercent=None, nextRequestAttempt=None, request503Count=None, requestFailCount=None, status=None, statusTime=None):
        self.original_tagname_ = None
        super(FileStatus, self).__init__()
        self.activateTime = activateTime
        self.FileLink = FileLink
        self.loadPercent = loadPercent
        self.nextRequestAttempt = nextRequestAttempt
        self.request503Count = request503Count
        self.requestFailCount = requestFailCount
        self.status = status
        self.statusTime = statusTime
    def factory(*args_, **kwargs_):
        if FileStatus.subclass:
            return FileStatus.subclass(*args_, **kwargs_)
        else:
            return FileStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_activateTime(self): return self.activateTime
    def set_activateTime(self, activateTime): self.activateTime = activateTime
    def get_FileLink(self): return self.FileLink
    def set_FileLink(self, FileLink): self.FileLink = FileLink
    def get_loadPercent(self): return self.loadPercent
    def set_loadPercent(self, loadPercent): self.loadPercent = loadPercent
    def get_nextRequestAttempt(self): return self.nextRequestAttempt
    def set_nextRequestAttempt(self, nextRequestAttempt): self.nextRequestAttempt = nextRequestAttempt
    def get_request503Count(self): return self.request503Count
    def set_request503Count(self, request503Count): self.request503Count = request503Count
    def get_requestFailCount(self): return self.requestFailCount
    def set_requestFailCount(self, requestFailCount): self.requestFailCount = requestFailCount
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_statusTime(self): return self.statusTime
    def set_statusTime(self, statusTime): self.statusTime = statusTime
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.activateTime is not None or
            self.FileLink is not None or
            self.loadPercent is not None or
            self.nextRequestAttempt is not None or
            self.request503Count is not None or
            self.requestFailCount is not None or
            self.status is not None or
            self.statusTime is not None or
            super(FileStatus, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileStatus'):
        super(FileStatus, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileStatus')
    def exportChildren(self, outfile, level, namespace_='', name_='FileStatus', fromsubclass_=False, pretty_print=True):
        super(FileStatus, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.activateTime is not None:
            self.activateTime.export(outfile, level, namespace_, name_='activateTime', pretty_print=pretty_print)
        if self.FileLink is not None:
            self.FileLink.export(outfile, level, namespace_, name_='FileLink', pretty_print=pretty_print)
        if self.loadPercent is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadPercent>%s</%sloadPercent>%s' % (namespace_, self.gds_format_integer(self.loadPercent, input_name='loadPercent'), namespace_, eol_))
        if self.nextRequestAttempt is not None:
            self.nextRequestAttempt.export(outfile, level, namespace_, name_='nextRequestAttempt', pretty_print=pretty_print)
        if self.request503Count is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequest503Count>%s</%srequest503Count>%s' % (namespace_, self.gds_format_integer(self.request503Count, input_name='request503Count'), namespace_, eol_))
        if self.requestFailCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequestFailCount>%s</%srequestFailCount>%s' % (namespace_, self.gds_format_integer(self.requestFailCount, input_name='requestFailCount'), namespace_, eol_))
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_format_integer(self.status, input_name='status'), namespace_, eol_))
        if self.statusTime is not None:
            self.statusTime.export(outfile, level, namespace_, name_='statusTime', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileStatus'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FileStatus, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileStatus, self).exportLiteralChildren(outfile, level, name_)
        if self.activateTime is not None:
            showIndent(outfile, level)
            outfile.write('activateTime=model_.TimeType(\n')
            self.activateTime.exportLiteral(outfile, level, name_='activateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FileLink is not None:
            showIndent(outfile, level)
            outfile.write('FileLink=model_.FileLink(\n')
            self.FileLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.loadPercent is not None:
            showIndent(outfile, level)
            outfile.write('loadPercent=%d,\n' % self.loadPercent)
        if self.nextRequestAttempt is not None:
            showIndent(outfile, level)
            outfile.write('nextRequestAttempt=model_.TimeType(\n')
            self.nextRequestAttempt.exportLiteral(outfile, level, name_='nextRequestAttempt')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.request503Count is not None:
            showIndent(outfile, level)
            outfile.write('request503Count=%d,\n' % self.request503Count)
        if self.requestFailCount is not None:
            showIndent(outfile, level)
            outfile.write('requestFailCount=%d,\n' % self.requestFailCount)
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % self.status)
        if self.statusTime is not None:
            showIndent(outfile, level)
            outfile.write('statusTime=model_.TimeType(\n')
            self.statusTime.exportLiteral(outfile, level, name_='statusTime')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FileStatus, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'activateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.activateTime = obj_
            obj_.original_tagname_ = 'activateTime'
        elif nodeName_ == 'FileLink':
            obj_ = FileLink.factory()
            obj_.build(child_)
            self.FileLink = obj_
            obj_.original_tagname_ = 'FileLink'
        elif nodeName_ == 'loadPercent':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'loadPercent')
            self.loadPercent = ival_
            self.validate_UInt8(self.loadPercent)    # validate type UInt8
        elif nodeName_ == 'nextRequestAttempt':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.nextRequestAttempt = obj_
            obj_.original_tagname_ = 'nextRequestAttempt'
        elif nodeName_ == 'request503Count':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'request503Count')
            self.request503Count = ival_
            self.validate_UInt16(self.request503Count)    # validate type UInt16
        elif nodeName_ == 'requestFailCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'requestFailCount')
            self.requestFailCount = ival_
            self.validate_UInt16(self.requestFailCount)    # validate type UInt16
        elif nodeName_ == 'status':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
            self.validate_UInt8(self.status)    # validate type UInt8
        elif nodeName_ == 'statusTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.statusTime = obj_
            obj_.original_tagname_ = 'statusTime'
        super(FileStatus, self).buildChildren(child_, node, nodeName_, True)
# end class FileStatus


class FileList(List):
    """A List element to hold File objects."""
    subclass = None
    superclass = List
    def __init__(self, File=None):
        self.original_tagname_ = None
        super(FileList, self).__init__()
        if File is None:
            self.File = []
        else:
            self.File = File
    def factory(*args_, **kwargs_):
        if FileList.subclass:
            return FileList.subclass(*args_, **kwargs_)
        else:
            return FileList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File(self): return self.File
    def set_File(self, File): self.File = File
    def add_File(self, value): self.File.append(value)
    def insert_File_at(self, index, value): self.File.insert(index, value)
    def replace_File_at(self, index, value): self.File[index] = value
    def hasContent_(self):
        if (
            self.File or
            super(FileList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FileList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FileList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FileList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FileList'):
        super(FileList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FileList')
    def exportChildren(self, outfile, level, namespace_='', name_='FileList', fromsubclass_=False, pretty_print=True):
        super(FileList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for File_ in self.File:
            File_.export(outfile, level, namespace_, name_='File', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FileList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FileList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FileList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('File=[\n')
        level += 1
        for File_ in self.File:
            showIndent(outfile, level)
            outfile.write('model_.File(\n')
            File_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FileList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File':
            obj_ = File.factory()
            obj_.build(child_)
            self.File.append(obj_)
            obj_.original_tagname_ = 'File'
        super(FileList, self).buildChildren(child_, node, nodeName_, True)
# end class FileList


class File(Resource):
    """This resource contains various meta-data describing a file's
    characteristics. The meta-data provides general file information
    and also is used to support filtered queries of file lists"""
    subclass = None
    superclass = Resource
    def __init__(self, activateTime=None, fileURI=None, lFDI=None, mfHwVer=None, mfID=None, mfModel=None, mfSerNum=None, mfVer=None, size=None, type_=None):
        self.original_tagname_ = None
        super(File, self).__init__()
        self.activateTime = activateTime
        self.fileURI = fileURI
        self.lFDI = lFDI
        self.mfHwVer = mfHwVer
        self.mfID = mfID
        self.mfModel = mfModel
        self.mfSerNum = mfSerNum
        self.mfVer = mfVer
        self.size = size
        self.type_ = type_
    def factory(*args_, **kwargs_):
        if File.subclass:
            return File.subclass(*args_, **kwargs_)
        else:
            return File(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_activateTime(self): return self.activateTime
    def set_activateTime(self, activateTime): self.activateTime = activateTime
    def get_fileURI(self): return self.fileURI
    def set_fileURI(self, fileURI): self.fileURI = fileURI
    def get_lFDI(self): return self.lFDI
    def set_lFDI(self, lFDI): self.lFDI = lFDI
    def get_mfHwVer(self): return self.mfHwVer
    def set_mfHwVer(self, mfHwVer): self.mfHwVer = mfHwVer
    def get_mfID(self): return self.mfID
    def set_mfID(self, mfID): self.mfID = mfID
    def get_mfModel(self): return self.mfModel
    def set_mfModel(self, mfModel): self.mfModel = mfModel
    def get_mfSerNum(self): return self.mfSerNum
    def set_mfSerNum(self, mfSerNum): self.mfSerNum = mfSerNum
    def get_mfVer(self): return self.mfVer
    def set_mfVer(self, mfVer): self.mfVer = mfVer
    def get_size(self): return self.size
    def set_size(self, size): self.size = size
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_HexBinary160(self, value):
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        pass
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def validate_String16(self, value):
        # Validate type String16, a restriction on xs:string.
        pass
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def validate_HexBinary16(self, value):
        # Validate type HexBinary16, a restriction on xs:hexBinary.
        pass
    def hasContent_(self):
        if (
            self.activateTime is not None or
            self.fileURI is not None or
            self.lFDI is not None or
            self.mfHwVer is not None or
            self.mfID is not None or
            self.mfModel is not None or
            self.mfSerNum is not None or
            self.mfVer is not None or
            self.size is not None or
            self.type_ is not None or
            super(File, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='File', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File'):
        super(File, self).exportAttributes(outfile, level, already_processed, namespace_, name_='File')
    def exportChildren(self, outfile, level, namespace_='', name_='File', fromsubclass_=False, pretty_print=True):
        super(File, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.activateTime is not None:
            self.activateTime.export(outfile, level, namespace_, name_='activateTime', pretty_print=pretty_print)
        if self.fileURI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfileURI>%s</%sfileURI>%s' % (namespace_, self.gds_format_string(quote_xml(self.fileURI).encode(ExternalEncoding), input_name='fileURI'), namespace_, eol_))
        if self.lFDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slFDI>%s</%slFDI>%s' % (namespace_, self.gds_format_string(quote_xml(self.lFDI).encode(ExternalEncoding), input_name='lFDI'), namespace_, eol_))
        if self.mfHwVer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfHwVer>%s</%smfHwVer>%s' % (namespace_, self.gds_format_string(quote_xml(self.mfHwVer).encode(ExternalEncoding), input_name='mfHwVer'), namespace_, eol_))
        if self.mfID is not None:
            self.mfID.export(outfile, level, namespace_, name_='mfID', pretty_print=pretty_print)
        if self.mfModel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfModel>%s</%smfModel>%s' % (namespace_, self.gds_format_string(quote_xml(self.mfModel).encode(ExternalEncoding), input_name='mfModel'), namespace_, eol_))
        if self.mfSerNum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfSerNum>%s</%smfSerNum>%s' % (namespace_, self.gds_format_string(quote_xml(self.mfSerNum).encode(ExternalEncoding), input_name='mfSerNum'), namespace_, eol_))
        if self.mfVer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfVer>%s</%smfVer>%s' % (namespace_, self.gds_format_string(quote_xml(self.mfVer).encode(ExternalEncoding), input_name='mfVer'), namespace_, eol_))
        if self.size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespace_, self.gds_format_integer(self.size, input_name='size'), namespace_, eol_))
        if self.type_ is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespace_, self.gds_format_string(quote_xml(self.type_).encode(ExternalEncoding), input_name='type'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='File'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(File, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(File, self).exportLiteralChildren(outfile, level, name_)
        if self.activateTime is not None:
            showIndent(outfile, level)
            outfile.write('activateTime=model_.TimeType(\n')
            self.activateTime.exportLiteral(outfile, level, name_='activateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.fileURI is not None:
            showIndent(outfile, level)
            outfile.write('fileURI=%s,\n' % quote_python(self.fileURI).encode(ExternalEncoding))
        if self.lFDI is not None:
            showIndent(outfile, level)
            outfile.write('lFDI=%s,\n' % quote_python(self.lFDI).encode(ExternalEncoding))
        if self.mfHwVer is not None:
            showIndent(outfile, level)
            outfile.write('mfHwVer=%s,\n' % quote_python(self.mfHwVer).encode(ExternalEncoding))
        if self.mfID is not None:
            showIndent(outfile, level)
            outfile.write('mfID=model_.PENType(\n')
            self.mfID.exportLiteral(outfile, level, name_='mfID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mfModel is not None:
            showIndent(outfile, level)
            outfile.write('mfModel=%s,\n' % quote_python(self.mfModel).encode(ExternalEncoding))
        if self.mfSerNum is not None:
            showIndent(outfile, level)
            outfile.write('mfSerNum=%s,\n' % quote_python(self.mfSerNum).encode(ExternalEncoding))
        if self.mfVer is not None:
            showIndent(outfile, level)
            outfile.write('mfVer=%s,\n' % quote_python(self.mfVer).encode(ExternalEncoding))
        if self.size is not None:
            showIndent(outfile, level)
            outfile.write('size=%d,\n' % self.size)
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_=%s,\n' % quote_python(self.type_).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(File, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'activateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.activateTime = obj_
            obj_.original_tagname_ = 'activateTime'
        elif nodeName_ == 'fileURI':
            fileURI_ = child_.text
            fileURI_ = self.gds_validate_string(fileURI_, node, 'fileURI')
            self.fileURI = fileURI_
        elif nodeName_ == 'lFDI':
            lFDI_ = child_.text
            lFDI_ = self.gds_validate_string(lFDI_, node, 'lFDI')
            self.lFDI = lFDI_
            self.validate_HexBinary160(self.lFDI)    # validate type HexBinary160
        elif nodeName_ == 'mfHwVer':
            mfHwVer_ = child_.text
            mfHwVer_ = self.gds_validate_string(mfHwVer_, node, 'mfHwVer')
            self.mfHwVer = mfHwVer_
            self.validate_String32(self.mfHwVer)    # validate type String32
        elif nodeName_ == 'mfID':
            obj_ = PENType.factory()
            obj_.build(child_)
            self.mfID = obj_
            obj_.original_tagname_ = 'mfID'
        elif nodeName_ == 'mfModel':
            mfModel_ = child_.text
            mfModel_ = self.gds_validate_string(mfModel_, node, 'mfModel')
            self.mfModel = mfModel_
            self.validate_String32(self.mfModel)    # validate type String32
        elif nodeName_ == 'mfSerNum':
            mfSerNum_ = child_.text
            mfSerNum_ = self.gds_validate_string(mfSerNum_, node, 'mfSerNum')
            self.mfSerNum = mfSerNum_
            self.validate_String32(self.mfSerNum)    # validate type String32
        elif nodeName_ == 'mfVer':
            mfVer_ = child_.text
            mfVer_ = self.gds_validate_string(mfVer_, node, 'mfVer')
            self.mfVer = mfVer_
            self.validate_String16(self.mfVer)    # validate type String16
        elif nodeName_ == 'size':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
            self.validate_UInt32(self.size)    # validate type UInt32
        elif nodeName_ == 'type':
            type_ = child_.text
            type_ = self.gds_validate_string(type_, node, 'type')
            self.type_ = type_
            self.validate_HexBinary16(self.type_)    # validate type HexBinary16
        super(File, self).buildChildren(child_, node, nodeName_, True)
# end class File


class PriceResponseCfgList(List):
    """A List element to hold PriceResponseCfg objects."""
    subclass = None
    superclass = List
    def __init__(self, PriceResponseCfg=None):
        self.original_tagname_ = None
        super(PriceResponseCfgList, self).__init__()
        if PriceResponseCfg is None:
            self.PriceResponseCfg = []
        else:
            self.PriceResponseCfg = PriceResponseCfg
    def factory(*args_, **kwargs_):
        if PriceResponseCfgList.subclass:
            return PriceResponseCfgList.subclass(*args_, **kwargs_)
        else:
            return PriceResponseCfgList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PriceResponseCfg(self): return self.PriceResponseCfg
    def set_PriceResponseCfg(self, PriceResponseCfg): self.PriceResponseCfg = PriceResponseCfg
    def add_PriceResponseCfg(self, value): self.PriceResponseCfg.append(value)
    def insert_PriceResponseCfg_at(self, index, value): self.PriceResponseCfg.insert(index, value)
    def replace_PriceResponseCfg_at(self, index, value): self.PriceResponseCfg[index] = value
    def hasContent_(self):
        if (
            self.PriceResponseCfg or
            super(PriceResponseCfgList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PriceResponseCfgList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriceResponseCfgList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PriceResponseCfgList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriceResponseCfgList'):
        super(PriceResponseCfgList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PriceResponseCfgList')
    def exportChildren(self, outfile, level, namespace_='', name_='PriceResponseCfgList', fromsubclass_=False, pretty_print=True):
        super(PriceResponseCfgList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PriceResponseCfg_ in self.PriceResponseCfg:
            PriceResponseCfg_.export(outfile, level, namespace_, name_='PriceResponseCfg', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PriceResponseCfgList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PriceResponseCfgList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PriceResponseCfgList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('PriceResponseCfg=[\n')
        level += 1
        for PriceResponseCfg_ in self.PriceResponseCfg:
            showIndent(outfile, level)
            outfile.write('model_.PriceResponseCfg(\n')
            PriceResponseCfg_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PriceResponseCfgList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PriceResponseCfg':
            obj_ = PriceResponseCfg.factory()
            obj_.build(child_)
            self.PriceResponseCfg.append(obj_)
            obj_.original_tagname_ = 'PriceResponseCfg'
        super(PriceResponseCfgList, self).buildChildren(child_, node, nodeName_, True)
# end class PriceResponseCfgList


class PriceResponseCfg(Resource):
    """Configuration data that specifies how price responsive devices
    SHOULD respond to price changes while acting upon a given
    RateComponent."""
    subclass = None
    superclass = Resource
    def __init__(self, consumeThreshold=None, maxReductionThreshold=None, RateComponentLink=None):
        self.original_tagname_ = None
        super(PriceResponseCfg, self).__init__()
        self.consumeThreshold = consumeThreshold
        self.maxReductionThreshold = maxReductionThreshold
        self.RateComponentLink = RateComponentLink
    def factory(*args_, **kwargs_):
        if PriceResponseCfg.subclass:
            return PriceResponseCfg.subclass(*args_, **kwargs_)
        else:
            return PriceResponseCfg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_consumeThreshold(self): return self.consumeThreshold
    def set_consumeThreshold(self, consumeThreshold): self.consumeThreshold = consumeThreshold
    def get_maxReductionThreshold(self): return self.maxReductionThreshold
    def set_maxReductionThreshold(self, maxReductionThreshold): self.maxReductionThreshold = maxReductionThreshold
    def get_RateComponentLink(self): return self.RateComponentLink
    def set_RateComponentLink(self, RateComponentLink): self.RateComponentLink = RateComponentLink
    def validate_Int32(self, value):
        # Validate type Int32, a restriction on xs:int.
        pass
    def hasContent_(self):
        if (
            self.consumeThreshold is not None or
            self.maxReductionThreshold is not None or
            self.RateComponentLink is not None or
            super(PriceResponseCfg, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PriceResponseCfg', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriceResponseCfg')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PriceResponseCfg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriceResponseCfg'):
        super(PriceResponseCfg, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PriceResponseCfg')
    def exportChildren(self, outfile, level, namespace_='', name_='PriceResponseCfg', fromsubclass_=False, pretty_print=True):
        super(PriceResponseCfg, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.consumeThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconsumeThreshold>%s</%sconsumeThreshold>%s' % (namespace_, self.gds_format_integer(self.consumeThreshold, input_name='consumeThreshold'), namespace_, eol_))
        if self.maxReductionThreshold is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxReductionThreshold>%s</%smaxReductionThreshold>%s' % (namespace_, self.gds_format_integer(self.maxReductionThreshold, input_name='maxReductionThreshold'), namespace_, eol_))
        if self.RateComponentLink is not None:
            self.RateComponentLink.export(outfile, level, namespace_, name_='RateComponentLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PriceResponseCfg'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PriceResponseCfg, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PriceResponseCfg, self).exportLiteralChildren(outfile, level, name_)
        if self.consumeThreshold is not None:
            showIndent(outfile, level)
            outfile.write('consumeThreshold=%d,\n' % self.consumeThreshold)
        if self.maxReductionThreshold is not None:
            showIndent(outfile, level)
            outfile.write('maxReductionThreshold=%d,\n' % self.maxReductionThreshold)
        if self.RateComponentLink is not None:
            showIndent(outfile, level)
            outfile.write('RateComponentLink=model_.RateComponentLink(\n')
            self.RateComponentLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PriceResponseCfg, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'consumeThreshold':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'consumeThreshold')
            self.consumeThreshold = ival_
            self.validate_Int32(self.consumeThreshold)    # validate type Int32
        elif nodeName_ == 'maxReductionThreshold':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'maxReductionThreshold')
            self.maxReductionThreshold = ival_
            self.validate_Int32(self.maxReductionThreshold)    # validate type Int32
        elif nodeName_ == 'RateComponentLink':
            obj_ = RateComponentLink.factory()
            obj_.build(child_)
            self.RateComponentLink = obj_
            obj_.original_tagname_ = 'RateComponentLink'
        super(PriceResponseCfg, self).buildChildren(child_, node, nodeName_, True)
# end class PriceResponseCfg


class Configuration(SubscribableResource):
    """This resource contains various settings to control the operation of
    the device"""
    subclass = None
    superclass = SubscribableResource
    def __init__(self, currentLocale=None, PowerConfiguration=None, PriceResponseCfgListLink=None, TimeConfiguration=None, userDeviceName=None):
        self.original_tagname_ = None
        super(Configuration, self).__init__()
        self.currentLocale = currentLocale
        self.PowerConfiguration = PowerConfiguration
        self.PriceResponseCfgListLink = PriceResponseCfgListLink
        self.TimeConfiguration = TimeConfiguration
        self.userDeviceName = userDeviceName
    def factory(*args_, **kwargs_):
        if Configuration.subclass:
            return Configuration.subclass(*args_, **kwargs_)
        else:
            return Configuration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currentLocale(self): return self.currentLocale
    def set_currentLocale(self, currentLocale): self.currentLocale = currentLocale
    def get_PowerConfiguration(self): return self.PowerConfiguration
    def set_PowerConfiguration(self, PowerConfiguration): self.PowerConfiguration = PowerConfiguration
    def get_PriceResponseCfgListLink(self): return self.PriceResponseCfgListLink
    def set_PriceResponseCfgListLink(self, PriceResponseCfgListLink): self.PriceResponseCfgListLink = PriceResponseCfgListLink
    def get_TimeConfiguration(self): return self.TimeConfiguration
    def set_TimeConfiguration(self, TimeConfiguration): self.TimeConfiguration = TimeConfiguration
    def get_userDeviceName(self): return self.userDeviceName
    def set_userDeviceName(self, userDeviceName): self.userDeviceName = userDeviceName
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.currentLocale is not None or
            self.PowerConfiguration is not None or
            self.PriceResponseCfgListLink is not None or
            self.TimeConfiguration is not None or
            self.userDeviceName is not None or
            super(Configuration, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Configuration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Configuration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Configuration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Configuration'):
        super(Configuration, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Configuration')
    def exportChildren(self, outfile, level, namespace_='', name_='Configuration', fromsubclass_=False, pretty_print=True):
        super(Configuration, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentLocale is not None:
            self.currentLocale.export(outfile, level, namespace_, name_='currentLocale', pretty_print=pretty_print)
        if self.PowerConfiguration is not None:
            self.PowerConfiguration.export(outfile, level, namespace_, name_='PowerConfiguration', pretty_print=pretty_print)
        if self.PriceResponseCfgListLink is not None:
            self.PriceResponseCfgListLink.export(outfile, level, namespace_, name_='PriceResponseCfgListLink', pretty_print=pretty_print)
        if self.TimeConfiguration is not None:
            self.TimeConfiguration.export(outfile, level, namespace_, name_='TimeConfiguration', pretty_print=pretty_print)
        if self.userDeviceName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suserDeviceName>%s</%suserDeviceName>%s' % (namespace_, self.gds_format_string(quote_xml(self.userDeviceName).encode(ExternalEncoding), input_name='userDeviceName'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Configuration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Configuration, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Configuration, self).exportLiteralChildren(outfile, level, name_)
        if self.currentLocale is not None:
            showIndent(outfile, level)
            outfile.write('currentLocale=model_.LocaleType(\n')
            self.currentLocale.exportLiteral(outfile, level, name_='currentLocale')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PowerConfiguration is not None:
            showIndent(outfile, level)
            outfile.write('PowerConfiguration=model_.PowerConfiguration(\n')
            self.PowerConfiguration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PriceResponseCfgListLink is not None:
            showIndent(outfile, level)
            outfile.write('PriceResponseCfgListLink=model_.PriceResponseCfgListLink(\n')
            self.PriceResponseCfgListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TimeConfiguration is not None:
            showIndent(outfile, level)
            outfile.write('TimeConfiguration=model_.TimeConfiguration(\n')
            self.TimeConfiguration.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.userDeviceName is not None:
            showIndent(outfile, level)
            outfile.write('userDeviceName=%s,\n' % quote_python(self.userDeviceName).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Configuration, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currentLocale':
            obj_ = LocaleType.factory()
            obj_.build(child_)
            self.currentLocale = obj_
            obj_.original_tagname_ = 'currentLocale'
        elif nodeName_ == 'PowerConfiguration':
            obj_ = PowerConfiguration.factory()
            obj_.build(child_)
            self.PowerConfiguration = obj_
            obj_.original_tagname_ = 'PowerConfiguration'
        elif nodeName_ == 'PriceResponseCfgListLink':
            obj_ = PriceResponseCfgListLink.factory()
            obj_.build(child_)
            self.PriceResponseCfgListLink = obj_
            obj_.original_tagname_ = 'PriceResponseCfgListLink'
        elif nodeName_ == 'TimeConfiguration':
            obj_ = TimeConfiguration.factory()
            obj_.build(child_)
            self.TimeConfiguration = obj_
            obj_.original_tagname_ = 'TimeConfiguration'
        elif nodeName_ == 'userDeviceName':
            userDeviceName_ = child_.text
            userDeviceName_ = self.gds_validate_string(userDeviceName_, node, 'userDeviceName')
            self.userDeviceName = userDeviceName_
            self.validate_String32(self.userDeviceName)    # validate type String32
        super(Configuration, self).buildChildren(child_, node, nodeName_, True)
# end class Configuration


class LogEventList(SubscribableList):
    """A List element to hold LogEvent objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, LogEvent=None):
        self.original_tagname_ = None
        super(LogEventList, self).__init__()
        if LogEvent is None:
            self.LogEvent = []
        else:
            self.LogEvent = LogEvent
    def factory(*args_, **kwargs_):
        if LogEventList.subclass:
            return LogEventList.subclass(*args_, **kwargs_)
        else:
            return LogEventList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LogEvent(self): return self.LogEvent
    def set_LogEvent(self, LogEvent): self.LogEvent = LogEvent
    def add_LogEvent(self, value): self.LogEvent.append(value)
    def insert_LogEvent_at(self, index, value): self.LogEvent.insert(index, value)
    def replace_LogEvent_at(self, index, value): self.LogEvent[index] = value
    def hasContent_(self):
        if (
            self.LogEvent or
            super(LogEventList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LogEventList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogEventList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LogEventList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LogEventList'):
        super(LogEventList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LogEventList')
    def exportChildren(self, outfile, level, namespace_='', name_='LogEventList', fromsubclass_=False, pretty_print=True):
        super(LogEventList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LogEvent_ in self.LogEvent:
            LogEvent_.export(outfile, level, namespace_, name_='LogEvent', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LogEventList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LogEventList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LogEventList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('LogEvent=[\n')
        level += 1
        for LogEvent_ in self.LogEvent:
            showIndent(outfile, level)
            outfile.write('model_.LogEvent(\n')
            LogEvent_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LogEventList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LogEvent':
            obj_ = LogEvent.factory()
            obj_.build(child_)
            self.LogEvent.append(obj_)
            obj_.original_tagname_ = 'LogEvent'
        super(LogEventList, self).buildChildren(child_, node, nodeName_, True)
# end class LogEventList


class LogEvent(Resource):
    """A time stamped instance of a significant event detected by the
    device."""
    subclass = None
    superclass = Resource
    def __init__(self, createdDateTime=None, extendedData=None, functionSet=None, logEventCode=None, logEventID=None, logEventPEN=None, profileID=None):
        self.original_tagname_ = None
        super(LogEvent, self).__init__()
        self.createdDateTime = createdDateTime
        self.extendedData = extendedData
        self.functionSet = functionSet
        self.logEventCode = logEventCode
        self.logEventID = logEventID
        self.logEventPEN = logEventPEN
        self.profileID = profileID
    def factory(*args_, **kwargs_):
        if LogEvent.subclass:
            return LogEvent.subclass(*args_, **kwargs_)
        else:
            return LogEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_createdDateTime(self): return self.createdDateTime
    def set_createdDateTime(self, createdDateTime): self.createdDateTime = createdDateTime
    def get_extendedData(self): return self.extendedData
    def set_extendedData(self, extendedData): self.extendedData = extendedData
    def get_functionSet(self): return self.functionSet
    def set_functionSet(self, functionSet): self.functionSet = functionSet
    def get_logEventCode(self): return self.logEventCode
    def set_logEventCode(self, logEventCode): self.logEventCode = logEventCode
    def get_logEventID(self): return self.logEventID
    def set_logEventID(self, logEventID): self.logEventID = logEventID
    def get_logEventPEN(self): return self.logEventPEN
    def set_logEventPEN(self, logEventPEN): self.logEventPEN = logEventPEN
    def get_profileID(self): return self.profileID
    def set_profileID(self, profileID): self.profileID = profileID
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.createdDateTime is not None or
            self.extendedData is not None or
            self.functionSet is not None or
            self.logEventCode is not None or
            self.logEventID is not None or
            self.logEventPEN is not None or
            self.profileID is not None or
            super(LogEvent, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LogEvent', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LogEvent')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LogEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LogEvent'):
        super(LogEvent, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LogEvent')
    def exportChildren(self, outfile, level, namespace_='', name_='LogEvent', fromsubclass_=False, pretty_print=True):
        super(LogEvent, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.createdDateTime is not None:
            self.createdDateTime.export(outfile, level, namespace_, name_='createdDateTime', pretty_print=pretty_print)
        if self.extendedData is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sextendedData>%s</%sextendedData>%s' % (namespace_, self.gds_format_integer(self.extendedData, input_name='extendedData'), namespace_, eol_))
        if self.functionSet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfunctionSet>%s</%sfunctionSet>%s' % (namespace_, self.gds_format_integer(self.functionSet, input_name='functionSet'), namespace_, eol_))
        if self.logEventCode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogEventCode>%s</%slogEventCode>%s' % (namespace_, self.gds_format_integer(self.logEventCode, input_name='logEventCode'), namespace_, eol_))
        if self.logEventID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogEventID>%s</%slogEventID>%s' % (namespace_, self.gds_format_integer(self.logEventID, input_name='logEventID'), namespace_, eol_))
        if self.logEventPEN is not None:
            self.logEventPEN.export(outfile, level, namespace_, name_='logEventPEN', pretty_print=pretty_print)
        if self.profileID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprofileID>%s</%sprofileID>%s' % (namespace_, self.gds_format_integer(self.profileID, input_name='profileID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LogEvent'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LogEvent, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LogEvent, self).exportLiteralChildren(outfile, level, name_)
        if self.createdDateTime is not None:
            showIndent(outfile, level)
            outfile.write('createdDateTime=model_.TimeType(\n')
            self.createdDateTime.exportLiteral(outfile, level, name_='createdDateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extendedData is not None:
            showIndent(outfile, level)
            outfile.write('extendedData=%d,\n' % self.extendedData)
        if self.functionSet is not None:
            showIndent(outfile, level)
            outfile.write('functionSet=%d,\n' % self.functionSet)
        if self.logEventCode is not None:
            showIndent(outfile, level)
            outfile.write('logEventCode=%d,\n' % self.logEventCode)
        if self.logEventID is not None:
            showIndent(outfile, level)
            outfile.write('logEventID=%d,\n' % self.logEventID)
        if self.logEventPEN is not None:
            showIndent(outfile, level)
            outfile.write('logEventPEN=model_.PENType(\n')
            self.logEventPEN.exportLiteral(outfile, level, name_='logEventPEN')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.profileID is not None:
            showIndent(outfile, level)
            outfile.write('profileID=%d,\n' % self.profileID)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LogEvent, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'createdDateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.createdDateTime = obj_
            obj_.original_tagname_ = 'createdDateTime'
        elif nodeName_ == 'extendedData':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'extendedData')
            self.extendedData = ival_
            self.validate_UInt32(self.extendedData)    # validate type UInt32
        elif nodeName_ == 'functionSet':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'functionSet')
            self.functionSet = ival_
            self.validate_UInt8(self.functionSet)    # validate type UInt8
        elif nodeName_ == 'logEventCode':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'logEventCode')
            self.logEventCode = ival_
            self.validate_UInt8(self.logEventCode)    # validate type UInt8
        elif nodeName_ == 'logEventID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'logEventID')
            self.logEventID = ival_
            self.validate_UInt16(self.logEventID)    # validate type UInt16
        elif nodeName_ == 'logEventPEN':
            obj_ = PENType.factory()
            obj_.build(child_)
            self.logEventPEN = obj_
            obj_.original_tagname_ = 'logEventPEN'
        elif nodeName_ == 'profileID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'profileID')
            self.profileID = ival_
            self.validate_UInt8(self.profileID)    # validate type UInt8
        super(LogEvent, self).buildChildren(child_, node, nodeName_, True)
# end class LogEvent


class RPLSourceRoutesList(List):
    """List or RPL source routes if the hosting device is the DODAGroot"""
    subclass = None
    superclass = List
    def __init__(self, RPLSourceRoutes=None):
        self.original_tagname_ = None
        super(RPLSourceRoutesList, self).__init__()
        if RPLSourceRoutes is None:
            self.RPLSourceRoutes = []
        else:
            self.RPLSourceRoutes = RPLSourceRoutes
    def factory(*args_, **kwargs_):
        if RPLSourceRoutesList.subclass:
            return RPLSourceRoutesList.subclass(*args_, **kwargs_)
        else:
            return RPLSourceRoutesList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RPLSourceRoutes(self): return self.RPLSourceRoutes
    def set_RPLSourceRoutes(self, RPLSourceRoutes): self.RPLSourceRoutes = RPLSourceRoutes
    def add_RPLSourceRoutes(self, value): self.RPLSourceRoutes.append(value)
    def insert_RPLSourceRoutes_at(self, index, value): self.RPLSourceRoutes.insert(index, value)
    def replace_RPLSourceRoutes_at(self, index, value): self.RPLSourceRoutes[index] = value
    def hasContent_(self):
        if (
            self.RPLSourceRoutes or
            super(RPLSourceRoutesList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RPLSourceRoutesList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RPLSourceRoutesList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RPLSourceRoutesList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RPLSourceRoutesList'):
        super(RPLSourceRoutesList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RPLSourceRoutesList')
    def exportChildren(self, outfile, level, namespace_='', name_='RPLSourceRoutesList', fromsubclass_=False, pretty_print=True):
        super(RPLSourceRoutesList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RPLSourceRoutes_ in self.RPLSourceRoutes:
            RPLSourceRoutes_.export(outfile, level, namespace_, name_='RPLSourceRoutes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RPLSourceRoutesList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RPLSourceRoutesList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RPLSourceRoutesList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('RPLSourceRoutes=[\n')
        level += 1
        for RPLSourceRoutes_ in self.RPLSourceRoutes:
            showIndent(outfile, level)
            outfile.write('model_.RPLSourceRoutes(\n')
            RPLSourceRoutes_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RPLSourceRoutesList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RPLSourceRoutes':
            obj_ = RPLSourceRoutes.factory()
            obj_.build(child_)
            self.RPLSourceRoutes.append(obj_)
            obj_.original_tagname_ = 'RPLSourceRoutes'
        super(RPLSourceRoutesList, self).buildChildren(child_, node, nodeName_, True)
# end class RPLSourceRoutesList


class RPLSourceRoutes(Resource):
    """A RPL source routes object."""
    subclass = None
    superclass = Resource
    def __init__(self, DestAddress=None, SourceRoute=None):
        self.original_tagname_ = None
        super(RPLSourceRoutes, self).__init__()
        self.DestAddress = DestAddress
        self.SourceRoute = SourceRoute
    def factory(*args_, **kwargs_):
        if RPLSourceRoutes.subclass:
            return RPLSourceRoutes.subclass(*args_, **kwargs_)
        else:
            return RPLSourceRoutes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DestAddress(self): return self.DestAddress
    def set_DestAddress(self, DestAddress): self.DestAddress = DestAddress
    def get_SourceRoute(self): return self.SourceRoute
    def set_SourceRoute(self, SourceRoute): self.SourceRoute = SourceRoute
    def validate_HexBinary128(self, value):
        # Validate type HexBinary128, a restriction on xs:hexBinary.
        pass
    def hasContent_(self):
        if (
            self.DestAddress is not None or
            self.SourceRoute is not None or
            super(RPLSourceRoutes, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RPLSourceRoutes', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RPLSourceRoutes')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RPLSourceRoutes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RPLSourceRoutes'):
        super(RPLSourceRoutes, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RPLSourceRoutes')
    def exportChildren(self, outfile, level, namespace_='', name_='RPLSourceRoutes', fromsubclass_=False, pretty_print=True):
        super(RPLSourceRoutes, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DestAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestAddress>%s</%sDestAddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.DestAddress).encode(ExternalEncoding), input_name='DestAddress'), namespace_, eol_))
        if self.SourceRoute is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceRoute>%s</%sSourceRoute>%s' % (namespace_, self.gds_format_string(quote_xml(self.SourceRoute).encode(ExternalEncoding), input_name='SourceRoute'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RPLSourceRoutes'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RPLSourceRoutes, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RPLSourceRoutes, self).exportLiteralChildren(outfile, level, name_)
        if self.DestAddress is not None:
            showIndent(outfile, level)
            outfile.write('DestAddress=%s,\n' % quote_python(self.DestAddress).encode(ExternalEncoding))
        if self.SourceRoute is not None:
            showIndent(outfile, level)
            outfile.write('SourceRoute=%s,\n' % quote_python(self.SourceRoute).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RPLSourceRoutes, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DestAddress':
            DestAddress_ = child_.text
            DestAddress_ = self.gds_validate_string(DestAddress_, node, 'DestAddress')
            self.DestAddress = DestAddress_
            self.validate_HexBinary128(self.DestAddress)    # validate type HexBinary128
        elif nodeName_ == 'SourceRoute':
            SourceRoute_ = child_.text
            SourceRoute_ = self.gds_validate_string(SourceRoute_, node, 'SourceRoute')
            self.SourceRoute = SourceRoute_
            self.validate_HexBinary128(self.SourceRoute)    # validate type HexBinary128
        super(RPLSourceRoutes, self).buildChildren(child_, node, nodeName_, True)
# end class RPLSourceRoutes


class RPLInstanceList(List):
    """List of RPLInstances associated with the IPinterface."""
    subclass = None
    superclass = List
    def __init__(self, RPLInstance=None):
        self.original_tagname_ = None
        super(RPLInstanceList, self).__init__()
        if RPLInstance is None:
            self.RPLInstance = []
        else:
            self.RPLInstance = RPLInstance
    def factory(*args_, **kwargs_):
        if RPLInstanceList.subclass:
            return RPLInstanceList.subclass(*args_, **kwargs_)
        else:
            return RPLInstanceList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RPLInstance(self): return self.RPLInstance
    def set_RPLInstance(self, RPLInstance): self.RPLInstance = RPLInstance
    def add_RPLInstance(self, value): self.RPLInstance.append(value)
    def insert_RPLInstance_at(self, index, value): self.RPLInstance.insert(index, value)
    def replace_RPLInstance_at(self, index, value): self.RPLInstance[index] = value
    def hasContent_(self):
        if (
            self.RPLInstance or
            super(RPLInstanceList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RPLInstanceList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RPLInstanceList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RPLInstanceList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RPLInstanceList'):
        super(RPLInstanceList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RPLInstanceList')
    def exportChildren(self, outfile, level, namespace_='', name_='RPLInstanceList', fromsubclass_=False, pretty_print=True):
        super(RPLInstanceList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RPLInstance_ in self.RPLInstance:
            RPLInstance_.export(outfile, level, namespace_, name_='RPLInstance', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RPLInstanceList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RPLInstanceList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RPLInstanceList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('RPLInstance=[\n')
        level += 1
        for RPLInstance_ in self.RPLInstance:
            showIndent(outfile, level)
            outfile.write('model_.RPLInstance(\n')
            RPLInstance_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RPLInstanceList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RPLInstance':
            obj_ = RPLInstance.factory()
            obj_.build(child_)
            self.RPLInstance.append(obj_)
            obj_.original_tagname_ = 'RPLInstance'
        super(RPLInstanceList, self).buildChildren(child_, node, nodeName_, True)
# end class RPLInstanceList


class RPLInstance(Resource):
    """Specific RPLInstance resource. This resource may be thought of as
    network status information for a specific RPL instance
    associated with IPInterface."""
    subclass = None
    superclass = Resource
    def __init__(self, DODAGid=None, DODAGroot=None, flags=None, groundedFlag=None, MOP=None, PRF=None, rank=None, RPLInstanceID=None, RPLSourceRoutesListLink=None, versionNumber=None):
        self.original_tagname_ = None
        super(RPLInstance, self).__init__()
        self.DODAGid = DODAGid
        self.DODAGroot = DODAGroot
        self.flags = flags
        self.groundedFlag = groundedFlag
        self.MOP = MOP
        self.PRF = PRF
        self.rank = rank
        self.RPLInstanceID = RPLInstanceID
        self.RPLSourceRoutesListLink = RPLSourceRoutesListLink
        self.versionNumber = versionNumber
    def factory(*args_, **kwargs_):
        if RPLInstance.subclass:
            return RPLInstance.subclass(*args_, **kwargs_)
        else:
            return RPLInstance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DODAGid(self): return self.DODAGid
    def set_DODAGid(self, DODAGid): self.DODAGid = DODAGid
    def get_DODAGroot(self): return self.DODAGroot
    def set_DODAGroot(self, DODAGroot): self.DODAGroot = DODAGroot
    def get_flags(self): return self.flags
    def set_flags(self, flags): self.flags = flags
    def get_groundedFlag(self): return self.groundedFlag
    def set_groundedFlag(self, groundedFlag): self.groundedFlag = groundedFlag
    def get_MOP(self): return self.MOP
    def set_MOP(self, MOP): self.MOP = MOP
    def get_PRF(self): return self.PRF
    def set_PRF(self, PRF): self.PRF = PRF
    def get_rank(self): return self.rank
    def set_rank(self, rank): self.rank = rank
    def get_RPLInstanceID(self): return self.RPLInstanceID
    def set_RPLInstanceID(self, RPLInstanceID): self.RPLInstanceID = RPLInstanceID
    def get_RPLSourceRoutesListLink(self): return self.RPLSourceRoutesListLink
    def set_RPLSourceRoutesListLink(self, RPLSourceRoutesListLink): self.RPLSourceRoutesListLink = RPLSourceRoutesListLink
    def get_versionNumber(self): return self.versionNumber
    def set_versionNumber(self, versionNumber): self.versionNumber = versionNumber
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.DODAGid is not None or
            self.DODAGroot is not None or
            self.flags is not None or
            self.groundedFlag is not None or
            self.MOP is not None or
            self.PRF is not None or
            self.rank is not None or
            self.RPLInstanceID is not None or
            self.RPLSourceRoutesListLink is not None or
            self.versionNumber is not None or
            super(RPLInstance, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RPLInstance', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RPLInstance')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RPLInstance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RPLInstance'):
        super(RPLInstance, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RPLInstance')
    def exportChildren(self, outfile, level, namespace_='', name_='RPLInstance', fromsubclass_=False, pretty_print=True):
        super(RPLInstance, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DODAGid is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDODAGid>%s</%sDODAGid>%s' % (namespace_, self.gds_format_integer(self.DODAGid, input_name='DODAGid'), namespace_, eol_))
        if self.DODAGroot is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDODAGroot>%s</%sDODAGroot>%s' % (namespace_, self.gds_format_boolean(self.DODAGroot, input_name='DODAGroot'), namespace_, eol_))
        if self.flags is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflags>%s</%sflags>%s' % (namespace_, self.gds_format_integer(self.flags, input_name='flags'), namespace_, eol_))
        if self.groundedFlag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroundedFlag>%s</%sgroundedFlag>%s' % (namespace_, self.gds_format_boolean(self.groundedFlag, input_name='groundedFlag'), namespace_, eol_))
        if self.MOP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMOP>%s</%sMOP>%s' % (namespace_, self.gds_format_integer(self.MOP, input_name='MOP'), namespace_, eol_))
        if self.PRF is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPRF>%s</%sPRF>%s' % (namespace_, self.gds_format_integer(self.PRF, input_name='PRF'), namespace_, eol_))
        if self.rank is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srank>%s</%srank>%s' % (namespace_, self.gds_format_integer(self.rank, input_name='rank'), namespace_, eol_))
        if self.RPLInstanceID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRPLInstanceID>%s</%sRPLInstanceID>%s' % (namespace_, self.gds_format_integer(self.RPLInstanceID, input_name='RPLInstanceID'), namespace_, eol_))
        if self.RPLSourceRoutesListLink is not None:
            self.RPLSourceRoutesListLink.export(outfile, level, namespace_, name_='RPLSourceRoutesListLink', pretty_print=pretty_print)
        if self.versionNumber is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversionNumber>%s</%sversionNumber>%s' % (namespace_, self.gds_format_integer(self.versionNumber, input_name='versionNumber'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RPLInstance'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RPLInstance, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RPLInstance, self).exportLiteralChildren(outfile, level, name_)
        if self.DODAGid is not None:
            showIndent(outfile, level)
            outfile.write('DODAGid=%d,\n' % self.DODAGid)
        if self.DODAGroot is not None:
            showIndent(outfile, level)
            outfile.write('DODAGroot=%s,\n' % self.DODAGroot)
        if self.flags is not None:
            showIndent(outfile, level)
            outfile.write('flags=%d,\n' % self.flags)
        if self.groundedFlag is not None:
            showIndent(outfile, level)
            outfile.write('groundedFlag=%s,\n' % self.groundedFlag)
        if self.MOP is not None:
            showIndent(outfile, level)
            outfile.write('MOP=%d,\n' % self.MOP)
        if self.PRF is not None:
            showIndent(outfile, level)
            outfile.write('PRF=%d,\n' % self.PRF)
        if self.rank is not None:
            showIndent(outfile, level)
            outfile.write('rank=%d,\n' % self.rank)
        if self.RPLInstanceID is not None:
            showIndent(outfile, level)
            outfile.write('RPLInstanceID=%d,\n' % self.RPLInstanceID)
        if self.RPLSourceRoutesListLink is not None:
            showIndent(outfile, level)
            outfile.write('RPLSourceRoutesListLink=model_.RPLSourceRoutesListLink(\n')
            self.RPLSourceRoutesListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.versionNumber is not None:
            showIndent(outfile, level)
            outfile.write('versionNumber=%d,\n' % self.versionNumber)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RPLInstance, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DODAGid':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'DODAGid')
            self.DODAGid = ival_
            self.validate_UInt8(self.DODAGid)    # validate type UInt8
        elif nodeName_ == 'DODAGroot':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'DODAGroot')
            self.DODAGroot = ival_
        elif nodeName_ == 'flags':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'flags')
            self.flags = ival_
            self.validate_UInt8(self.flags)    # validate type UInt8
        elif nodeName_ == 'groundedFlag':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'groundedFlag')
            self.groundedFlag = ival_
        elif nodeName_ == 'MOP':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'MOP')
            self.MOP = ival_
            self.validate_UInt8(self.MOP)    # validate type UInt8
        elif nodeName_ == 'PRF':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'PRF')
            self.PRF = ival_
            self.validate_UInt8(self.PRF)    # validate type UInt8
        elif nodeName_ == 'rank':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'rank')
            self.rank = ival_
            self.validate_UInt16(self.rank)    # validate type UInt16
        elif nodeName_ == 'RPLInstanceID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'RPLInstanceID')
            self.RPLInstanceID = ival_
            self.validate_UInt8(self.RPLInstanceID)    # validate type UInt8
        elif nodeName_ == 'RPLSourceRoutesListLink':
            obj_ = RPLSourceRoutesListLink.factory()
            obj_.build(child_)
            self.RPLSourceRoutesListLink = obj_
            obj_.original_tagname_ = 'RPLSourceRoutesListLink'
        elif nodeName_ == 'versionNumber':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'versionNumber')
            self.versionNumber = ival_
            self.validate_UInt8(self.versionNumber)    # validate type UInt8
        super(RPLInstance, self).buildChildren(child_, node, nodeName_, True)
# end class RPLInstance


class NeighborList(List):
    """List of 15.4 neighbors."""
    subclass = None
    superclass = List
    def __init__(self, Neighbor=None):
        self.original_tagname_ = None
        super(NeighborList, self).__init__()
        if Neighbor is None:
            self.Neighbor = []
        else:
            self.Neighbor = Neighbor
    def factory(*args_, **kwargs_):
        if NeighborList.subclass:
            return NeighborList.subclass(*args_, **kwargs_)
        else:
            return NeighborList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Neighbor(self): return self.Neighbor
    def set_Neighbor(self, Neighbor): self.Neighbor = Neighbor
    def add_Neighbor(self, value): self.Neighbor.append(value)
    def insert_Neighbor_at(self, index, value): self.Neighbor.insert(index, value)
    def replace_Neighbor_at(self, index, value): self.Neighbor[index] = value
    def hasContent_(self):
        if (
            self.Neighbor or
            super(NeighborList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NeighborList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NeighborList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NeighborList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NeighborList'):
        super(NeighborList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NeighborList')
    def exportChildren(self, outfile, level, namespace_='', name_='NeighborList', fromsubclass_=False, pretty_print=True):
        super(NeighborList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Neighbor_ in self.Neighbor:
            Neighbor_.export(outfile, level, namespace_, name_='Neighbor', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NeighborList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NeighborList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NeighborList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Neighbor=[\n')
        level += 1
        for Neighbor_ in self.Neighbor:
            showIndent(outfile, level)
            outfile.write('model_.Neighbor(\n')
            Neighbor_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NeighborList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Neighbor':
            obj_ = Neighbor.factory()
            obj_.build(child_)
            self.Neighbor.append(obj_)
            obj_.original_tagname_ = 'Neighbor'
        super(NeighborList, self).buildChildren(child_, node, nodeName_, True)
# end class NeighborList


class Neighbor(Resource):
    """Contains 802.15.4 link layer specific attributes."""
    subclass = None
    superclass = Resource
    def __init__(self, isChild=None, linkQuality=None, shortAddress=None):
        self.original_tagname_ = None
        super(Neighbor, self).__init__()
        self.isChild = isChild
        self.linkQuality = linkQuality
        self.shortAddress = shortAddress
    def factory(*args_, **kwargs_):
        if Neighbor.subclass:
            return Neighbor.subclass(*args_, **kwargs_)
        else:
            return Neighbor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_isChild(self): return self.isChild
    def set_isChild(self, isChild): self.isChild = isChild
    def get_linkQuality(self): return self.linkQuality
    def set_linkQuality(self, linkQuality): self.linkQuality = linkQuality
    def get_shortAddress(self): return self.shortAddress
    def set_shortAddress(self, shortAddress): self.shortAddress = shortAddress
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.isChild is not None or
            self.linkQuality is not None or
            self.shortAddress is not None or
            super(Neighbor, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Neighbor', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Neighbor')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Neighbor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Neighbor'):
        super(Neighbor, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Neighbor')
    def exportChildren(self, outfile, level, namespace_='', name_='Neighbor', fromsubclass_=False, pretty_print=True):
        super(Neighbor, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isChild is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisChild>%s</%sisChild>%s' % (namespace_, self.gds_format_boolean(self.isChild, input_name='isChild'), namespace_, eol_))
        if self.linkQuality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slinkQuality>%s</%slinkQuality>%s' % (namespace_, self.gds_format_integer(self.linkQuality, input_name='linkQuality'), namespace_, eol_))
        if self.shortAddress is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortAddress>%s</%sshortAddress>%s' % (namespace_, self.gds_format_integer(self.shortAddress, input_name='shortAddress'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Neighbor'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Neighbor, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Neighbor, self).exportLiteralChildren(outfile, level, name_)
        if self.isChild is not None:
            showIndent(outfile, level)
            outfile.write('isChild=%s,\n' % self.isChild)
        if self.linkQuality is not None:
            showIndent(outfile, level)
            outfile.write('linkQuality=%d,\n' % self.linkQuality)
        if self.shortAddress is not None:
            showIndent(outfile, level)
            outfile.write('shortAddress=%d,\n' % self.shortAddress)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Neighbor, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'isChild':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'isChild')
            self.isChild = ival_
        elif nodeName_ == 'linkQuality':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'linkQuality')
            self.linkQuality = ival_
            self.validate_UInt8(self.linkQuality)    # validate type UInt8
        elif nodeName_ == 'shortAddress':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'shortAddress')
            self.shortAddress = ival_
            self.validate_UInt16(self.shortAddress)    # validate type UInt16
        super(Neighbor, self).buildChildren(child_, node, nodeName_, True)
# end class Neighbor


class LLInterfaceList(List):
    """List of LLInterface instances."""
    subclass = None
    superclass = List
    def __init__(self, LLInterface=None):
        self.original_tagname_ = None
        super(LLInterfaceList, self).__init__()
        if LLInterface is None:
            self.LLInterface = []
        else:
            self.LLInterface = LLInterface
    def factory(*args_, **kwargs_):
        if LLInterfaceList.subclass:
            return LLInterfaceList.subclass(*args_, **kwargs_)
        else:
            return LLInterfaceList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LLInterface(self): return self.LLInterface
    def set_LLInterface(self, LLInterface): self.LLInterface = LLInterface
    def add_LLInterface(self, value): self.LLInterface.append(value)
    def insert_LLInterface_at(self, index, value): self.LLInterface.insert(index, value)
    def replace_LLInterface_at(self, index, value): self.LLInterface[index] = value
    def hasContent_(self):
        if (
            self.LLInterface or
            super(LLInterfaceList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LLInterfaceList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LLInterfaceList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LLInterfaceList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LLInterfaceList'):
        super(LLInterfaceList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LLInterfaceList')
    def exportChildren(self, outfile, level, namespace_='', name_='LLInterfaceList', fromsubclass_=False, pretty_print=True):
        super(LLInterfaceList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LLInterface_ in self.LLInterface:
            LLInterface_.export(outfile, level, namespace_, name_='LLInterface', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LLInterfaceList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LLInterfaceList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LLInterfaceList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('LLInterface=[\n')
        level += 1
        for LLInterface_ in self.LLInterface:
            showIndent(outfile, level)
            outfile.write('model_.LLInterface(\n')
            LLInterface_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LLInterfaceList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LLInterface':
            obj_ = LLInterface.factory()
            obj_.build(child_)
            self.LLInterface.append(obj_)
            obj_.original_tagname_ = 'LLInterface'
        super(LLInterfaceList, self).buildChildren(child_, node, nodeName_, True)
# end class LLInterfaceList


class LLInterface(Resource):
    """A link-layer interface object."""
    subclass = None
    superclass = Resource
    def __init__(self, CRCerrors=None, EUI64=None, IEEE_802_15_4=None, linkLayerType=None, LLAckNotRx=None, LLCSMAFail=None, LLFramesDropRx=None, LLFramesDropTx=None, LLFramesRx=None, LLFramesTx=None, LLMediaAccessFail=None, LLOctetsRx=None, LLOctetsTx=None, LLRetryCount=None, LLSecurityErrorRx=None, loWPAN=None):
        self.original_tagname_ = None
        super(LLInterface, self).__init__()
        self.CRCerrors = CRCerrors
        self.EUI64 = EUI64
        self.IEEE_802_15_4 = IEEE_802_15_4
        self.linkLayerType = linkLayerType
        self.LLAckNotRx = LLAckNotRx
        self.LLCSMAFail = LLCSMAFail
        self.LLFramesDropRx = LLFramesDropRx
        self.LLFramesDropTx = LLFramesDropTx
        self.LLFramesRx = LLFramesRx
        self.LLFramesTx = LLFramesTx
        self.LLMediaAccessFail = LLMediaAccessFail
        self.LLOctetsRx = LLOctetsRx
        self.LLOctetsTx = LLOctetsTx
        self.LLRetryCount = LLRetryCount
        self.LLSecurityErrorRx = LLSecurityErrorRx
        self.loWPAN = loWPAN
    def factory(*args_, **kwargs_):
        if LLInterface.subclass:
            return LLInterface.subclass(*args_, **kwargs_)
        else:
            return LLInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CRCerrors(self): return self.CRCerrors
    def set_CRCerrors(self, CRCerrors): self.CRCerrors = CRCerrors
    def get_EUI64(self): return self.EUI64
    def set_EUI64(self, EUI64): self.EUI64 = EUI64
    def get_IEEE_802_15_4(self): return self.IEEE_802_15_4
    def set_IEEE_802_15_4(self, IEEE_802_15_4): self.IEEE_802_15_4 = IEEE_802_15_4
    def get_linkLayerType(self): return self.linkLayerType
    def set_linkLayerType(self, linkLayerType): self.linkLayerType = linkLayerType
    def get_LLAckNotRx(self): return self.LLAckNotRx
    def set_LLAckNotRx(self, LLAckNotRx): self.LLAckNotRx = LLAckNotRx
    def get_LLCSMAFail(self): return self.LLCSMAFail
    def set_LLCSMAFail(self, LLCSMAFail): self.LLCSMAFail = LLCSMAFail
    def get_LLFramesDropRx(self): return self.LLFramesDropRx
    def set_LLFramesDropRx(self, LLFramesDropRx): self.LLFramesDropRx = LLFramesDropRx
    def get_LLFramesDropTx(self): return self.LLFramesDropTx
    def set_LLFramesDropTx(self, LLFramesDropTx): self.LLFramesDropTx = LLFramesDropTx
    def get_LLFramesRx(self): return self.LLFramesRx
    def set_LLFramesRx(self, LLFramesRx): self.LLFramesRx = LLFramesRx
    def get_LLFramesTx(self): return self.LLFramesTx
    def set_LLFramesTx(self, LLFramesTx): self.LLFramesTx = LLFramesTx
    def get_LLMediaAccessFail(self): return self.LLMediaAccessFail
    def set_LLMediaAccessFail(self, LLMediaAccessFail): self.LLMediaAccessFail = LLMediaAccessFail
    def get_LLOctetsRx(self): return self.LLOctetsRx
    def set_LLOctetsRx(self, LLOctetsRx): self.LLOctetsRx = LLOctetsRx
    def get_LLOctetsTx(self): return self.LLOctetsTx
    def set_LLOctetsTx(self, LLOctetsTx): self.LLOctetsTx = LLOctetsTx
    def get_LLRetryCount(self): return self.LLRetryCount
    def set_LLRetryCount(self, LLRetryCount): self.LLRetryCount = LLRetryCount
    def get_LLSecurityErrorRx(self): return self.LLSecurityErrorRx
    def set_LLSecurityErrorRx(self, LLSecurityErrorRx): self.LLSecurityErrorRx = LLSecurityErrorRx
    def get_loWPAN(self): return self.loWPAN
    def set_loWPAN(self, loWPAN): self.loWPAN = loWPAN
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def validate_HexBinary64(self, value):
        # Validate type HexBinary64, a restriction on xs:hexBinary.
        pass
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.CRCerrors is not None or
            self.EUI64 is not None or
            self.IEEE_802_15_4 is not None or
            self.linkLayerType is not None or
            self.LLAckNotRx is not None or
            self.LLCSMAFail is not None or
            self.LLFramesDropRx is not None or
            self.LLFramesDropTx is not None or
            self.LLFramesRx is not None or
            self.LLFramesTx is not None or
            self.LLMediaAccessFail is not None or
            self.LLOctetsRx is not None or
            self.LLOctetsTx is not None or
            self.LLRetryCount is not None or
            self.LLSecurityErrorRx is not None or
            self.loWPAN is not None or
            super(LLInterface, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LLInterface', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LLInterface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LLInterface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LLInterface'):
        super(LLInterface, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LLInterface')
    def exportChildren(self, outfile, level, namespace_='', name_='LLInterface', fromsubclass_=False, pretty_print=True):
        super(LLInterface, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CRCerrors is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCRCerrors>%s</%sCRCerrors>%s' % (namespace_, self.gds_format_integer(self.CRCerrors, input_name='CRCerrors'), namespace_, eol_))
        if self.EUI64 is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEUI64>%s</%sEUI64>%s' % (namespace_, self.gds_format_string(quote_xml(self.EUI64).encode(ExternalEncoding), input_name='EUI64'), namespace_, eol_))
        if self.IEEE_802_15_4 is not None:
            self.IEEE_802_15_4.export(outfile, level, namespace_, name_='IEEE_802_15_4', pretty_print=pretty_print)
        if self.linkLayerType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slinkLayerType>%s</%slinkLayerType>%s' % (namespace_, self.gds_format_integer(self.linkLayerType, input_name='linkLayerType'), namespace_, eol_))
        if self.LLAckNotRx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLAckNotRx>%s</%sLLAckNotRx>%s' % (namespace_, self.gds_format_integer(self.LLAckNotRx, input_name='LLAckNotRx'), namespace_, eol_))
        if self.LLCSMAFail is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLCSMAFail>%s</%sLLCSMAFail>%s' % (namespace_, self.gds_format_integer(self.LLCSMAFail, input_name='LLCSMAFail'), namespace_, eol_))
        if self.LLFramesDropRx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLFramesDropRx>%s</%sLLFramesDropRx>%s' % (namespace_, self.gds_format_integer(self.LLFramesDropRx, input_name='LLFramesDropRx'), namespace_, eol_))
        if self.LLFramesDropTx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLFramesDropTx>%s</%sLLFramesDropTx>%s' % (namespace_, self.gds_format_integer(self.LLFramesDropTx, input_name='LLFramesDropTx'), namespace_, eol_))
        if self.LLFramesRx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLFramesRx>%s</%sLLFramesRx>%s' % (namespace_, self.gds_format_integer(self.LLFramesRx, input_name='LLFramesRx'), namespace_, eol_))
        if self.LLFramesTx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLFramesTx>%s</%sLLFramesTx>%s' % (namespace_, self.gds_format_integer(self.LLFramesTx, input_name='LLFramesTx'), namespace_, eol_))
        if self.LLMediaAccessFail is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLMediaAccessFail>%s</%sLLMediaAccessFail>%s' % (namespace_, self.gds_format_integer(self.LLMediaAccessFail, input_name='LLMediaAccessFail'), namespace_, eol_))
        if self.LLOctetsRx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLOctetsRx>%s</%sLLOctetsRx>%s' % (namespace_, self.gds_format_integer(self.LLOctetsRx, input_name='LLOctetsRx'), namespace_, eol_))
        if self.LLOctetsTx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLOctetsTx>%s</%sLLOctetsTx>%s' % (namespace_, self.gds_format_integer(self.LLOctetsTx, input_name='LLOctetsTx'), namespace_, eol_))
        if self.LLRetryCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLRetryCount>%s</%sLLRetryCount>%s' % (namespace_, self.gds_format_integer(self.LLRetryCount, input_name='LLRetryCount'), namespace_, eol_))
        if self.LLSecurityErrorRx is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLSecurityErrorRx>%s</%sLLSecurityErrorRx>%s' % (namespace_, self.gds_format_integer(self.LLSecurityErrorRx, input_name='LLSecurityErrorRx'), namespace_, eol_))
        if self.loWPAN is not None:
            self.loWPAN.export(outfile, level, namespace_, name_='loWPAN', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LLInterface'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LLInterface, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LLInterface, self).exportLiteralChildren(outfile, level, name_)
        if self.CRCerrors is not None:
            showIndent(outfile, level)
            outfile.write('CRCerrors=%d,\n' % self.CRCerrors)
        if self.EUI64 is not None:
            showIndent(outfile, level)
            outfile.write('EUI64=%s,\n' % quote_python(self.EUI64).encode(ExternalEncoding))
        if self.IEEE_802_15_4 is not None:
            showIndent(outfile, level)
            outfile.write('IEEE_802_15_4=model_.IEEE_802_15_4(\n')
            self.IEEE_802_15_4.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.linkLayerType is not None:
            showIndent(outfile, level)
            outfile.write('linkLayerType=%d,\n' % self.linkLayerType)
        if self.LLAckNotRx is not None:
            showIndent(outfile, level)
            outfile.write('LLAckNotRx=%d,\n' % self.LLAckNotRx)
        if self.LLCSMAFail is not None:
            showIndent(outfile, level)
            outfile.write('LLCSMAFail=%d,\n' % self.LLCSMAFail)
        if self.LLFramesDropRx is not None:
            showIndent(outfile, level)
            outfile.write('LLFramesDropRx=%d,\n' % self.LLFramesDropRx)
        if self.LLFramesDropTx is not None:
            showIndent(outfile, level)
            outfile.write('LLFramesDropTx=%d,\n' % self.LLFramesDropTx)
        if self.LLFramesRx is not None:
            showIndent(outfile, level)
            outfile.write('LLFramesRx=%d,\n' % self.LLFramesRx)
        if self.LLFramesTx is not None:
            showIndent(outfile, level)
            outfile.write('LLFramesTx=%d,\n' % self.LLFramesTx)
        if self.LLMediaAccessFail is not None:
            showIndent(outfile, level)
            outfile.write('LLMediaAccessFail=%d,\n' % self.LLMediaAccessFail)
        if self.LLOctetsRx is not None:
            showIndent(outfile, level)
            outfile.write('LLOctetsRx=%d,\n' % self.LLOctetsRx)
        if self.LLOctetsTx is not None:
            showIndent(outfile, level)
            outfile.write('LLOctetsTx=%d,\n' % self.LLOctetsTx)
        if self.LLRetryCount is not None:
            showIndent(outfile, level)
            outfile.write('LLRetryCount=%d,\n' % self.LLRetryCount)
        if self.LLSecurityErrorRx is not None:
            showIndent(outfile, level)
            outfile.write('LLSecurityErrorRx=%d,\n' % self.LLSecurityErrorRx)
        if self.loWPAN is not None:
            showIndent(outfile, level)
            outfile.write('loWPAN=model_.loWPAN(\n')
            self.loWPAN.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(LLInterface, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CRCerrors':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'CRCerrors')
            self.CRCerrors = ival_
            self.validate_UInt32(self.CRCerrors)    # validate type UInt32
        elif nodeName_ == 'EUI64':
            EUI64_ = child_.text
            EUI64_ = self.gds_validate_string(EUI64_, node, 'EUI64')
            self.EUI64 = EUI64_
            self.validate_HexBinary64(self.EUI64)    # validate type HexBinary64
        elif nodeName_ == 'IEEE_802_15_4':
            obj_ = IEEE_802_15_4.factory()
            obj_.build(child_)
            self.IEEE_802_15_4 = obj_
            obj_.original_tagname_ = 'IEEE_802_15_4'
        elif nodeName_ == 'linkLayerType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'linkLayerType')
            self.linkLayerType = ival_
            self.validate_UInt8(self.linkLayerType)    # validate type UInt8
        elif nodeName_ == 'LLAckNotRx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLAckNotRx')
            self.LLAckNotRx = ival_
            self.validate_UInt32(self.LLAckNotRx)    # validate type UInt32
        elif nodeName_ == 'LLCSMAFail':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLCSMAFail')
            self.LLCSMAFail = ival_
            self.validate_UInt32(self.LLCSMAFail)    # validate type UInt32
        elif nodeName_ == 'LLFramesDropRx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLFramesDropRx')
            self.LLFramesDropRx = ival_
            self.validate_UInt32(self.LLFramesDropRx)    # validate type UInt32
        elif nodeName_ == 'LLFramesDropTx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLFramesDropTx')
            self.LLFramesDropTx = ival_
            self.validate_UInt32(self.LLFramesDropTx)    # validate type UInt32
        elif nodeName_ == 'LLFramesRx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLFramesRx')
            self.LLFramesRx = ival_
            self.validate_UInt32(self.LLFramesRx)    # validate type UInt32
        elif nodeName_ == 'LLFramesTx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLFramesTx')
            self.LLFramesTx = ival_
            self.validate_UInt32(self.LLFramesTx)    # validate type UInt32
        elif nodeName_ == 'LLMediaAccessFail':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLMediaAccessFail')
            self.LLMediaAccessFail = ival_
            self.validate_UInt32(self.LLMediaAccessFail)    # validate type UInt32
        elif nodeName_ == 'LLOctetsRx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLOctetsRx')
            self.LLOctetsRx = ival_
            self.validate_UInt32(self.LLOctetsRx)    # validate type UInt32
        elif nodeName_ == 'LLOctetsTx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLOctetsTx')
            self.LLOctetsTx = ival_
            self.validate_UInt32(self.LLOctetsTx)    # validate type UInt32
        elif nodeName_ == 'LLRetryCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLRetryCount')
            self.LLRetryCount = ival_
            self.validate_UInt32(self.LLRetryCount)    # validate type UInt32
        elif nodeName_ == 'LLSecurityErrorRx':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'LLSecurityErrorRx')
            self.LLSecurityErrorRx = ival_
            self.validate_UInt32(self.LLSecurityErrorRx)    # validate type UInt32
        elif nodeName_ == 'loWPAN':
            obj_ = loWPAN.factory()
            obj_.build(child_)
            self.loWPAN = obj_
            obj_.original_tagname_ = 'loWPAN'
        super(LLInterface, self).buildChildren(child_, node, nodeName_, True)
# end class LLInterface


class IPInterfaceList(List):
    """List of IPInterface instances."""
    subclass = None
    superclass = List
    def __init__(self, IPInterface=None):
        self.original_tagname_ = None
        super(IPInterfaceList, self).__init__()
        if IPInterface is None:
            self.IPInterface = []
        else:
            self.IPInterface = IPInterface
    def factory(*args_, **kwargs_):
        if IPInterfaceList.subclass:
            return IPInterfaceList.subclass(*args_, **kwargs_)
        else:
            return IPInterfaceList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPInterface(self): return self.IPInterface
    def set_IPInterface(self, IPInterface): self.IPInterface = IPInterface
    def add_IPInterface(self, value): self.IPInterface.append(value)
    def insert_IPInterface_at(self, index, value): self.IPInterface.insert(index, value)
    def replace_IPInterface_at(self, index, value): self.IPInterface[index] = value
    def hasContent_(self):
        if (
            self.IPInterface or
            super(IPInterfaceList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPInterfaceList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPInterfaceList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPInterfaceList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPInterfaceList'):
        super(IPInterfaceList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IPInterfaceList')
    def exportChildren(self, outfile, level, namespace_='', name_='IPInterfaceList', fromsubclass_=False, pretty_print=True):
        super(IPInterfaceList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IPInterface_ in self.IPInterface:
            IPInterface_.export(outfile, level, namespace_, name_='IPInterface', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IPInterfaceList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IPInterfaceList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IPInterfaceList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IPInterface=[\n')
        level += 1
        for IPInterface_ in self.IPInterface:
            showIndent(outfile, level)
            outfile.write('model_.IPInterface(\n')
            IPInterface_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IPInterfaceList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPInterface':
            obj_ = IPInterface.factory()
            obj_.build(child_)
            self.IPInterface.append(obj_)
            obj_.original_tagname_ = 'IPInterface'
        super(IPInterfaceList, self).buildChildren(child_, node, nodeName_, True)
# end class IPInterfaceList


class IPInterface(Resource):
    """Specific IPInterface resource. This resource may be thought of as
    network status information for a specific network (IP) layer
    interface."""
    subclass = None
    superclass = Resource
    def __init__(self, ifDescr=None, ifHighSpeed=None, ifInBroadcastPkts=None, ifIndex=None, ifInDiscards=None, ifInErrors=None, ifInMulticastPkts=None, ifInOctets=None, ifInUcastPkts=None, ifInUnknownProtos=None, ifMtu=None, ifName=None, ifOperStatus=None, ifOutBroadcastPkts=None, ifOutDiscards=None, ifOutErrors=None, ifOutMulticastPkts=None, ifOutOctets=None, ifOutUcastPkts=None, ifPromiscuousMode=None, ifSpeed=None, ifType=None, IPAddrListLink=None, lastResetTime=None, lastUpdatedTime=None, LLInterfaceListLink=None):
        self.original_tagname_ = None
        super(IPInterface, self).__init__()
        self.ifDescr = ifDescr
        self.ifHighSpeed = ifHighSpeed
        self.ifInBroadcastPkts = ifInBroadcastPkts
        self.ifIndex = ifIndex
        self.ifInDiscards = ifInDiscards
        self.ifInErrors = ifInErrors
        self.ifInMulticastPkts = ifInMulticastPkts
        self.ifInOctets = ifInOctets
        self.ifInUcastPkts = ifInUcastPkts
        self.ifInUnknownProtos = ifInUnknownProtos
        self.ifMtu = ifMtu
        self.ifName = ifName
        self.ifOperStatus = ifOperStatus
        self.ifOutBroadcastPkts = ifOutBroadcastPkts
        self.ifOutDiscards = ifOutDiscards
        self.ifOutErrors = ifOutErrors
        self.ifOutMulticastPkts = ifOutMulticastPkts
        self.ifOutOctets = ifOutOctets
        self.ifOutUcastPkts = ifOutUcastPkts
        self.ifPromiscuousMode = ifPromiscuousMode
        self.ifSpeed = ifSpeed
        self.ifType = ifType
        self.IPAddrListLink = IPAddrListLink
        self.lastResetTime = lastResetTime
        self.lastUpdatedTime = lastUpdatedTime
        self.LLInterfaceListLink = LLInterfaceListLink
    def factory(*args_, **kwargs_):
        if IPInterface.subclass:
            return IPInterface.subclass(*args_, **kwargs_)
        else:
            return IPInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ifDescr(self): return self.ifDescr
    def set_ifDescr(self, ifDescr): self.ifDescr = ifDescr
    def get_ifHighSpeed(self): return self.ifHighSpeed
    def set_ifHighSpeed(self, ifHighSpeed): self.ifHighSpeed = ifHighSpeed
    def get_ifInBroadcastPkts(self): return self.ifInBroadcastPkts
    def set_ifInBroadcastPkts(self, ifInBroadcastPkts): self.ifInBroadcastPkts = ifInBroadcastPkts
    def get_ifIndex(self): return self.ifIndex
    def set_ifIndex(self, ifIndex): self.ifIndex = ifIndex
    def get_ifInDiscards(self): return self.ifInDiscards
    def set_ifInDiscards(self, ifInDiscards): self.ifInDiscards = ifInDiscards
    def get_ifInErrors(self): return self.ifInErrors
    def set_ifInErrors(self, ifInErrors): self.ifInErrors = ifInErrors
    def get_ifInMulticastPkts(self): return self.ifInMulticastPkts
    def set_ifInMulticastPkts(self, ifInMulticastPkts): self.ifInMulticastPkts = ifInMulticastPkts
    def get_ifInOctets(self): return self.ifInOctets
    def set_ifInOctets(self, ifInOctets): self.ifInOctets = ifInOctets
    def get_ifInUcastPkts(self): return self.ifInUcastPkts
    def set_ifInUcastPkts(self, ifInUcastPkts): self.ifInUcastPkts = ifInUcastPkts
    def get_ifInUnknownProtos(self): return self.ifInUnknownProtos
    def set_ifInUnknownProtos(self, ifInUnknownProtos): self.ifInUnknownProtos = ifInUnknownProtos
    def get_ifMtu(self): return self.ifMtu
    def set_ifMtu(self, ifMtu): self.ifMtu = ifMtu
    def get_ifName(self): return self.ifName
    def set_ifName(self, ifName): self.ifName = ifName
    def get_ifOperStatus(self): return self.ifOperStatus
    def set_ifOperStatus(self, ifOperStatus): self.ifOperStatus = ifOperStatus
    def get_ifOutBroadcastPkts(self): return self.ifOutBroadcastPkts
    def set_ifOutBroadcastPkts(self, ifOutBroadcastPkts): self.ifOutBroadcastPkts = ifOutBroadcastPkts
    def get_ifOutDiscards(self): return self.ifOutDiscards
    def set_ifOutDiscards(self, ifOutDiscards): self.ifOutDiscards = ifOutDiscards
    def get_ifOutErrors(self): return self.ifOutErrors
    def set_ifOutErrors(self, ifOutErrors): self.ifOutErrors = ifOutErrors
    def get_ifOutMulticastPkts(self): return self.ifOutMulticastPkts
    def set_ifOutMulticastPkts(self, ifOutMulticastPkts): self.ifOutMulticastPkts = ifOutMulticastPkts
    def get_ifOutOctets(self): return self.ifOutOctets
    def set_ifOutOctets(self, ifOutOctets): self.ifOutOctets = ifOutOctets
    def get_ifOutUcastPkts(self): return self.ifOutUcastPkts
    def set_ifOutUcastPkts(self, ifOutUcastPkts): self.ifOutUcastPkts = ifOutUcastPkts
    def get_ifPromiscuousMode(self): return self.ifPromiscuousMode
    def set_ifPromiscuousMode(self, ifPromiscuousMode): self.ifPromiscuousMode = ifPromiscuousMode
    def get_ifSpeed(self): return self.ifSpeed
    def set_ifSpeed(self, ifSpeed): self.ifSpeed = ifSpeed
    def get_ifType(self): return self.ifType
    def set_ifType(self, ifType): self.ifType = ifType
    def get_IPAddrListLink(self): return self.IPAddrListLink
    def set_IPAddrListLink(self, IPAddrListLink): self.IPAddrListLink = IPAddrListLink
    def get_lastResetTime(self): return self.lastResetTime
    def set_lastResetTime(self, lastResetTime): self.lastResetTime = lastResetTime
    def get_lastUpdatedTime(self): return self.lastUpdatedTime
    def set_lastUpdatedTime(self, lastUpdatedTime): self.lastUpdatedTime = lastUpdatedTime
    def get_LLInterfaceListLink(self): return self.LLInterfaceListLink
    def set_LLInterfaceListLink(self, LLInterfaceListLink): self.LLInterfaceListLink = LLInterfaceListLink
    def validate_String192(self, value):
        # Validate type String192, a restriction on xs:string.
        pass
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def validate_String16(self, value):
        # Validate type String16, a restriction on xs:string.
        pass
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def validate_Int64(self, value):
        # Validate type Int64, a restriction on xs:long.
        pass
    def hasContent_(self):
        if (
            self.ifDescr is not None or
            self.ifHighSpeed is not None or
            self.ifInBroadcastPkts is not None or
            self.ifIndex is not None or
            self.ifInDiscards is not None or
            self.ifInErrors is not None or
            self.ifInMulticastPkts is not None or
            self.ifInOctets is not None or
            self.ifInUcastPkts is not None or
            self.ifInUnknownProtos is not None or
            self.ifMtu is not None or
            self.ifName is not None or
            self.ifOperStatus is not None or
            self.ifOutBroadcastPkts is not None or
            self.ifOutDiscards is not None or
            self.ifOutErrors is not None or
            self.ifOutMulticastPkts is not None or
            self.ifOutOctets is not None or
            self.ifOutUcastPkts is not None or
            self.ifPromiscuousMode is not None or
            self.ifSpeed is not None or
            self.ifType is not None or
            self.IPAddrListLink is not None or
            self.lastResetTime is not None or
            self.lastUpdatedTime is not None or
            self.LLInterfaceListLink is not None or
            super(IPInterface, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPInterface', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPInterface')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPInterface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPInterface'):
        super(IPInterface, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IPInterface')
    def exportChildren(self, outfile, level, namespace_='', name_='IPInterface', fromsubclass_=False, pretty_print=True):
        super(IPInterface, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ifDescr is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifDescr>%s</%sifDescr>%s' % (namespace_, self.gds_format_string(quote_xml(self.ifDescr).encode(ExternalEncoding), input_name='ifDescr'), namespace_, eol_))
        if self.ifHighSpeed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifHighSpeed>%s</%sifHighSpeed>%s' % (namespace_, self.gds_format_integer(self.ifHighSpeed, input_name='ifHighSpeed'), namespace_, eol_))
        if self.ifInBroadcastPkts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInBroadcastPkts>%s</%sifInBroadcastPkts>%s' % (namespace_, self.gds_format_integer(self.ifInBroadcastPkts, input_name='ifInBroadcastPkts'), namespace_, eol_))
        if self.ifIndex is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifIndex>%s</%sifIndex>%s' % (namespace_, self.gds_format_integer(self.ifIndex, input_name='ifIndex'), namespace_, eol_))
        if self.ifInDiscards is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInDiscards>%s</%sifInDiscards>%s' % (namespace_, self.gds_format_integer(self.ifInDiscards, input_name='ifInDiscards'), namespace_, eol_))
        if self.ifInErrors is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInErrors>%s</%sifInErrors>%s' % (namespace_, self.gds_format_integer(self.ifInErrors, input_name='ifInErrors'), namespace_, eol_))
        if self.ifInMulticastPkts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInMulticastPkts>%s</%sifInMulticastPkts>%s' % (namespace_, self.gds_format_integer(self.ifInMulticastPkts, input_name='ifInMulticastPkts'), namespace_, eol_))
        if self.ifInOctets is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInOctets>%s</%sifInOctets>%s' % (namespace_, self.gds_format_integer(self.ifInOctets, input_name='ifInOctets'), namespace_, eol_))
        if self.ifInUcastPkts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInUcastPkts>%s</%sifInUcastPkts>%s' % (namespace_, self.gds_format_integer(self.ifInUcastPkts, input_name='ifInUcastPkts'), namespace_, eol_))
        if self.ifInUnknownProtos is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInUnknownProtos>%s</%sifInUnknownProtos>%s' % (namespace_, self.gds_format_integer(self.ifInUnknownProtos, input_name='ifInUnknownProtos'), namespace_, eol_))
        if self.ifMtu is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifMtu>%s</%sifMtu>%s' % (namespace_, self.gds_format_integer(self.ifMtu, input_name='ifMtu'), namespace_, eol_))
        if self.ifName is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifName>%s</%sifName>%s' % (namespace_, self.gds_format_string(quote_xml(self.ifName).encode(ExternalEncoding), input_name='ifName'), namespace_, eol_))
        if self.ifOperStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOperStatus>%s</%sifOperStatus>%s' % (namespace_, self.gds_format_integer(self.ifOperStatus, input_name='ifOperStatus'), namespace_, eol_))
        if self.ifOutBroadcastPkts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutBroadcastPkts>%s</%sifOutBroadcastPkts>%s' % (namespace_, self.gds_format_integer(self.ifOutBroadcastPkts, input_name='ifOutBroadcastPkts'), namespace_, eol_))
        if self.ifOutDiscards is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutDiscards>%s</%sifOutDiscards>%s' % (namespace_, self.gds_format_integer(self.ifOutDiscards, input_name='ifOutDiscards'), namespace_, eol_))
        if self.ifOutErrors is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutErrors>%s</%sifOutErrors>%s' % (namespace_, self.gds_format_integer(self.ifOutErrors, input_name='ifOutErrors'), namespace_, eol_))
        if self.ifOutMulticastPkts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutMulticastPkts>%s</%sifOutMulticastPkts>%s' % (namespace_, self.gds_format_integer(self.ifOutMulticastPkts, input_name='ifOutMulticastPkts'), namespace_, eol_))
        if self.ifOutOctets is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutOctets>%s</%sifOutOctets>%s' % (namespace_, self.gds_format_integer(self.ifOutOctets, input_name='ifOutOctets'), namespace_, eol_))
        if self.ifOutUcastPkts is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutUcastPkts>%s</%sifOutUcastPkts>%s' % (namespace_, self.gds_format_integer(self.ifOutUcastPkts, input_name='ifOutUcastPkts'), namespace_, eol_))
        if self.ifPromiscuousMode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifPromiscuousMode>%s</%sifPromiscuousMode>%s' % (namespace_, self.gds_format_boolean(self.ifPromiscuousMode, input_name='ifPromiscuousMode'), namespace_, eol_))
        if self.ifSpeed is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifSpeed>%s</%sifSpeed>%s' % (namespace_, self.gds_format_integer(self.ifSpeed, input_name='ifSpeed'), namespace_, eol_))
        if self.ifType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifType>%s</%sifType>%s' % (namespace_, self.gds_format_integer(self.ifType, input_name='ifType'), namespace_, eol_))
        if self.IPAddrListLink is not None:
            self.IPAddrListLink.export(outfile, level, namespace_, name_='IPAddrListLink', pretty_print=pretty_print)
        if self.lastResetTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastResetTime>%s</%slastResetTime>%s' % (namespace_, self.gds_format_integer(self.lastResetTime, input_name='lastResetTime'), namespace_, eol_))
        if self.lastUpdatedTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastUpdatedTime>%s</%slastUpdatedTime>%s' % (namespace_, self.gds_format_integer(self.lastUpdatedTime, input_name='lastUpdatedTime'), namespace_, eol_))
        if self.LLInterfaceListLink is not None:
            self.LLInterfaceListLink.export(outfile, level, namespace_, name_='LLInterfaceListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IPInterface'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IPInterface, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IPInterface, self).exportLiteralChildren(outfile, level, name_)
        if self.ifDescr is not None:
            showIndent(outfile, level)
            outfile.write('ifDescr=%s,\n' % quote_python(self.ifDescr).encode(ExternalEncoding))
        if self.ifHighSpeed is not None:
            showIndent(outfile, level)
            outfile.write('ifHighSpeed=%d,\n' % self.ifHighSpeed)
        if self.ifInBroadcastPkts is not None:
            showIndent(outfile, level)
            outfile.write('ifInBroadcastPkts=%d,\n' % self.ifInBroadcastPkts)
        if self.ifIndex is not None:
            showIndent(outfile, level)
            outfile.write('ifIndex=%d,\n' % self.ifIndex)
        if self.ifInDiscards is not None:
            showIndent(outfile, level)
            outfile.write('ifInDiscards=%d,\n' % self.ifInDiscards)
        if self.ifInErrors is not None:
            showIndent(outfile, level)
            outfile.write('ifInErrors=%d,\n' % self.ifInErrors)
        if self.ifInMulticastPkts is not None:
            showIndent(outfile, level)
            outfile.write('ifInMulticastPkts=%d,\n' % self.ifInMulticastPkts)
        if self.ifInOctets is not None:
            showIndent(outfile, level)
            outfile.write('ifInOctets=%d,\n' % self.ifInOctets)
        if self.ifInUcastPkts is not None:
            showIndent(outfile, level)
            outfile.write('ifInUcastPkts=%d,\n' % self.ifInUcastPkts)
        if self.ifInUnknownProtos is not None:
            showIndent(outfile, level)
            outfile.write('ifInUnknownProtos=%d,\n' % self.ifInUnknownProtos)
        if self.ifMtu is not None:
            showIndent(outfile, level)
            outfile.write('ifMtu=%d,\n' % self.ifMtu)
        if self.ifName is not None:
            showIndent(outfile, level)
            outfile.write('ifName=%s,\n' % quote_python(self.ifName).encode(ExternalEncoding))
        if self.ifOperStatus is not None:
            showIndent(outfile, level)
            outfile.write('ifOperStatus=%d,\n' % self.ifOperStatus)
        if self.ifOutBroadcastPkts is not None:
            showIndent(outfile, level)
            outfile.write('ifOutBroadcastPkts=%d,\n' % self.ifOutBroadcastPkts)
        if self.ifOutDiscards is not None:
            showIndent(outfile, level)
            outfile.write('ifOutDiscards=%d,\n' % self.ifOutDiscards)
        if self.ifOutErrors is not None:
            showIndent(outfile, level)
            outfile.write('ifOutErrors=%d,\n' % self.ifOutErrors)
        if self.ifOutMulticastPkts is not None:
            showIndent(outfile, level)
            outfile.write('ifOutMulticastPkts=%d,\n' % self.ifOutMulticastPkts)
        if self.ifOutOctets is not None:
            showIndent(outfile, level)
            outfile.write('ifOutOctets=%d,\n' % self.ifOutOctets)
        if self.ifOutUcastPkts is not None:
            showIndent(outfile, level)
            outfile.write('ifOutUcastPkts=%d,\n' % self.ifOutUcastPkts)
        if self.ifPromiscuousMode is not None:
            showIndent(outfile, level)
            outfile.write('ifPromiscuousMode=%s,\n' % self.ifPromiscuousMode)
        if self.ifSpeed is not None:
            showIndent(outfile, level)
            outfile.write('ifSpeed=%d,\n' % self.ifSpeed)
        if self.ifType is not None:
            showIndent(outfile, level)
            outfile.write('ifType=%d,\n' % self.ifType)
        if self.IPAddrListLink is not None:
            showIndent(outfile, level)
            outfile.write('IPAddrListLink=model_.IPAddrListLink(\n')
            self.IPAddrListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.lastResetTime is not None:
            showIndent(outfile, level)
            outfile.write('lastResetTime=%d,\n' % self.lastResetTime)
        if self.lastUpdatedTime is not None:
            showIndent(outfile, level)
            outfile.write('lastUpdatedTime=%d,\n' % self.lastUpdatedTime)
        if self.LLInterfaceListLink is not None:
            showIndent(outfile, level)
            outfile.write('LLInterfaceListLink=model_.LLInterfaceListLink(\n')
            self.LLInterfaceListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IPInterface, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ifDescr':
            ifDescr_ = child_.text
            ifDescr_ = self.gds_validate_string(ifDescr_, node, 'ifDescr')
            self.ifDescr = ifDescr_
            self.validate_String192(self.ifDescr)    # validate type String192
        elif nodeName_ == 'ifHighSpeed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifHighSpeed')
            self.ifHighSpeed = ival_
            self.validate_UInt32(self.ifHighSpeed)    # validate type UInt32
        elif nodeName_ == 'ifInBroadcastPkts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifInBroadcastPkts')
            self.ifInBroadcastPkts = ival_
            self.validate_UInt32(self.ifInBroadcastPkts)    # validate type UInt32
        elif nodeName_ == 'ifIndex':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifIndex')
            self.ifIndex = ival_
            self.validate_UInt32(self.ifIndex)    # validate type UInt32
        elif nodeName_ == 'ifInDiscards':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifInDiscards')
            self.ifInDiscards = ival_
            self.validate_UInt32(self.ifInDiscards)    # validate type UInt32
        elif nodeName_ == 'ifInErrors':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifInErrors')
            self.ifInErrors = ival_
            self.validate_UInt32(self.ifInErrors)    # validate type UInt32
        elif nodeName_ == 'ifInMulticastPkts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifInMulticastPkts')
            self.ifInMulticastPkts = ival_
            self.validate_UInt32(self.ifInMulticastPkts)    # validate type UInt32
        elif nodeName_ == 'ifInOctets':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifInOctets')
            self.ifInOctets = ival_
            self.validate_UInt32(self.ifInOctets)    # validate type UInt32
        elif nodeName_ == 'ifInUcastPkts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifInUcastPkts')
            self.ifInUcastPkts = ival_
            self.validate_UInt32(self.ifInUcastPkts)    # validate type UInt32
        elif nodeName_ == 'ifInUnknownProtos':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifInUnknownProtos')
            self.ifInUnknownProtos = ival_
            self.validate_UInt32(self.ifInUnknownProtos)    # validate type UInt32
        elif nodeName_ == 'ifMtu':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifMtu')
            self.ifMtu = ival_
            self.validate_UInt32(self.ifMtu)    # validate type UInt32
        elif nodeName_ == 'ifName':
            ifName_ = child_.text
            ifName_ = self.gds_validate_string(ifName_, node, 'ifName')
            self.ifName = ifName_
            self.validate_String16(self.ifName)    # validate type String16
        elif nodeName_ == 'ifOperStatus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifOperStatus')
            self.ifOperStatus = ival_
            self.validate_UInt8(self.ifOperStatus)    # validate type UInt8
        elif nodeName_ == 'ifOutBroadcastPkts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutBroadcastPkts')
            self.ifOutBroadcastPkts = ival_
            self.validate_UInt32(self.ifOutBroadcastPkts)    # validate type UInt32
        elif nodeName_ == 'ifOutDiscards':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutDiscards')
            self.ifOutDiscards = ival_
            self.validate_UInt32(self.ifOutDiscards)    # validate type UInt32
        elif nodeName_ == 'ifOutErrors':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutErrors')
            self.ifOutErrors = ival_
            self.validate_UInt32(self.ifOutErrors)    # validate type UInt32
        elif nodeName_ == 'ifOutMulticastPkts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutMulticastPkts')
            self.ifOutMulticastPkts = ival_
            self.validate_UInt32(self.ifOutMulticastPkts)    # validate type UInt32
        elif nodeName_ == 'ifOutOctets':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutOctets')
            self.ifOutOctets = ival_
            self.validate_UInt32(self.ifOutOctets)    # validate type UInt32
        elif nodeName_ == 'ifOutUcastPkts':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutUcastPkts')
            self.ifOutUcastPkts = ival_
            self.validate_UInt32(self.ifOutUcastPkts)    # validate type UInt32
        elif nodeName_ == 'ifPromiscuousMode':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'ifPromiscuousMode')
            self.ifPromiscuousMode = ival_
        elif nodeName_ == 'ifSpeed':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifSpeed')
            self.ifSpeed = ival_
            self.validate_UInt32(self.ifSpeed)    # validate type UInt32
        elif nodeName_ == 'ifType':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'ifType')
            self.ifType = ival_
            self.validate_UInt16(self.ifType)    # validate type UInt16
        elif nodeName_ == 'IPAddrListLink':
            obj_ = IPAddrListLink.factory()
            obj_.build(child_)
            self.IPAddrListLink = obj_
            obj_.original_tagname_ = 'IPAddrListLink'
        elif nodeName_ == 'lastResetTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lastResetTime')
            self.lastResetTime = ival_
            self.validate_Int64(self.lastResetTime)    # validate type Int64
        elif nodeName_ == 'lastUpdatedTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'lastUpdatedTime')
            self.lastUpdatedTime = ival_
            self.validate_Int64(self.lastUpdatedTime)    # validate type Int64
        elif nodeName_ == 'LLInterfaceListLink':
            obj_ = LLInterfaceListLink.factory()
            obj_.build(child_)
            self.LLInterfaceListLink = obj_
            obj_.original_tagname_ = 'LLInterfaceListLink'
        super(IPInterface, self).buildChildren(child_, node, nodeName_, True)
# end class IPInterface


class IPAddrList(List):
    """List of IPAddr instances."""
    subclass = None
    superclass = List
    def __init__(self, IPAddr=None):
        self.original_tagname_ = None
        super(IPAddrList, self).__init__()
        if IPAddr is None:
            self.IPAddr = []
        else:
            self.IPAddr = IPAddr
    def factory(*args_, **kwargs_):
        if IPAddrList.subclass:
            return IPAddrList.subclass(*args_, **kwargs_)
        else:
            return IPAddrList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IPAddr(self): return self.IPAddr
    def set_IPAddr(self, IPAddr): self.IPAddr = IPAddr
    def add_IPAddr(self, value): self.IPAddr.append(value)
    def insert_IPAddr_at(self, index, value): self.IPAddr.insert(index, value)
    def replace_IPAddr_at(self, index, value): self.IPAddr[index] = value
    def hasContent_(self):
        if (
            self.IPAddr or
            super(IPAddrList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPAddrList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddrList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPAddrList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPAddrList'):
        super(IPAddrList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddrList')
    def exportChildren(self, outfile, level, namespace_='', name_='IPAddrList', fromsubclass_=False, pretty_print=True):
        super(IPAddrList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IPAddr_ in self.IPAddr:
            IPAddr_.export(outfile, level, namespace_, name_='IPAddr', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IPAddrList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IPAddrList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IPAddrList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IPAddr=[\n')
        level += 1
        for IPAddr_ in self.IPAddr:
            showIndent(outfile, level)
            outfile.write('model_.IPAddr(\n')
            IPAddr_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IPAddrList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IPAddr':
            obj_ = IPAddr.factory()
            obj_.build(child_)
            self.IPAddr.append(obj_)
            obj_.original_tagname_ = 'IPAddr'
        super(IPAddrList, self).buildChildren(child_, node, nodeName_, True)
# end class IPAddrList


class IPAddr(Resource):
    """An Internet Protocol address object."""
    subclass = None
    superclass = Resource
    def __init__(self, address=None, RPLInstanceListLink=None):
        self.original_tagname_ = None
        super(IPAddr, self).__init__()
        self.address = address
        self.RPLInstanceListLink = RPLInstanceListLink
    def factory(*args_, **kwargs_):
        if IPAddr.subclass:
            return IPAddr.subclass(*args_, **kwargs_)
        else:
            return IPAddr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_address(self): return self.address
    def set_address(self, address): self.address = address
    def get_RPLInstanceListLink(self): return self.RPLInstanceListLink
    def set_RPLInstanceListLink(self, RPLInstanceListLink): self.RPLInstanceListLink = RPLInstanceListLink
    def validate_HexBinary128(self, value):
        # Validate type HexBinary128, a restriction on xs:hexBinary.
        pass
    def hasContent_(self):
        if (
            self.address is not None or
            self.RPLInstanceListLink is not None or
            super(IPAddr, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IPAddr', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddr')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IPAddr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IPAddr'):
        super(IPAddr, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IPAddr')
    def exportChildren(self, outfile, level, namespace_='', name_='IPAddr', fromsubclass_=False, pretty_print=True):
        super(IPAddr, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespace_, self.gds_format_string(quote_xml(self.address).encode(ExternalEncoding), input_name='address'), namespace_, eol_))
        if self.RPLInstanceListLink is not None:
            self.RPLInstanceListLink.export(outfile, level, namespace_, name_='RPLInstanceListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IPAddr'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(IPAddr, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IPAddr, self).exportLiteralChildren(outfile, level, name_)
        if self.address is not None:
            showIndent(outfile, level)
            outfile.write('address=%s,\n' % quote_python(self.address).encode(ExternalEncoding))
        if self.RPLInstanceListLink is not None:
            showIndent(outfile, level)
            outfile.write('RPLInstanceListLink=model_.RPLInstanceListLink(\n')
            self.RPLInstanceListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(IPAddr, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'address':
            address_ = child_.text
            address_ = self.gds_validate_string(address_, node, 'address')
            self.address = address_
            self.validate_HexBinary128(self.address)    # validate type HexBinary128
        elif nodeName_ == 'RPLInstanceListLink':
            obj_ = RPLInstanceListLink.factory()
            obj_.build(child_)
            self.RPLInstanceListLink = obj_
            obj_.original_tagname_ = 'RPLInstanceListLink'
        super(IPAddr, self).buildChildren(child_, node, nodeName_, True)
# end class IPAddr


class PowerStatus(Resource):
    """Contains the status of the device's power sources"""
    subclass = None
    superclass = Resource
    def __init__(self, batteryStatus=None, changedTime=None, currentPowerSource=None, estimatedChargeRemaining=None, estimatedTimeRemaining=None, PEVInfo=None, sessionTimeOnBattery=None, totalTimeOnBattery=None):
        self.original_tagname_ = None
        super(PowerStatus, self).__init__()
        self.batteryStatus = batteryStatus
        self.changedTime = changedTime
        self.currentPowerSource = currentPowerSource
        self.estimatedChargeRemaining = estimatedChargeRemaining
        self.estimatedTimeRemaining = estimatedTimeRemaining
        self.PEVInfo = PEVInfo
        self.sessionTimeOnBattery = sessionTimeOnBattery
        self.totalTimeOnBattery = totalTimeOnBattery
    def factory(*args_, **kwargs_):
        if PowerStatus.subclass:
            return PowerStatus.subclass(*args_, **kwargs_)
        else:
            return PowerStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_batteryStatus(self): return self.batteryStatus
    def set_batteryStatus(self, batteryStatus): self.batteryStatus = batteryStatus
    def get_changedTime(self): return self.changedTime
    def set_changedTime(self, changedTime): self.changedTime = changedTime
    def get_currentPowerSource(self): return self.currentPowerSource
    def set_currentPowerSource(self, currentPowerSource): self.currentPowerSource = currentPowerSource
    def get_estimatedChargeRemaining(self): return self.estimatedChargeRemaining
    def set_estimatedChargeRemaining(self, estimatedChargeRemaining): self.estimatedChargeRemaining = estimatedChargeRemaining
    def get_estimatedTimeRemaining(self): return self.estimatedTimeRemaining
    def set_estimatedTimeRemaining(self, estimatedTimeRemaining): self.estimatedTimeRemaining = estimatedTimeRemaining
    def get_PEVInfo(self): return self.PEVInfo
    def set_PEVInfo(self, PEVInfo): self.PEVInfo = PEVInfo
    def get_sessionTimeOnBattery(self): return self.sessionTimeOnBattery
    def set_sessionTimeOnBattery(self, sessionTimeOnBattery): self.sessionTimeOnBattery = sessionTimeOnBattery
    def get_totalTimeOnBattery(self): return self.totalTimeOnBattery
    def set_totalTimeOnBattery(self, totalTimeOnBattery): self.totalTimeOnBattery = totalTimeOnBattery
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def hasContent_(self):
        if (
            self.batteryStatus is not None or
            self.changedTime is not None or
            self.currentPowerSource is not None or
            self.estimatedChargeRemaining is not None or
            self.estimatedTimeRemaining is not None or
            self.PEVInfo is not None or
            self.sessionTimeOnBattery is not None or
            self.totalTimeOnBattery is not None or
            super(PowerStatus, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PowerStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PowerStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PowerStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PowerStatus'):
        super(PowerStatus, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PowerStatus')
    def exportChildren(self, outfile, level, namespace_='', name_='PowerStatus', fromsubclass_=False, pretty_print=True):
        super(PowerStatus, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.batteryStatus is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbatteryStatus>%s</%sbatteryStatus>%s' % (namespace_, self.gds_format_integer(self.batteryStatus, input_name='batteryStatus'), namespace_, eol_))
        if self.changedTime is not None:
            self.changedTime.export(outfile, level, namespace_, name_='changedTime', pretty_print=pretty_print)
        if self.currentPowerSource is not None:
            self.currentPowerSource.export(outfile, level, namespace_, name_='currentPowerSource', pretty_print=pretty_print)
        if self.estimatedChargeRemaining is not None:
            self.estimatedChargeRemaining.export(outfile, level, namespace_, name_='estimatedChargeRemaining', pretty_print=pretty_print)
        if self.estimatedTimeRemaining is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sestimatedTimeRemaining>%s</%sestimatedTimeRemaining>%s' % (namespace_, self.gds_format_integer(self.estimatedTimeRemaining, input_name='estimatedTimeRemaining'), namespace_, eol_))
        if self.PEVInfo is not None:
            self.PEVInfo.export(outfile, level, namespace_, name_='PEVInfo', pretty_print=pretty_print)
        if self.sessionTimeOnBattery is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssessionTimeOnBattery>%s</%ssessionTimeOnBattery>%s' % (namespace_, self.gds_format_integer(self.sessionTimeOnBattery, input_name='sessionTimeOnBattery'), namespace_, eol_))
        if self.totalTimeOnBattery is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalTimeOnBattery>%s</%stotalTimeOnBattery>%s' % (namespace_, self.gds_format_integer(self.totalTimeOnBattery, input_name='totalTimeOnBattery'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PowerStatus'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PowerStatus, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PowerStatus, self).exportLiteralChildren(outfile, level, name_)
        if self.batteryStatus is not None:
            showIndent(outfile, level)
            outfile.write('batteryStatus=%d,\n' % self.batteryStatus)
        if self.changedTime is not None:
            showIndent(outfile, level)
            outfile.write('changedTime=model_.TimeType(\n')
            self.changedTime.exportLiteral(outfile, level, name_='changedTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.currentPowerSource is not None:
            showIndent(outfile, level)
            outfile.write('currentPowerSource=model_.PowerSourceType(\n')
            self.currentPowerSource.exportLiteral(outfile, level, name_='currentPowerSource')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.estimatedChargeRemaining is not None:
            showIndent(outfile, level)
            outfile.write('estimatedChargeRemaining=model_.PerCent(\n')
            self.estimatedChargeRemaining.exportLiteral(outfile, level, name_='estimatedChargeRemaining')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.estimatedTimeRemaining is not None:
            showIndent(outfile, level)
            outfile.write('estimatedTimeRemaining=%d,\n' % self.estimatedTimeRemaining)
        if self.PEVInfo is not None:
            showIndent(outfile, level)
            outfile.write('PEVInfo=model_.PEVInfo(\n')
            self.PEVInfo.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sessionTimeOnBattery is not None:
            showIndent(outfile, level)
            outfile.write('sessionTimeOnBattery=%d,\n' % self.sessionTimeOnBattery)
        if self.totalTimeOnBattery is not None:
            showIndent(outfile, level)
            outfile.write('totalTimeOnBattery=%d,\n' % self.totalTimeOnBattery)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PowerStatus, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'batteryStatus':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'batteryStatus')
            self.batteryStatus = ival_
            self.validate_UInt8(self.batteryStatus)    # validate type UInt8
        elif nodeName_ == 'changedTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.changedTime = obj_
            obj_.original_tagname_ = 'changedTime'
        elif nodeName_ == 'currentPowerSource':
            obj_ = PowerSourceType.factory()
            obj_.build(child_)
            self.currentPowerSource = obj_
            obj_.original_tagname_ = 'currentPowerSource'
        elif nodeName_ == 'estimatedChargeRemaining':
            obj_ = PerCent.factory()
            obj_.build(child_)
            self.estimatedChargeRemaining = obj_
            obj_.original_tagname_ = 'estimatedChargeRemaining'
        elif nodeName_ == 'estimatedTimeRemaining':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'estimatedTimeRemaining')
            self.estimatedTimeRemaining = ival_
            self.validate_UInt32(self.estimatedTimeRemaining)    # validate type UInt32
        elif nodeName_ == 'PEVInfo':
            obj_ = PEVInfo.factory()
            obj_.build(child_)
            self.PEVInfo = obj_
            obj_.original_tagname_ = 'PEVInfo'
        elif nodeName_ == 'sessionTimeOnBattery':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'sessionTimeOnBattery')
            self.sessionTimeOnBattery = ival_
            self.validate_UInt32(self.sessionTimeOnBattery)    # validate type UInt32
        elif nodeName_ == 'totalTimeOnBattery':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'totalTimeOnBattery')
            self.totalTimeOnBattery = ival_
            self.validate_UInt32(self.totalTimeOnBattery)    # validate type UInt32
        super(PowerStatus, self).buildChildren(child_, node, nodeName_, True)
# end class PowerStatus


class SupportedLocaleList(List):
    """A List element to hold SupportedLocale objects."""
    subclass = None
    superclass = List
    def __init__(self, SupportedLocale=None):
        self.original_tagname_ = None
        super(SupportedLocaleList, self).__init__()
        if SupportedLocale is None:
            self.SupportedLocale = []
        else:
            self.SupportedLocale = SupportedLocale
    def factory(*args_, **kwargs_):
        if SupportedLocaleList.subclass:
            return SupportedLocaleList.subclass(*args_, **kwargs_)
        else:
            return SupportedLocaleList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SupportedLocale(self): return self.SupportedLocale
    def set_SupportedLocale(self, SupportedLocale): self.SupportedLocale = SupportedLocale
    def add_SupportedLocale(self, value): self.SupportedLocale.append(value)
    def insert_SupportedLocale_at(self, index, value): self.SupportedLocale.insert(index, value)
    def replace_SupportedLocale_at(self, index, value): self.SupportedLocale[index] = value
    def hasContent_(self):
        if (
            self.SupportedLocale or
            super(SupportedLocaleList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportedLocaleList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedLocaleList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportedLocaleList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportedLocaleList'):
        super(SupportedLocaleList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedLocaleList')
    def exportChildren(self, outfile, level, namespace_='', name_='SupportedLocaleList', fromsubclass_=False, pretty_print=True):
        super(SupportedLocaleList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SupportedLocale_ in self.SupportedLocale:
            SupportedLocale_.export(outfile, level, namespace_, name_='SupportedLocale', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SupportedLocaleList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SupportedLocaleList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SupportedLocaleList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SupportedLocale=[\n')
        level += 1
        for SupportedLocale_ in self.SupportedLocale:
            showIndent(outfile, level)
            outfile.write('model_.SupportedLocale(\n')
            SupportedLocale_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SupportedLocaleList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SupportedLocale':
            obj_ = SupportedLocale.factory()
            obj_.build(child_)
            self.SupportedLocale.append(obj_)
            obj_.original_tagname_ = 'SupportedLocale'
        super(SupportedLocaleList, self).buildChildren(child_, node, nodeName_, True)
# end class SupportedLocaleList


class SupportedLocale(Resource):
    """Specifies a locale that is supported"""
    subclass = None
    superclass = Resource
    def __init__(self, locale=None):
        self.original_tagname_ = None
        super(SupportedLocale, self).__init__()
        self.locale = locale
    def factory(*args_, **kwargs_):
        if SupportedLocale.subclass:
            return SupportedLocale.subclass(*args_, **kwargs_)
        else:
            return SupportedLocale(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_locale(self): return self.locale
    def set_locale(self, locale): self.locale = locale
    def hasContent_(self):
        if (
            self.locale is not None or
            super(SupportedLocale, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SupportedLocale', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedLocale')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SupportedLocale', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SupportedLocale'):
        super(SupportedLocale, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SupportedLocale')
    def exportChildren(self, outfile, level, namespace_='', name_='SupportedLocale', fromsubclass_=False, pretty_print=True):
        super(SupportedLocale, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.locale is not None:
            self.locale.export(outfile, level, namespace_, name_='locale', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SupportedLocale'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SupportedLocale, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SupportedLocale, self).exportLiteralChildren(outfile, level, name_)
        if self.locale is not None:
            showIndent(outfile, level)
            outfile.write('locale=model_.LocaleType(\n')
            self.locale.exportLiteral(outfile, level, name_='locale')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SupportedLocale, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'locale':
            obj_ = LocaleType.factory()
            obj_.build(child_)
            self.locale = obj_
            obj_.original_tagname_ = 'locale'
        super(SupportedLocale, self).buildChildren(child_, node, nodeName_, True)
# end class SupportedLocale


class DeviceInformation(Resource):
    """Contains identification and other information about the device that
    changes very infrequently, typically only when updates are
    applied, if ever."""
    subclass = None
    superclass = Resource
    def __init__(self, DRLCCapabilities=None, functionsImplemented=None, lFDI=None, mfDate=None, mfHwVer=None, mfID=None, mfInfo=None, mfModel=None, mfSerNum=None, primaryPower=None, secondaryPower=None, SupportedLocaleListLink=None, swActTime=None, swVer=None):
        self.original_tagname_ = None
        super(DeviceInformation, self).__init__()
        self.DRLCCapabilities = DRLCCapabilities
        self.functionsImplemented = functionsImplemented
        self.lFDI = lFDI
        self.mfDate = mfDate
        self.mfHwVer = mfHwVer
        self.mfID = mfID
        self.mfInfo = mfInfo
        self.mfModel = mfModel
        self.mfSerNum = mfSerNum
        self.primaryPower = primaryPower
        self.secondaryPower = secondaryPower
        self.SupportedLocaleListLink = SupportedLocaleListLink
        self.swActTime = swActTime
        self.swVer = swVer
    def factory(*args_, **kwargs_):
        if DeviceInformation.subclass:
            return DeviceInformation.subclass(*args_, **kwargs_)
        else:
            return DeviceInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DRLCCapabilities(self): return self.DRLCCapabilities
    def set_DRLCCapabilities(self, DRLCCapabilities): self.DRLCCapabilities = DRLCCapabilities
    def get_functionsImplemented(self): return self.functionsImplemented
    def set_functionsImplemented(self, functionsImplemented): self.functionsImplemented = functionsImplemented
    def get_lFDI(self): return self.lFDI
    def set_lFDI(self, lFDI): self.lFDI = lFDI
    def get_mfDate(self): return self.mfDate
    def set_mfDate(self, mfDate): self.mfDate = mfDate
    def get_mfHwVer(self): return self.mfHwVer
    def set_mfHwVer(self, mfHwVer): self.mfHwVer = mfHwVer
    def get_mfID(self): return self.mfID
    def set_mfID(self, mfID): self.mfID = mfID
    def get_mfInfo(self): return self.mfInfo
    def set_mfInfo(self, mfInfo): self.mfInfo = mfInfo
    def get_mfModel(self): return self.mfModel
    def set_mfModel(self, mfModel): self.mfModel = mfModel
    def get_mfSerNum(self): return self.mfSerNum
    def set_mfSerNum(self, mfSerNum): self.mfSerNum = mfSerNum
    def get_primaryPower(self): return self.primaryPower
    def set_primaryPower(self, primaryPower): self.primaryPower = primaryPower
    def get_secondaryPower(self): return self.secondaryPower
    def set_secondaryPower(self, secondaryPower): self.secondaryPower = secondaryPower
    def get_SupportedLocaleListLink(self): return self.SupportedLocaleListLink
    def set_SupportedLocaleListLink(self, SupportedLocaleListLink): self.SupportedLocaleListLink = SupportedLocaleListLink
    def get_swActTime(self): return self.swActTime
    def set_swActTime(self, swActTime): self.swActTime = swActTime
    def get_swVer(self): return self.swVer
    def set_swVer(self, swVer): self.swVer = swVer
    def validate_HexBinary64(self, value):
        # Validate type HexBinary64, a restriction on xs:hexBinary.
        pass
    def validate_HexBinary160(self, value):
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        pass
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DRLCCapabilities is not None or
            self.functionsImplemented is not None or
            self.lFDI is not None or
            self.mfDate is not None or
            self.mfHwVer is not None or
            self.mfID is not None or
            self.mfInfo is not None or
            self.mfModel is not None or
            self.mfSerNum is not None or
            self.primaryPower is not None or
            self.secondaryPower is not None or
            self.SupportedLocaleListLink is not None or
            self.swActTime is not None or
            self.swVer is not None or
            super(DeviceInformation, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceInformation', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceInformation')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeviceInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceInformation'):
        super(DeviceInformation, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceInformation')
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceInformation', fromsubclass_=False, pretty_print=True):
        super(DeviceInformation, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DRLCCapabilities is not None:
            self.DRLCCapabilities.export(outfile, level, namespace_, name_='DRLCCapabilities', pretty_print=pretty_print)
        if self.functionsImplemented is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfunctionsImplemented>%s</%sfunctionsImplemented>%s' % (namespace_, self.gds_format_string(quote_xml(self.functionsImplemented).encode(ExternalEncoding), input_name='functionsImplemented'), namespace_, eol_))
        if self.lFDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slFDI>%s</%slFDI>%s' % (namespace_, self.gds_format_string(quote_xml(self.lFDI).encode(ExternalEncoding), input_name='lFDI'), namespace_, eol_))
        if self.mfDate is not None:
            self.mfDate.export(outfile, level, namespace_, name_='mfDate', pretty_print=pretty_print)
        if self.mfHwVer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfHwVer>%s</%smfHwVer>%s' % (namespace_, self.gds_format_string(quote_xml(self.mfHwVer).encode(ExternalEncoding), input_name='mfHwVer'), namespace_, eol_))
        if self.mfID is not None:
            self.mfID.export(outfile, level, namespace_, name_='mfID', pretty_print=pretty_print)
        if self.mfInfo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfInfo>%s</%smfInfo>%s' % (namespace_, self.gds_format_string(quote_xml(self.mfInfo).encode(ExternalEncoding), input_name='mfInfo'), namespace_, eol_))
        if self.mfModel is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfModel>%s</%smfModel>%s' % (namespace_, self.gds_format_string(quote_xml(self.mfModel).encode(ExternalEncoding), input_name='mfModel'), namespace_, eol_))
        if self.mfSerNum is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfSerNum>%s</%smfSerNum>%s' % (namespace_, self.gds_format_string(quote_xml(self.mfSerNum).encode(ExternalEncoding), input_name='mfSerNum'), namespace_, eol_))
        if self.primaryPower is not None:
            self.primaryPower.export(outfile, level, namespace_, name_='primaryPower', pretty_print=pretty_print)
        if self.secondaryPower is not None:
            self.secondaryPower.export(outfile, level, namespace_, name_='secondaryPower', pretty_print=pretty_print)
        if self.SupportedLocaleListLink is not None:
            self.SupportedLocaleListLink.export(outfile, level, namespace_, name_='SupportedLocaleListLink', pretty_print=pretty_print)
        if self.swActTime is not None:
            self.swActTime.export(outfile, level, namespace_, name_='swActTime', pretty_print=pretty_print)
        if self.swVer is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sswVer>%s</%sswVer>%s' % (namespace_, self.gds_format_string(quote_xml(self.swVer).encode(ExternalEncoding), input_name='swVer'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DeviceInformation'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DeviceInformation, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeviceInformation, self).exportLiteralChildren(outfile, level, name_)
        if self.DRLCCapabilities is not None:
            showIndent(outfile, level)
            outfile.write('DRLCCapabilities=model_.DRLCCapabilities(\n')
            self.DRLCCapabilities.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.functionsImplemented is not None:
            showIndent(outfile, level)
            outfile.write('functionsImplemented=%s,\n' % quote_python(self.functionsImplemented).encode(ExternalEncoding))
        if self.lFDI is not None:
            showIndent(outfile, level)
            outfile.write('lFDI=%s,\n' % quote_python(self.lFDI).encode(ExternalEncoding))
        if self.mfDate is not None:
            showIndent(outfile, level)
            outfile.write('mfDate=model_.TimeType(\n')
            self.mfDate.exportLiteral(outfile, level, name_='mfDate')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mfHwVer is not None:
            showIndent(outfile, level)
            outfile.write('mfHwVer=%s,\n' % quote_python(self.mfHwVer).encode(ExternalEncoding))
        if self.mfID is not None:
            showIndent(outfile, level)
            outfile.write('mfID=model_.PENType(\n')
            self.mfID.exportLiteral(outfile, level, name_='mfID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.mfInfo is not None:
            showIndent(outfile, level)
            outfile.write('mfInfo=%s,\n' % quote_python(self.mfInfo).encode(ExternalEncoding))
        if self.mfModel is not None:
            showIndent(outfile, level)
            outfile.write('mfModel=%s,\n' % quote_python(self.mfModel).encode(ExternalEncoding))
        if self.mfSerNum is not None:
            showIndent(outfile, level)
            outfile.write('mfSerNum=%s,\n' % quote_python(self.mfSerNum).encode(ExternalEncoding))
        if self.primaryPower is not None:
            showIndent(outfile, level)
            outfile.write('primaryPower=model_.PowerSourceType(\n')
            self.primaryPower.exportLiteral(outfile, level, name_='primaryPower')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.secondaryPower is not None:
            showIndent(outfile, level)
            outfile.write('secondaryPower=model_.PowerSourceType(\n')
            self.secondaryPower.exportLiteral(outfile, level, name_='secondaryPower')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SupportedLocaleListLink is not None:
            showIndent(outfile, level)
            outfile.write('SupportedLocaleListLink=model_.SupportedLocaleListLink(\n')
            self.SupportedLocaleListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.swActTime is not None:
            showIndent(outfile, level)
            outfile.write('swActTime=model_.TimeType(\n')
            self.swActTime.exportLiteral(outfile, level, name_='swActTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.swVer is not None:
            showIndent(outfile, level)
            outfile.write('swVer=%s,\n' % quote_python(self.swVer).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DeviceInformation, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DRLCCapabilities':
            obj_ = DRLCCapabilities.factory()
            obj_.build(child_)
            self.DRLCCapabilities = obj_
            obj_.original_tagname_ = 'DRLCCapabilities'
        elif nodeName_ == 'functionsImplemented':
            functionsImplemented_ = child_.text
            functionsImplemented_ = self.gds_validate_string(functionsImplemented_, node, 'functionsImplemented')
            self.functionsImplemented = functionsImplemented_
            self.validate_HexBinary64(self.functionsImplemented)    # validate type HexBinary64
        elif nodeName_ == 'lFDI':
            lFDI_ = child_.text
            lFDI_ = self.gds_validate_string(lFDI_, node, 'lFDI')
            self.lFDI = lFDI_
            self.validate_HexBinary160(self.lFDI)    # validate type HexBinary160
        elif nodeName_ == 'mfDate':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.mfDate = obj_
            obj_.original_tagname_ = 'mfDate'
        elif nodeName_ == 'mfHwVer':
            mfHwVer_ = child_.text
            mfHwVer_ = self.gds_validate_string(mfHwVer_, node, 'mfHwVer')
            self.mfHwVer = mfHwVer_
            self.validate_String32(self.mfHwVer)    # validate type String32
        elif nodeName_ == 'mfID':
            obj_ = PENType.factory()
            obj_.build(child_)
            self.mfID = obj_
            obj_.original_tagname_ = 'mfID'
        elif nodeName_ == 'mfInfo':
            mfInfo_ = child_.text
            mfInfo_ = self.gds_validate_string(mfInfo_, node, 'mfInfo')
            self.mfInfo = mfInfo_
            self.validate_String32(self.mfInfo)    # validate type String32
        elif nodeName_ == 'mfModel':
            mfModel_ = child_.text
            mfModel_ = self.gds_validate_string(mfModel_, node, 'mfModel')
            self.mfModel = mfModel_
            self.validate_String32(self.mfModel)    # validate type String32
        elif nodeName_ == 'mfSerNum':
            mfSerNum_ = child_.text
            mfSerNum_ = self.gds_validate_string(mfSerNum_, node, 'mfSerNum')
            self.mfSerNum = mfSerNum_
            self.validate_String32(self.mfSerNum)    # validate type String32
        elif nodeName_ == 'primaryPower':
            obj_ = PowerSourceType.factory()
            obj_.build(child_)
            self.primaryPower = obj_
            obj_.original_tagname_ = 'primaryPower'
        elif nodeName_ == 'secondaryPower':
            obj_ = PowerSourceType.factory()
            obj_.build(child_)
            self.secondaryPower = obj_
            obj_.original_tagname_ = 'secondaryPower'
        elif nodeName_ == 'SupportedLocaleListLink':
            obj_ = SupportedLocaleListLink.factory()
            obj_.build(child_)
            self.SupportedLocaleListLink = obj_
            obj_.original_tagname_ = 'SupportedLocaleListLink'
        elif nodeName_ == 'swActTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.swActTime = obj_
            obj_.original_tagname_ = 'swActTime'
        elif nodeName_ == 'swVer':
            swVer_ = child_.text
            swVer_ = self.gds_validate_string(swVer_, node, 'swVer')
            self.swVer = swVer_
            self.validate_String32(self.swVer)    # validate type String32
        super(DeviceInformation, self).buildChildren(child_, node, nodeName_, True)
# end class DeviceInformation


class Time(Resource):
    """Contains the representation of time, constantly updated."""
    subclass = None
    superclass = Resource
    def __init__(self, currentTime=None, dstEndTime=None, dstOffset=None, dstStartTime=None, localTime=None, quality=None, tzOffset=None):
        self.original_tagname_ = None
        super(Time, self).__init__()
        self.currentTime = currentTime
        self.dstEndTime = dstEndTime
        self.dstOffset = dstOffset
        self.dstStartTime = dstStartTime
        self.localTime = localTime
        self.quality = quality
        self.tzOffset = tzOffset
    def factory(*args_, **kwargs_):
        if Time.subclass:
            return Time.subclass(*args_, **kwargs_)
        else:
            return Time(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_currentTime(self): return self.currentTime
    def set_currentTime(self, currentTime): self.currentTime = currentTime
    def get_dstEndTime(self): return self.dstEndTime
    def set_dstEndTime(self, dstEndTime): self.dstEndTime = dstEndTime
    def get_dstOffset(self): return self.dstOffset
    def set_dstOffset(self, dstOffset): self.dstOffset = dstOffset
    def get_dstStartTime(self): return self.dstStartTime
    def set_dstStartTime(self, dstStartTime): self.dstStartTime = dstStartTime
    def get_localTime(self): return self.localTime
    def set_localTime(self, localTime): self.localTime = localTime
    def get_quality(self): return self.quality
    def set_quality(self, quality): self.quality = quality
    def get_tzOffset(self): return self.tzOffset
    def set_tzOffset(self, tzOffset): self.tzOffset = tzOffset
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.currentTime is not None or
            self.dstEndTime is not None or
            self.dstOffset is not None or
            self.dstStartTime is not None or
            self.localTime is not None or
            self.quality is not None or
            self.tzOffset is not None or
            super(Time, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Time', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Time')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Time', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Time'):
        super(Time, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Time')
    def exportChildren(self, outfile, level, namespace_='', name_='Time', fromsubclass_=False, pretty_print=True):
        super(Time, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentTime is not None:
            self.currentTime.export(outfile, level, namespace_, name_='currentTime', pretty_print=pretty_print)
        if self.dstEndTime is not None:
            self.dstEndTime.export(outfile, level, namespace_, name_='dstEndTime', pretty_print=pretty_print)
        if self.dstOffset is not None:
            self.dstOffset.export(outfile, level, namespace_, name_='dstOffset', pretty_print=pretty_print)
        if self.dstStartTime is not None:
            self.dstStartTime.export(outfile, level, namespace_, name_='dstStartTime', pretty_print=pretty_print)
        if self.localTime is not None:
            self.localTime.export(outfile, level, namespace_, name_='localTime', pretty_print=pretty_print)
        if self.quality is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squality>%s</%squality>%s' % (namespace_, self.gds_format_integer(self.quality, input_name='quality'), namespace_, eol_))
        if self.tzOffset is not None:
            self.tzOffset.export(outfile, level, namespace_, name_='tzOffset', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Time'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Time, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Time, self).exportLiteralChildren(outfile, level, name_)
        if self.currentTime is not None:
            showIndent(outfile, level)
            outfile.write('currentTime=model_.TimeType(\n')
            self.currentTime.exportLiteral(outfile, level, name_='currentTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dstEndTime is not None:
            showIndent(outfile, level)
            outfile.write('dstEndTime=model_.TimeType(\n')
            self.dstEndTime.exportLiteral(outfile, level, name_='dstEndTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dstOffset is not None:
            showIndent(outfile, level)
            outfile.write('dstOffset=model_.TimeOffsetType(\n')
            self.dstOffset.exportLiteral(outfile, level, name_='dstOffset')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.dstStartTime is not None:
            showIndent(outfile, level)
            outfile.write('dstStartTime=model_.TimeType(\n')
            self.dstStartTime.exportLiteral(outfile, level, name_='dstStartTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.localTime is not None:
            showIndent(outfile, level)
            outfile.write('localTime=model_.TimeType(\n')
            self.localTime.exportLiteral(outfile, level, name_='localTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.quality is not None:
            showIndent(outfile, level)
            outfile.write('quality=%d,\n' % self.quality)
        if self.tzOffset is not None:
            showIndent(outfile, level)
            outfile.write('tzOffset=model_.TimeOffsetType(\n')
            self.tzOffset.exportLiteral(outfile, level, name_='tzOffset')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Time, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'currentTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.currentTime = obj_
            obj_.original_tagname_ = 'currentTime'
        elif nodeName_ == 'dstEndTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dstEndTime = obj_
            obj_.original_tagname_ = 'dstEndTime'
        elif nodeName_ == 'dstOffset':
            obj_ = TimeOffsetType.factory()
            obj_.build(child_)
            self.dstOffset = obj_
            obj_.original_tagname_ = 'dstOffset'
        elif nodeName_ == 'dstStartTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dstStartTime = obj_
            obj_.original_tagname_ = 'dstStartTime'
        elif nodeName_ == 'localTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.localTime = obj_
            obj_.original_tagname_ = 'localTime'
        elif nodeName_ == 'quality':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'quality')
            self.quality = ival_
            self.validate_UInt8(self.quality)    # validate type UInt8
        elif nodeName_ == 'tzOffset':
            obj_ = TimeOffsetType.factory()
            obj_.build(child_)
            self.tzOffset = obj_
            obj_.original_tagname_ = 'tzOffset'
        super(Time, self).buildChildren(child_, node, nodeName_, True)
# end class Time


class ResponseSetList(List):
    """A List element to hold ResponseSet objects."""
    subclass = None
    superclass = List
    def __init__(self, ResponseSet=None):
        self.original_tagname_ = None
        super(ResponseSetList, self).__init__()
        if ResponseSet is None:
            self.ResponseSet = []
        else:
            self.ResponseSet = ResponseSet
    def factory(*args_, **kwargs_):
        if ResponseSetList.subclass:
            return ResponseSetList.subclass(*args_, **kwargs_)
        else:
            return ResponseSetList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResponseSet(self): return self.ResponseSet
    def set_ResponseSet(self, ResponseSet): self.ResponseSet = ResponseSet
    def add_ResponseSet(self, value): self.ResponseSet.append(value)
    def insert_ResponseSet_at(self, index, value): self.ResponseSet.insert(index, value)
    def replace_ResponseSet_at(self, index, value): self.ResponseSet[index] = value
    def hasContent_(self):
        if (
            self.ResponseSet or
            super(ResponseSetList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseSetList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseSetList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseSetList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseSetList'):
        super(ResponseSetList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseSetList')
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseSetList', fromsubclass_=False, pretty_print=True):
        super(ResponseSetList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResponseSet_ in self.ResponseSet:
            ResponseSet_.export(outfile, level, namespace_, name_='ResponseSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResponseSetList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResponseSetList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResponseSetList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('ResponseSet=[\n')
        level += 1
        for ResponseSet_ in self.ResponseSet:
            showIndent(outfile, level)
            outfile.write('model_.ResponseSet(\n')
            ResponseSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResponseSetList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResponseSet':
            obj_ = ResponseSet.factory()
            obj_.build(child_)
            self.ResponseSet.append(obj_)
            obj_.original_tagname_ = 'ResponseSet'
        super(ResponseSetList, self).buildChildren(child_, node, nodeName_, True)
# end class ResponseSetList


class ResponseSet(IdentifiedObject):
    """A container for a ResponseList."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, ResponseListLink=None):
        self.original_tagname_ = None
        super(ResponseSet, self).__init__()
        self.ResponseListLink = ResponseListLink
    def factory(*args_, **kwargs_):
        if ResponseSet.subclass:
            return ResponseSet.subclass(*args_, **kwargs_)
        else:
            return ResponseSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ResponseListLink(self): return self.ResponseListLink
    def set_ResponseListLink(self, ResponseListLink): self.ResponseListLink = ResponseListLink
    def hasContent_(self):
        if (
            self.ResponseListLink is not None or
            super(ResponseSet, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseSet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseSet'):
        super(ResponseSet, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseSet')
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseSet', fromsubclass_=False, pretty_print=True):
        super(ResponseSet, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ResponseListLink is not None:
            self.ResponseListLink.export(outfile, level, namespace_, name_='ResponseListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResponseSet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResponseSet, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResponseSet, self).exportLiteralChildren(outfile, level, name_)
        if self.ResponseListLink is not None:
            showIndent(outfile, level)
            outfile.write('ResponseListLink=model_.ResponseListLink(\n')
            self.ResponseListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResponseSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ResponseListLink':
            obj_ = ResponseListLink.factory()
            obj_.build(child_)
            self.ResponseListLink = obj_
            obj_.original_tagname_ = 'ResponseListLink'
        super(ResponseSet, self).buildChildren(child_, node, nodeName_, True)
# end class ResponseSet


class ResponseList(List):
    """A List element to hold Response objects."""
    subclass = None
    superclass = List
    def __init__(self, Response=None):
        self.original_tagname_ = None
        super(ResponseList, self).__init__()
        if Response is None:
            self.Response = []
        else:
            self.Response = Response
    def factory(*args_, **kwargs_):
        if ResponseList.subclass:
            return ResponseList.subclass(*args_, **kwargs_)
        else:
            return ResponseList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Response(self): return self.Response
    def set_Response(self, Response): self.Response = Response
    def add_Response(self, value): self.Response.append(value)
    def insert_Response_at(self, index, value): self.Response.insert(index, value)
    def replace_Response_at(self, index, value): self.Response[index] = value
    def hasContent_(self):
        if (
            self.Response or
            super(ResponseList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ResponseList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ResponseList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ResponseList'):
        super(ResponseList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ResponseList')
    def exportChildren(self, outfile, level, namespace_='', name_='ResponseList', fromsubclass_=False, pretty_print=True):
        super(ResponseList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Response_ in self.Response:
            Response_.export(outfile, level, namespace_, name_='Response', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResponseList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ResponseList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ResponseList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Response=[\n')
        level += 1
        for Response_ in self.Response:
            showIndent(outfile, level)
            outfile.write('model_.Response(\n')
            Response_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ResponseList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Response':
            class_obj_ = self.get_class_obj_(child_, Response)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Response.append(obj_)
            obj_.original_tagname_ = 'Response'
        super(ResponseList, self).buildChildren(child_, node, nodeName_, True)
# end class ResponseList


class Response(Resource):
    """The Response object is the generic response data repository for
    functions which do not have additional specific data (e.g. DRLC
    has additional data fields (SetPoint) where Price and Text event
    do not)."""
    subclass = None
    superclass = Resource
    def __init__(self, createdDateTime=None, endDeviceLFDI=None, status=None, subject=None):
        self.original_tagname_ = None
        super(Response, self).__init__()
        self.createdDateTime = createdDateTime
        self.endDeviceLFDI = endDeviceLFDI
        self.status = status
        self.subject = subject
    def factory(*args_, **kwargs_):
        if Response.subclass:
            return Response.subclass(*args_, **kwargs_)
        else:
            return Response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_createdDateTime(self): return self.createdDateTime
    def set_createdDateTime(self, createdDateTime): self.createdDateTime = createdDateTime
    def get_endDeviceLFDI(self): return self.endDeviceLFDI
    def set_endDeviceLFDI(self, endDeviceLFDI): self.endDeviceLFDI = endDeviceLFDI
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_subject(self): return self.subject
    def set_subject(self, subject): self.subject = subject
    def validate_HexBinary160(self, value):
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        pass
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.createdDateTime is not None or
            self.endDeviceLFDI is not None or
            self.status is not None or
            self.subject is not None or
            super(Response, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Response', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Response')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Response'):
        super(Response, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Response')
    def exportChildren(self, outfile, level, namespace_='', name_='Response', fromsubclass_=False, pretty_print=True):
        super(Response, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.createdDateTime is not None:
            self.createdDateTime.export(outfile, level, namespace_, name_='createdDateTime', pretty_print=pretty_print)
        if self.endDeviceLFDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendDeviceLFDI>%s</%sendDeviceLFDI>%s' % (namespace_, self.gds_format_string(quote_xml(self.endDeviceLFDI).encode(ExternalEncoding), input_name='endDeviceLFDI'), namespace_, eol_))
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_format_integer(self.status, input_name='status'), namespace_, eol_))
        if self.subject is not None:
            self.subject.export(outfile, level, namespace_, name_='subject', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Response'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Response, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Response, self).exportLiteralChildren(outfile, level, name_)
        if self.createdDateTime is not None:
            showIndent(outfile, level)
            outfile.write('createdDateTime=model_.TimeType(\n')
            self.createdDateTime.exportLiteral(outfile, level, name_='createdDateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.endDeviceLFDI is not None:
            showIndent(outfile, level)
            outfile.write('endDeviceLFDI=%s,\n' % quote_python(self.endDeviceLFDI).encode(ExternalEncoding))
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % self.status)
        if self.subject is not None:
            showIndent(outfile, level)
            outfile.write('subject=model_.mRIDType(\n')
            self.subject.exportLiteral(outfile, level, name_='subject')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Response, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'createdDateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.createdDateTime = obj_
            obj_.original_tagname_ = 'createdDateTime'
        elif nodeName_ == 'endDeviceLFDI':
            endDeviceLFDI_ = child_.text
            endDeviceLFDI_ = self.gds_validate_string(endDeviceLFDI_, node, 'endDeviceLFDI')
            self.endDeviceLFDI = endDeviceLFDI_
            self.validate_HexBinary160(self.endDeviceLFDI)    # validate type HexBinary160
        elif nodeName_ == 'status':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
            self.validate_UInt8(self.status)    # validate type UInt8
        elif nodeName_ == 'subject':
            obj_ = mRIDType.factory()
            obj_.build(child_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        super(Response, self).buildChildren(child_, node, nodeName_, True)
# end class Response


class PriceResponse(Response):
    """A response related to a price message."""
    subclass = None
    superclass = Response
    def __init__(self):
        self.original_tagname_ = None
        super(PriceResponse, self).__init__()
    def factory(*args_, **kwargs_):
        if PriceResponse.subclass:
            return PriceResponse.subclass(*args_, **kwargs_)
        else:
            return PriceResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(PriceResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PriceResponse', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PriceResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PriceResponse', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PriceResponse'):
        super(PriceResponse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PriceResponse')
    def exportChildren(self, outfile, level, namespace_='', name_='PriceResponse', fromsubclass_=False, pretty_print=True):
        super(PriceResponse, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='PriceResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(PriceResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PriceResponse, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(PriceResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(PriceResponse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class PriceResponse


class DrResponse(Response):
    """A response to a Demand Response Load Control (EndDeviceControl)
    message."""
    subclass = None
    superclass = Response
    def __init__(self, ApplianceLoadReduction=None, AppliedTargetReduction=None, DutyCycle=None, Offset=None, overrideDuration=None, SetPoint=None):
        self.original_tagname_ = None
        super(DrResponse, self).__init__()
        self.ApplianceLoadReduction = ApplianceLoadReduction
        self.AppliedTargetReduction = AppliedTargetReduction
        self.DutyCycle = DutyCycle
        self.Offset = Offset
        self.overrideDuration = overrideDuration
        self.SetPoint = SetPoint
    def factory(*args_, **kwargs_):
        if DrResponse.subclass:
            return DrResponse.subclass(*args_, **kwargs_)
        else:
            return DrResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ApplianceLoadReduction(self): return self.ApplianceLoadReduction
    def set_ApplianceLoadReduction(self, ApplianceLoadReduction): self.ApplianceLoadReduction = ApplianceLoadReduction
    def get_AppliedTargetReduction(self): return self.AppliedTargetReduction
    def set_AppliedTargetReduction(self, AppliedTargetReduction): self.AppliedTargetReduction = AppliedTargetReduction
    def get_DutyCycle(self): return self.DutyCycle
    def set_DutyCycle(self, DutyCycle): self.DutyCycle = DutyCycle
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def get_overrideDuration(self): return self.overrideDuration
    def set_overrideDuration(self, overrideDuration): self.overrideDuration = overrideDuration
    def get_SetPoint(self): return self.SetPoint
    def set_SetPoint(self, SetPoint): self.SetPoint = SetPoint
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.ApplianceLoadReduction is not None or
            self.AppliedTargetReduction is not None or
            self.DutyCycle is not None or
            self.Offset is not None or
            self.overrideDuration is not None or
            self.SetPoint is not None or
            super(DrResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DrResponse', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DrResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DrResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DrResponse'):
        super(DrResponse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DrResponse')
    def exportChildren(self, outfile, level, namespace_='', name_='DrResponse', fromsubclass_=False, pretty_print=True):
        super(DrResponse, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ApplianceLoadReduction is not None:
            self.ApplianceLoadReduction.export(outfile, level, namespace_, name_='ApplianceLoadReduction', pretty_print=pretty_print)
        if self.AppliedTargetReduction is not None:
            self.AppliedTargetReduction.export(outfile, level, namespace_, name_='AppliedTargetReduction', pretty_print=pretty_print)
        if self.DutyCycle is not None:
            self.DutyCycle.export(outfile, level, namespace_, name_='DutyCycle', pretty_print=pretty_print)
        if self.Offset is not None:
            self.Offset.export(outfile, level, namespace_, name_='Offset', pretty_print=pretty_print)
        if self.overrideDuration is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverrideDuration>%s</%soverrideDuration>%s' % (namespace_, self.gds_format_integer(self.overrideDuration, input_name='overrideDuration'), namespace_, eol_))
        if self.SetPoint is not None:
            self.SetPoint.export(outfile, level, namespace_, name_='SetPoint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DrResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DrResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DrResponse, self).exportLiteralChildren(outfile, level, name_)
        if self.ApplianceLoadReduction is not None:
            showIndent(outfile, level)
            outfile.write('ApplianceLoadReduction=model_.ApplianceLoadReduction(\n')
            self.ApplianceLoadReduction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AppliedTargetReduction is not None:
            showIndent(outfile, level)
            outfile.write('AppliedTargetReduction=model_.AppliedTargetReduction(\n')
            self.AppliedTargetReduction.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DutyCycle is not None:
            showIndent(outfile, level)
            outfile.write('DutyCycle=model_.DutyCycle(\n')
            self.DutyCycle.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Offset is not None:
            showIndent(outfile, level)
            outfile.write('Offset=model_.Offset(\n')
            self.Offset.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.overrideDuration is not None:
            showIndent(outfile, level)
            outfile.write('overrideDuration=%d,\n' % self.overrideDuration)
        if self.SetPoint is not None:
            showIndent(outfile, level)
            outfile.write('SetPoint=model_.SetPoint(\n')
            self.SetPoint.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DrResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ApplianceLoadReduction':
            obj_ = ApplianceLoadReduction.factory()
            obj_.build(child_)
            self.ApplianceLoadReduction = obj_
            obj_.original_tagname_ = 'ApplianceLoadReduction'
        elif nodeName_ == 'AppliedTargetReduction':
            obj_ = AppliedTargetReduction.factory()
            obj_.build(child_)
            self.AppliedTargetReduction = obj_
            obj_.original_tagname_ = 'AppliedTargetReduction'
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory()
            obj_.build(child_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'Offset':
            obj_ = Offset.factory()
            obj_.build(child_)
            self.Offset = obj_
            obj_.original_tagname_ = 'Offset'
        elif nodeName_ == 'overrideDuration':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'overrideDuration')
            self.overrideDuration = ival_
            self.validate_UInt16(self.overrideDuration)    # validate type UInt16
        elif nodeName_ == 'SetPoint':
            obj_ = SetPoint.factory()
            obj_.build(child_)
            self.SetPoint = obj_
            obj_.original_tagname_ = 'SetPoint'
        super(DrResponse, self).buildChildren(child_, node, nodeName_, True)
# end class DrResponse


class NotificationList(List):
    """A List element to hold Notification objects."""
    subclass = None
    superclass = List
    def __init__(self, Notification=None):
        self.original_tagname_ = None
        super(NotificationList, self).__init__()
        if Notification is None:
            self.Notification = []
        else:
            self.Notification = Notification
    def factory(*args_, **kwargs_):
        if NotificationList.subclass:
            return NotificationList.subclass(*args_, **kwargs_)
        else:
            return NotificationList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Notification(self): return self.Notification
    def set_Notification(self, Notification): self.Notification = Notification
    def add_Notification(self, value): self.Notification.append(value)
    def insert_Notification_at(self, index, value): self.Notification.insert(index, value)
    def replace_Notification_at(self, index, value): self.Notification[index] = value
    def hasContent_(self):
        if (
            self.Notification or
            super(NotificationList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NotificationList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NotificationList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NotificationList'):
        super(NotificationList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='NotificationList')
    def exportChildren(self, outfile, level, namespace_='', name_='NotificationList', fromsubclass_=False, pretty_print=True):
        super(NotificationList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Notification_ in self.Notification:
            Notification_.export(outfile, level, namespace_, name_='Notification', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NotificationList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(NotificationList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(NotificationList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Notification=[\n')
        level += 1
        for Notification_ in self.Notification:
            showIndent(outfile, level)
            outfile.write('model_.Notification(\n')
            Notification_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(NotificationList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Notification':
            obj_ = Notification.factory()
            obj_.build(child_)
            self.Notification.append(obj_)
            obj_.original_tagname_ = 'Notification'
        super(NotificationList, self).buildChildren(child_, node, nodeName_, True)
# end class NotificationList


class SubscriptionList(List):
    """A List element to hold Subscription objects."""
    subclass = None
    superclass = List
    def __init__(self, Subscription=None):
        self.original_tagname_ = None
        super(SubscriptionList, self).__init__()
        if Subscription is None:
            self.Subscription = []
        else:
            self.Subscription = Subscription
    def factory(*args_, **kwargs_):
        if SubscriptionList.subclass:
            return SubscriptionList.subclass(*args_, **kwargs_)
        else:
            return SubscriptionList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Subscription(self): return self.Subscription
    def set_Subscription(self, Subscription): self.Subscription = Subscription
    def add_Subscription(self, value): self.Subscription.append(value)
    def insert_Subscription_at(self, index, value): self.Subscription.insert(index, value)
    def replace_Subscription_at(self, index, value): self.Subscription[index] = value
    def hasContent_(self):
        if (
            self.Subscription or
            super(SubscriptionList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubscriptionList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubscriptionList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubscriptionList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubscriptionList'):
        super(SubscriptionList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubscriptionList')
    def exportChildren(self, outfile, level, namespace_='', name_='SubscriptionList', fromsubclass_=False, pretty_print=True):
        super(SubscriptionList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Subscription_ in self.Subscription:
            Subscription_.export(outfile, level, namespace_, name_='Subscription', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubscriptionList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubscriptionList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubscriptionList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Subscription=[\n')
        level += 1
        for Subscription_ in self.Subscription:
            showIndent(outfile, level)
            outfile.write('model_.Subscription(\n')
            Subscription_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubscriptionList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Subscription':
            obj_ = Subscription.factory()
            obj_.build(child_)
            self.Subscription.append(obj_)
            obj_.original_tagname_ = 'Subscription'
        super(SubscriptionList, self).buildChildren(child_, node, nodeName_, True)
# end class SubscriptionList


class SubscriptionBase(Resource):
    """Holds the information related to a client subscription to receive
    updates to a resource automatically. The actual resources may be
    passed in the Notification by specifying a specific xsi:type for
    the Resource and passing the full representation."""
    subclass = None
    superclass = Resource
    def __init__(self, subscribedResource=None):
        self.original_tagname_ = None
        super(SubscriptionBase, self).__init__()
        self.subscribedResource = subscribedResource
    def factory(*args_, **kwargs_):
        if SubscriptionBase.subclass:
            return SubscriptionBase.subclass(*args_, **kwargs_)
        else:
            return SubscriptionBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_subscribedResource(self): return self.subscribedResource
    def set_subscribedResource(self, subscribedResource): self.subscribedResource = subscribedResource
    def hasContent_(self):
        if (
            self.subscribedResource is not None or
            super(SubscriptionBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SubscriptionBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubscriptionBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SubscriptionBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SubscriptionBase'):
        super(SubscriptionBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubscriptionBase')
    def exportChildren(self, outfile, level, namespace_='', name_='SubscriptionBase', fromsubclass_=False, pretty_print=True):
        super(SubscriptionBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subscribedResource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubscribedResource>%s</%ssubscribedResource>%s' % (namespace_, self.gds_format_string(quote_xml(self.subscribedResource).encode(ExternalEncoding), input_name='subscribedResource'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SubscriptionBase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SubscriptionBase, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubscriptionBase, self).exportLiteralChildren(outfile, level, name_)
        if self.subscribedResource is not None:
            showIndent(outfile, level)
            outfile.write('subscribedResource=%s,\n' % quote_python(self.subscribedResource).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SubscriptionBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'subscribedResource':
            subscribedResource_ = child_.text
            subscribedResource_ = self.gds_validate_string(subscribedResource_, node, 'subscribedResource')
            self.subscribedResource = subscribedResource_
        super(SubscriptionBase, self).buildChildren(child_, node, nodeName_, True)
# end class SubscriptionBase


class FunctionSetAssignmentsList(SubscribableList):
    """A List element to hold FunctionSetAssignments objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, FunctionSetAssignments=None):
        self.original_tagname_ = None
        super(FunctionSetAssignmentsList, self).__init__()
        if FunctionSetAssignments is None:
            self.FunctionSetAssignments = []
        else:
            self.FunctionSetAssignments = FunctionSetAssignments
    def factory(*args_, **kwargs_):
        if FunctionSetAssignmentsList.subclass:
            return FunctionSetAssignmentsList.subclass(*args_, **kwargs_)
        else:
            return FunctionSetAssignmentsList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FunctionSetAssignments(self): return self.FunctionSetAssignments
    def set_FunctionSetAssignments(self, FunctionSetAssignments): self.FunctionSetAssignments = FunctionSetAssignments
    def add_FunctionSetAssignments(self, value): self.FunctionSetAssignments.append(value)
    def insert_FunctionSetAssignments_at(self, index, value): self.FunctionSetAssignments.insert(index, value)
    def replace_FunctionSetAssignments_at(self, index, value): self.FunctionSetAssignments[index] = value
    def hasContent_(self):
        if (
            self.FunctionSetAssignments or
            super(FunctionSetAssignmentsList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FunctionSetAssignmentsList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionSetAssignmentsList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FunctionSetAssignmentsList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FunctionSetAssignmentsList'):
        super(FunctionSetAssignmentsList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionSetAssignmentsList')
    def exportChildren(self, outfile, level, namespace_='', name_='FunctionSetAssignmentsList', fromsubclass_=False, pretty_print=True):
        super(FunctionSetAssignmentsList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FunctionSetAssignments_ in self.FunctionSetAssignments:
            FunctionSetAssignments_.export(outfile, level, namespace_, name_='FunctionSetAssignments', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FunctionSetAssignmentsList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FunctionSetAssignmentsList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FunctionSetAssignmentsList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('FunctionSetAssignments=[\n')
        level += 1
        for FunctionSetAssignments_ in self.FunctionSetAssignments:
            showIndent(outfile, level)
            outfile.write('model_.FunctionSetAssignments(\n')
            FunctionSetAssignments_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FunctionSetAssignmentsList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FunctionSetAssignments':
            obj_ = FunctionSetAssignments.factory()
            obj_.build(child_)
            self.FunctionSetAssignments.append(obj_)
            obj_.original_tagname_ = 'FunctionSetAssignments'
        super(FunctionSetAssignmentsList, self).buildChildren(child_, node, nodeName_, True)
# end class FunctionSetAssignmentsList


class FunctionSetAssignmentsBase(Resource):
    """Defines a collection of function set instances that are to be used
    by one or more devices as indicated by the EndDevice object(s)
    of the server."""
    subclass = None
    superclass = Resource
    def __init__(self, CustomerAccountListLink=None, DemandResponseProgramListLink=None, DERProgramListLink=None, FileListLink=None, MessagingProgramListLink=None, PrepaymentListLink=None, ResponseSetListLink=None, TariffProfileListLink=None, TimeLink=None, UsagePointListLink=None):
        self.original_tagname_ = None
        super(FunctionSetAssignmentsBase, self).__init__()
        self.CustomerAccountListLink = CustomerAccountListLink
        self.DemandResponseProgramListLink = DemandResponseProgramListLink
        self.DERProgramListLink = DERProgramListLink
        self.FileListLink = FileListLink
        self.MessagingProgramListLink = MessagingProgramListLink
        self.PrepaymentListLink = PrepaymentListLink
        self.ResponseSetListLink = ResponseSetListLink
        self.TariffProfileListLink = TariffProfileListLink
        self.TimeLink = TimeLink
        self.UsagePointListLink = UsagePointListLink
    def factory(*args_, **kwargs_):
        if FunctionSetAssignmentsBase.subclass:
            return FunctionSetAssignmentsBase.subclass(*args_, **kwargs_)
        else:
            return FunctionSetAssignmentsBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CustomerAccountListLink(self): return self.CustomerAccountListLink
    def set_CustomerAccountListLink(self, CustomerAccountListLink): self.CustomerAccountListLink = CustomerAccountListLink
    def get_DemandResponseProgramListLink(self): return self.DemandResponseProgramListLink
    def set_DemandResponseProgramListLink(self, DemandResponseProgramListLink): self.DemandResponseProgramListLink = DemandResponseProgramListLink
    def get_DERProgramListLink(self): return self.DERProgramListLink
    def set_DERProgramListLink(self, DERProgramListLink): self.DERProgramListLink = DERProgramListLink
    def get_FileListLink(self): return self.FileListLink
    def set_FileListLink(self, FileListLink): self.FileListLink = FileListLink
    def get_MessagingProgramListLink(self): return self.MessagingProgramListLink
    def set_MessagingProgramListLink(self, MessagingProgramListLink): self.MessagingProgramListLink = MessagingProgramListLink
    def get_PrepaymentListLink(self): return self.PrepaymentListLink
    def set_PrepaymentListLink(self, PrepaymentListLink): self.PrepaymentListLink = PrepaymentListLink
    def get_ResponseSetListLink(self): return self.ResponseSetListLink
    def set_ResponseSetListLink(self, ResponseSetListLink): self.ResponseSetListLink = ResponseSetListLink
    def get_TariffProfileListLink(self): return self.TariffProfileListLink
    def set_TariffProfileListLink(self, TariffProfileListLink): self.TariffProfileListLink = TariffProfileListLink
    def get_TimeLink(self): return self.TimeLink
    def set_TimeLink(self, TimeLink): self.TimeLink = TimeLink
    def get_UsagePointListLink(self): return self.UsagePointListLink
    def set_UsagePointListLink(self, UsagePointListLink): self.UsagePointListLink = UsagePointListLink
    def hasContent_(self):
        if (
            self.CustomerAccountListLink is not None or
            self.DemandResponseProgramListLink is not None or
            self.DERProgramListLink is not None or
            self.FileListLink is not None or
            self.MessagingProgramListLink is not None or
            self.PrepaymentListLink is not None or
            self.ResponseSetListLink is not None or
            self.TariffProfileListLink is not None or
            self.TimeLink is not None or
            self.UsagePointListLink is not None or
            super(FunctionSetAssignmentsBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FunctionSetAssignmentsBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionSetAssignmentsBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FunctionSetAssignmentsBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FunctionSetAssignmentsBase'):
        super(FunctionSetAssignmentsBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionSetAssignmentsBase')
    def exportChildren(self, outfile, level, namespace_='', name_='FunctionSetAssignmentsBase', fromsubclass_=False, pretty_print=True):
        super(FunctionSetAssignmentsBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerAccountListLink is not None:
            self.CustomerAccountListLink.export(outfile, level, namespace_, name_='CustomerAccountListLink', pretty_print=pretty_print)
        if self.DemandResponseProgramListLink is not None:
            self.DemandResponseProgramListLink.export(outfile, level, namespace_, name_='DemandResponseProgramListLink', pretty_print=pretty_print)
        if self.DERProgramListLink is not None:
            self.DERProgramListLink.export(outfile, level, namespace_, name_='DERProgramListLink', pretty_print=pretty_print)
        if self.FileListLink is not None:
            self.FileListLink.export(outfile, level, namespace_, name_='FileListLink', pretty_print=pretty_print)
        if self.MessagingProgramListLink is not None:
            self.MessagingProgramListLink.export(outfile, level, namespace_, name_='MessagingProgramListLink', pretty_print=pretty_print)
        if self.PrepaymentListLink is not None:
            self.PrepaymentListLink.export(outfile, level, namespace_, name_='PrepaymentListLink', pretty_print=pretty_print)
        if self.ResponseSetListLink is not None:
            self.ResponseSetListLink.export(outfile, level, namespace_, name_='ResponseSetListLink', pretty_print=pretty_print)
        if self.TariffProfileListLink is not None:
            self.TariffProfileListLink.export(outfile, level, namespace_, name_='TariffProfileListLink', pretty_print=pretty_print)
        if self.TimeLink is not None:
            self.TimeLink.export(outfile, level, namespace_, name_='TimeLink', pretty_print=pretty_print)
        if self.UsagePointListLink is not None:
            self.UsagePointListLink.export(outfile, level, namespace_, name_='UsagePointListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FunctionSetAssignmentsBase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(FunctionSetAssignmentsBase, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FunctionSetAssignmentsBase, self).exportLiteralChildren(outfile, level, name_)
        if self.CustomerAccountListLink is not None:
            showIndent(outfile, level)
            outfile.write('CustomerAccountListLink=model_.CustomerAccountListLink(\n')
            self.CustomerAccountListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DemandResponseProgramListLink is not None:
            showIndent(outfile, level)
            outfile.write('DemandResponseProgramListLink=model_.DemandResponseProgramListLink(\n')
            self.DemandResponseProgramListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DERProgramListLink is not None:
            showIndent(outfile, level)
            outfile.write('DERProgramListLink=model_.DERProgramListLink(\n')
            self.DERProgramListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FileListLink is not None:
            showIndent(outfile, level)
            outfile.write('FileListLink=model_.FileListLink(\n')
            self.FileListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MessagingProgramListLink is not None:
            showIndent(outfile, level)
            outfile.write('MessagingProgramListLink=model_.MessagingProgramListLink(\n')
            self.MessagingProgramListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PrepaymentListLink is not None:
            showIndent(outfile, level)
            outfile.write('PrepaymentListLink=model_.PrepaymentListLink(\n')
            self.PrepaymentListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ResponseSetListLink is not None:
            showIndent(outfile, level)
            outfile.write('ResponseSetListLink=model_.ResponseSetListLink(\n')
            self.ResponseSetListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TariffProfileListLink is not None:
            showIndent(outfile, level)
            outfile.write('TariffProfileListLink=model_.TariffProfileListLink(\n')
            self.TariffProfileListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TimeLink is not None:
            showIndent(outfile, level)
            outfile.write('TimeLink=model_.TimeLink(\n')
            self.TimeLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.UsagePointListLink is not None:
            showIndent(outfile, level)
            outfile.write('UsagePointListLink=model_.UsagePointListLink(\n')
            self.UsagePointListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(FunctionSetAssignmentsBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CustomerAccountListLink':
            obj_ = CustomerAccountListLink.factory()
            obj_.build(child_)
            self.CustomerAccountListLink = obj_
            obj_.original_tagname_ = 'CustomerAccountListLink'
        elif nodeName_ == 'DemandResponseProgramListLink':
            obj_ = DemandResponseProgramListLink.factory()
            obj_.build(child_)
            self.DemandResponseProgramListLink = obj_
            obj_.original_tagname_ = 'DemandResponseProgramListLink'
        elif nodeName_ == 'DERProgramListLink':
            obj_ = DERProgramListLink.factory()
            obj_.build(child_)
            self.DERProgramListLink = obj_
            obj_.original_tagname_ = 'DERProgramListLink'
        elif nodeName_ == 'FileListLink':
            obj_ = FileListLink.factory()
            obj_.build(child_)
            self.FileListLink = obj_
            obj_.original_tagname_ = 'FileListLink'
        elif nodeName_ == 'MessagingProgramListLink':
            obj_ = MessagingProgramListLink.factory()
            obj_.build(child_)
            self.MessagingProgramListLink = obj_
            obj_.original_tagname_ = 'MessagingProgramListLink'
        elif nodeName_ == 'PrepaymentListLink':
            obj_ = PrepaymentListLink.factory()
            obj_.build(child_)
            self.PrepaymentListLink = obj_
            obj_.original_tagname_ = 'PrepaymentListLink'
        elif nodeName_ == 'ResponseSetListLink':
            obj_ = ResponseSetListLink.factory()
            obj_.build(child_)
            self.ResponseSetListLink = obj_
            obj_.original_tagname_ = 'ResponseSetListLink'
        elif nodeName_ == 'TariffProfileListLink':
            obj_ = TariffProfileListLink.factory()
            obj_.build(child_)
            self.TariffProfileListLink = obj_
            obj_.original_tagname_ = 'TariffProfileListLink'
        elif nodeName_ == 'TimeLink':
            obj_ = TimeLink.factory()
            obj_.build(child_)
            self.TimeLink = obj_
            obj_.original_tagname_ = 'TimeLink'
        elif nodeName_ == 'UsagePointListLink':
            obj_ = UsagePointListLink.factory()
            obj_.build(child_)
            self.UsagePointListLink = obj_
            obj_.original_tagname_ = 'UsagePointListLink'
        super(FunctionSetAssignmentsBase, self).buildChildren(child_, node, nodeName_, True)
# end class FunctionSetAssignmentsBase


class Registration(Resource):
    """Registration represents an authorization to access the resources on
    a host."""
    subclass = None
    superclass = Resource
    def __init__(self, dateTimeRegistered=None, pIN=None):
        self.original_tagname_ = None
        super(Registration, self).__init__()
        self.dateTimeRegistered = dateTimeRegistered
        self.pIN = pIN
    def factory(*args_, **kwargs_):
        if Registration.subclass:
            return Registration.subclass(*args_, **kwargs_)
        else:
            return Registration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dateTimeRegistered(self): return self.dateTimeRegistered
    def set_dateTimeRegistered(self, dateTimeRegistered): self.dateTimeRegistered = dateTimeRegistered
    def get_pIN(self): return self.pIN
    def set_pIN(self, pIN): self.pIN = pIN
    def hasContent_(self):
        if (
            self.dateTimeRegistered is not None or
            self.pIN is not None or
            super(Registration, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Registration', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Registration')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Registration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Registration'):
        super(Registration, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Registration')
    def exportChildren(self, outfile, level, namespace_='', name_='Registration', fromsubclass_=False, pretty_print=True):
        super(Registration, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTimeRegistered is not None:
            self.dateTimeRegistered.export(outfile, level, namespace_, name_='dateTimeRegistered', pretty_print=pretty_print)
        if self.pIN is not None:
            self.pIN.export(outfile, level, namespace_, name_='pIN', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Registration'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Registration, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Registration, self).exportLiteralChildren(outfile, level, name_)
        if self.dateTimeRegistered is not None:
            showIndent(outfile, level)
            outfile.write('dateTimeRegistered=model_.TimeType(\n')
            self.dateTimeRegistered.exportLiteral(outfile, level, name_='dateTimeRegistered')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.pIN is not None:
            showIndent(outfile, level)
            outfile.write('pIN=model_.PINType(\n')
            self.pIN.exportLiteral(outfile, level, name_='pIN')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Registration, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'dateTimeRegistered':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.dateTimeRegistered = obj_
            obj_.original_tagname_ = 'dateTimeRegistered'
        elif nodeName_ == 'pIN':
            obj_ = PINType.factory()
            obj_.build(child_)
            self.pIN = obj_
            obj_.original_tagname_ = 'pIN'
        super(Registration, self).buildChildren(child_, node, nodeName_, True)
# end class Registration


class EndDeviceList(SubscribableList):
    """A List element to hold EndDevice objects."""
    subclass = None
    superclass = SubscribableList
    def __init__(self, EndDevice=None):
        self.original_tagname_ = None
        super(EndDeviceList, self).__init__()
        if EndDevice is None:
            self.EndDevice = []
        else:
            self.EndDevice = EndDevice
    def factory(*args_, **kwargs_):
        if EndDeviceList.subclass:
            return EndDeviceList.subclass(*args_, **kwargs_)
        else:
            return EndDeviceList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EndDevice(self): return self.EndDevice
    def set_EndDevice(self, EndDevice): self.EndDevice = EndDevice
    def add_EndDevice(self, value): self.EndDevice.append(value)
    def insert_EndDevice_at(self, index, value): self.EndDevice.insert(index, value)
    def replace_EndDevice_at(self, index, value): self.EndDevice[index] = value
    def hasContent_(self):
        if (
            self.EndDevice or
            super(EndDeviceList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EndDeviceList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EndDeviceList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndDeviceList'):
        super(EndDeviceList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EndDeviceList')
    def exportChildren(self, outfile, level, namespace_='', name_='EndDeviceList', fromsubclass_=False, pretty_print=True):
        super(EndDeviceList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EndDevice_ in self.EndDevice:
            EndDevice_.export(outfile, level, namespace_, name_='EndDevice', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EndDeviceList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EndDeviceList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EndDeviceList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('EndDevice=[\n')
        level += 1
        for EndDevice_ in self.EndDevice:
            showIndent(outfile, level)
            outfile.write('model_.EndDevice(\n')
            EndDevice_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EndDevice':
            obj_ = EndDevice.factory()
            obj_.build(child_)
            self.EndDevice.append(obj_)
            obj_.original_tagname_ = 'EndDevice'
        super(EndDeviceList, self).buildChildren(child_, node, nodeName_, True)
# end class EndDeviceList


class DeviceStatus(Resource):
    """Status of device"""
    subclass = None
    superclass = Resource
    def __init__(self, changedTime=None, onCount=None, opState=None, opTime=None, Temperature=None, TimeLink=None):
        self.original_tagname_ = None
        super(DeviceStatus, self).__init__()
        self.changedTime = changedTime
        self.onCount = onCount
        self.opState = opState
        self.opTime = opTime
        if Temperature is None:
            self.Temperature = []
        else:
            self.Temperature = Temperature
        self.TimeLink = TimeLink
    def factory(*args_, **kwargs_):
        if DeviceStatus.subclass:
            return DeviceStatus.subclass(*args_, **kwargs_)
        else:
            return DeviceStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_changedTime(self): return self.changedTime
    def set_changedTime(self, changedTime): self.changedTime = changedTime
    def get_onCount(self): return self.onCount
    def set_onCount(self, onCount): self.onCount = onCount
    def get_opState(self): return self.opState
    def set_opState(self, opState): self.opState = opState
    def get_opTime(self): return self.opTime
    def set_opTime(self, opTime): self.opTime = opTime
    def get_Temperature(self): return self.Temperature
    def set_Temperature(self, Temperature): self.Temperature = Temperature
    def add_Temperature(self, value): self.Temperature.append(value)
    def insert_Temperature_at(self, index, value): self.Temperature.insert(index, value)
    def replace_Temperature_at(self, index, value): self.Temperature[index] = value
    def get_TimeLink(self): return self.TimeLink
    def set_TimeLink(self, TimeLink): self.TimeLink = TimeLink
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        pass
    def hasContent_(self):
        if (
            self.changedTime is not None or
            self.onCount is not None or
            self.opState is not None or
            self.opTime is not None or
            self.Temperature or
            self.TimeLink is not None or
            super(DeviceStatus, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceStatus', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceStatus')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeviceStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceStatus'):
        super(DeviceStatus, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceStatus')
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceStatus', fromsubclass_=False, pretty_print=True):
        super(DeviceStatus, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.changedTime is not None:
            self.changedTime.export(outfile, level, namespace_, name_='changedTime', pretty_print=pretty_print)
        if self.onCount is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sonCount>%s</%sonCount>%s' % (namespace_, self.gds_format_integer(self.onCount, input_name='onCount'), namespace_, eol_))
        if self.opState is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopState>%s</%sopState>%s' % (namespace_, self.gds_format_integer(self.opState, input_name='opState'), namespace_, eol_))
        if self.opTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopTime>%s</%sopTime>%s' % (namespace_, self.gds_format_integer(self.opTime, input_name='opTime'), namespace_, eol_))
        for Temperature_ in self.Temperature:
            Temperature_.export(outfile, level, namespace_, name_='Temperature', pretty_print=pretty_print)
        if self.TimeLink is not None:
            self.TimeLink.export(outfile, level, namespace_, name_='TimeLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeviceStatus'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DeviceStatus, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeviceStatus, self).exportLiteralChildren(outfile, level, name_)
        if self.changedTime is not None:
            showIndent(outfile, level)
            outfile.write('changedTime=model_.TimeType(\n')
            self.changedTime.exportLiteral(outfile, level, name_='changedTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.onCount is not None:
            showIndent(outfile, level)
            outfile.write('onCount=%d,\n' % self.onCount)
        if self.opState is not None:
            showIndent(outfile, level)
            outfile.write('opState=%d,\n' % self.opState)
        if self.opTime is not None:
            showIndent(outfile, level)
            outfile.write('opTime=%d,\n' % self.opTime)
        showIndent(outfile, level)
        outfile.write('Temperature=[\n')
        level += 1
        for Temperature_ in self.Temperature:
            showIndent(outfile, level)
            outfile.write('model_.Temperature(\n')
            Temperature_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TimeLink is not None:
            showIndent(outfile, level)
            outfile.write('TimeLink=model_.TimeLink(\n')
            self.TimeLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DeviceStatus, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'changedTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.changedTime = obj_
            obj_.original_tagname_ = 'changedTime'
        elif nodeName_ == 'onCount':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'onCount')
            self.onCount = ival_
            self.validate_UInt16(self.onCount)    # validate type UInt16
        elif nodeName_ == 'opState':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'opState')
            self.opState = ival_
            self.validate_UInt8(self.opState)    # validate type UInt8
        elif nodeName_ == 'opTime':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'opTime')
            self.opTime = ival_
            self.validate_UInt32(self.opTime)    # validate type UInt32
        elif nodeName_ == 'Temperature':
            obj_ = Temperature.factory()
            obj_.build(child_)
            self.Temperature.append(obj_)
            obj_.original_tagname_ = 'Temperature'
        elif nodeName_ == 'TimeLink':
            obj_ = TimeLink.factory()
            obj_.build(child_)
            self.TimeLink = obj_
            obj_.original_tagname_ = 'TimeLink'
        super(DeviceStatus, self).buildChildren(child_, node, nodeName_, True)
# end class DeviceStatus


class AbstractDevice(SubscribableResource):
    """The EndDevice providing the resources available within the
    DeviceCapabilities."""
    subclass = None
    superclass = SubscribableResource
    def __init__(self, ConfigurationLink=None, DERListLink=None, DeviceInformationLink=None, DeviceStatusLink=None, FileStatusLink=None, IPInterfaceListLink=None, LoadShedAvailabilityLink=None, loadShedDeviceCategory=None, LogEventListLink=None, PowerStatusLink=None, sFDI=None):
        self.original_tagname_ = None
        super(AbstractDevice, self).__init__()
        self.ConfigurationLink = ConfigurationLink
        self.DERListLink = DERListLink
        self.DeviceInformationLink = DeviceInformationLink
        self.DeviceStatusLink = DeviceStatusLink
        self.FileStatusLink = FileStatusLink
        self.IPInterfaceListLink = IPInterfaceListLink
        self.LoadShedAvailabilityLink = LoadShedAvailabilityLink
        self.loadShedDeviceCategory = loadShedDeviceCategory
        self.LogEventListLink = LogEventListLink
        self.PowerStatusLink = PowerStatusLink
        self.sFDI = sFDI
    def factory(*args_, **kwargs_):
        if AbstractDevice.subclass:
            return AbstractDevice.subclass(*args_, **kwargs_)
        else:
            return AbstractDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConfigurationLink(self): return self.ConfigurationLink
    def set_ConfigurationLink(self, ConfigurationLink): self.ConfigurationLink = ConfigurationLink
    def get_DERListLink(self): return self.DERListLink
    def set_DERListLink(self, DERListLink): self.DERListLink = DERListLink
    def get_DeviceInformationLink(self): return self.DeviceInformationLink
    def set_DeviceInformationLink(self, DeviceInformationLink): self.DeviceInformationLink = DeviceInformationLink
    def get_DeviceStatusLink(self): return self.DeviceStatusLink
    def set_DeviceStatusLink(self, DeviceStatusLink): self.DeviceStatusLink = DeviceStatusLink
    def get_FileStatusLink(self): return self.FileStatusLink
    def set_FileStatusLink(self, FileStatusLink): self.FileStatusLink = FileStatusLink
    def get_IPInterfaceListLink(self): return self.IPInterfaceListLink
    def set_IPInterfaceListLink(self, IPInterfaceListLink): self.IPInterfaceListLink = IPInterfaceListLink
    def get_LoadShedAvailabilityLink(self): return self.LoadShedAvailabilityLink
    def set_LoadShedAvailabilityLink(self, LoadShedAvailabilityLink): self.LoadShedAvailabilityLink = LoadShedAvailabilityLink
    def get_loadShedDeviceCategory(self): return self.loadShedDeviceCategory
    def set_loadShedDeviceCategory(self, loadShedDeviceCategory): self.loadShedDeviceCategory = loadShedDeviceCategory
    def get_LogEventListLink(self): return self.LogEventListLink
    def set_LogEventListLink(self, LogEventListLink): self.LogEventListLink = LogEventListLink
    def get_PowerStatusLink(self): return self.PowerStatusLink
    def set_PowerStatusLink(self, PowerStatusLink): self.PowerStatusLink = PowerStatusLink
    def get_sFDI(self): return self.sFDI
    def set_sFDI(self, sFDI): self.sFDI = sFDI
    def hasContent_(self):
        if (
            self.ConfigurationLink is not None or
            self.DERListLink is not None or
            self.DeviceInformationLink is not None or
            self.DeviceStatusLink is not None or
            self.FileStatusLink is not None or
            self.IPInterfaceListLink is not None or
            self.LoadShedAvailabilityLink is not None or
            self.loadShedDeviceCategory is not None or
            self.LogEventListLink is not None or
            self.PowerStatusLink is not None or
            self.sFDI is not None or
            super(AbstractDevice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AbstractDevice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDevice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AbstractDevice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AbstractDevice'):
        super(AbstractDevice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AbstractDevice')
    def exportChildren(self, outfile, level, namespace_='', name_='AbstractDevice', fromsubclass_=False, pretty_print=True):
        super(AbstractDevice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConfigurationLink is not None:
            self.ConfigurationLink.export(outfile, level, namespace_, name_='ConfigurationLink', pretty_print=pretty_print)
        if self.DERListLink is not None:
            self.DERListLink.export(outfile, level, namespace_, name_='DERListLink', pretty_print=pretty_print)
        if self.DeviceInformationLink is not None:
            self.DeviceInformationLink.export(outfile, level, namespace_, name_='DeviceInformationLink', pretty_print=pretty_print)
        if self.DeviceStatusLink is not None:
            self.DeviceStatusLink.export(outfile, level, namespace_, name_='DeviceStatusLink', pretty_print=pretty_print)
        if self.FileStatusLink is not None:
            self.FileStatusLink.export(outfile, level, namespace_, name_='FileStatusLink', pretty_print=pretty_print)
        if self.IPInterfaceListLink is not None:
            self.IPInterfaceListLink.export(outfile, level, namespace_, name_='IPInterfaceListLink', pretty_print=pretty_print)
        if self.LoadShedAvailabilityLink is not None:
            self.LoadShedAvailabilityLink.export(outfile, level, namespace_, name_='LoadShedAvailabilityLink', pretty_print=pretty_print)
        if self.loadShedDeviceCategory is not None:
            self.loadShedDeviceCategory.export(outfile, level, namespace_, name_='loadShedDeviceCategory', pretty_print=pretty_print)
        if self.LogEventListLink is not None:
            self.LogEventListLink.export(outfile, level, namespace_, name_='LogEventListLink', pretty_print=pretty_print)
        if self.PowerStatusLink is not None:
            self.PowerStatusLink.export(outfile, level, namespace_, name_='PowerStatusLink', pretty_print=pretty_print)
        if self.sFDI is not None:
            self.sFDI.export(outfile, level, namespace_, name_='sFDI', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AbstractDevice'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(AbstractDevice, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AbstractDevice, self).exportLiteralChildren(outfile, level, name_)
        if self.ConfigurationLink is not None:
            showIndent(outfile, level)
            outfile.write('ConfigurationLink=model_.ConfigurationLink(\n')
            self.ConfigurationLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DERListLink is not None:
            showIndent(outfile, level)
            outfile.write('DERListLink=model_.DERListLink(\n')
            self.DERListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DeviceInformationLink is not None:
            showIndent(outfile, level)
            outfile.write('DeviceInformationLink=model_.DeviceInformationLink(\n')
            self.DeviceInformationLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DeviceStatusLink is not None:
            showIndent(outfile, level)
            outfile.write('DeviceStatusLink=model_.DeviceStatusLink(\n')
            self.DeviceStatusLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FileStatusLink is not None:
            showIndent(outfile, level)
            outfile.write('FileStatusLink=model_.FileStatusLink(\n')
            self.FileStatusLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.IPInterfaceListLink is not None:
            showIndent(outfile, level)
            outfile.write('IPInterfaceListLink=model_.IPInterfaceListLink(\n')
            self.IPInterfaceListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LoadShedAvailabilityLink is not None:
            showIndent(outfile, level)
            outfile.write('LoadShedAvailabilityLink=model_.LoadShedAvailabilityLink(\n')
            self.LoadShedAvailabilityLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.loadShedDeviceCategory is not None:
            showIndent(outfile, level)
            outfile.write('loadShedDeviceCategory=model_.DeviceCategoryType(\n')
            self.loadShedDeviceCategory.exportLiteral(outfile, level, name_='loadShedDeviceCategory')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LogEventListLink is not None:
            showIndent(outfile, level)
            outfile.write('LogEventListLink=model_.LogEventListLink(\n')
            self.LogEventListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PowerStatusLink is not None:
            showIndent(outfile, level)
            outfile.write('PowerStatusLink=model_.PowerStatusLink(\n')
            self.PowerStatusLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.sFDI is not None:
            showIndent(outfile, level)
            outfile.write('sFDI=model_.SFDIType(\n')
            self.sFDI.exportLiteral(outfile, level, name_='sFDI')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(AbstractDevice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConfigurationLink':
            obj_ = ConfigurationLink.factory()
            obj_.build(child_)
            self.ConfigurationLink = obj_
            obj_.original_tagname_ = 'ConfigurationLink'
        elif nodeName_ == 'DERListLink':
            obj_ = DERListLink.factory()
            obj_.build(child_)
            self.DERListLink = obj_
            obj_.original_tagname_ = 'DERListLink'
        elif nodeName_ == 'DeviceInformationLink':
            obj_ = DeviceInformationLink.factory()
            obj_.build(child_)
            self.DeviceInformationLink = obj_
            obj_.original_tagname_ = 'DeviceInformationLink'
        elif nodeName_ == 'DeviceStatusLink':
            obj_ = DeviceStatusLink.factory()
            obj_.build(child_)
            self.DeviceStatusLink = obj_
            obj_.original_tagname_ = 'DeviceStatusLink'
        elif nodeName_ == 'FileStatusLink':
            obj_ = FileStatusLink.factory()
            obj_.build(child_)
            self.FileStatusLink = obj_
            obj_.original_tagname_ = 'FileStatusLink'
        elif nodeName_ == 'IPInterfaceListLink':
            obj_ = IPInterfaceListLink.factory()
            obj_.build(child_)
            self.IPInterfaceListLink = obj_
            obj_.original_tagname_ = 'IPInterfaceListLink'
        elif nodeName_ == 'LoadShedAvailabilityLink':
            obj_ = LoadShedAvailabilityLink.factory()
            obj_.build(child_)
            self.LoadShedAvailabilityLink = obj_
            obj_.original_tagname_ = 'LoadShedAvailabilityLink'
        elif nodeName_ == 'loadShedDeviceCategory':
            obj_ = DeviceCategoryType.factory()
            obj_.build(child_)
            self.loadShedDeviceCategory = obj_
            obj_.original_tagname_ = 'loadShedDeviceCategory'
        elif nodeName_ == 'LogEventListLink':
            obj_ = LogEventListLink.factory()
            obj_.build(child_)
            self.LogEventListLink = obj_
            obj_.original_tagname_ = 'LogEventListLink'
        elif nodeName_ == 'PowerStatusLink':
            obj_ = PowerStatusLink.factory()
            obj_.build(child_)
            self.PowerStatusLink = obj_
            obj_.original_tagname_ = 'PowerStatusLink'
        elif nodeName_ == 'sFDI':
            obj_ = SFDIType.factory()
            obj_.build(child_)
            self.sFDI = obj_
            obj_.original_tagname_ = 'sFDI'
        super(AbstractDevice, self).buildChildren(child_, node, nodeName_, True)
# end class AbstractDevice


class DeviceCapability(FunctionSetAssignmentsBase):
    """Returned by the URI provided by DNS-SD, to allow clients to find the
    URIs to the resources in which they are interested."""
    subclass = None
    superclass = FunctionSetAssignmentsBase
    def __init__(self, EndDeviceListLink=None, MirrorUsagePointListLink=None, SelfDeviceLink=None):
        self.original_tagname_ = None
        super(DeviceCapability, self).__init__()
        self.EndDeviceListLink = EndDeviceListLink
        self.MirrorUsagePointListLink = MirrorUsagePointListLink
        self.SelfDeviceLink = SelfDeviceLink
    def factory(*args_, **kwargs_):
        if DeviceCapability.subclass:
            return DeviceCapability.subclass(*args_, **kwargs_)
        else:
            return DeviceCapability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EndDeviceListLink(self): return self.EndDeviceListLink
    def set_EndDeviceListLink(self, EndDeviceListLink): self.EndDeviceListLink = EndDeviceListLink
    def get_MirrorUsagePointListLink(self): return self.MirrorUsagePointListLink
    def set_MirrorUsagePointListLink(self, MirrorUsagePointListLink): self.MirrorUsagePointListLink = MirrorUsagePointListLink
    def get_SelfDeviceLink(self): return self.SelfDeviceLink
    def set_SelfDeviceLink(self, SelfDeviceLink): self.SelfDeviceLink = SelfDeviceLink
    def hasContent_(self):
        if (
            self.EndDeviceListLink is not None or
            self.MirrorUsagePointListLink is not None or
            self.SelfDeviceLink is not None or
            super(DeviceCapability, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DeviceCapability', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceCapability')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DeviceCapability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DeviceCapability'):
        super(DeviceCapability, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DeviceCapability')
    def exportChildren(self, outfile, level, namespace_='', name_='DeviceCapability', fromsubclass_=False, pretty_print=True):
        super(DeviceCapability, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EndDeviceListLink is not None:
            self.EndDeviceListLink.export(outfile, level, namespace_, name_='EndDeviceListLink', pretty_print=pretty_print)
        if self.MirrorUsagePointListLink is not None:
            self.MirrorUsagePointListLink.export(outfile, level, namespace_, name_='MirrorUsagePointListLink', pretty_print=pretty_print)
        if self.SelfDeviceLink is not None:
            self.SelfDeviceLink.export(outfile, level, namespace_, name_='SelfDeviceLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DeviceCapability'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(DeviceCapability, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DeviceCapability, self).exportLiteralChildren(outfile, level, name_)
        if self.EndDeviceListLink is not None:
            showIndent(outfile, level)
            outfile.write('EndDeviceListLink=model_.EndDeviceListLink(\n')
            self.EndDeviceListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MirrorUsagePointListLink is not None:
            showIndent(outfile, level)
            outfile.write('MirrorUsagePointListLink=model_.MirrorUsagePointListLink(\n')
            self.MirrorUsagePointListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SelfDeviceLink is not None:
            showIndent(outfile, level)
            outfile.write('SelfDeviceLink=model_.SelfDeviceLink(\n')
            self.SelfDeviceLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(DeviceCapability, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EndDeviceListLink':
            obj_ = EndDeviceListLink.factory()
            obj_.build(child_)
            self.EndDeviceListLink = obj_
            obj_.original_tagname_ = 'EndDeviceListLink'
        elif nodeName_ == 'MirrorUsagePointListLink':
            obj_ = MirrorUsagePointListLink.factory()
            obj_.build(child_)
            self.MirrorUsagePointListLink = obj_
            obj_.original_tagname_ = 'MirrorUsagePointListLink'
        elif nodeName_ == 'SelfDeviceLink':
            obj_ = SelfDeviceLink.factory()
            obj_.build(child_)
            self.SelfDeviceLink = obj_
            obj_.original_tagname_ = 'SelfDeviceLink'
        super(DeviceCapability, self).buildChildren(child_, node, nodeName_, True)
# end class DeviceCapability


class UsagePointBase(IdentifiedObject):
    """Logical point on a network at which consumption or production is
    either physically measured (e.g. metered) or estimated (e.g.
    unmetered street lights). A container for associating
    ReadingType, Readings and ReadingSets."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, roleFlags=None, serviceCategoryKind=None, status=None):
        self.original_tagname_ = None
        super(UsagePointBase, self).__init__()
        self.roleFlags = roleFlags
        self.serviceCategoryKind = serviceCategoryKind
        self.status = status
    def factory(*args_, **kwargs_):
        if UsagePointBase.subclass:
            return UsagePointBase.subclass(*args_, **kwargs_)
        else:
            return UsagePointBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_roleFlags(self): return self.roleFlags
    def set_roleFlags(self, roleFlags): self.roleFlags = roleFlags
    def get_serviceCategoryKind(self): return self.serviceCategoryKind
    def set_serviceCategoryKind(self, serviceCategoryKind): self.serviceCategoryKind = serviceCategoryKind
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.roleFlags is not None or
            self.serviceCategoryKind is not None or
            self.status is not None or
            super(UsagePointBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UsagePointBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePointBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UsagePointBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UsagePointBase'):
        super(UsagePointBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePointBase')
    def exportChildren(self, outfile, level, namespace_='', name_='UsagePointBase', fromsubclass_=False, pretty_print=True):
        super(UsagePointBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.roleFlags is not None:
            self.roleFlags.export(outfile, level, namespace_, name_='roleFlags', pretty_print=pretty_print)
        if self.serviceCategoryKind is not None:
            self.serviceCategoryKind.export(outfile, level, namespace_, name_='serviceCategoryKind', pretty_print=pretty_print)
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_format_integer(self.status, input_name='status'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='UsagePointBase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UsagePointBase, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UsagePointBase, self).exportLiteralChildren(outfile, level, name_)
        if self.roleFlags is not None:
            showIndent(outfile, level)
            outfile.write('roleFlags=model_.RoleFlagsType(\n')
            self.roleFlags.exportLiteral(outfile, level, name_='roleFlags')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.serviceCategoryKind is not None:
            showIndent(outfile, level)
            outfile.write('serviceCategoryKind=model_.ServiceKind(\n')
            self.serviceCategoryKind.exportLiteral(outfile, level, name_='serviceCategoryKind')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % self.status)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UsagePointBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'roleFlags':
            obj_ = RoleFlagsType.factory()
            obj_.build(child_)
            self.roleFlags = obj_
            obj_.original_tagname_ = 'roleFlags'
        elif nodeName_ == 'serviceCategoryKind':
            obj_ = ServiceKind.factory()
            obj_.build(child_)
            self.serviceCategoryKind = obj_
            obj_.original_tagname_ = 'serviceCategoryKind'
        elif nodeName_ == 'status':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
            self.validate_UInt8(self.status)    # validate type UInt8
        super(UsagePointBase, self).buildChildren(child_, node, nodeName_, True)
# end class UsagePointBase


class ReadingSetBase(IdentifiedObject):
    """A set of Readings of the ReadingType indicated by the parent
    MeterReading. ReadingBase is abstract, used to define the
    elements common to ReadingSet and IntervalBlock."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, timePeriod=None):
        self.original_tagname_ = None
        super(ReadingSetBase, self).__init__()
        self.timePeriod = timePeriod
    def factory(*args_, **kwargs_):
        if ReadingSetBase.subclass:
            return ReadingSetBase.subclass(*args_, **kwargs_)
        else:
            return ReadingSetBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timePeriod(self): return self.timePeriod
    def set_timePeriod(self, timePeriod): self.timePeriod = timePeriod
    def hasContent_(self):
        if (
            self.timePeriod is not None or
            super(ReadingSetBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingSetBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingSetBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingSetBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingSetBase'):
        super(ReadingSetBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingSetBase')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingSetBase', fromsubclass_=False, pretty_print=True):
        super(ReadingSetBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.timePeriod is not None:
            self.timePeriod.export(outfile, level, namespace_, name_='timePeriod', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReadingSetBase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingSetBase, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingSetBase, self).exportLiteralChildren(outfile, level, name_)
        if self.timePeriod is not None:
            showIndent(outfile, level)
            outfile.write('timePeriod=model_.DateTimeInterval(\n')
            self.timePeriod.exportLiteral(outfile, level, name_='timePeriod')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingSetBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'timePeriod':
            obj_ = DateTimeInterval.factory()
            obj_.build(child_)
            self.timePeriod = obj_
            obj_.original_tagname_ = 'timePeriod'
        super(ReadingSetBase, self).buildChildren(child_, node, nodeName_, True)
# end class ReadingSetBase


class MirrorUsagePointList(List):
    """A List of MirrorUsagePoint instances."""
    subclass = None
    superclass = List
    def __init__(self, MirrorUsagePoint=None):
        self.original_tagname_ = None
        super(MirrorUsagePointList, self).__init__()
        if MirrorUsagePoint is None:
            self.MirrorUsagePoint = []
        else:
            self.MirrorUsagePoint = MirrorUsagePoint
    def factory(*args_, **kwargs_):
        if MirrorUsagePointList.subclass:
            return MirrorUsagePointList.subclass(*args_, **kwargs_)
        else:
            return MirrorUsagePointList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MirrorUsagePoint(self): return self.MirrorUsagePoint
    def set_MirrorUsagePoint(self, MirrorUsagePoint): self.MirrorUsagePoint = MirrorUsagePoint
    def add_MirrorUsagePoint(self, value): self.MirrorUsagePoint.append(value)
    def insert_MirrorUsagePoint_at(self, index, value): self.MirrorUsagePoint.insert(index, value)
    def replace_MirrorUsagePoint_at(self, index, value): self.MirrorUsagePoint[index] = value
    def hasContent_(self):
        if (
            self.MirrorUsagePoint or
            super(MirrorUsagePointList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MirrorUsagePointList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorUsagePointList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MirrorUsagePointList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MirrorUsagePointList'):
        super(MirrorUsagePointList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorUsagePointList')
    def exportChildren(self, outfile, level, namespace_='', name_='MirrorUsagePointList', fromsubclass_=False, pretty_print=True):
        super(MirrorUsagePointList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MirrorUsagePoint_ in self.MirrorUsagePoint:
            MirrorUsagePoint_.export(outfile, level, namespace_, name_='MirrorUsagePoint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MirrorUsagePointList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MirrorUsagePointList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MirrorUsagePointList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('MirrorUsagePoint=[\n')
        level += 1
        for MirrorUsagePoint_ in self.MirrorUsagePoint:
            showIndent(outfile, level)
            outfile.write('model_.MirrorUsagePoint(\n')
            MirrorUsagePoint_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MirrorUsagePointList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MirrorUsagePoint':
            obj_ = MirrorUsagePoint.factory()
            obj_.build(child_)
            self.MirrorUsagePoint.append(obj_)
            obj_.original_tagname_ = 'MirrorUsagePoint'
        super(MirrorUsagePointList, self).buildChildren(child_, node, nodeName_, True)
# end class MirrorUsagePointList


class MirrorUsagePoint(UsagePointBase):
    """A parallel to UsagePoint to support mirroring"""
    subclass = None
    superclass = UsagePointBase
    def __init__(self, deviceLFDI=None, MirrorMeterReading=None):
        self.original_tagname_ = None
        super(MirrorUsagePoint, self).__init__()
        self.deviceLFDI = deviceLFDI
        if MirrorMeterReading is None:
            self.MirrorMeterReading = []
        else:
            self.MirrorMeterReading = MirrorMeterReading
    def factory(*args_, **kwargs_):
        if MirrorUsagePoint.subclass:
            return MirrorUsagePoint.subclass(*args_, **kwargs_)
        else:
            return MirrorUsagePoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_deviceLFDI(self): return self.deviceLFDI
    def set_deviceLFDI(self, deviceLFDI): self.deviceLFDI = deviceLFDI
    def get_MirrorMeterReading(self): return self.MirrorMeterReading
    def set_MirrorMeterReading(self, MirrorMeterReading): self.MirrorMeterReading = MirrorMeterReading
    def add_MirrorMeterReading(self, value): self.MirrorMeterReading.append(value)
    def insert_MirrorMeterReading_at(self, index, value): self.MirrorMeterReading.insert(index, value)
    def replace_MirrorMeterReading_at(self, index, value): self.MirrorMeterReading[index] = value
    def validate_HexBinary160(self, value):
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        pass
    def hasContent_(self):
        if (
            self.deviceLFDI is not None or
            self.MirrorMeterReading or
            super(MirrorUsagePoint, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MirrorUsagePoint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorUsagePoint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MirrorUsagePoint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MirrorUsagePoint'):
        super(MirrorUsagePoint, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorUsagePoint')
    def exportChildren(self, outfile, level, namespace_='', name_='MirrorUsagePoint', fromsubclass_=False, pretty_print=True):
        super(MirrorUsagePoint, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deviceLFDI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeviceLFDI>%s</%sdeviceLFDI>%s' % (namespace_, self.gds_format_string(quote_xml(self.deviceLFDI).encode(ExternalEncoding), input_name='deviceLFDI'), namespace_, eol_))
        for MirrorMeterReading_ in self.MirrorMeterReading:
            MirrorMeterReading_.export(outfile, level, namespace_, name_='MirrorMeterReading', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MirrorUsagePoint'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MirrorUsagePoint, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MirrorUsagePoint, self).exportLiteralChildren(outfile, level, name_)
        if self.deviceLFDI is not None:
            showIndent(outfile, level)
            outfile.write('deviceLFDI=%s,\n' % quote_python(self.deviceLFDI).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('MirrorMeterReading=[\n')
        level += 1
        for MirrorMeterReading_ in self.MirrorMeterReading:
            showIndent(outfile, level)
            outfile.write('model_.MirrorMeterReading(\n')
            MirrorMeterReading_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MirrorUsagePoint, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'deviceLFDI':
            deviceLFDI_ = child_.text
            deviceLFDI_ = self.gds_validate_string(deviceLFDI_, node, 'deviceLFDI')
            self.deviceLFDI = deviceLFDI_
            self.validate_HexBinary160(self.deviceLFDI)    # validate type HexBinary160
        elif nodeName_ == 'MirrorMeterReading':
            obj_ = MirrorMeterReading.factory()
            obj_.build(child_)
            self.MirrorMeterReading.append(obj_)
            obj_.original_tagname_ = 'MirrorMeterReading'
        super(MirrorUsagePoint, self).buildChildren(child_, node, nodeName_, True)
# end class MirrorUsagePoint


class MirrorReadingSet(ReadingSetBase):
    """A set of Readings of the ReadingType indicated by the parent
    MeterReading."""
    subclass = None
    superclass = ReadingSetBase
    def __init__(self, Reading=None):
        self.original_tagname_ = None
        super(MirrorReadingSet, self).__init__()
        if Reading is None:
            self.Reading = []
        else:
            self.Reading = Reading
    def factory(*args_, **kwargs_):
        if MirrorReadingSet.subclass:
            return MirrorReadingSet.subclass(*args_, **kwargs_)
        else:
            return MirrorReadingSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Reading(self): return self.Reading
    def set_Reading(self, Reading): self.Reading = Reading
    def add_Reading(self, value): self.Reading.append(value)
    def insert_Reading_at(self, index, value): self.Reading.insert(index, value)
    def replace_Reading_at(self, index, value): self.Reading[index] = value
    def hasContent_(self):
        if (
            self.Reading or
            super(MirrorReadingSet, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MirrorReadingSet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorReadingSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MirrorReadingSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MirrorReadingSet'):
        super(MirrorReadingSet, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorReadingSet')
    def exportChildren(self, outfile, level, namespace_='', name_='MirrorReadingSet', fromsubclass_=False, pretty_print=True):
        super(MirrorReadingSet, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reading_ in self.Reading:
            Reading_.export(outfile, level, namespace_, name_='Reading', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MirrorReadingSet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MirrorReadingSet, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MirrorReadingSet, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Reading=[\n')
        level += 1
        for Reading_ in self.Reading:
            showIndent(outfile, level)
            outfile.write('model_.Reading(\n')
            Reading_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MirrorReadingSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Reading':
            obj_ = Reading.factory()
            obj_.build(child_)
            self.Reading.append(obj_)
            obj_.original_tagname_ = 'Reading'
        super(MirrorReadingSet, self).buildChildren(child_, node, nodeName_, True)
# end class MirrorReadingSet


class MeterReadingBase(IdentifiedObject):
    """A container for associating ReadingType, Readings and ReadingSets."""
    subclass = None
    superclass = IdentifiedObject
    def __init__(self):
        self.original_tagname_ = None
        super(MeterReadingBase, self).__init__()
    def factory(*args_, **kwargs_):
        if MeterReadingBase.subclass:
            return MeterReadingBase.subclass(*args_, **kwargs_)
        else:
            return MeterReadingBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(MeterReadingBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeterReadingBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReadingBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeterReadingBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeterReadingBase'):
        super(MeterReadingBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReadingBase')
    def exportChildren(self, outfile, level, namespace_='', name_='MeterReadingBase', fromsubclass_=False, pretty_print=True):
        super(MeterReadingBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='MeterReadingBase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MeterReadingBase, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MeterReadingBase, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MeterReadingBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MeterReadingBase, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MeterReadingBase


class MirrorMeterReadingList(List):
    """A List of MirrorMeterReading instances."""
    subclass = None
    superclass = List
    def __init__(self, MirrorMeterReading=None):
        self.original_tagname_ = None
        super(MirrorMeterReadingList, self).__init__()
        if MirrorMeterReading is None:
            self.MirrorMeterReading = []
        else:
            self.MirrorMeterReading = MirrorMeterReading
    def factory(*args_, **kwargs_):
        if MirrorMeterReadingList.subclass:
            return MirrorMeterReadingList.subclass(*args_, **kwargs_)
        else:
            return MirrorMeterReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MirrorMeterReading(self): return self.MirrorMeterReading
    def set_MirrorMeterReading(self, MirrorMeterReading): self.MirrorMeterReading = MirrorMeterReading
    def add_MirrorMeterReading(self, value): self.MirrorMeterReading.append(value)
    def insert_MirrorMeterReading_at(self, index, value): self.MirrorMeterReading.insert(index, value)
    def replace_MirrorMeterReading_at(self, index, value): self.MirrorMeterReading[index] = value
    def hasContent_(self):
        if (
            self.MirrorMeterReading or
            super(MirrorMeterReadingList, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MirrorMeterReadingList', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorMeterReadingList')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MirrorMeterReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MirrorMeterReadingList'):
        super(MirrorMeterReadingList, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorMeterReadingList')
    def exportChildren(self, outfile, level, namespace_='', name_='MirrorMeterReadingList', fromsubclass_=False, pretty_print=True):
        super(MirrorMeterReadingList, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MirrorMeterReading_ in self.MirrorMeterReading:
            MirrorMeterReading_.export(outfile, level, namespace_, name_='MirrorMeterReading', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MirrorMeterReadingList'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MirrorMeterReadingList, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MirrorMeterReadingList, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('MirrorMeterReading=[\n')
        level += 1
        for MirrorMeterReading_ in self.MirrorMeterReading:
            showIndent(outfile, level)
            outfile.write('model_.MirrorMeterReading(\n')
            MirrorMeterReading_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MirrorMeterReadingList, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MirrorMeterReading':
            obj_ = MirrorMeterReading.factory()
            obj_.build(child_)
            self.MirrorMeterReading.append(obj_)
            obj_.original_tagname_ = 'MirrorMeterReading'
        super(MirrorMeterReadingList, self).buildChildren(child_, node, nodeName_, True)
# end class MirrorMeterReadingList


class MirrorMeterReading(MeterReadingBase):
    """Mimic of MeterReading used for managing mirrors."""
    subclass = None
    superclass = MeterReadingBase
    def __init__(self, lastUpdateTime=None, MirrorReadingSet=None, nextUpdateTime=None, Reading=None, ReadingType=None):
        self.original_tagname_ = None
        super(MirrorMeterReading, self).__init__()
        self.lastUpdateTime = lastUpdateTime
        if MirrorReadingSet is None:
            self.MirrorReadingSet = []
        else:
            self.MirrorReadingSet = MirrorReadingSet
        self.nextUpdateTime = nextUpdateTime
        self.Reading = Reading
        self.ReadingType = ReadingType
    def factory(*args_, **kwargs_):
        if MirrorMeterReading.subclass:
            return MirrorMeterReading.subclass(*args_, **kwargs_)
        else:
            return MirrorMeterReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lastUpdateTime(self): return self.lastUpdateTime
    def set_lastUpdateTime(self, lastUpdateTime): self.lastUpdateTime = lastUpdateTime
    def get_MirrorReadingSet(self): return self.MirrorReadingSet
    def set_MirrorReadingSet(self, MirrorReadingSet): self.MirrorReadingSet = MirrorReadingSet
    def add_MirrorReadingSet(self, value): self.MirrorReadingSet.append(value)
    def insert_MirrorReadingSet_at(self, index, value): self.MirrorReadingSet.insert(index, value)
    def replace_MirrorReadingSet_at(self, index, value): self.MirrorReadingSet[index] = value
    def get_nextUpdateTime(self): return self.nextUpdateTime
    def set_nextUpdateTime(self, nextUpdateTime): self.nextUpdateTime = nextUpdateTime
    def get_Reading(self): return self.Reading
    def set_Reading(self, Reading): self.Reading = Reading
    def get_ReadingType(self): return self.ReadingType
    def set_ReadingType(self, ReadingType): self.ReadingType = ReadingType
    def hasContent_(self):
        if (
            self.lastUpdateTime is not None or
            self.MirrorReadingSet or
            self.nextUpdateTime is not None or
            self.Reading is not None or
            self.ReadingType is not None or
            super(MirrorMeterReading, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MirrorMeterReading', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorMeterReading')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MirrorMeterReading', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MirrorMeterReading'):
        super(MirrorMeterReading, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MirrorMeterReading')
    def exportChildren(self, outfile, level, namespace_='', name_='MirrorMeterReading', fromsubclass_=False, pretty_print=True):
        super(MirrorMeterReading, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lastUpdateTime is not None:
            self.lastUpdateTime.export(outfile, level, namespace_, name_='lastUpdateTime', pretty_print=pretty_print)
        for MirrorReadingSet_ in self.MirrorReadingSet:
            MirrorReadingSet_.export(outfile, level, namespace_, name_='MirrorReadingSet', pretty_print=pretty_print)
        if self.nextUpdateTime is not None:
            self.nextUpdateTime.export(outfile, level, namespace_, name_='nextUpdateTime', pretty_print=pretty_print)
        if self.Reading is not None:
            self.Reading.export(outfile, level, namespace_, name_='Reading', pretty_print=pretty_print)
        if self.ReadingType is not None:
            self.ReadingType.export(outfile, level, namespace_, name_='ReadingType', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MirrorMeterReading'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MirrorMeterReading, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MirrorMeterReading, self).exportLiteralChildren(outfile, level, name_)
        if self.lastUpdateTime is not None:
            showIndent(outfile, level)
            outfile.write('lastUpdateTime=model_.TimeType(\n')
            self.lastUpdateTime.exportLiteral(outfile, level, name_='lastUpdateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('MirrorReadingSet=[\n')
        level += 1
        for MirrorReadingSet_ in self.MirrorReadingSet:
            showIndent(outfile, level)
            outfile.write('model_.MirrorReadingSet(\n')
            MirrorReadingSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.nextUpdateTime is not None:
            showIndent(outfile, level)
            outfile.write('nextUpdateTime=model_.TimeType(\n')
            self.nextUpdateTime.exportLiteral(outfile, level, name_='nextUpdateTime')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Reading is not None:
            showIndent(outfile, level)
            outfile.write('Reading=model_.Reading(\n')
            self.Reading.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReadingType is not None:
            showIndent(outfile, level)
            outfile.write('ReadingType=model_.ReadingType(\n')
            self.ReadingType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MirrorMeterReading, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'lastUpdateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.lastUpdateTime = obj_
            obj_.original_tagname_ = 'lastUpdateTime'
        elif nodeName_ == 'MirrorReadingSet':
            obj_ = MirrorReadingSet.factory()
            obj_.build(child_)
            self.MirrorReadingSet.append(obj_)
            obj_.original_tagname_ = 'MirrorReadingSet'
        elif nodeName_ == 'nextUpdateTime':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.nextUpdateTime = obj_
            obj_.original_tagname_ = 'nextUpdateTime'
        elif nodeName_ == 'Reading':
            obj_ = Reading.factory()
            obj_.build(child_)
            self.Reading = obj_
            obj_.original_tagname_ = 'Reading'
        elif nodeName_ == 'ReadingType':
            obj_ = ReadingType.factory()
            obj_.build(child_)
            self.ReadingType = obj_
            obj_.original_tagname_ = 'ReadingType'
        super(MirrorMeterReading, self).buildChildren(child_, node, nodeName_, True)
# end class MirrorMeterReading


class BillingReadingSet(ReadingSetBase):
    """Time sequence of readings of the same reading type."""
    subclass = None
    superclass = ReadingSetBase
    def __init__(self, BillingReadingListLink=None):
        self.original_tagname_ = None
        super(BillingReadingSet, self).__init__()
        self.BillingReadingListLink = BillingReadingListLink
    def factory(*args_, **kwargs_):
        if BillingReadingSet.subclass:
            return BillingReadingSet.subclass(*args_, **kwargs_)
        else:
            return BillingReadingSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BillingReadingListLink(self): return self.BillingReadingListLink
    def set_BillingReadingListLink(self, BillingReadingListLink): self.BillingReadingListLink = BillingReadingListLink
    def hasContent_(self):
        if (
            self.BillingReadingListLink is not None or
            super(BillingReadingSet, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingReadingSet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingReadingSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingReadingSet'):
        super(BillingReadingSet, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingReadingSet')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingReadingSet', fromsubclass_=False, pretty_print=True):
        super(BillingReadingSet, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BillingReadingListLink is not None:
            self.BillingReadingListLink.export(outfile, level, namespace_, name_='BillingReadingListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillingReadingSet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingReadingSet, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingReadingSet, self).exportLiteralChildren(outfile, level, name_)
        if self.BillingReadingListLink is not None:
            showIndent(outfile, level)
            outfile.write('BillingReadingListLink=model_.BillingReadingListLink(\n')
            self.BillingReadingListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BillingReadingListLink':
            obj_ = BillingReadingListLink.factory()
            obj_.build(child_)
            self.BillingReadingListLink = obj_
            obj_.original_tagname_ = 'BillingReadingListLink'
        super(BillingReadingSet, self).buildChildren(child_, node, nodeName_, True)
# end class BillingReadingSet


class BillingMeterReadingBase(MeterReadingBase):
    """Contains historical, target, and projection readings of various
    types, possibly associated with charges."""
    subclass = None
    superclass = MeterReadingBase
    def __init__(self, BillingReadingSetListLink=None, ReadingTypeLink=None):
        self.original_tagname_ = None
        super(BillingMeterReadingBase, self).__init__()
        self.BillingReadingSetListLink = BillingReadingSetListLink
        self.ReadingTypeLink = ReadingTypeLink
    def factory(*args_, **kwargs_):
        if BillingMeterReadingBase.subclass:
            return BillingMeterReadingBase.subclass(*args_, **kwargs_)
        else:
            return BillingMeterReadingBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BillingReadingSetListLink(self): return self.BillingReadingSetListLink
    def set_BillingReadingSetListLink(self, BillingReadingSetListLink): self.BillingReadingSetListLink = BillingReadingSetListLink
    def get_ReadingTypeLink(self): return self.ReadingTypeLink
    def set_ReadingTypeLink(self, ReadingTypeLink): self.ReadingTypeLink = ReadingTypeLink
    def hasContent_(self):
        if (
            self.BillingReadingSetListLink is not None or
            self.ReadingTypeLink is not None or
            super(BillingMeterReadingBase, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BillingMeterReadingBase', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BillingMeterReadingBase')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BillingMeterReadingBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BillingMeterReadingBase'):
        super(BillingMeterReadingBase, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BillingMeterReadingBase')
    def exportChildren(self, outfile, level, namespace_='', name_='BillingMeterReadingBase', fromsubclass_=False, pretty_print=True):
        super(BillingMeterReadingBase, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BillingReadingSetListLink is not None:
            self.BillingReadingSetListLink.export(outfile, level, namespace_, name_='BillingReadingSetListLink', pretty_print=pretty_print)
        if self.ReadingTypeLink is not None:
            self.ReadingTypeLink.export(outfile, level, namespace_, name_='ReadingTypeLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='BillingMeterReadingBase'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BillingMeterReadingBase, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BillingMeterReadingBase, self).exportLiteralChildren(outfile, level, name_)
        if self.BillingReadingSetListLink is not None:
            showIndent(outfile, level)
            outfile.write('BillingReadingSetListLink=model_.BillingReadingSetListLink(\n')
            self.BillingReadingSetListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReadingTypeLink is not None:
            showIndent(outfile, level)
            outfile.write('ReadingTypeLink=model_.ReadingTypeLink(\n')
            self.ReadingTypeLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(BillingMeterReadingBase, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BillingReadingSetListLink':
            obj_ = BillingReadingSetListLink.factory()
            obj_.build(child_)
            self.BillingReadingSetListLink = obj_
            obj_.original_tagname_ = 'BillingReadingSetListLink'
        elif nodeName_ == 'ReadingTypeLink':
            obj_ = ReadingTypeLink.factory()
            obj_.build(child_)
            self.ReadingTypeLink = obj_
            obj_.original_tagname_ = 'ReadingTypeLink'
        super(BillingMeterReadingBase, self).buildChildren(child_, node, nodeName_, True)
# end class BillingMeterReadingBase


class UsagePoint(UsagePointBase):
    """Logical point on a network at which consumption or production is
    either physically measured (e.g. metered) or estimated (e.g.
    unmetered street lights)."""
    subclass = None
    superclass = UsagePointBase
    def __init__(self, MeterReadingListLink=None):
        self.original_tagname_ = None
        super(UsagePoint, self).__init__()
        self.MeterReadingListLink = MeterReadingListLink
    def factory(*args_, **kwargs_):
        if UsagePoint.subclass:
            return UsagePoint.subclass(*args_, **kwargs_)
        else:
            return UsagePoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MeterReadingListLink(self): return self.MeterReadingListLink
    def set_MeterReadingListLink(self, MeterReadingListLink): self.MeterReadingListLink = MeterReadingListLink
    def hasContent_(self):
        if (
            self.MeterReadingListLink is not None or
            super(UsagePoint, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='UsagePoint', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePoint')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='UsagePoint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='UsagePoint'):
        super(UsagePoint, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UsagePoint')
    def exportChildren(self, outfile, level, namespace_='', name_='UsagePoint', fromsubclass_=False, pretty_print=True):
        super(UsagePoint, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MeterReadingListLink is not None:
            self.MeterReadingListLink.export(outfile, level, namespace_, name_='MeterReadingListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='UsagePoint'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UsagePoint, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UsagePoint, self).exportLiteralChildren(outfile, level, name_)
        if self.MeterReadingListLink is not None:
            showIndent(outfile, level)
            outfile.write('MeterReadingListLink=model_.MeterReadingListLink(\n')
            self.MeterReadingListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UsagePoint, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MeterReadingListLink':
            obj_ = MeterReadingListLink.factory()
            obj_.build(child_)
            self.MeterReadingListLink = obj_
            obj_.original_tagname_ = 'MeterReadingListLink'
        super(UsagePoint, self).buildChildren(child_, node, nodeName_, True)
# end class UsagePoint


class ReadingSet(ReadingSetBase):
    """A set of Readings of the ReadingType indicated by the parent
    MeterReading."""
    subclass = None
    superclass = ReadingSetBase
    def __init__(self, ReadingListLink=None):
        self.original_tagname_ = None
        super(ReadingSet, self).__init__()
        self.ReadingListLink = ReadingListLink
    def factory(*args_, **kwargs_):
        if ReadingSet.subclass:
            return ReadingSet.subclass(*args_, **kwargs_)
        else:
            return ReadingSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReadingListLink(self): return self.ReadingListLink
    def set_ReadingListLink(self, ReadingListLink): self.ReadingListLink = ReadingListLink
    def hasContent_(self):
        if (
            self.ReadingListLink is not None or
            super(ReadingSet, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReadingSet', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingSet')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReadingSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReadingSet'):
        super(ReadingSet, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ReadingSet')
    def exportChildren(self, outfile, level, namespace_='', name_='ReadingSet', fromsubclass_=False, pretty_print=True):
        super(ReadingSet, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReadingListLink is not None:
            self.ReadingListLink.export(outfile, level, namespace_, name_='ReadingListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReadingSet'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ReadingSet, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ReadingSet, self).exportLiteralChildren(outfile, level, name_)
        if self.ReadingListLink is not None:
            showIndent(outfile, level)
            outfile.write('ReadingListLink=model_.ReadingListLink(\n')
            self.ReadingListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ReadingSet, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReadingListLink':
            obj_ = ReadingListLink.factory()
            obj_.build(child_)
            self.ReadingListLink = obj_
            obj_.original_tagname_ = 'ReadingListLink'
        super(ReadingSet, self).buildChildren(child_, node, nodeName_, True)
# end class ReadingSet


class MeterReading(MeterReadingBase):
    """Set of values obtained from the meter."""
    subclass = None
    superclass = MeterReadingBase
    def __init__(self, RateComponentListLink=None, ReadingLink=None, ReadingSetListLink=None, ReadingTypeLink=None):
        self.original_tagname_ = None
        super(MeterReading, self).__init__()
        self.RateComponentListLink = RateComponentListLink
        self.ReadingLink = ReadingLink
        self.ReadingSetListLink = ReadingSetListLink
        self.ReadingTypeLink = ReadingTypeLink
    def factory(*args_, **kwargs_):
        if MeterReading.subclass:
            return MeterReading.subclass(*args_, **kwargs_)
        else:
            return MeterReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RateComponentListLink(self): return self.RateComponentListLink
    def set_RateComponentListLink(self, RateComponentListLink): self.RateComponentListLink = RateComponentListLink
    def get_ReadingLink(self): return self.ReadingLink
    def set_ReadingLink(self, ReadingLink): self.ReadingLink = ReadingLink
    def get_ReadingSetListLink(self): return self.ReadingSetListLink
    def set_ReadingSetListLink(self, ReadingSetListLink): self.ReadingSetListLink = ReadingSetListLink
    def get_ReadingTypeLink(self): return self.ReadingTypeLink
    def set_ReadingTypeLink(self, ReadingTypeLink): self.ReadingTypeLink = ReadingTypeLink
    def hasContent_(self):
        if (
            self.RateComponentListLink is not None or
            self.ReadingLink is not None or
            self.ReadingSetListLink is not None or
            self.ReadingTypeLink is not None or
            super(MeterReading, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='MeterReading', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReading')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='MeterReading', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='MeterReading'):
        super(MeterReading, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MeterReading')
    def exportChildren(self, outfile, level, namespace_='', name_='MeterReading', fromsubclass_=False, pretty_print=True):
        super(MeterReading, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RateComponentListLink is not None:
            self.RateComponentListLink.export(outfile, level, namespace_, name_='RateComponentListLink', pretty_print=pretty_print)
        if self.ReadingLink is not None:
            self.ReadingLink.export(outfile, level, namespace_, name_='ReadingLink', pretty_print=pretty_print)
        if self.ReadingSetListLink is not None:
            self.ReadingSetListLink.export(outfile, level, namespace_, name_='ReadingSetListLink', pretty_print=pretty_print)
        if self.ReadingTypeLink is not None:
            self.ReadingTypeLink.export(outfile, level, namespace_, name_='ReadingTypeLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MeterReading'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MeterReading, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MeterReading, self).exportLiteralChildren(outfile, level, name_)
        if self.RateComponentListLink is not None:
            showIndent(outfile, level)
            outfile.write('RateComponentListLink=model_.RateComponentListLink(\n')
            self.RateComponentListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReadingLink is not None:
            showIndent(outfile, level)
            outfile.write('ReadingLink=model_.ReadingLink(\n')
            self.ReadingLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReadingSetListLink is not None:
            showIndent(outfile, level)
            outfile.write('ReadingSetListLink=model_.ReadingSetListLink(\n')
            self.ReadingSetListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReadingTypeLink is not None:
            showIndent(outfile, level)
            outfile.write('ReadingTypeLink=model_.ReadingTypeLink(\n')
            self.ReadingTypeLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MeterReading, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RateComponentListLink':
            obj_ = RateComponentListLink.factory()
            obj_.build(child_)
            self.RateComponentListLink = obj_
            obj_.original_tagname_ = 'RateComponentListLink'
        elif nodeName_ == 'ReadingLink':
            obj_ = ReadingLink.factory()
            obj_.build(child_)
            self.ReadingLink = obj_
            obj_.original_tagname_ = 'ReadingLink'
        elif nodeName_ == 'ReadingSetListLink':
            obj_ = ReadingSetListLink.factory()
            obj_.build(child_)
            self.ReadingSetListLink = obj_
            obj_.original_tagname_ = 'ReadingSetListLink'
        elif nodeName_ == 'ReadingTypeLink':
            obj_ = ReadingTypeLink.factory()
            obj_.build(child_)
            self.ReadingTypeLink = obj_
            obj_.original_tagname_ = 'ReadingTypeLink'
        super(MeterReading, self).buildChildren(child_, node, nodeName_, True)
# end class MeterReading


class TextResponse(Response):
    """A response to a text message"""
    subclass = None
    superclass = Response
    def __init__(self):
        self.original_tagname_ = None
        super(TextResponse, self).__init__()
    def factory(*args_, **kwargs_):
        if TextResponse.subclass:
            return TextResponse.subclass(*args_, **kwargs_)
        else:
            return TextResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(TextResponse, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TextResponse', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextResponse')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TextResponse', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TextResponse'):
        super(TextResponse, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TextResponse')
    def exportChildren(self, outfile, level, namespace_='', name_='TextResponse', fromsubclass_=False, pretty_print=True):
        super(TextResponse, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TextResponse'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TextResponse, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TextResponse, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TextResponse, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TextResponse, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TextResponse


class Notification(SubscriptionBase):
    """Holds the information related to a client subscription to receive
    updates to a resource automatically. The actual resources may be
    passed in the Notification by specifying a specific xsi:type for
    the Resource and passing the full representation."""
    subclass = None
    superclass = SubscriptionBase
    def __init__(self, newResourceURI=None, Resource=None, status=None, subscriptionURI=None):
        self.original_tagname_ = None
        super(Notification, self).__init__()
        self.newResourceURI = newResourceURI
        self.Resource = Resource
        self.status = status
        self.subscriptionURI = subscriptionURI
    def factory(*args_, **kwargs_):
        if Notification.subclass:
            return Notification.subclass(*args_, **kwargs_)
        else:
            return Notification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_newResourceURI(self): return self.newResourceURI
    def set_newResourceURI(self, newResourceURI): self.newResourceURI = newResourceURI
    def get_Resource(self): return self.Resource
    def set_Resource(self, Resource): self.Resource = Resource
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_subscriptionURI(self): return self.subscriptionURI
    def set_subscriptionURI(self, subscriptionURI): self.subscriptionURI = subscriptionURI
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def hasContent_(self):
        if (
            self.newResourceURI is not None or
            self.Resource is not None or
            self.status is not None or
            self.subscriptionURI is not None or
            super(Notification, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Notification', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Notification')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Notification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Notification'):
        super(Notification, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Notification')
    def exportChildren(self, outfile, level, namespace_='', name_='Notification', fromsubclass_=False, pretty_print=True):
        super(Notification, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.newResourceURI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewResourceURI>%s</%snewResourceURI>%s' % (namespace_, self.gds_format_string(quote_xml(self.newResourceURI).encode(ExternalEncoding), input_name='newResourceURI'), namespace_, eol_))
        if self.Resource is not None:
            self.Resource.export(outfile, level, namespace_, name_='Resource', pretty_print=pretty_print)
        if self.status is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespace_, self.gds_format_integer(self.status, input_name='status'), namespace_, eol_))
        if self.subscriptionURI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubscriptionURI>%s</%ssubscriptionURI>%s' % (namespace_, self.gds_format_string(quote_xml(self.subscriptionURI).encode(ExternalEncoding), input_name='subscriptionURI'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Notification'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Notification, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Notification, self).exportLiteralChildren(outfile, level, name_)
        if self.newResourceURI is not None:
            showIndent(outfile, level)
            outfile.write('newResourceURI=%s,\n' % quote_python(self.newResourceURI).encode(ExternalEncoding))
        if self.Resource is not None:
            showIndent(outfile, level)
            outfile.write('Resource=model_.Resource(\n')
            self.Resource.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.status is not None:
            showIndent(outfile, level)
            outfile.write('status=%d,\n' % self.status)
        if self.subscriptionURI is not None:
            showIndent(outfile, level)
            outfile.write('subscriptionURI=%s,\n' % quote_python(self.subscriptionURI).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Notification, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'newResourceURI':
            newResourceURI_ = child_.text
            newResourceURI_ = self.gds_validate_string(newResourceURI_, node, 'newResourceURI')
            self.newResourceURI = newResourceURI_
        elif nodeName_ == 'Resource':
            class_obj_ = self.get_class_obj_(child_, Resource)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Resource = obj_
            obj_.original_tagname_ = 'Resource'
        elif nodeName_ == 'status':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
            self.validate_UInt8(self.status)    # validate type UInt8
        elif nodeName_ == 'subscriptionURI':
            subscriptionURI_ = child_.text
            subscriptionURI_ = self.gds_validate_string(subscriptionURI_, node, 'subscriptionURI')
            self.subscriptionURI = subscriptionURI_
        super(Notification, self).buildChildren(child_, node, nodeName_, True)
# end class Notification


class Subscription(SubscriptionBase):
    """Holds the information related to a client subscription to receive
    updates to a resource automatically."""
    subclass = None
    superclass = SubscriptionBase
    def __init__(self, Condition=None, encoding=None, level=None, limit=None, notificationURI=None):
        self.original_tagname_ = None
        super(Subscription, self).__init__()
        self.Condition = Condition
        self.encoding = encoding
        self.level = level
        self.limit = limit
        self.notificationURI = notificationURI
    def factory(*args_, **kwargs_):
        if Subscription.subclass:
            return Subscription.subclass(*args_, **kwargs_)
        else:
            return Subscription(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def get_encoding(self): return self.encoding
    def set_encoding(self, encoding): self.encoding = encoding
    def get_level(self): return self.level
    def set_level(self, level): self.level = level
    def get_limit(self): return self.limit
    def set_limit(self, limit): self.limit = limit
    def get_notificationURI(self): return self.notificationURI
    def set_notificationURI(self, notificationURI): self.notificationURI = notificationURI
    def validate_UInt8(self, value):
        # Validate type UInt8, a restriction on xs:unsignedByte.
        pass
    def validate_String16(self, value):
        # Validate type String16, a restriction on xs:string.
        pass
    def validate_UInt16(self, value):
        # Validate type UInt16, a restriction on xs:unsignedShort.
        pass
    def hasContent_(self):
        if (
            self.Condition is not None or
            self.encoding is not None or
            self.level is not None or
            self.limit is not None or
            self.notificationURI is not None or
            super(Subscription, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Subscription', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Subscription')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='Subscription', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Subscription'):
        super(Subscription, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Subscription')
    def exportChildren(self, outfile, level, namespace_='', name_='Subscription', fromsubclass_=False, pretty_print=True):
        super(Subscription, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Condition is not None:
            self.Condition.export(outfile, level, namespace_, name_='Condition', pretty_print=pretty_print)
        if self.encoding is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sencoding>%s</%sencoding>%s' % (namespace_, self.gds_format_integer(self.encoding, input_name='encoding'), namespace_, eol_))
        if self.level is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevel>%s</%slevel>%s' % (namespace_, self.gds_format_string(quote_xml(self.level).encode(ExternalEncoding), input_name='level'), namespace_, eol_))
        if self.limit is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimit>%s</%slimit>%s' % (namespace_, self.gds_format_integer(self.limit, input_name='limit'), namespace_, eol_))
        if self.notificationURI is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotificationURI>%s</%snotificationURI>%s' % (namespace_, self.gds_format_string(quote_xml(self.notificationURI).encode(ExternalEncoding), input_name='notificationURI'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Subscription'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Subscription, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Subscription, self).exportLiteralChildren(outfile, level, name_)
        if self.Condition is not None:
            showIndent(outfile, level)
            outfile.write('Condition=model_.Condition(\n')
            self.Condition.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.encoding is not None:
            showIndent(outfile, level)
            outfile.write('encoding=%d,\n' % self.encoding)
        if self.level is not None:
            showIndent(outfile, level)
            outfile.write('level=%s,\n' % quote_python(self.level).encode(ExternalEncoding))
        if self.limit is not None:
            showIndent(outfile, level)
            outfile.write('limit=%d,\n' % self.limit)
        if self.notificationURI is not None:
            showIndent(outfile, level)
            outfile.write('notificationURI=%s,\n' % quote_python(self.notificationURI).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(Subscription, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Condition':
            obj_ = Condition.factory()
            obj_.build(child_)
            self.Condition = obj_
            obj_.original_tagname_ = 'Condition'
        elif nodeName_ == 'encoding':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'encoding')
            self.encoding = ival_
            self.validate_UInt8(self.encoding)    # validate type UInt8
        elif nodeName_ == 'level':
            level_ = child_.text
            level_ = self.gds_validate_string(level_, node, 'level')
            self.level = level_
            self.validate_String16(self.level)    # validate type String16
        elif nodeName_ == 'limit':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'limit')
            self.limit = ival_
            self.validate_UInt16(self.limit)    # validate type UInt16
        elif nodeName_ == 'notificationURI':
            notificationURI_ = child_.text
            notificationURI_ = self.gds_validate_string(notificationURI_, node, 'notificationURI')
            self.notificationURI = notificationURI_
        super(Subscription, self).buildChildren(child_, node, nodeName_, True)
# end class Subscription


class FunctionSetAssignments(FunctionSetAssignmentsBase):
    """Provides an identifiable, subscribable collection of resources for a
    particular device to consume.Indicates whether or not
    subscriptions are supported for this resource, and whether or
    not conditional (thresholds) are supported. If not specified, is
    "not subscribable" (0)."""
    subclass = None
    superclass = FunctionSetAssignmentsBase
    def __init__(self, subscribable='0', mRID=None, description=None, version=None):
        self.original_tagname_ = None
        super(FunctionSetAssignments, self).__init__()
        self.subscribable = _cast(None, subscribable)
        self.mRID = mRID
        self.description = description
        self.version = version
    def factory(*args_, **kwargs_):
        if FunctionSetAssignments.subclass:
            return FunctionSetAssignments.subclass(*args_, **kwargs_)
        else:
            return FunctionSetAssignments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_mRID(self): return self.mRID
    def set_mRID(self, mRID): self.mRID = mRID
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_subscribable(self): return self.subscribable
    def set_subscribable(self, subscribable): self.subscribable = subscribable
    def validate_String32(self, value):
        # Validate type String32, a restriction on xs:string.
        pass
    def validate_SubscribableType(self, value):
        # Validate type SubscribableType, a restriction on UInt8.
        pass
    def hasContent_(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(FunctionSetAssignments, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FunctionSetAssignments', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionSetAssignments')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FunctionSetAssignments', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FunctionSetAssignments'):
        super(FunctionSetAssignments, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionSetAssignments')
        if self.subscribable is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            outfile.write(' subscribable=%s' % (quote_attrib(self.subscribable), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FunctionSetAssignments', fromsubclass_=False, pretty_print=True):
        super(FunctionSetAssignments, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            self.mRID.export(outfile, level, namespace_, name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespace_, self.gds_format_string(quote_xml(self.description).encode(ExternalEncoding), input_name='description'), namespace_, eol_))
        if self.version is not None:
            self.version.export(outfile, level, namespace_, name_='version', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FunctionSetAssignments'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.subscribable is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            showIndent(outfile, level)
            outfile.write('subscribable=%d,\n' % (self.subscribable,))
        super(FunctionSetAssignments, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FunctionSetAssignments, self).exportLiteralChildren(outfile, level, name_)
        if self.mRID is not None:
            showIndent(outfile, level)
            outfile.write('mRID=model_.mRIDType(\n')
            self.mRID.exportLiteral(outfile, level, name_='mRID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.description is not None:
            showIndent(outfile, level)
            outfile.write('description=%s,\n' % quote_python(self.description).encode(ExternalEncoding))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=model_.VersionType(\n')
            self.version.exportLiteral(outfile, level, name_='version')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subscribable', node)
        if value is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            self.subscribable = value
            self.validate_SubscribableType(self.subscribable)    # validate type SubscribableType
        super(FunctionSetAssignments, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory()
            obj_.build(child_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            description_ = child_.text
            description_ = self.gds_validate_string(description_, node, 'description')
            self.description = description_
            self.validate_String32(self.description)    # validate type String32
        elif nodeName_ == 'version':
            obj_ = VersionType.factory()
            obj_.build(child_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(FunctionSetAssignments, self).buildChildren(child_, node, nodeName_, True)
# end class FunctionSetAssignments


class SelfDevice(AbstractDevice):
    """The EndDevice providing the resources available within the
    DeviceCapabilities."""
    subclass = None
    superclass = AbstractDevice
    def __init__(self):
        self.original_tagname_ = None
        super(SelfDevice, self).__init__()
    def factory(*args_, **kwargs_):
        if SelfDevice.subclass:
            return SelfDevice.subclass(*args_, **kwargs_)
        else:
            return SelfDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(SelfDevice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SelfDevice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SelfDevice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SelfDevice', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SelfDevice'):
        super(SelfDevice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SelfDevice')
    def exportChildren(self, outfile, level, namespace_='', name_='SelfDevice', fromsubclass_=False, pretty_print=True):
        super(SelfDevice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='SelfDevice'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SelfDevice, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SelfDevice, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SelfDevice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(SelfDevice, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class SelfDevice


class EndDevice(AbstractDevice):
    """Asset container that performs one or more end device functions.
    Contains information about individual devices in the network."""
    subclass = None
    superclass = AbstractDevice
    def __init__(self, FlowReservationRequestListLink=None, FlowReservationResponseListLink=None, FunctionSetAssignmentsListLink=None, RegistrationLink=None, SubscriptionListLink=None):
        self.original_tagname_ = None
        super(EndDevice, self).__init__()
        self.FlowReservationRequestListLink = FlowReservationRequestListLink
        self.FlowReservationResponseListLink = FlowReservationResponseListLink
        self.FunctionSetAssignmentsListLink = FunctionSetAssignmentsListLink
        self.RegistrationLink = RegistrationLink
        self.SubscriptionListLink = SubscriptionListLink
    def factory(*args_, **kwargs_):
        if EndDevice.subclass:
            return EndDevice.subclass(*args_, **kwargs_)
        else:
            return EndDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FlowReservationRequestListLink(self): return self.FlowReservationRequestListLink
    def set_FlowReservationRequestListLink(self, FlowReservationRequestListLink): self.FlowReservationRequestListLink = FlowReservationRequestListLink
    def get_FlowReservationResponseListLink(self): return self.FlowReservationResponseListLink
    def set_FlowReservationResponseListLink(self, FlowReservationResponseListLink): self.FlowReservationResponseListLink = FlowReservationResponseListLink
    def get_FunctionSetAssignmentsListLink(self): return self.FunctionSetAssignmentsListLink
    def set_FunctionSetAssignmentsListLink(self, FunctionSetAssignmentsListLink): self.FunctionSetAssignmentsListLink = FunctionSetAssignmentsListLink
    def get_RegistrationLink(self): return self.RegistrationLink
    def set_RegistrationLink(self, RegistrationLink): self.RegistrationLink = RegistrationLink
    def get_SubscriptionListLink(self): return self.SubscriptionListLink
    def set_SubscriptionListLink(self, SubscriptionListLink): self.SubscriptionListLink = SubscriptionListLink
    def hasContent_(self):
        if (
            self.FlowReservationRequestListLink is not None or
            self.FlowReservationResponseListLink is not None or
            self.FunctionSetAssignmentsListLink is not None or
            self.RegistrationLink is not None or
            self.SubscriptionListLink is not None or
            super(EndDevice, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EndDevice', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndDevice')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EndDevice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EndDevice'):
        super(EndDevice, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EndDevice')
    def exportChildren(self, outfile, level, namespace_='', name_='EndDevice', fromsubclass_=False, pretty_print=True):
        super(EndDevice, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FlowReservationRequestListLink is not None:
            self.FlowReservationRequestListLink.export(outfile, level, namespace_, name_='FlowReservationRequestListLink', pretty_print=pretty_print)
        if self.FlowReservationResponseListLink is not None:
            self.FlowReservationResponseListLink.export(outfile, level, namespace_, name_='FlowReservationResponseListLink', pretty_print=pretty_print)
        if self.FunctionSetAssignmentsListLink is not None:
            self.FunctionSetAssignmentsListLink.export(outfile, level, namespace_, name_='FunctionSetAssignmentsListLink', pretty_print=pretty_print)
        if self.RegistrationLink is not None:
            self.RegistrationLink.export(outfile, level, namespace_, name_='RegistrationLink', pretty_print=pretty_print)
        if self.SubscriptionListLink is not None:
            self.SubscriptionListLink.export(outfile, level, namespace_, name_='SubscriptionListLink', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EndDevice'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EndDevice, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EndDevice, self).exportLiteralChildren(outfile, level, name_)
        if self.FlowReservationRequestListLink is not None:
            showIndent(outfile, level)
            outfile.write('FlowReservationRequestListLink=model_.FlowReservationRequestListLink(\n')
            self.FlowReservationRequestListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FlowReservationResponseListLink is not None:
            showIndent(outfile, level)
            outfile.write('FlowReservationResponseListLink=model_.FlowReservationResponseListLink(\n')
            self.FlowReservationResponseListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.FunctionSetAssignmentsListLink is not None:
            showIndent(outfile, level)
            outfile.write('FunctionSetAssignmentsListLink=model_.FunctionSetAssignmentsListLink(\n')
            self.FunctionSetAssignmentsListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RegistrationLink is not None:
            showIndent(outfile, level)
            outfile.write('RegistrationLink=model_.RegistrationLink(\n')
            self.RegistrationLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubscriptionListLink is not None:
            showIndent(outfile, level)
            outfile.write('SubscriptionListLink=model_.SubscriptionListLink(\n')
            self.SubscriptionListLink.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EndDevice, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FlowReservationRequestListLink':
            obj_ = FlowReservationRequestListLink.factory()
            obj_.build(child_)
            self.FlowReservationRequestListLink = obj_
            obj_.original_tagname_ = 'FlowReservationRequestListLink'
        elif nodeName_ == 'FlowReservationResponseListLink':
            obj_ = FlowReservationResponseListLink.factory()
            obj_.build(child_)
            self.FlowReservationResponseListLink = obj_
            obj_.original_tagname_ = 'FlowReservationResponseListLink'
        elif nodeName_ == 'FunctionSetAssignmentsListLink':
            obj_ = FunctionSetAssignmentsListLink.factory()
            obj_.build(child_)
            self.FunctionSetAssignmentsListLink = obj_
            obj_.original_tagname_ = 'FunctionSetAssignmentsListLink'
        elif nodeName_ == 'RegistrationLink':
            obj_ = RegistrationLink.factory()
            obj_.build(child_)
            self.RegistrationLink = obj_
            obj_.original_tagname_ = 'RegistrationLink'
        elif nodeName_ == 'SubscriptionListLink':
            obj_ = SubscriptionListLink.factory()
            obj_.build(child_)
            self.SubscriptionListLink = obj_
            obj_.original_tagname_ = 'SubscriptionListLink'
        super(EndDevice, self).buildChildren(child_, node, nodeName_, True)
# end class EndDevice


class TargetReading(BillingMeterReadingBase):
    """Contains readings that specify a target or goal, such as a
    consumption target, to which billing incentives or other
    contractual ramifications may be associated."""
    subclass = None
    superclass = BillingMeterReadingBase
    def __init__(self):
        self.original_tagname_ = None
        super(TargetReading, self).__init__()
    def factory(*args_, **kwargs_):
        if TargetReading.subclass:
            return TargetReading.subclass(*args_, **kwargs_)
        else:
            return TargetReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(TargetReading, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TargetReading', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetReading')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TargetReading', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TargetReading'):
        super(TargetReading, self).exportAttributes(outfile, level, already_processed, namespace_, name_='TargetReading')
    def exportChildren(self, outfile, level, namespace_='', name_='TargetReading', fromsubclass_=False, pretty_print=True):
        super(TargetReading, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='TargetReading'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(TargetReading, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(TargetReading, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(TargetReading, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(TargetReading, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class TargetReading


class ProjectionReading(BillingMeterReadingBase):
    """Contains values that forecast a future reading for the time or
    interval specified."""
    subclass = None
    superclass = BillingMeterReadingBase
    def __init__(self):
        self.original_tagname_ = None
        super(ProjectionReading, self).__init__()
    def factory(*args_, **kwargs_):
        if ProjectionReading.subclass:
            return ProjectionReading.subclass(*args_, **kwargs_)
        else:
            return ProjectionReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(ProjectionReading, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProjectionReading', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectionReading')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProjectionReading', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProjectionReading'):
        super(ProjectionReading, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ProjectionReading')
    def exportChildren(self, outfile, level, namespace_='', name_='ProjectionReading', fromsubclass_=False, pretty_print=True):
        super(ProjectionReading, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='ProjectionReading'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ProjectionReading, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ProjectionReading, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ProjectionReading, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ProjectionReading, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ProjectionReading


class HistoricalReading(BillingMeterReadingBase):
    """To be used to present readings that have been processed and possibly
    corrected (as allowed, due to missing or incorrect data) by
    backend systems. This includes quality codes valid, verified,
    estimated, and derived / corrected."""
    subclass = None
    superclass = BillingMeterReadingBase
    def __init__(self):
        self.original_tagname_ = None
        super(HistoricalReading, self).__init__()
    def factory(*args_, **kwargs_):
        if HistoricalReading.subclass:
            return HistoricalReading.subclass(*args_, **kwargs_)
        else:
            return HistoricalReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(HistoricalReading, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HistoricalReading', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HistoricalReading')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HistoricalReading', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HistoricalReading'):
        super(HistoricalReading, self).exportAttributes(outfile, level, already_processed, namespace_, name_='HistoricalReading')
    def exportChildren(self, outfile, level, namespace_='', name_='HistoricalReading', fromsubclass_=False, pretty_print=True):
        super(HistoricalReading, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='HistoricalReading'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(HistoricalReading, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(HistoricalReading, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(HistoricalReading, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(HistoricalReading, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class HistoricalReading


GDSClassesMapping = {
    'energyRequested': SignedRealEnergy,
    'rtgA': CurrentRMS,
    'setVRefOfs': VoltageRMS,
    'availableCredit': AccountingUnit,
    'secondaryPower': PowerSourceType,
    'rtgW': ActivePower,
    'primaryPower': PowerSourceType,
    'creditStatus': CreditStatusType,
    'opModVoltWatt': DERCurveLink,
    'pricePowerOfTenMultiplier': PowerOfTenMultiplierType,
    'opModVoltVAr': DERCurveLink,
    'maxForwardPower': ActivePower,
    'localControlModeStatus': LocalControlModeStatusType,
    'dstStartRule': DstRuleType,
    'xMultiplier': PowerOfTenMultiplierType,
    'lowEmergencyCreditWarningLevel': AccountingUnit,
    'sheddablePercent': PerCent,
    'flowRateEndLimit': UnitValueType,
    'accumulationBehaviour': AccumulationBehaviourType,
    'yMultiplier': PowerOfTenMultiplierType,
    'uom': UomType,
    'touTier': TOUType,
    'refType': DERUnitRefType,
    'activateTime': TimeType,
    'opModFixedW': PerCent,
    'lowerLimit': DERCurveLink,
    'rtgMinPF': UnsignedFixedPointType,
    'setMinPFNeg': FixedPointType,
    'swActTime': TimeType,
    'reservePercent': PerCent,
    'flowDirection': FlowDirectionType,
    'setMaxDischargeRate': ActivePower,
    'costKind': CostKindType,
    'serviceStatus': ServiceStatusType,
    'rtgVArNeg': ReactivePower,
    'timeChargingStatusPEV': TimeType,
    'curveType': DERCurveType,
    'monetaryUnit': CurrencyCode,
    'energyRequestNow': RealEnergy,
    'estimatedChargeRemaining': PerCent,
    'dateTime': TimeType,
    'genConnectStatus': ConnectStatusType,
    'prepayMode': PrepayModeType,
    'timeChargeIsNeeded': TimeType,
    'upperLimit': DERCurveLink,
    'powerOfTenMultiplier': PowerOfTenMultiplierType,
    'lastUpdateTime': TimeType,
    'locale': LocaleType,
    'serviceCategoryKind': ServiceKind,
    'opModHVRT': CurvePairType,
    'serviceChange': ServiceChange,
    'value': PerCent,
    'logEventPEN': PENType,
    'timePeriod': DateTimeInterval,
    'subject': mRIDType,
    'sFDI': SFDIType,
    'flowRateStartLimit': UnitValueType,
    'chargingPowerNow': ActivePower,
    'version': VersionType,
    'mfID': PENType,
    'creditExpiryLevel': AccountingUnit,
    'setMaxVArNeg': ReactivePower,
    'multiplier': PowerOfTenMultiplierType,
    'randomizeStart': OneHourRangeType,
    'setMinPF': UnsignedFixedPointType,
    'rtgMaxChargeRate': ActivePower,
    'availabilityUpdatePercentChangeThreshold': PerCent,
    'dstEndTime': TimeType,
    'deviceCategory': DeviceCategoryType,
    'dateTimeRegistered': TimeType,
    'rtgAh': AmpereHour,
    'manufacturerStatus': ManufacturerStatusType,
    'statusTimeStamp': TimeType,
    'opModWattPF': DERCurveLink,
    'conversionFactor': UnitValueType,
    'mfDate': TimeType,
    'statWAvail': ActivePower,
    'currentPowerSource': PowerSourceType,
    'modesSupported': DERControlType,
    'opModFixedPF': FixedPowerFactor,
    'energyAvailable': RealEnergy,
    'sheddablePower': ActivePower,
    'changedTime': TimeType,
    'unit': UomType,
    'intervalRequested': DateTimeInterval,
    'start': TimeType,
    'consumptionBlock': ConsumptionBlockType,
    'setMaxW': ActivePower,
    'priority': PriorityType,
    'setMaxVA': ApparentPower,
    'creditTypeInUse': CreditTypeType,
    'dstEndRule': DstRuleType,
    'rtgVA': ApparentPower,
    'type': DERType,
    'potentiallySupersededTime': TimeType,
    'powerRequested': ActivePower,
    'rtgVAr': ReactivePower,
    'rtgWh': WattHour,
    'setMaxChargeRate': ActivePower,
    'stateOfChargeStatus': StateOfChargeStatusType,
    'emergencyCredit': AccountingUnit,
    'dstStartTime': TimeType,
    'updatedTime': TimeType,
    'kind': ChargeKind,
    'energyUnit': RealEnergy,
    'dstOffset': TimeOffsetType,
    'batteryInstallTime': TimeType,
    'creationTime': TimeType,
    'lowCreditWarningLevel': AccountingUnit,
    'availabilityUpdatePowerChangeThreshold': ActivePower,
    'powerAvailable': ActivePower,
    'inverterStatus': InverterStatusType,
    'statusTime': TimeType,
    'nextUpdateTime': TimeType,
    'primacy': PrimacyType,
    'tzOffset': TimeOffsetType,
    'nextRequestAttempt': TimeType,
    'newStatus': ServiceStatusType,
    'creditType': CreditTypeType,
    'roleFlags': RoleFlagsType,
    'effectiveTime': TimeType,
    'readingTime': TimeType,
    'loadShedDeviceCategory': DeviceCategoryType,
    'creditAmount': AccountingUnit,
    'setMaxVAr': ReactivePower,
    'currency': CurrencyCode,
    'setVRef': VoltageRMS,
    'currentLocale': LocaleType,
    'mRID': mRIDType,
    'targetStateOfCharge': PerCent,
    'maxDemand': ActivePower,
    'opModLVRT': CurvePairType,
    'storConnectStatus': ConnectStatusType,
    'opModFixedVAr': FixedVAr,
    'storageModeStatus': StorageModeStatusType,
    'rtgMinPFNeg': FixedPointType,
    'pIN': PINType,
    'emergencyCreditStatus': CreditStatusType,
    'randomizeDuration': OneHourRangeType,
    'yRefType': DERUnitRefType,
    'opModFixedFlow': SignedPerCent,
    'statVArAvail': ReactivePower,
    'startTime': TimeType,
    'phase': PhaseCode,
    'rtgMaxDischargeRate': ActivePower,
    'calorificValue': UnitValueType,
    'localTime': TimeType,
    'commodity': CommodityType,
    'currentTime': TimeType,
    'createdDateTime': TimeType,
    'dataQualifier': DataQualifierType,
    'interval': DateTimeInterval,
    'averageEnergy': RealEnergy,
    'operationalModeStatus': OperationalModeStatusType,
    'creditTypeChange': CreditTypeChange,
    'reserveChargePercent': PerCent,
    'opModFreqWatt': DERCurveLink,
    'newType': CreditTypeType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeviceCapability'
        rootClass = DeviceCapability
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeviceCapability'
        rootClass = DeviceCapability
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from io import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeviceCapability'
        rootClass = DeviceCapability
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeviceCapability'
        rootClass = DeviceCapability
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from xsd_models import *\n\n')
        sys.stdout.write('import xsd_models as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AbstractDevice",
    "AbstractFlowReservation",
    "AccountBalance",
    "AccountBalanceLink",
    "AccountingUnit",
    "AccumulationBehaviourType",
    "ActiveBillingPeriodListLink",
    "ActiveCreditRegisterListLink",
    "ActiveDERControlListLink",
    "ActiveEndDeviceControlListLink",
    "ActiveFlowReservationListLink",
    "ActivePower",
    "ActiveProjectionReadingListLink",
    "ActiveSupplyInterruptionOverrideListLink",
    "ActiveTargetReadingListLink",
    "ActiveTextMessageListLink",
    "ActiveTimeTariffIntervalListLink",
    "AmpereHour",
    "ApparentPower",
    "ApplianceLoadReduction",
    "ApplianceLoadReductionType",
    "AppliedTargetReduction",
    "AssociatedDERProgramListLink",
    "AssociatedUsagePointLink",
    "BillingMeterReadingBase",
    "BillingPeriod",
    "BillingPeriodList",
    "BillingPeriodListLink",
    "BillingReading",
    "BillingReadingList",
    "BillingReadingListLink",
    "BillingReadingSet",
    "BillingReadingSetList",
    "BillingReadingSetListLink",
    "Charge",
    "ChargeKind",
    "CommodityType",
    "Condition",
    "Configuration",
    "ConfigurationLink",
    "ConnectStatusType",
    "ConsumptionBlockType",
    "ConsumptionTariffInterval",
    "ConsumptionTariffIntervalList",
    "ConsumptionTariffIntervalListLink",
    "CostKindType",
    "CreditRegister",
    "CreditRegisterList",
    "CreditRegisterListLink",
    "CreditStatusType",
    "CreditTypeChange",
    "CreditTypeType",
    "CurrencyCode",
    "CurrentDERProgramLink",
    "CurrentRMS",
    "CurveData",
    "CurvePairType",
    "CustomerAccount",
    "CustomerAccountLink",
    "CustomerAccountList",
    "CustomerAccountListLink",
    "CustomerAgreement",
    "CustomerAgreementList",
    "CustomerAgreementListLink",
    "DER",
    "DERAvailability",
    "DERAvailabilityLink",
    "DERCapability",
    "DERCapabilityLink",
    "DERControl",
    "DERControlBase",
    "DERControlList",
    "DERControlListLink",
    "DERControlType",
    "DERCurve",
    "DERCurveLink",
    "DERCurveList",
    "DERCurveListLink",
    "DERCurveType",
    "DERLink",
    "DERList",
    "DERListLink",
    "DERProgram",
    "DERProgramLink",
    "DERProgramList",
    "DERProgramListLink",
    "DERSettings",
    "DERSettingsLink",
    "DERStatus",
    "DERStatusLink",
    "DERType",
    "DERUnitRefType",
    "DRLCCapabilities",
    "DataQualifierType",
    "DateTimeInterval",
    "DefaultDERControl",
    "DefaultDERControlLink",
    "DemandResponseProgram",
    "DemandResponseProgramLink",
    "DemandResponseProgramList",
    "DemandResponseProgramListLink",
    "DeviceCapability",
    "DeviceCapabilityLink",
    "DeviceCategoryType",
    "DeviceInformation",
    "DeviceInformationLink",
    "DeviceStatus",
    "DeviceStatusLink",
    "DrResponse",
    "DstRuleType",
    "DutyCycle",
    "EndDevice",
    "EndDeviceControl",
    "EndDeviceControlList",
    "EndDeviceControlListLink",
    "EndDeviceLink",
    "EndDeviceList",
    "EndDeviceListLink",
    "EnvironmentalCost",
    "Error",
    "Event",
    "EventStatus",
    "File",
    "FileLink",
    "FileList",
    "FileListLink",
    "FileStatus",
    "FileStatusLink",
    "FixedPointType",
    "FixedPowerFactor",
    "FixedVAr",
    "FlowDirectionType",
    "FlowReservationRequest",
    "FlowReservationRequestList",
    "FlowReservationRequestListLink",
    "FlowReservationResponse",
    "FlowReservationResponseList",
    "FlowReservationResponseListLink",
    "FunctionSetAssignments",
    "FunctionSetAssignmentsBase",
    "FunctionSetAssignmentsList",
    "FunctionSetAssignmentsListLink",
    "HistoricalReading",
    "HistoricalReadingList",
    "HistoricalReadingListLink",
    "IEEE_802_15_4",
    "IPAddr",
    "IPAddrList",
    "IPAddrListLink",
    "IPInterface",
    "IPInterfaceList",
    "IPInterfaceListLink",
    "IdentifiedObject",
    "InverterStatusType",
    "KindType",
    "LLInterface",
    "LLInterfaceList",
    "LLInterfaceListLink",
    "Link",
    "List",
    "ListLink",
    "LoadShedAvailability",
    "LoadShedAvailabilityLink",
    "LocalControlModeStatusType",
    "LocaleType",
    "LogEvent",
    "LogEventList",
    "LogEventListLink",
    "ManufacturerStatusType",
    "MessagingProgram",
    "MessagingProgramList",
    "MessagingProgramListLink",
    "MeterReading",
    "MeterReadingBase",
    "MeterReadingLink",
    "MeterReadingList",
    "MeterReadingListLink",
    "MirrorMeterReading",
    "MirrorMeterReadingList",
    "MirrorReadingSet",
    "MirrorUsagePoint",
    "MirrorUsagePointList",
    "MirrorUsagePointListLink",
    "Neighbor",
    "NeighborList",
    "NeighborListLink",
    "Notification",
    "NotificationList",
    "NotificationListLink",
    "Offset",
    "OneHourRangeType",
    "OperationalModeStatusType",
    "PENType",
    "PEVInfo",
    "PINType",
    "PerCent",
    "PhaseCode",
    "PowerConfiguration",
    "PowerOfTenMultiplierType",
    "PowerSourceType",
    "PowerStatus",
    "PowerStatusLink",
    "PrepayModeType",
    "PrepayOperationStatus",
    "PrepayOperationStatusLink",
    "Prepayment",
    "PrepaymentLink",
    "PrepaymentList",
    "PrepaymentListLink",
    "PriceResponse",
    "PriceResponseCfg",
    "PriceResponseCfgList",
    "PriceResponseCfgListLink",
    "PrimacyType",
    "PriorityType",
    "ProjectionReading",
    "ProjectionReadingList",
    "ProjectionReadingListLink",
    "RPLInstance",
    "RPLInstanceList",
    "RPLInstanceListLink",
    "RPLSourceRoutes",
    "RPLSourceRoutesList",
    "RPLSourceRoutesListLink",
    "RandomizableEvent",
    "RateComponent",
    "RateComponentLink",
    "RateComponentList",
    "RateComponentListLink",
    "ReactivePower",
    "Reading",
    "ReadingBase",
    "ReadingLink",
    "ReadingList",
    "ReadingListLink",
    "ReadingSet",
    "ReadingSetBase",
    "ReadingSetList",
    "ReadingSetListLink",
    "ReadingType",
    "ReadingTypeLink",
    "RealEnergy",
    "Registration",
    "RegistrationLink",
    "RequestStatus",
    "Resource",
    "RespondableIdentifiedObject",
    "RespondableResource",
    "RespondableSubscribableIdentifiedObject",
    "Response",
    "ResponseList",
    "ResponseListLink",
    "ResponseSet",
    "ResponseSetList",
    "ResponseSetListLink",
    "RoleFlagsType",
    "SFDIType",
    "SelfDevice",
    "SelfDeviceLink",
    "ServiceChange",
    "ServiceKind",
    "ServiceStatusType",
    "ServiceSupplier",
    "ServiceSupplierLink",
    "ServiceSupplierList",
    "SetPoint",
    "SignedPerCent",
    "SignedRealEnergy",
    "StateOfChargeStatusType",
    "StorageModeStatusType",
    "SubscribableIdentifiedObject",
    "SubscribableList",
    "SubscribableResource",
    "Subscription",
    "SubscriptionBase",
    "SubscriptionList",
    "SubscriptionListLink",
    "SupplyInterruptionOverride",
    "SupplyInterruptionOverrideList",
    "SupplyInterruptionOverrideListLink",
    "SupportedLocale",
    "SupportedLocaleList",
    "SupportedLocaleListLink",
    "TOUType",
    "TargetReading",
    "TargetReadingList",
    "TargetReadingListLink",
    "TargetReduction",
    "TariffProfile",
    "TariffProfileLink",
    "TariffProfileList",
    "TariffProfileListLink",
    "Temperature",
    "TextMessage",
    "TextMessageList",
    "TextMessageListLink",
    "TextResponse",
    "Time",
    "TimeConfiguration",
    "TimeLink",
    "TimeOffsetType",
    "TimeTariffInterval",
    "TimeTariffIntervalList",
    "TimeTariffIntervalListLink",
    "TimeType",
    "UnitType",
    "UnitValueType",
    "UnsignedFixedPointType",
    "UomType",
    "UsagePoint",
    "UsagePointBase",
    "UsagePointLink",
    "UsagePointList",
    "UsagePointListLink",
    "VersionType",
    "VoltageRMS",
    "WattHour",
    "loWPAN",
    "mRIDType"
]
