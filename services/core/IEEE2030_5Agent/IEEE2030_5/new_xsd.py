#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Jun 29 18:10:49 2021 by generateDS.py version 2.39.2.
# Python 3.8.5 (default, Sep  4 2020, 07:30:14)  [GCC 7.3.0]
#
# Command line options:
#   ('-o', '/home/callwardt/repos/volttron/services/core/IEEE2030_5Agent/new_xsd.py')
#
# Command line arguments:
#   sep.xsd
#
# Command line:
#   ../generateDS-2.39.2/generateDS.py -o "/home/callwardt/repos/volttron/services/core/IEEE2030_5Agent/new_xsd.py" sep.xsd
#
# Current working directory (os.getcwd()):
#   Model Build 20180301
#

import sys
try:
    ModulenotfoundExp_ = ModuleNotFoundError
except NameError:
    ModulenotfoundExp_ = ImportError
from six.moves import zip_longest
import os
import re as re_
import base64
import datetime as datetime_
import decimal as decimal_
try:
    from lxml import etree as etree_
except ModulenotfoundExp_ :
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
SaveElementTreeNode = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for an example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#
# Additionally, the generatedsnamespaces module can contain a python
# dictionary named GenerateDSNamespaceTypePrefixes that associates element
# types with the namespace prefixes that are to be added to the
# "xsi:type" attribute value.  See the _exportAttributes method of
# any generated element type and the generation of "xsi:type" for an
# example of the use of this table.
# An example table:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceTypePrefixes = {
#         "ElementtypeC": "aaa:",
#         "ElementtypeD": "bbb:",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ModulenotfoundExp_ :
    GenerateDSNamespaceDefs_ = {}
try:
    from generatedsnamespaces import GenerateDSNamespaceTypePrefixes as GenerateDSNamespaceTypePrefixes_
except ModulenotfoundExp_ :
    GenerateDSNamespaceTypePrefixes_ = {}

#
# You can replace the following class definition by defining an
# importable module named "generatedscollector" containing a class
# named "GdsCollector".  See the default class definition below for
# clues about the possible content of that class.
#
try:
    from generatedscollector import GdsCollector as GdsCollector_
except ModulenotfoundExp_ :

    class GdsCollector_(object):

        def __init__(self, messages=None):
            if messages is None:
                self.messages = []
            else:
                self.messages = messages

        def add_message(self, msg):
            self.messages.append(msg)

        def get_messages(self):
            return self.messages

        def clear_messages(self):
            self.messages = []

        def print_messages(self):
            for msg in self.messages:
                print("Warning: {}".format(msg))

        def write_messages(self, outstream):
            for msg in self.messages:
                outstream.write("Warning: {}\n".format(msg))


#
# The super-class for enum types
#

try:
    from enum import Enum
except ModulenotfoundExp_ :
    Enum = object

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ModulenotfoundExp_ as exp:
    try:
        from generatedssupersuper import GeneratedsSuperSuper
    except ModulenotfoundExp_ as exp:
        class GeneratedsSuperSuper(object):
            pass
    
    class GeneratedsSuper(GeneratedsSuperSuper):
        __hash__ = object.__hash__
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_parse_string(self, input_data, node=None, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_parse_integer(self, input_data, node=None, input_name=''):
            try:
                ival = int(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires integer value: %s' % exp)
            return ival
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            try:
                value = int(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires integer value')
            return value
        def gds_format_integer_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integer values')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_parse_float(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires float or double value: %s' % exp)
            return fval_
        def gds_validate_float(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires float value')
            return value
        def gds_format_float_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of float values')
            return values
        def gds_format_decimal(self, input_data, input_name=''):
            return_value = '%s' % input_data
            if '.' in return_value:
                return_value = return_value.rstrip('0')
                if return_value.endswith('.'):
                    return_value = return_value.rstrip('.')
            return return_value
        def gds_parse_decimal(self, input_data, node=None, input_name=''):
            try:
                decimal_value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return decimal_value
        def gds_validate_decimal(self, input_data, node=None, input_name=''):
            try:
                value = decimal_.Decimal(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires decimal value')
            return value
        def gds_format_decimal_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return ' '.join([self.gds_format_decimal(item) for item in input_data])
        def gds_validate_decimal_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    decimal_.Decimal(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of decimal values')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_parse_double(self, input_data, node=None, input_name=''):
            try:
                fval_ = float(input_data)
            except (TypeError, ValueError) as exp:
                raise_parse_error(node, 'Requires double or float value: %s' % exp)
            return fval_
        def gds_validate_double(self, input_data, node=None, input_name=''):
            try:
                value = float(input_data)
            except (TypeError, ValueError):
                raise_parse_error(node, 'Requires double or float value')
            return value
        def gds_format_double_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(
                        node, 'Requires sequence of double or float values')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_parse_boolean(self, input_data, node=None, input_name=''):
            if input_data in ('true', '1'):
                bval = True
            elif input_data in ('false', '0'):
                bval = False
            else:
                raise_parse_error(node, 'Requires boolean value')
            return bval
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            if input_data not in (True, 1, False, 0, ):
                raise_parse_error(
                    node,
                    'Requires boolean value '
                    '(one of True, 1, False, 0)')
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            if len(input_data) > 0 and not isinstance(input_data[0], BaseStrType_):
                input_data = [str(s) for s in input_data]
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                value = self.gds_parse_boolean(value, node, input_name)
                if value not in (True, 1, False, 0, ):
                    raise_parse_error(
                        node,
                        'Requires sequence of boolean values '
                        '(one of True, 1, False, 0)')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (
                    time_parts[0], "{}".format(micro_seconds).rjust(6, "0"), )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.
            # The target value must match at least one of the patterns
            # in order for the test to succeed.
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    mo = re_.search(patterns2, target)
                    if mo is not None and len(mo.group(0)) == len(target):
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_check_cardinality_(
                self, value, input_name,
                min_occurs=0, max_occurs=1, required=None):
            if value is None:
                length = 0
            elif isinstance(value, list):
                length = len(value)
            else:
                length = 1
            if required is not None :
                if required and length < 1:
                    self.gds_collector_.add_message(
                        "Required value {}{} is missing".format(
                            input_name, self.gds_get_node_lineno_()))
            if length < min_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is below "
                    "the minimum allowed, "
                    "expected at least {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        min_occurs, length))
            elif length > max_occurs:
                self.gds_collector_.add_message(
                    "Number of values for {}{} is above "
                    "the maximum allowed, "
                    "expected at most {}, found {}".format(
                        input_name, self.gds_get_node_lineno_(),
                        max_occurs, length))
        def gds_validate_builtin_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value, input_name=input_name)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_validate_defined_ST_(
                self, validator, value, input_name,
                min_occurs=None, max_occurs=None, required=None):
            if value is not None:
                try:
                    validator(value)
                except GDSParseError as parse_error:
                    self.gds_collector_.add_message(str(parse_error))
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            # provide default value in case option --disable-xml is used.
            content = ""
            content = etree_.tostring(node, encoding="unicode")
            return content
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.items()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            def excl_select_objs_(obj):
                return (obj[0] != 'parent_object_' and
                        obj[0] != 'gds_collector_')
            if type(self) != type(other):
                return False
            return all(x == y for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items())))
        def __ne__(self, other):
            return not self.__eq__(other)
        # Django ETL transform hooks.
        def gds_djo_etl_transform(self):
            pass
        def gds_djo_etl_transform_db_obj(self, dbobj):
            pass
        # SQLAlchemy ETL transform hooks.
        def gds_sqa_etl_transform(self):
            return 0, None
        def gds_sqa_etl_transform_db_obj(self, dbobj):
            pass
        def gds_get_node_lineno_(self):
            if (hasattr(self, "gds_elementtree_node_") and
                    self.gds_elementtree_node_ is not None):
                return ' near line {}'.format(
                    self.gds_elementtree_node_.sourceline)
            else:
                return ""
    
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == 'xml':
            namespace = 'http://www.w3.org/XML/1998/namespace'
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


def encode_str_2_3(instr):
    return instr


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if node is not None:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name_=name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element, mapping_=None, nsmap_=None):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self, mapping_=None, nsmap_=None):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Temperature(GeneratedsSuper):
    """Temperature -- Specification of a temperature.
    multiplier -- Multiplier for 'unit'.
    subject -- The subject of the temperature measurement
    0 - Enclosure
    1 - Transformer
    2 - HeatSink
    value -- Value in Degrees Celsius (uom 23).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, subject=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.subject = subject
        self.validate_UInt8(self.subject)
        self.subject_nsprefix_ = None
        self.value = value
        self.validate_Int16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Temperature)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Temperature.subclass:
            return Temperature.subclass(*args_, **kwargs_)
        else:
            return Temperature(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Int16(self, value):
        result = True
        # Validate type Int16, a restriction on xs:short.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.subject is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Temperature', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Temperature')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Temperature':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Temperature')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Temperature', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Temperature'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Temperature', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubject>%s</%ssubject>%s' % (namespaceprefix_ , self.gds_format_integer(self.subject, input_name='subject'), namespaceprefix_ , eol_))
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'subject' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'subject')
            ival_ = self.gds_validate_integer(ival_, node, 'subject')
            self.subject = ival_
            self.subject_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.subject)
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.value)
# end class Temperature


class Condition(GeneratedsSuper):
    """Condition -- Indicates a condition that must be satisfied for the Notification to be triggered.
    attributeIdentifier -- 0 = Reading value
    1-255 = Reserved
    lowerThreshold -- The value of the lower threshold
    upperThreshold -- The value of the upper threshold
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, attributeIdentifier=None, lowerThreshold=None, upperThreshold=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.attributeIdentifier = attributeIdentifier
        self.validate_UInt8(self.attributeIdentifier)
        self.attributeIdentifier_nsprefix_ = None
        self.lowerThreshold = lowerThreshold
        self.validate_Int48(self.lowerThreshold)
        self.lowerThreshold_nsprefix_ = None
        self.upperThreshold = upperThreshold
        self.validate_Int48(self.upperThreshold)
        self.upperThreshold_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Condition)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Condition.subclass:
            return Condition.subclass(*args_, **kwargs_)
        else:
            return Condition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_attributeIdentifier(self):
        return self.attributeIdentifier
    def set_attributeIdentifier(self, attributeIdentifier):
        self.attributeIdentifier = attributeIdentifier
    def get_lowerThreshold(self):
        return self.lowerThreshold
    def set_lowerThreshold(self, lowerThreshold):
        self.lowerThreshold = lowerThreshold
    def get_upperThreshold(self):
        return self.upperThreshold
    def set_upperThreshold(self, upperThreshold):
        self.upperThreshold = upperThreshold
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Int48(self, value):
        result = True
        # Validate type Int48, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < -140737488355328:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Int48' % {"value": value, "lineno": lineno} )
                result = False
            if value > 140737488355328:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on Int48' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.attributeIdentifier is not None or
            self.lowerThreshold is not None or
            self.upperThreshold is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Condition', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Condition')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Condition':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Condition')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Condition', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Condition'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Condition', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.attributeIdentifier is not None:
            namespaceprefix_ = self.attributeIdentifier_nsprefix_ + ':' if (UseCapturedNS_ and self.attributeIdentifier_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sattributeIdentifier>%s</%sattributeIdentifier>%s' % (namespaceprefix_ , self.gds_format_integer(self.attributeIdentifier, input_name='attributeIdentifier'), namespaceprefix_ , eol_))
        if self.lowerThreshold is not None:
            namespaceprefix_ = self.lowerThreshold_nsprefix_ + ':' if (UseCapturedNS_ and self.lowerThreshold_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slowerThreshold>%s</%slowerThreshold>%s' % (namespaceprefix_ , self.gds_format_integer(self.lowerThreshold, input_name='lowerThreshold'), namespaceprefix_ , eol_))
        if self.upperThreshold is not None:
            namespaceprefix_ = self.upperThreshold_nsprefix_ + ':' if (UseCapturedNS_ and self.upperThreshold_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%supperThreshold>%s</%supperThreshold>%s' % (namespaceprefix_ , self.gds_format_integer(self.upperThreshold, input_name='upperThreshold'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'attributeIdentifier' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'attributeIdentifier')
            ival_ = self.gds_validate_integer(ival_, node, 'attributeIdentifier')
            self.attributeIdentifier = ival_
            self.attributeIdentifier_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.attributeIdentifier)
        elif nodeName_ == 'lowerThreshold' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lowerThreshold')
            ival_ = self.gds_validate_integer(ival_, node, 'lowerThreshold')
            self.lowerThreshold = ival_
            self.lowerThreshold_nsprefix_ = child_.prefix
            # validate type Int48
            self.validate_Int48(self.lowerThreshold)
        elif nodeName_ == 'upperThreshold' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'upperThreshold')
            ival_ = self.gds_validate_integer(ival_, node, 'upperThreshold')
            self.upperThreshold = ival_
            self.upperThreshold_nsprefix_ = child_.prefix
            # validate type Int48
            self.validate_Int48(self.upperThreshold)
# end class Condition


class AppliedTargetReduction(GeneratedsSuper):
    """AppliedTargetReduction -- Specifies the value of the TargetReduction applied by the device.
    type -- Enumerated field representing the type of reduction requested.
    value -- Indicates the requested amount of the relevant commodity to be reduced.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        self.value = value
        self.validate_UInt16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AppliedTargetReduction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AppliedTargetReduction.subclass:
            return AppliedTargetReduction.subclass(*args_, **kwargs_)
        else:
            return AppliedTargetReduction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.type_ is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AppliedTargetReduction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AppliedTargetReduction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AppliedTargetReduction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AppliedTargetReduction')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AppliedTargetReduction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AppliedTargetReduction'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AppliedTargetReduction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'type':
            obj_ = UnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.value)
# end class AppliedTargetReduction


class DRLCCapabilities(GeneratedsSuper):
    """DRLCCapabilities -- Contains information about the static capabilities of the device, to allow service providers to know what types of functions are supported, what the normal operating ranges and limits are, and other similar information, in order to provide better suggestions of applicable programs to receive the maximum benefit.
    averageEnergy -- The average hourly energy usage when in normal operating mode.
    maxDemand -- The maximum demand rating of this end device.
    optionsImplemented -- Bitmap indicating the DRLC options implemented by the device.
    0 - Target reduction (kWh)
    1 - Target reduction (kW)
    2 - Target reduction (Watts)
    3 - Target reduction (Cubic Meters)
    4 - Target reduction (Cubic Feet)
    5 - Target reduction (US Gallons)
    6 - Target reduction (Imperial Gallons)
    7 - Target reduction (BTUs)
    8 - Target reduction (Liters)
    9 - Target reduction (kPA (gauge))
    10 - Target reduction (kPA (absolute))
    11 - Target reduction (Mega Joule)
    12 - Target reduction (Unitless)
    13-15 - Reserved
    16 - Temperature set point
    17 - Temperature offset
    18 - Duty cycle
    19 - Load adjustment percentage
    20 - Appliance load reduction
    21-31 - Reserved
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, averageEnergy=None, maxDemand=None, optionsImplemented=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.averageEnergy = averageEnergy
        self.averageEnergy_nsprefix_ = None
        self.maxDemand = maxDemand
        self.maxDemand_nsprefix_ = None
        self.optionsImplemented = optionsImplemented
        self.validate_HexBinary32(self.optionsImplemented)
        self.optionsImplemented_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DRLCCapabilities)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DRLCCapabilities.subclass:
            return DRLCCapabilities.subclass(*args_, **kwargs_)
        else:
            return DRLCCapabilities(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_averageEnergy(self):
        return self.averageEnergy
    def set_averageEnergy(self, averageEnergy):
        self.averageEnergy = averageEnergy
    def get_maxDemand(self):
        return self.maxDemand
    def set_maxDemand(self, maxDemand):
        self.maxDemand = maxDemand
    def get_optionsImplemented(self):
        return self.optionsImplemented
    def set_optionsImplemented(self, optionsImplemented):
        self.optionsImplemented = optionsImplemented
    def validate_HexBinary32(self, value):
        result = True
        # Validate type HexBinary32, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary32' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.averageEnergy is not None or
            self.maxDemand is not None or
            self.optionsImplemented is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DRLCCapabilities', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DRLCCapabilities')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DRLCCapabilities':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DRLCCapabilities')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DRLCCapabilities', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DRLCCapabilities'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DRLCCapabilities', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.averageEnergy is not None:
            namespaceprefix_ = self.averageEnergy_nsprefix_ + ':' if (UseCapturedNS_ and self.averageEnergy_nsprefix_) else ''
            self.averageEnergy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='averageEnergy', pretty_print=pretty_print)
        if self.maxDemand is not None:
            namespaceprefix_ = self.maxDemand_nsprefix_ + ':' if (UseCapturedNS_ and self.maxDemand_nsprefix_) else ''
            self.maxDemand.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maxDemand', pretty_print=pretty_print)
        if self.optionsImplemented is not None:
            namespaceprefix_ = self.optionsImplemented_nsprefix_ + ':' if (UseCapturedNS_ and self.optionsImplemented_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soptionsImplemented>%s</%soptionsImplemented>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.optionsImplemented), input_name='optionsImplemented')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'averageEnergy':
            obj_ = RealEnergy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.averageEnergy = obj_
            obj_.original_tagname_ = 'averageEnergy'
        elif nodeName_ == 'maxDemand':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maxDemand = obj_
            obj_.original_tagname_ = 'maxDemand'
        elif nodeName_ == 'optionsImplemented':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'optionsImplemented')
            value_ = self.gds_validate_string(value_, node, 'optionsImplemented')
            self.optionsImplemented = value_
            self.optionsImplemented_nsprefix_ = child_.prefix
            # validate type HexBinary32
            self.validate_HexBinary32(self.optionsImplemented)
# end class DRLCCapabilities


class PowerSourceType(GeneratedsSuper):
    """PowerSourceType -- 0 - none
    1 - mains
    2 - battery
    3 - local generation
    4 - emergency
    5 - unknown
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerSourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerSourceType.subclass:
            return PowerSourceType.subclass(*args_, **kwargs_)
        else:
            return PowerSourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PowerSourceType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PowerSourceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PowerSourceType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerSourceType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PowerSourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PowerSourceType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PowerSourceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PowerSourceType


class PEVInfo(GeneratedsSuper):
    """PEVInfo -- Contains attributes that can be exposed by PEVs and other devices that have charging requirements.
    chargingPowerNow -- This is the actual power flow in or out of the charger or inverter. This is calculated by the vehicle based on actual measurements. This number is positive for charging.
    energyRequestNow -- This is the amount of energy that must be transferred from the grid to EVSE and PEV to achieve the target state of charge allowing for charger efficiency and any vehicle and EVSE parasitic loads. This is calculated by the vehicle and changes throughout the connection as forward or reverse power flow change the battery state of charge.  This number is positive for charging.
    maxForwardPower -- This is maximum power transfer capability that could be used for charging the PEV to perform the requested energy transfer.  It is the lower of the vehicle or EVSE physical power limitations. It is not based on economic considerations. The vehicle may draw less power than this value based on its charging cycle. The vehicle defines this parameter. This number is positive for charging power flow.
    minimumChargingDuration -- This is computed by the PEV based on the charging profile to complete the energy transfer if the maximum power is authorized.  The value will never be smaller than the ratio of the energy request to the power request because the charging profile may not allow the maximum power to be used throughout the transfer.   This is a critical parameter for determining whether any slack time exists in the charging cycle between the current time and the TCIN.
    targetStateOfCharge -- This is the target state of charge that is to be achieved during charging before the time of departure (TCIN).  The default value is 100%. The value cannot be set to a value less than the actual state of charge.
    timeChargeIsNeeded -- Time Charge is Needed (TCIN) is the time that the PEV is expected to depart. The value is manually entered using controls and displays in the vehicle or on the EVSE or using a mobile device.  It is authenticated and saved by the PEV.  This value may be updated during a charging session.
    timeChargingStatusPEV -- This is the time that the parameters are updated, except for changes to TCIN.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, chargingPowerNow=None, energyRequestNow=None, maxForwardPower=None, minimumChargingDuration=None, targetStateOfCharge=None, timeChargeIsNeeded=None, timeChargingStatusPEV=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.chargingPowerNow = chargingPowerNow
        self.chargingPowerNow_nsprefix_ = None
        self.energyRequestNow = energyRequestNow
        self.energyRequestNow_nsprefix_ = None
        self.maxForwardPower = maxForwardPower
        self.maxForwardPower_nsprefix_ = None
        self.minimumChargingDuration = minimumChargingDuration
        self.validate_UInt32(self.minimumChargingDuration)
        self.minimumChargingDuration_nsprefix_ = None
        self.targetStateOfCharge = targetStateOfCharge
        self.targetStateOfCharge_nsprefix_ = None
        self.timeChargeIsNeeded = timeChargeIsNeeded
        self.timeChargeIsNeeded_nsprefix_ = None
        self.timeChargingStatusPEV = timeChargingStatusPEV
        self.timeChargingStatusPEV_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PEVInfo)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PEVInfo.subclass:
            return PEVInfo.subclass(*args_, **kwargs_)
        else:
            return PEVInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_chargingPowerNow(self):
        return self.chargingPowerNow
    def set_chargingPowerNow(self, chargingPowerNow):
        self.chargingPowerNow = chargingPowerNow
    def get_energyRequestNow(self):
        return self.energyRequestNow
    def set_energyRequestNow(self, energyRequestNow):
        self.energyRequestNow = energyRequestNow
    def get_maxForwardPower(self):
        return self.maxForwardPower
    def set_maxForwardPower(self, maxForwardPower):
        self.maxForwardPower = maxForwardPower
    def get_minimumChargingDuration(self):
        return self.minimumChargingDuration
    def set_minimumChargingDuration(self, minimumChargingDuration):
        self.minimumChargingDuration = minimumChargingDuration
    def get_targetStateOfCharge(self):
        return self.targetStateOfCharge
    def set_targetStateOfCharge(self, targetStateOfCharge):
        self.targetStateOfCharge = targetStateOfCharge
    def get_timeChargeIsNeeded(self):
        return self.timeChargeIsNeeded
    def set_timeChargeIsNeeded(self, timeChargeIsNeeded):
        self.timeChargeIsNeeded = timeChargeIsNeeded
    def get_timeChargingStatusPEV(self):
        return self.timeChargingStatusPEV
    def set_timeChargingStatusPEV(self, timeChargingStatusPEV):
        self.timeChargingStatusPEV = timeChargingStatusPEV
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.chargingPowerNow is not None or
            self.energyRequestNow is not None or
            self.maxForwardPower is not None or
            self.minimumChargingDuration is not None or
            self.targetStateOfCharge is not None or
            self.timeChargeIsNeeded is not None or
            self.timeChargingStatusPEV is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PEVInfo', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PEVInfo')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PEVInfo':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PEVInfo')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PEVInfo', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PEVInfo'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PEVInfo', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.chargingPowerNow is not None:
            namespaceprefix_ = self.chargingPowerNow_nsprefix_ + ':' if (UseCapturedNS_ and self.chargingPowerNow_nsprefix_) else ''
            self.chargingPowerNow.export(outfile, level, namespaceprefix_, namespacedef_='', name_='chargingPowerNow', pretty_print=pretty_print)
        if self.energyRequestNow is not None:
            namespaceprefix_ = self.energyRequestNow_nsprefix_ + ':' if (UseCapturedNS_ and self.energyRequestNow_nsprefix_) else ''
            self.energyRequestNow.export(outfile, level, namespaceprefix_, namespacedef_='', name_='energyRequestNow', pretty_print=pretty_print)
        if self.maxForwardPower is not None:
            namespaceprefix_ = self.maxForwardPower_nsprefix_ + ':' if (UseCapturedNS_ and self.maxForwardPower_nsprefix_) else ''
            self.maxForwardPower.export(outfile, level, namespaceprefix_, namespacedef_='', name_='maxForwardPower', pretty_print=pretty_print)
        if self.minimumChargingDuration is not None:
            namespaceprefix_ = self.minimumChargingDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.minimumChargingDuration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sminimumChargingDuration>%s</%sminimumChargingDuration>%s' % (namespaceprefix_ , self.gds_format_integer(self.minimumChargingDuration, input_name='minimumChargingDuration'), namespaceprefix_ , eol_))
        if self.targetStateOfCharge is not None:
            namespaceprefix_ = self.targetStateOfCharge_nsprefix_ + ':' if (UseCapturedNS_ and self.targetStateOfCharge_nsprefix_) else ''
            self.targetStateOfCharge.export(outfile, level, namespaceprefix_, namespacedef_='', name_='targetStateOfCharge', pretty_print=pretty_print)
        if self.timeChargeIsNeeded is not None:
            namespaceprefix_ = self.timeChargeIsNeeded_nsprefix_ + ':' if (UseCapturedNS_ and self.timeChargeIsNeeded_nsprefix_) else ''
            self.timeChargeIsNeeded.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeChargeIsNeeded', pretty_print=pretty_print)
        if self.timeChargingStatusPEV is not None:
            namespaceprefix_ = self.timeChargingStatusPEV_nsprefix_ + ':' if (UseCapturedNS_ and self.timeChargingStatusPEV_nsprefix_) else ''
            self.timeChargingStatusPEV.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timeChargingStatusPEV', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'chargingPowerNow':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.chargingPowerNow = obj_
            obj_.original_tagname_ = 'chargingPowerNow'
        elif nodeName_ == 'energyRequestNow':
            obj_ = RealEnergy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.energyRequestNow = obj_
            obj_.original_tagname_ = 'energyRequestNow'
        elif nodeName_ == 'maxForwardPower':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.maxForwardPower = obj_
            obj_.original_tagname_ = 'maxForwardPower'
        elif nodeName_ == 'minimumChargingDuration' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'minimumChargingDuration')
            ival_ = self.gds_validate_integer(ival_, node, 'minimumChargingDuration')
            self.minimumChargingDuration = ival_
            self.minimumChargingDuration_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.minimumChargingDuration)
        elif nodeName_ == 'targetStateOfCharge':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.targetStateOfCharge = obj_
            obj_.original_tagname_ = 'targetStateOfCharge'
        elif nodeName_ == 'timeChargeIsNeeded':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeChargeIsNeeded = obj_
            obj_.original_tagname_ = 'timeChargeIsNeeded'
        elif nodeName_ == 'timeChargingStatusPEV':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timeChargingStatusPEV = obj_
            obj_.original_tagname_ = 'timeChargingStatusPEV'
# end class PEVInfo


class IEEE_802_15_4(GeneratedsSuper):
    """IEEE_802_15_4 -- Contains 802.15.4 link layer specific attributes.
    capabilityInfo -- As defined by IEEE 802.15.4
    shortAddress -- As defined by IEEE 802.15.4
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, capabilityInfo=None, NeighborListLink=None, shortAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.capabilityInfo = capabilityInfo
        self.validate_HexBinary8(self.capabilityInfo)
        self.capabilityInfo_nsprefix_ = None
        self.NeighborListLink = NeighborListLink
        self.NeighborListLink_nsprefix_ = None
        self.shortAddress = shortAddress
        self.validate_UInt16(self.shortAddress)
        self.shortAddress_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IEEE_802_15_4)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IEEE_802_15_4.subclass:
            return IEEE_802_15_4.subclass(*args_, **kwargs_)
        else:
            return IEEE_802_15_4(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_capabilityInfo(self):
        return self.capabilityInfo
    def set_capabilityInfo(self, capabilityInfo):
        self.capabilityInfo = capabilityInfo
    def get_NeighborListLink(self):
        return self.NeighborListLink
    def set_NeighborListLink(self, NeighborListLink):
        self.NeighborListLink = NeighborListLink
    def get_shortAddress(self):
        return self.shortAddress
    def set_shortAddress(self, shortAddress):
        self.shortAddress = shortAddress
    def validate_HexBinary8(self, value):
        result = True
        # Validate type HexBinary8, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary8' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.capabilityInfo is not None or
            self.NeighborListLink is not None or
            self.shortAddress is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IEEE_802_15_4', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IEEE_802_15_4')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IEEE_802_15_4':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IEEE_802_15_4')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IEEE_802_15_4', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IEEE_802_15_4'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IEEE_802_15_4', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.capabilityInfo is not None:
            namespaceprefix_ = self.capabilityInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.capabilityInfo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scapabilityInfo>%s</%scapabilityInfo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.capabilityInfo), input_name='capabilityInfo')), namespaceprefix_ , eol_))
        if self.NeighborListLink is not None:
            namespaceprefix_ = self.NeighborListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.NeighborListLink_nsprefix_) else ''
            self.NeighborListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='NeighborListLink', pretty_print=pretty_print)
        if self.shortAddress is not None:
            namespaceprefix_ = self.shortAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.shortAddress_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortAddress>%s</%sshortAddress>%s' % (namespaceprefix_ , self.gds_format_integer(self.shortAddress, input_name='shortAddress'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'capabilityInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'capabilityInfo')
            value_ = self.gds_validate_string(value_, node, 'capabilityInfo')
            self.capabilityInfo = value_
            self.capabilityInfo_nsprefix_ = child_.prefix
            # validate type HexBinary8
            self.validate_HexBinary8(self.capabilityInfo)
        elif nodeName_ == 'NeighborListLink':
            obj_ = NeighborListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.NeighborListLink = obj_
            obj_.original_tagname_ = 'NeighborListLink'
        elif nodeName_ == 'shortAddress' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'shortAddress')
            ival_ = self.gds_validate_integer(ival_, node, 'shortAddress')
            self.shortAddress = ival_
            self.shortAddress_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.shortAddress)
# end class IEEE_802_15_4


class loWPAN(GeneratedsSuper):
    """loWPAN -- Contains information specific to 6LoWPAN.
    octetsRx -- Number of Bytes received
    octetsTx -- Number of Bytes transmitted
    packetsRx -- Number of packets received
    packetsTx -- Number of packets transmitted
    rxFragError -- Number of errors receiving fragments
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, octetsRx=None, octetsTx=None, packetsRx=None, packetsTx=None, rxFragError=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.octetsRx = octetsRx
        self.validate_UInt32(self.octetsRx)
        self.octetsRx_nsprefix_ = None
        self.octetsTx = octetsTx
        self.validate_UInt32(self.octetsTx)
        self.octetsTx_nsprefix_ = None
        self.packetsRx = packetsRx
        self.validate_UInt32(self.packetsRx)
        self.packetsRx_nsprefix_ = None
        self.packetsTx = packetsTx
        self.validate_UInt32(self.packetsTx)
        self.packetsTx_nsprefix_ = None
        self.rxFragError = rxFragError
        self.validate_UInt32(self.rxFragError)
        self.rxFragError_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, loWPAN)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if loWPAN.subclass:
            return loWPAN.subclass(*args_, **kwargs_)
        else:
            return loWPAN(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_octetsRx(self):
        return self.octetsRx
    def set_octetsRx(self, octetsRx):
        self.octetsRx = octetsRx
    def get_octetsTx(self):
        return self.octetsTx
    def set_octetsTx(self, octetsTx):
        self.octetsTx = octetsTx
    def get_packetsRx(self):
        return self.packetsRx
    def set_packetsRx(self, packetsRx):
        self.packetsRx = packetsRx
    def get_packetsTx(self):
        return self.packetsTx
    def set_packetsTx(self, packetsTx):
        self.packetsTx = packetsTx
    def get_rxFragError(self):
        return self.rxFragError
    def set_rxFragError(self, rxFragError):
        self.rxFragError = rxFragError
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.octetsRx is not None or
            self.octetsTx is not None or
            self.packetsRx is not None or
            self.packetsTx is not None or
            self.rxFragError is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='loWPAN', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('loWPAN')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'loWPAN':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='loWPAN')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='loWPAN', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='loWPAN'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='loWPAN', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.octetsRx is not None:
            namespaceprefix_ = self.octetsRx_nsprefix_ + ':' if (UseCapturedNS_ and self.octetsRx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soctetsRx>%s</%soctetsRx>%s' % (namespaceprefix_ , self.gds_format_integer(self.octetsRx, input_name='octetsRx'), namespaceprefix_ , eol_))
        if self.octetsTx is not None:
            namespaceprefix_ = self.octetsTx_nsprefix_ + ':' if (UseCapturedNS_ and self.octetsTx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soctetsTx>%s</%soctetsTx>%s' % (namespaceprefix_ , self.gds_format_integer(self.octetsTx, input_name='octetsTx'), namespaceprefix_ , eol_))
        if self.packetsRx is not None:
            namespaceprefix_ = self.packetsRx_nsprefix_ + ':' if (UseCapturedNS_ and self.packetsRx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spacketsRx>%s</%spacketsRx>%s' % (namespaceprefix_ , self.gds_format_integer(self.packetsRx, input_name='packetsRx'), namespaceprefix_ , eol_))
        if self.packetsTx is not None:
            namespaceprefix_ = self.packetsTx_nsprefix_ + ':' if (UseCapturedNS_ and self.packetsTx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spacketsTx>%s</%spacketsTx>%s' % (namespaceprefix_ , self.gds_format_integer(self.packetsTx, input_name='packetsTx'), namespaceprefix_ , eol_))
        if self.rxFragError is not None:
            namespaceprefix_ = self.rxFragError_nsprefix_ + ':' if (UseCapturedNS_ and self.rxFragError_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srxFragError>%s</%srxFragError>%s' % (namespaceprefix_ , self.gds_format_integer(self.rxFragError, input_name='rxFragError'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'octetsRx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'octetsRx')
            ival_ = self.gds_validate_integer(ival_, node, 'octetsRx')
            self.octetsRx = ival_
            self.octetsRx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.octetsRx)
        elif nodeName_ == 'octetsTx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'octetsTx')
            ival_ = self.gds_validate_integer(ival_, node, 'octetsTx')
            self.octetsTx = ival_
            self.octetsTx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.octetsTx)
        elif nodeName_ == 'packetsRx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'packetsRx')
            ival_ = self.gds_validate_integer(ival_, node, 'packetsRx')
            self.packetsRx = ival_
            self.packetsRx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.packetsRx)
        elif nodeName_ == 'packetsTx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'packetsTx')
            ival_ = self.gds_validate_integer(ival_, node, 'packetsTx')
            self.packetsTx = ival_
            self.packetsTx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.packetsTx)
        elif nodeName_ == 'rxFragError' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'rxFragError')
            ival_ = self.gds_validate_integer(ival_, node, 'rxFragError')
            self.rxFragError = ival_
            self.rxFragError_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.rxFragError)
# end class loWPAN


class PowerConfiguration(GeneratedsSuper):
    """PowerConfiguration -- Contains configuration related to the device's power sources
    batteryInstallTime -- Time/Date at which battery was installed,
    lowChargeThreshold -- In context of the PowerStatus resource, this is the value of EstimatedTimeRemaining below which BatteryStatus "low" is indicated and the PS_LOW_BATTERY is raised.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, batteryInstallTime=None, lowChargeThreshold=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.batteryInstallTime = batteryInstallTime
        self.batteryInstallTime_nsprefix_ = None
        self.lowChargeThreshold = lowChargeThreshold
        self.validate_UInt32(self.lowChargeThreshold)
        self.lowChargeThreshold_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerConfiguration.subclass:
            return PowerConfiguration.subclass(*args_, **kwargs_)
        else:
            return PowerConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_batteryInstallTime(self):
        return self.batteryInstallTime
    def set_batteryInstallTime(self, batteryInstallTime):
        self.batteryInstallTime = batteryInstallTime
    def get_lowChargeThreshold(self):
        return self.lowChargeThreshold
    def set_lowChargeThreshold(self, lowChargeThreshold):
        self.lowChargeThreshold = lowChargeThreshold
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.batteryInstallTime is not None or
            self.lowChargeThreshold is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PowerConfiguration', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PowerConfiguration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PowerConfiguration':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerConfiguration')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PowerConfiguration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PowerConfiguration'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PowerConfiguration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.batteryInstallTime is not None:
            namespaceprefix_ = self.batteryInstallTime_nsprefix_ + ':' if (UseCapturedNS_ and self.batteryInstallTime_nsprefix_) else ''
            self.batteryInstallTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='batteryInstallTime', pretty_print=pretty_print)
        if self.lowChargeThreshold is not None:
            namespaceprefix_ = self.lowChargeThreshold_nsprefix_ + ':' if (UseCapturedNS_ and self.lowChargeThreshold_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slowChargeThreshold>%s</%slowChargeThreshold>%s' % (namespaceprefix_ , self.gds_format_integer(self.lowChargeThreshold, input_name='lowChargeThreshold'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'batteryInstallTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.batteryInstallTime = obj_
            obj_.original_tagname_ = 'batteryInstallTime'
        elif nodeName_ == 'lowChargeThreshold' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lowChargeThreshold')
            ival_ = self.gds_validate_integer(ival_, node, 'lowChargeThreshold')
            self.lowChargeThreshold = ival_
            self.lowChargeThreshold_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.lowChargeThreshold)
# end class PowerConfiguration


class TimeConfiguration(GeneratedsSuper):
    """TimeConfiguration -- Contains attributes related to the configuration of the time service.
    dstEndRule -- Rule to calculate end of daylight savings time in the current year.  Result of dstEndRule must be greater than result of dstStartRule.
    dstOffset -- Daylight savings time offset from local standard time.
    dstStartRule -- Rule to calculate start of daylight savings time in the current year. Result of dstEndRule must be greater than result of dstStartRule.
    tzOffset -- Local time zone offset from UTCTime. Does not include any daylight savings time offsets.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dstEndRule=None, dstOffset=None, dstStartRule=None, tzOffset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dstEndRule = dstEndRule
        self.dstEndRule_nsprefix_ = None
        self.dstOffset = dstOffset
        self.dstOffset_nsprefix_ = None
        self.dstStartRule = dstStartRule
        self.dstStartRule_nsprefix_ = None
        self.tzOffset = tzOffset
        self.tzOffset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeConfiguration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeConfiguration.subclass:
            return TimeConfiguration.subclass(*args_, **kwargs_)
        else:
            return TimeConfiguration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dstEndRule(self):
        return self.dstEndRule
    def set_dstEndRule(self, dstEndRule):
        self.dstEndRule = dstEndRule
    def get_dstOffset(self):
        return self.dstOffset
    def set_dstOffset(self, dstOffset):
        self.dstOffset = dstOffset
    def get_dstStartRule(self):
        return self.dstStartRule
    def set_dstStartRule(self, dstStartRule):
        self.dstStartRule = dstStartRule
    def get_tzOffset(self):
        return self.tzOffset
    def set_tzOffset(self, tzOffset):
        self.tzOffset = tzOffset
    def _hasContent(self):
        if (
            self.dstEndRule is not None or
            self.dstOffset is not None or
            self.dstStartRule is not None or
            self.tzOffset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TimeConfiguration', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeConfiguration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeConfiguration':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeConfiguration')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeConfiguration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeConfiguration'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TimeConfiguration', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dstEndRule is not None:
            namespaceprefix_ = self.dstEndRule_nsprefix_ + ':' if (UseCapturedNS_ and self.dstEndRule_nsprefix_) else ''
            self.dstEndRule.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dstEndRule', pretty_print=pretty_print)
        if self.dstOffset is not None:
            namespaceprefix_ = self.dstOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.dstOffset_nsprefix_) else ''
            self.dstOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dstOffset', pretty_print=pretty_print)
        if self.dstStartRule is not None:
            namespaceprefix_ = self.dstStartRule_nsprefix_ + ':' if (UseCapturedNS_ and self.dstStartRule_nsprefix_) else ''
            self.dstStartRule.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dstStartRule', pretty_print=pretty_print)
        if self.tzOffset is not None:
            namespaceprefix_ = self.tzOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.tzOffset_nsprefix_) else ''
            self.tzOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tzOffset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dstEndRule':
            obj_ = DstRuleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dstEndRule = obj_
            obj_.original_tagname_ = 'dstEndRule'
        elif nodeName_ == 'dstOffset':
            obj_ = TimeOffsetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dstOffset = obj_
            obj_.original_tagname_ = 'dstOffset'
        elif nodeName_ == 'dstStartRule':
            obj_ = DstRuleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dstStartRule = obj_
            obj_.original_tagname_ = 'dstStartRule'
        elif nodeName_ == 'tzOffset':
            obj_ = TimeOffsetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tzOffset = obj_
            obj_.original_tagname_ = 'tzOffset'
# end class TimeConfiguration


class ApplianceLoadReduction(GeneratedsSuper):
    """ApplianceLoadReduction -- The ApplianceLoadReduction object is used by a Demand Response service provider to provide signals for ENERGY STAR compliant appliances. See the definition of ApplianceLoadReductionType for more information.
    type -- Indicates the type of appliance load reduction requested.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ApplianceLoadReduction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ApplianceLoadReduction.subclass:
            return ApplianceLoadReduction.subclass(*args_, **kwargs_)
        else:
            return ApplianceLoadReduction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def _hasContent(self):
        if (
            self.type_ is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ApplianceLoadReduction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ApplianceLoadReduction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ApplianceLoadReduction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ApplianceLoadReduction')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ApplianceLoadReduction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ApplianceLoadReduction'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ApplianceLoadReduction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'type':
            obj_ = ApplianceLoadReductionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
# end class ApplianceLoadReduction


class DutyCycle(GeneratedsSuper):
    """DutyCycle -- Duty cycle control is a device specific issue and is managed by the device.  The duty cycle of the device under control should span the shortest practical time period in accordance with the nature of the device under control and the intent of the request for demand reduction.  The default factory setting SHOULD be three minutes for each 10% of duty cycle.  This indicates that the default time period over which a duty cycle is applied is 30 minutes, meaning a 10% duty cycle would cause a device to be ON for 3 minutes.   The
    
    off state
    
    SHALL precede the
    
    on state
    
    .
    normalValue -- Contains the maximum On state duty cycle applied by the end device, as a percentage of time.  The field not present indicates that this field has not been used by the end device.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, normalValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.normalValue = normalValue
        self.validate_UInt8(self.normalValue)
        self.normalValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DutyCycle)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DutyCycle.subclass:
            return DutyCycle.subclass(*args_, **kwargs_)
        else:
            return DutyCycle(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_normalValue(self):
        return self.normalValue
    def set_normalValue(self, normalValue):
        self.normalValue = normalValue
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.normalValue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DutyCycle', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DutyCycle')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DutyCycle':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DutyCycle')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DutyCycle', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DutyCycle'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DutyCycle', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.normalValue is not None:
            namespaceprefix_ = self.normalValue_nsprefix_ + ':' if (UseCapturedNS_ and self.normalValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snormalValue>%s</%snormalValue>%s' % (namespaceprefix_ , self.gds_format_integer(self.normalValue, input_name='normalValue'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'normalValue' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'normalValue')
            ival_ = self.gds_validate_integer(ival_, node, 'normalValue')
            self.normalValue = ival_
            self.normalValue_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.normalValue)
# end class DutyCycle


class Offset(GeneratedsSuper):
    """Offset -- If a temperature offset is sent that causes the heating or cooling temperature set point to exceed the limit boundaries that are programmed into the device, the device SHALL respond by setting the temperature at the limit.
    If an EDC is being targeted at multiple devices or to a device that controls multiple devices (e.g., EMS), it can provide multiple Offset types within one EDC. For events with multiple Offset types, a client SHALL select the Offset that best fits their operating function.
    Alternatively, an event with a single Offset type can be targeted at an EMS in order to request a percentage load reduction on the average energy usage of the entire premise. An EMS SHOULD use the Metering function set to determine the initial load in the premise, reduce energy consumption by controlling devices at its disposal, and at the conclusion of the event, once again use the Metering function set to determine if the desired load reduction was achieved.
    coolingOffset -- The value change requested for the cooling offset, in degree C / 10. The value should be added to the normal set point for cooling, or if loadShiftForward is true, then the value should be subtracted from the normal set point.
    heatingOffset -- The value change requested for the heating offset, in degree C / 10. The value should be subtracted for heating, or if loadShiftForward is true, then the value should be added to the normal set point.
    loadAdjustmentPercentageOffset -- The value change requested for the load adjustment percentage. The value should be subtracted from the normal setting, or if loadShiftForward is true, then the value should be added to the normal setting.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, coolingOffset=None, heatingOffset=None, loadAdjustmentPercentageOffset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.coolingOffset = coolingOffset
        self.validate_UInt8(self.coolingOffset)
        self.coolingOffset_nsprefix_ = None
        self.heatingOffset = heatingOffset
        self.validate_UInt8(self.heatingOffset)
        self.heatingOffset_nsprefix_ = None
        self.loadAdjustmentPercentageOffset = loadAdjustmentPercentageOffset
        self.loadAdjustmentPercentageOffset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Offset)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Offset.subclass:
            return Offset.subclass(*args_, **kwargs_)
        else:
            return Offset(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_coolingOffset(self):
        return self.coolingOffset
    def set_coolingOffset(self, coolingOffset):
        self.coolingOffset = coolingOffset
    def get_heatingOffset(self):
        return self.heatingOffset
    def set_heatingOffset(self, heatingOffset):
        self.heatingOffset = heatingOffset
    def get_loadAdjustmentPercentageOffset(self):
        return self.loadAdjustmentPercentageOffset
    def set_loadAdjustmentPercentageOffset(self, loadAdjustmentPercentageOffset):
        self.loadAdjustmentPercentageOffset = loadAdjustmentPercentageOffset
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.coolingOffset is not None or
            self.heatingOffset is not None or
            self.loadAdjustmentPercentageOffset is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Offset', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Offset')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Offset':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Offset')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Offset', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Offset'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Offset', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.coolingOffset is not None:
            namespaceprefix_ = self.coolingOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.coolingOffset_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scoolingOffset>%s</%scoolingOffset>%s' % (namespaceprefix_ , self.gds_format_integer(self.coolingOffset, input_name='coolingOffset'), namespaceprefix_ , eol_))
        if self.heatingOffset is not None:
            namespaceprefix_ = self.heatingOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.heatingOffset_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheatingOffset>%s</%sheatingOffset>%s' % (namespaceprefix_ , self.gds_format_integer(self.heatingOffset, input_name='heatingOffset'), namespaceprefix_ , eol_))
        if self.loadAdjustmentPercentageOffset is not None:
            namespaceprefix_ = self.loadAdjustmentPercentageOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.loadAdjustmentPercentageOffset_nsprefix_) else ''
            self.loadAdjustmentPercentageOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='loadAdjustmentPercentageOffset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'coolingOffset' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'coolingOffset')
            ival_ = self.gds_validate_integer(ival_, node, 'coolingOffset')
            self.coolingOffset = ival_
            self.coolingOffset_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.coolingOffset)
        elif nodeName_ == 'heatingOffset' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'heatingOffset')
            ival_ = self.gds_validate_integer(ival_, node, 'heatingOffset')
            self.heatingOffset = ival_
            self.heatingOffset_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.heatingOffset)
        elif nodeName_ == 'loadAdjustmentPercentageOffset':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loadAdjustmentPercentageOffset = obj_
            obj_.original_tagname_ = 'loadAdjustmentPercentageOffset'
# end class Offset


class SetPoint(GeneratedsSuper):
    """SetPoint -- The SetPoint object is used to apply specific temperature set points to a temperature control device. The values of the heatingSetpoint and coolingSetpoint attributes SHALL be calculated as follows:
    Cooling/Heating Temperature Set Point / 100 = temperature in degrees Celsius where -273.15
    
    C
    &
    lt;= temperature
    &
    lt;= 327.67
    
    C, corresponding to a Cooling and/or Heating Temperature Set Point. The maximum resolution this format allows is 0.01
    
    C.
    The field not present in a Response indicates that this field has not been used by the end device.
    If a temperature is sent that exceeds the temperature limit boundaries that are programmed into the device, the device SHALL respond by setting the temperature at the limit.
    coolingSetpoint -- This attribute represents the cooling temperature set point in degrees Celsius / 100. (Hundredths of a degree C)
    heatingSetpoint -- This attribute represents the heating temperature set point in degrees Celsius / 100. (Hundredths of a degree C)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, coolingSetpoint=None, heatingSetpoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.coolingSetpoint = coolingSetpoint
        self.validate_Int16(self.coolingSetpoint)
        self.coolingSetpoint_nsprefix_ = None
        self.heatingSetpoint = heatingSetpoint
        self.validate_Int16(self.heatingSetpoint)
        self.heatingSetpoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SetPoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SetPoint.subclass:
            return SetPoint.subclass(*args_, **kwargs_)
        else:
            return SetPoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_coolingSetpoint(self):
        return self.coolingSetpoint
    def set_coolingSetpoint(self, coolingSetpoint):
        self.coolingSetpoint = coolingSetpoint
    def get_heatingSetpoint(self):
        return self.heatingSetpoint
    def set_heatingSetpoint(self, heatingSetpoint):
        self.heatingSetpoint = heatingSetpoint
    def validate_Int16(self, value):
        result = True
        # Validate type Int16, a restriction on xs:short.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.coolingSetpoint is not None or
            self.heatingSetpoint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SetPoint', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SetPoint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SetPoint':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SetPoint')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SetPoint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SetPoint'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SetPoint', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.coolingSetpoint is not None:
            namespaceprefix_ = self.coolingSetpoint_nsprefix_ + ':' if (UseCapturedNS_ and self.coolingSetpoint_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scoolingSetpoint>%s</%scoolingSetpoint>%s' % (namespaceprefix_ , self.gds_format_integer(self.coolingSetpoint, input_name='coolingSetpoint'), namespaceprefix_ , eol_))
        if self.heatingSetpoint is not None:
            namespaceprefix_ = self.heatingSetpoint_nsprefix_ + ':' if (UseCapturedNS_ and self.heatingSetpoint_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sheatingSetpoint>%s</%sheatingSetpoint>%s' % (namespaceprefix_ , self.gds_format_integer(self.heatingSetpoint, input_name='heatingSetpoint'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'coolingSetpoint' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'coolingSetpoint')
            ival_ = self.gds_validate_integer(ival_, node, 'coolingSetpoint')
            self.coolingSetpoint = ival_
            self.coolingSetpoint_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.coolingSetpoint)
        elif nodeName_ == 'heatingSetpoint' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'heatingSetpoint')
            ival_ = self.gds_validate_integer(ival_, node, 'heatingSetpoint')
            self.heatingSetpoint = ival_
            self.heatingSetpoint_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.heatingSetpoint)
# end class SetPoint


class TargetReduction(GeneratedsSuper):
    """TargetReduction -- The TargetReduction object is used by a Demand Response service provider to provide a RECOMMENDED threshold that a device/premises should maintain its consumption below. For example, a service provider can provide a RECOMMENDED threshold of some kWh for a 3-hour event. This means that the device/premises would maintain its consumption below the specified limit for the specified period.
    type -- Indicates the type of reduction requested.
    value -- Indicates the requested amount of the relevant commodity to be reduced.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, type_=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
        self.value = value
        self.validate_UInt16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetReduction)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetReduction.subclass:
            return TargetReduction.subclass(*args_, **kwargs_)
        else:
            return TargetReduction(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.type_ is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TargetReduction', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetReduction')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TargetReduction':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetReduction')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TargetReduction', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TargetReduction'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TargetReduction', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'type':
            obj_ = UnitType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.value)
# end class TargetReduction


class CostKindType(GeneratedsSuper):
    """CostKindType -- 0 - Carbon Dioxide emissions, in grams per unit
    1 - Sulfur Dioxide emissions, in grams per unit
    2 - Nitrogen Oxides emissions, in grams per unit
    3 - Renewable generation, as a percentage of overall generation
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CostKindType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CostKindType.subclass:
            return CostKindType.subclass(*args_, **kwargs_)
        else:
            return CostKindType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CostKindType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CostKindType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CostKindType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CostKindType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CostKindType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CostKindType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CostKindType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CostKindType


class EnvironmentalCost(GeneratedsSuper):
    """EnvironmentalCost -- Provides alternative or secondary price information for the relevant RateComponent. Supports jurisdictions that seek to convey the environmental price per unit of the specified commodity not expressed in currency.
    Implementers and consumers can use this attribute to prioritize operations of their HAN devices (e.g., PEV charging during times of high availability of renewable electricity resources).
    amount -- The estimated or actual environmental or other cost, per commodity unit defined by the ReadingType, for this RateComponent (e.g., grams of carbon dioxide emissions each per kWh).
    costKind -- The kind of cost referred to in the amount.
    costLevel -- The relative level of the amount attribute.  In conjunction with numCostLevels, this attribute informs a device of the relative scarcity of the amount attribute (e.g., a high or low availability of renewable generation).
    numCostLevels and costLevel values SHALL ascend in order of scarcity, where "0" signals the lowest relative cost and higher values signal increasing cost.  For example, if numCostLevels is equal to
    
    3,
    
    then if the lowest relative costLevel were equal to
    
    0,
    
    devices would assume this is the lowest relative period to operate.  Likewise, if the costLevel in the next TimeTariffInterval instance is equal to
    
    1,
    
    then the device would assume it is relatively more expensive, in environmental terms, to operate during this TimeTariffInterval instance than the previous one.
    There is no limit to the number of relative price levels other than that indicated in the attribute type, but for practicality, service providers should strive for simplicity and recognize the diminishing returns derived from increasing the numCostLevel value greater than four.
    numCostLevels -- The number of all relative cost levels.
    In conjunction with costLevel, numCostLevels signals the relative scarcity of the commodity for the duration of the TimeTariffInterval instance (e.g., a relative indication of cost). This is useful in providing context for nominal cost signals to consumers or devices that might see a range of amount values from different service providres or from the same service provider.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, amount=None, costKind=None, costLevel=None, numCostLevels=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.amount = amount
        self.validate_UInt32(self.amount)
        self.amount_nsprefix_ = None
        self.costKind = costKind
        self.costKind_nsprefix_ = None
        self.costLevel = costLevel
        self.validate_UInt8(self.costLevel)
        self.costLevel_nsprefix_ = None
        self.numCostLevels = numCostLevels
        self.validate_UInt8(self.numCostLevels)
        self.numCostLevels_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EnvironmentalCost)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EnvironmentalCost.subclass:
            return EnvironmentalCost.subclass(*args_, **kwargs_)
        else:
            return EnvironmentalCost(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_amount(self):
        return self.amount
    def set_amount(self, amount):
        self.amount = amount
    def get_costKind(self):
        return self.costKind
    def set_costKind(self, costKind):
        self.costKind = costKind
    def get_costLevel(self):
        return self.costLevel
    def set_costLevel(self, costLevel):
        self.costLevel = costLevel
    def get_numCostLevels(self):
        return self.numCostLevels
    def set_numCostLevels(self, numCostLevels):
        self.numCostLevels = numCostLevels
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.amount is not None or
            self.costKind is not None or
            self.costLevel is not None or
            self.numCostLevels is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EnvironmentalCost', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EnvironmentalCost')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EnvironmentalCost':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EnvironmentalCost')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EnvironmentalCost', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EnvironmentalCost'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EnvironmentalCost', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.amount is not None:
            namespaceprefix_ = self.amount_nsprefix_ + ':' if (UseCapturedNS_ and self.amount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%samount>%s</%samount>%s' % (namespaceprefix_ , self.gds_format_integer(self.amount, input_name='amount'), namespaceprefix_ , eol_))
        if self.costKind is not None:
            namespaceprefix_ = self.costKind_nsprefix_ + ':' if (UseCapturedNS_ and self.costKind_nsprefix_) else ''
            self.costKind.export(outfile, level, namespaceprefix_, namespacedef_='', name_='costKind', pretty_print=pretty_print)
        if self.costLevel is not None:
            namespaceprefix_ = self.costLevel_nsprefix_ + ':' if (UseCapturedNS_ and self.costLevel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scostLevel>%s</%scostLevel>%s' % (namespaceprefix_ , self.gds_format_integer(self.costLevel, input_name='costLevel'), namespaceprefix_ , eol_))
        if self.numCostLevels is not None:
            namespaceprefix_ = self.numCostLevels_nsprefix_ + ':' if (UseCapturedNS_ and self.numCostLevels_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumCostLevels>%s</%snumCostLevels>%s' % (namespaceprefix_ , self.gds_format_integer(self.numCostLevels, input_name='numCostLevels'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'amount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'amount')
            ival_ = self.gds_validate_integer(ival_, node, 'amount')
            self.amount = ival_
            self.amount_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.amount)
        elif nodeName_ == 'costKind':
            obj_ = CostKindType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.costKind = obj_
            obj_.original_tagname_ = 'costKind'
        elif nodeName_ == 'costLevel' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'costLevel')
            ival_ = self.gds_validate_integer(ival_, node, 'costLevel')
            self.costLevel = ival_
            self.costLevel_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.costLevel)
        elif nodeName_ == 'numCostLevels' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'numCostLevels')
            ival_ = self.gds_validate_integer(ival_, node, 'numCostLevels')
            self.numCostLevels = ival_
            self.numCostLevels_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.numCostLevels)
# end class EnvironmentalCost


class PriorityType(GeneratedsSuper):
    """PriorityType -- Indicates the priority of a message:
    0 - Low
    1 - Normal
    2 - High
    3 - Critical
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PriorityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PriorityType.subclass:
            return PriorityType.subclass(*args_, **kwargs_)
        else:
            return PriorityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PriorityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PriorityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PriorityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PriorityType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PriorityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PriorityType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PriorityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PriorityType


class Charge(GeneratedsSuper):
    """Charge -- Charges contain charges on a customer bill.  These could be items like taxes, levies, surcharges, rebates, or others.  This is meant to allow the HAN device to retrieve enough information to be able to reconstruct an estimate of what the total bill would look like.
    Providers can provide line item billing, including multiple charge kinds (e.g. taxes, surcharges) at whatever granularity desired, using as many Charges as desired during a billing period. There can also be any number of Charges associated with different ReadingTypes to distinguish between TOU tiers, consumption blocks, or demand charges.
    description -- A description of the charge.
    kind -- The type (kind) of charge.
    value -- A monetary charge.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, description=None, kind=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.description = description
        self.validate_String20(self.description)
        self.description_nsprefix_ = None
        self.kind = kind
        self.kind_nsprefix_ = None
        self.value = value
        self.validate_Int32(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Charge)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Charge.subclass:
            return Charge.subclass(*args_, **kwargs_)
        else:
            return Charge(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_String20(self, value):
        result = True
        # Validate type String20, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String20' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_Int32(self, value):
        result = True
        # Validate type Int32, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.description is not None or
            self.kind is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Charge', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Charge')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Charge':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Charge')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Charge', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Charge'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Charge', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.kind is not None:
            namespaceprefix_ = self.kind_nsprefix_ + ':' if (UseCapturedNS_ and self.kind_nsprefix_) else ''
            self.kind.export(outfile, level, namespaceprefix_, namespacedef_='', name_='kind', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type String20
            self.validate_String20(self.description)
        elif nodeName_ == 'kind':
            obj_ = ChargeKind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type Int32
            self.validate_Int32(self.value)
# end class Charge


class ChargeKind(GeneratedsSuper):
    """ChargeKind -- Kind of charge.
    0 - Consumption Charge
    1 - Rebate
    2 - Auxiliary Charge
    3 - Demand Charge
    4 - Tax Charge
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ChargeKind)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ChargeKind.subclass:
            return ChargeKind.subclass(*args_, **kwargs_)
        else:
            return ChargeKind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChargeKind', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ChargeKind')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ChargeKind':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ChargeKind')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ChargeKind', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ChargeKind'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ChargeKind', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ChargeKind


class AccountingUnit(GeneratedsSuper):
    """AccountingUnit -- Unit for accounting; use either 'energyUnit' or 'currencyUnit' to specify the unit for 'value'.
    energyUnit -- Unit of service.
    monetaryUnit -- Unit of currency.
    multiplier -- Multiplier for the 'energyUnit' or 'monetaryUnit'.
    value -- Value of the monetary aspect
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, energyUnit=None, monetaryUnit=None, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.energyUnit = energyUnit
        self.energyUnit_nsprefix_ = None
        self.monetaryUnit = monetaryUnit
        self.monetaryUnit_nsprefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_Int32(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountingUnit)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountingUnit.subclass:
            return AccountingUnit.subclass(*args_, **kwargs_)
        else:
            return AccountingUnit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_energyUnit(self):
        return self.energyUnit
    def set_energyUnit(self, energyUnit):
        self.energyUnit = energyUnit
    def get_monetaryUnit(self):
        return self.monetaryUnit
    def set_monetaryUnit(self, monetaryUnit):
        self.monetaryUnit = monetaryUnit
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_Int32(self, value):
        result = True
        # Validate type Int32, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.energyUnit is not None or
            self.monetaryUnit is not None or
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AccountingUnit', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccountingUnit')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AccountingUnit':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccountingUnit')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccountingUnit', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccountingUnit'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AccountingUnit', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.energyUnit is not None:
            namespaceprefix_ = self.energyUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.energyUnit_nsprefix_) else ''
            self.energyUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='energyUnit', pretty_print=pretty_print)
        if self.monetaryUnit is not None:
            namespaceprefix_ = self.monetaryUnit_nsprefix_ + ':' if (UseCapturedNS_ and self.monetaryUnit_nsprefix_) else ''
            self.monetaryUnit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='monetaryUnit', pretty_print=pretty_print)
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'energyUnit':
            obj_ = RealEnergy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.energyUnit = obj_
            obj_.original_tagname_ = 'energyUnit'
        elif nodeName_ == 'monetaryUnit':
            obj_ = CurrencyCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.monetaryUnit = obj_
            obj_.original_tagname_ = 'monetaryUnit'
        elif nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type Int32
            self.validate_Int32(self.value)
# end class AccountingUnit


class PrepayModeType(GeneratedsSuper):
    """PrepayModeType -- 0 - Central Wallet
    1 - ESI
    2 - Local
    3 - Credit
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrepayModeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrepayModeType.subclass:
            return PrepayModeType.subclass(*args_, **kwargs_)
        else:
            return PrepayModeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrepayModeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrepayModeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrepayModeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepayModeType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrepayModeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrepayModeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrepayModeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PrepayModeType


class ServiceChange(GeneratedsSuper):
    """ServiceChange -- Specifies a change to the service status.
    newStatus -- The new service status, to take effect at the time specified by startTime
    startTime -- The date/time when the change is to take effect.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, newStatus=None, startTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.newStatus = newStatus
        self.newStatus_nsprefix_ = None
        self.startTime = startTime
        self.startTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceChange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceChange.subclass:
            return ServiceChange.subclass(*args_, **kwargs_)
        else:
            return ServiceChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_newStatus(self):
        return self.newStatus
    def set_newStatus(self, newStatus):
        self.newStatus = newStatus
    def get_startTime(self):
        return self.startTime
    def set_startTime(self, startTime):
        self.startTime = startTime
    def _hasContent(self):
        if (
            self.newStatus is not None or
            self.startTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ServiceChange', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceChange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceChange':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceChange')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceChange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceChange'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ServiceChange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.newStatus is not None:
            namespaceprefix_ = self.newStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.newStatus_nsprefix_) else ''
            self.newStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='newStatus', pretty_print=pretty_print)
        if self.startTime is not None:
            namespaceprefix_ = self.startTime_nsprefix_ + ':' if (UseCapturedNS_ and self.startTime_nsprefix_) else ''
            self.startTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='startTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'newStatus':
            obj_ = ServiceStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.newStatus = obj_
            obj_.original_tagname_ = 'newStatus'
        elif nodeName_ == 'startTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.startTime = obj_
            obj_.original_tagname_ = 'startTime'
# end class ServiceChange


class CreditStatusType(GeneratedsSuper):
    """CreditStatusType -- 0 - Credit Ok
    1 - Credit Low
    2 - Credit Exhausted
    3 - Credit Negative
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditStatusType.subclass:
            return CreditStatusType.subclass(*args_, **kwargs_)
        else:
            return CreditStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CreditStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditStatusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditStatusType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditStatusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CreditStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CreditStatusType


class CreditTypeType(GeneratedsSuper):
    """CreditTypeType -- 0 - Regular
    1 - Emergency
    2 - Regular, then Emergency
    3 - Emergency, then Regular
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditTypeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditTypeType.subclass:
            return CreditTypeType.subclass(*args_, **kwargs_)
        else:
            return CreditTypeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CreditTypeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditTypeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditTypeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditTypeType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditTypeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditTypeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CreditTypeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CreditTypeType


class CreditTypeChange(GeneratedsSuper):
    """CreditTypeChange -- Specifies a change to the credit type.
    newType -- The new credit type, to take effect at the time specified by startTime
    startTime -- The date/time when the change is to take effect.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, newType=None, startTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.newType = newType
        self.newType_nsprefix_ = None
        self.startTime = startTime
        self.startTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditTypeChange)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditTypeChange.subclass:
            return CreditTypeChange.subclass(*args_, **kwargs_)
        else:
            return CreditTypeChange(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_newType(self):
        return self.newType
    def set_newType(self, newType):
        self.newType = newType
    def get_startTime(self):
        return self.startTime
    def set_startTime(self, startTime):
        self.startTime = startTime
    def _hasContent(self):
        if (
            self.newType is not None or
            self.startTime is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CreditTypeChange', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditTypeChange')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditTypeChange':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditTypeChange')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditTypeChange', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditTypeChange'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CreditTypeChange', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.newType is not None:
            namespaceprefix_ = self.newType_nsprefix_ + ':' if (UseCapturedNS_ and self.newType_nsprefix_) else ''
            self.newType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='newType', pretty_print=pretty_print)
        if self.startTime is not None:
            namespaceprefix_ = self.startTime_nsprefix_ + ':' if (UseCapturedNS_ and self.startTime_nsprefix_) else ''
            self.startTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='startTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'newType':
            obj_ = CreditTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.newType = obj_
            obj_.original_tagname_ = 'newType'
        elif nodeName_ == 'startTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.startTime = obj_
            obj_.original_tagname_ = 'startTime'
# end class CreditTypeChange


class ServiceStatusType(GeneratedsSuper):
    """ServiceStatusType -- 0 - Connected
    1 - Disconnected
    2 - Armed for Connect
    3 - Armed for Disconnect
    4 - No Contactor
    5 - Load Limited
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceStatusType.subclass:
            return ServiceStatusType.subclass(*args_, **kwargs_)
        else:
            return ServiceStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceStatusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceStatusType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceStatusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ServiceStatusType


class RequestStatus(GeneratedsSuper):
    """RequestStatus -- The RequestStatus object is used to indicate the current status of a Flow Reservation Request.
    dateTime -- The dateTime attribute will provide a timestamp of when the request status was set. dateTime MUST be set to the time at which the status change occurred, not a time in the future or past.
    requestStatus -- Field representing the request status type.
    0 = Requested
    1 = Cancelled
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, requestStatus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
        self.requestStatus = requestStatus
        self.validate_UInt8(self.requestStatus)
        self.requestStatus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RequestStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RequestStatus.subclass:
            return RequestStatus.subclass(*args_, **kwargs_)
        else:
            return RequestStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def get_requestStatus(self):
        return self.requestStatus
    def set_requestStatus(self, requestStatus):
        self.requestStatus = requestStatus
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.dateTime is not None or
            self.requestStatus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RequestStatus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RequestStatus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RequestStatus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RequestStatus')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RequestStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RequestStatus'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RequestStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
        if self.requestStatus is not None:
            namespaceprefix_ = self.requestStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.requestStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequestStatus>%s</%srequestStatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.requestStatus, input_name='requestStatus'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'requestStatus' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'requestStatus')
            ival_ = self.gds_validate_integer(ival_, node, 'requestStatus')
            self.requestStatus = ival_
            self.requestStatus_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.requestStatus)
# end class RequestStatus


class FreqDroopType(GeneratedsSuper):
    """FreqDroopType -- Type for Frequency-Droop (Frequency-Watt) operation.
    dBOF -- Frequency droop dead band for over-frequency conditions. In thousandths of Hz.
    dBUF -- Frequency droop dead band for under-frequency conditions. In thousandths of Hz.
    kOF -- Frequency droop per-unit frequency change for over-frequency conditions corresponding to 1 per-unit power output change. In thousandths, unitless.
    kUF -- Frequency droop per-unit frequency change for under-frequency conditions corresponding to 1 per-unit power output change. In thousandths, unitless.
    openLoopTms -- Open loop response time, the duration from a step change in control signal input until the output changes by 90% of its final change before any overshoot, in hundredths of a second. Resolution is 1/100 sec. A value of 0 is used to mean no limit.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dBOF=None, dBUF=None, kOF=None, kUF=None, openLoopTms=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dBOF = dBOF
        self.validate_UInt32(self.dBOF)
        self.dBOF_nsprefix_ = None
        self.dBUF = dBUF
        self.validate_UInt32(self.dBUF)
        self.dBUF_nsprefix_ = None
        self.kOF = kOF
        self.validate_UInt16(self.kOF)
        self.kOF_nsprefix_ = None
        self.kUF = kUF
        self.validate_UInt16(self.kUF)
        self.kUF_nsprefix_ = None
        self.openLoopTms = openLoopTms
        self.validate_UInt16(self.openLoopTms)
        self.openLoopTms_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FreqDroopType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FreqDroopType.subclass:
            return FreqDroopType.subclass(*args_, **kwargs_)
        else:
            return FreqDroopType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dBOF(self):
        return self.dBOF
    def set_dBOF(self, dBOF):
        self.dBOF = dBOF
    def get_dBUF(self):
        return self.dBUF
    def set_dBUF(self, dBUF):
        self.dBUF = dBUF
    def get_kOF(self):
        return self.kOF
    def set_kOF(self, kOF):
        self.kOF = kOF
    def get_kUF(self):
        return self.kUF
    def set_kUF(self, kUF):
        self.kUF = kUF
    def get_openLoopTms(self):
        return self.openLoopTms
    def set_openLoopTms(self, openLoopTms):
        self.openLoopTms = openLoopTms
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.dBOF is not None or
            self.dBUF is not None or
            self.kOF is not None or
            self.kUF is not None or
            self.openLoopTms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FreqDroopType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FreqDroopType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FreqDroopType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FreqDroopType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FreqDroopType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FreqDroopType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FreqDroopType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dBOF is not None:
            namespaceprefix_ = self.dBOF_nsprefix_ + ':' if (UseCapturedNS_ and self.dBOF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdBOF>%s</%sdBOF>%s' % (namespaceprefix_ , self.gds_format_integer(self.dBOF, input_name='dBOF'), namespaceprefix_ , eol_))
        if self.dBUF is not None:
            namespaceprefix_ = self.dBUF_nsprefix_ + ':' if (UseCapturedNS_ and self.dBUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdBUF>%s</%sdBUF>%s' % (namespaceprefix_ , self.gds_format_integer(self.dBUF, input_name='dBUF'), namespaceprefix_ , eol_))
        if self.kOF is not None:
            namespaceprefix_ = self.kOF_nsprefix_ + ':' if (UseCapturedNS_ and self.kOF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skOF>%s</%skOF>%s' % (namespaceprefix_ , self.gds_format_integer(self.kOF, input_name='kOF'), namespaceprefix_ , eol_))
        if self.kUF is not None:
            namespaceprefix_ = self.kUF_nsprefix_ + ':' if (UseCapturedNS_ and self.kUF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%skUF>%s</%skUF>%s' % (namespaceprefix_ , self.gds_format_integer(self.kUF, input_name='kUF'), namespaceprefix_ , eol_))
        if self.openLoopTms is not None:
            namespaceprefix_ = self.openLoopTms_nsprefix_ + ':' if (UseCapturedNS_ and self.openLoopTms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenLoopTms>%s</%sopenLoopTms>%s' % (namespaceprefix_ , self.gds_format_integer(self.openLoopTms, input_name='openLoopTms'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dBOF' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'dBOF')
            ival_ = self.gds_validate_integer(ival_, node, 'dBOF')
            self.dBOF = ival_
            self.dBOF_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.dBOF)
        elif nodeName_ == 'dBUF' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'dBUF')
            ival_ = self.gds_validate_integer(ival_, node, 'dBUF')
            self.dBUF = ival_
            self.dBUF_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.dBUF)
        elif nodeName_ == 'kOF' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'kOF')
            ival_ = self.gds_validate_integer(ival_, node, 'kOF')
            self.kOF = ival_
            self.kOF_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.kOF)
        elif nodeName_ == 'kUF' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'kUF')
            ival_ = self.gds_validate_integer(ival_, node, 'kUF')
            self.kUF = ival_
            self.kUF_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.kUF)
        elif nodeName_ == 'openLoopTms' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'openLoopTms')
            ival_ = self.gds_validate_integer(ival_, node, 'openLoopTms')
            self.openLoopTms = ival_
            self.openLoopTms_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.openLoopTms)
# end class FreqDroopType


class DERType(GeneratedsSuper):
    """DERType -- 0 - Not applicable / Unknown
    1 - Virtual or mixed DER
    2 - Reciprocating engine
    3 - Fuel cell
    4 - Photovoltaic system
    5 - Combined heat and power
    6 - Other generation system
    80 - Other storage system
    81 - Electric vehicle
    82 - EVSE
    83 - Combined PV and storage
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERType.subclass:
            return DERType.subclass(*args_, **kwargs_)
        else:
            return DERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DERType


class DERControlBase(GeneratedsSuper):
    """DERControlBase -- Distributed Energy Resource (DER) control values.
    opModConnect -- Set DER as connected (true) or disconnected (false). Used in conjunction with ramp rate when re-connecting. Implies galvanic isolation.
    opModEnergize -- Set DER as energized (true) or de-energized (false). Used in conjunction with ramp rate when re-energizing.
    opModFixedPFAbsorbW -- The opModFixedPFAbsorbW function specifies a requested fixed Power Factor (PF) setting for when active power is being absorbed. The actual displacement SHALL be within the limits established by setMinPFOverExcited and setMinPFUnderExcited. If issued simultaneously with other reactive power controls (e.g. opModFixedVar) the control resulting in least var magnitude SHOULD take precedence.
    opModFixedPFInjectW -- The opModFixedPFInjectW function specifies a requested fixed Power Factor (PF) setting for when active power is being injected. The actual displacement SHALL be within the limits established by setMinPFOverExcited and setMinPFUnderExcited. If issued simultaneously with other reactive power controls (e.g. opModFixedVar) the control resulting in least var magnitude SHOULD take precedence.
    opModFixedVar -- The opModFixedVar function specifies the delivered or received reactive power setpoint.  The context for the setpoint value is determined by refType and SHALL be one of %setMaxW, %setMaxVar, or %statVarAvail.  If issued simultaneously with other reactive power controls (e.g. opModFixedPFInjectW) the control resulting in least var magnitude SHOULD take precedence.
    opModFixedW -- The opModFixedW function specifies a requested charge or discharge mode setpoint, in %setMaxChargeRateW if negative value or %setMaxW or %setMaxDischargeRateW if positive value (in hundredths).
    opModFreqDroop -- Specifies a frequency-watt operation. This operation limits active power generation or consumption when the line frequency deviates from nominal by a specified amount.
    opModFreqWatt -- Specify DERCurveLink for curveType == 0.  The Frequency-Watt function limits active power generation or consumption when the line frequency deviates from nominal by a specified amount. The Frequency-Watt curve is specified as an array of Frequency-Watt pairs that are interpolated into a piecewise linear function with hysteresis.  The x value of each pair specifies a frequency in Hz. The y value specifies a corresponding active power output in %setMaxW.
    opModHFRTMayTrip -- Specify DERCurveLink for curveType == 1. The High Frequency Ride-Through (HFRT) function is specified by one or two duration-frequency curves that define the operating region under high frequency conditions. Each HFRT curve is specified by an array of duration-frequency pairs that will be interpolated into a piecewise linear function that defines an operating region. The x value of each pair specifies a duration (time at a given frequency in seconds). The y value of each pair specifies a frequency, in Hz. This control specifies the "may trip" region.
    opModHFRTMustTrip -- Specify DERCurveLink for curveType == 2.  The High Frequency Ride-Through (HFRT) function is specified by a duration-frequency curve that defines the operating region under high frequency conditions.  Each HFRT curve is specified by an array of duration-frequency pairs that will be interpolated into a piecewise linear function that defines an operating region.  The x value of each pair specifies a duration (time at a given frequency in seconds). The y value of each pair specifies a frequency, in Hz. This control specifies the "must trip" region.
    opModHVRTMayTrip -- Specify DERCurveLink for curveType == 3. The High Voltage Ride-Through (HVRT) function is specified by one, two, or three duration-volt curves that define the operating region under high voltage conditions. Each HVRT curve is specified by an array of duration-volt pairs that will be interpolated into a piecewise linear function that defines an operating region. The x value of each pair specifies a duration (time at a given voltage in seconds). The y value of each pair specifies an effective percentage voltage, defined as ((locally measured voltage - setVRefOfs / setVRef). This control specifies the "may trip" region.
    opModHVRTMomentaryCessation -- Specify DERCurveLink for curveType == 4.  The High Voltage Ride-Through (HVRT) function is specified by duration-volt curves that define the operating region under high voltage conditions.  Each HVRT curve is specified by an array of duration-volt pairs that will be interpolated into a piecewise linear function that defines an operating region.  The x value of each pair specifies a duration (time at a given voltage in seconds). The y value of each pair specifies an effective percent voltage, defined as ((locally measured voltage - setVRefOfs) / setVRef). This control specifies the "momentary cessation" region.
    opModHVRTMustTrip -- Specify DERCurveLink for curveType == 5.  The High Voltage Ride-Through (HVRT) function is specified by duration-volt curves that define the operating region under high voltage conditions.  Each HVRT curve is specified by an array of duration-volt pairs that will be interpolated into a piecewise linear function that defines an operating region.  The x value of each pair specifies a duration (time at a given voltage in seconds). The y value of each pair specifies an effective percent voltage, defined as ((locally measured voltage - setVRefOfs) / setVRef). This control specifies the "must trip" region.
    opModLFRTMayTrip -- Specify DERCurveLink for curveType == 6. The Low Frequency Ride-Through (LFRT) function is specified by one or two duration-frequency curves that define the operating region under low frequency conditions. Each LFRT curve is specified by an array of duration-frequency pairs that will be interpolated into a piecewise linear function that defines an operating region. The x value of each pair specifies a duration (time at a given frequency in seconds). The y value of each pair specifies a frequency, in Hz. This control specifies the "may trip" region.
    opModLFRTMustTrip -- Specify DERCurveLink for curveType == 7.  The Low Frequency Ride-Through (LFRT) function is specified by a duration-frequency curve that defines the operating region under low frequency conditions.  Each LFRT curve is specified by an array of duration-frequency pairs that will be interpolated into a piecewise linear function that defines an operating region.  The x value of each pair specifies a duration (time at a given frequency in seconds). The y value of each pair specifies a frequency, in Hz. This control specifies the "must trip" region.
    opModLVRTMayTrip -- Specify DERCurveLink for curveType == 8. The Low Voltage Ride-Through (LVRT) function is specified by one, two, or three duration-volt curves that define the operating region under low voltage conditions. Each LVRT curve is specified by an array of duration-volt pairs that will be interpolated into a piecewise linear function that defines an operating region. The x value of each pair specifies a duration (time at a given voltage in seconds). The y value of each pair specifies an effective percent voltage, defined as ((locally measured voltage - setVRefOfs) / setVRef). This control specifies the "may trip" region.
    opModLVRTMomentaryCessation -- Specify DERCurveLink for curveType == 9.  The Low Voltage Ride-Through (LVRT) function is specified by duration-volt curves that define the operating region under low voltage conditions.  Each LVRT curve is specified by an array of duration-volt pairs that will be interpolated into a piecewise linear function that defines an operating region.  The x value of each pair specifies a duration (time at a given voltage in seconds). The y value of each pair specifies an effective percent voltage, defined as ((locally measured voltage - setVRefOfs) / setVRef). This control specifies the "momentary cessation" region.
    opModLVRTMustTrip -- Specify DERCurveLink for curveType == 10.  The Low Voltage Ride-Through (LVRT) function is specified by duration-volt curves that define the operating region under low voltage conditions.  Each LVRT curve is specified by an array of duration-volt pairs that will be interpolated into a piecewise linear function that defines an operating region.  The x value of each pair specifies a duration (time at a given voltage in seconds). The y value of each pair specifies an effective percent voltage, defined as ((locally measured voltage - setVRefOfs) / setVRef). This control specifies the "must trip" region.
    opModMaxLimW -- The opModMaxLimW function sets the maximum active power generation level at the electrical coupling point as a percentage of set capacity (%setMaxW, in hundredths). This limitation may be met e.g. by reducing PV output or by using excess PV output to charge associated storage.
    opModTargetVar -- Target reactive power, in var. This control is likely to be more useful for aggregators, as individual DERs may not be able to maintain a target setting.
    opModTargetW -- Target output power, in Watts. This control is likely to be more useful for aggregators, as individual DERs may not be able to maintain a target setting.
    opModVoltVar -- Specify DERCurveLink for curveType == 11.  The static volt-var function provides over- or under-excited var compensation as a function of measured voltage. The volt-var curve is specified as an array of volt-var pairs that are interpolated into a piecewise linear function with hysteresis. The x value of each pair specifies an effective percent voltage, defined as ((locally measured voltage - setVRefOfs) / setVRef) and SHOULD support a domain of at least 0 - 135. If VRef is present in DERCurve, then the x value of each pair is additionally multiplied by (VRef / 10000). The y value specifies a target var output interpreted as a signed percentage (-100 to 100). The meaning of the y value is determined by yRefType and must be one of %setMaxW, %setMaxVar, or %statVarAvail.
    opModVoltWatt -- Specify DERCurveLink for curveType == 12.  The Volt-Watt reduces active power output as a function of measured voltage. The Volt-Watt curve is specified as an array of Volt-Watt pairs that are interpolated into a piecewise linear function with hysteresis. The x value of each pair specifies an effective percent voltage, defined as ((locally measured voltage - setVRefOfs) / setVRef) and SHOULD support a domain of at least 0 - 135. The y value specifies an active power output interpreted as a percentage (0 - 100). The meaning of the y value is determined by yRefType and must be one of %setMaxW or %statWAvail.
    opModWattPF -- Specify DERCurveLink for curveType == 13.  The Watt-PF function varies Power Factor (PF) as a function of delivered active power. The Watt-PF curve is specified as an array of Watt-PF coordinates that are interpolated into a piecewise linear function with hysteresis.  The x value of each pair specifies a watt setting in %setMaxW, (0 - 100). The PF output setting is a signed displacement in y value (PF sign SHALL be interpreted according to the EEI convention, where unity PF is considered unsigned). These settings are not expected to be updated very often during the life of the installation, therefore only a single curve is required.  If issued simultaneously with other reactive power controls (e.g. opModFixedPFInjectW) the control resulting in least var magnitude SHOULD take precedence.
    opModWattVar -- Specify DERCurveLink for curveType == 14. The Watt-Var function varies vars as a function of delivered active power. The Watt-Var curve is specified as an array of Watt-Var pairs that are interpolated into a piecewise linear function with hysteresis. The x value of each pair specifies a watt setting in %setMaxW, (0-100). The y value specifies a target var output interpreted as a signed percentage (-100 to 100). The meaning of the y value is determined by yRefType and must be one of %setMaxW, %setMaxVar, or %statVarAvail.
    rampTms -- Requested ramp time, in hundredths of a second, for the device to transition from the current DERControl  mode setting(s) to the new mode setting(s). If absent, use default ramp rate (setGradW).  Resolution is 1/100 sec.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, opModConnect=None, opModEnergize=None, opModFixedPFAbsorbW=None, opModFixedPFInjectW=None, opModFixedVar=None, opModFixedW=None, opModFreqDroop=None, opModFreqWatt=None, opModHFRTMayTrip=None, opModHFRTMustTrip=None, opModHVRTMayTrip=None, opModHVRTMomentaryCessation=None, opModHVRTMustTrip=None, opModLFRTMayTrip=None, opModLFRTMustTrip=None, opModLVRTMayTrip=None, opModLVRTMomentaryCessation=None, opModLVRTMustTrip=None, opModMaxLimW=None, opModTargetVar=None, opModTargetW=None, opModVoltVar=None, opModVoltWatt=None, opModWattPF=None, opModWattVar=None, rampTms=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.opModConnect = opModConnect
        self.opModConnect_nsprefix_ = None
        self.opModEnergize = opModEnergize
        self.opModEnergize_nsprefix_ = None
        self.opModFixedPFAbsorbW = opModFixedPFAbsorbW
        self.opModFixedPFAbsorbW_nsprefix_ = None
        self.opModFixedPFInjectW = opModFixedPFInjectW
        self.opModFixedPFInjectW_nsprefix_ = None
        self.opModFixedVar = opModFixedVar
        self.opModFixedVar_nsprefix_ = None
        self.opModFixedW = opModFixedW
        self.opModFixedW_nsprefix_ = None
        self.opModFreqDroop = opModFreqDroop
        self.opModFreqDroop_nsprefix_ = None
        self.opModFreqWatt = opModFreqWatt
        self.opModFreqWatt_nsprefix_ = None
        self.opModHFRTMayTrip = opModHFRTMayTrip
        self.opModHFRTMayTrip_nsprefix_ = None
        self.opModHFRTMustTrip = opModHFRTMustTrip
        self.opModHFRTMustTrip_nsprefix_ = None
        self.opModHVRTMayTrip = opModHVRTMayTrip
        self.opModHVRTMayTrip_nsprefix_ = None
        self.opModHVRTMomentaryCessation = opModHVRTMomentaryCessation
        self.opModHVRTMomentaryCessation_nsprefix_ = None
        self.opModHVRTMustTrip = opModHVRTMustTrip
        self.opModHVRTMustTrip_nsprefix_ = None
        self.opModLFRTMayTrip = opModLFRTMayTrip
        self.opModLFRTMayTrip_nsprefix_ = None
        self.opModLFRTMustTrip = opModLFRTMustTrip
        self.opModLFRTMustTrip_nsprefix_ = None
        self.opModLVRTMayTrip = opModLVRTMayTrip
        self.opModLVRTMayTrip_nsprefix_ = None
        self.opModLVRTMomentaryCessation = opModLVRTMomentaryCessation
        self.opModLVRTMomentaryCessation_nsprefix_ = None
        self.opModLVRTMustTrip = opModLVRTMustTrip
        self.opModLVRTMustTrip_nsprefix_ = None
        self.opModMaxLimW = opModMaxLimW
        self.opModMaxLimW_nsprefix_ = None
        self.opModTargetVar = opModTargetVar
        self.opModTargetVar_nsprefix_ = None
        self.opModTargetW = opModTargetW
        self.opModTargetW_nsprefix_ = None
        self.opModVoltVar = opModVoltVar
        self.opModVoltVar_nsprefix_ = None
        self.opModVoltWatt = opModVoltWatt
        self.opModVoltWatt_nsprefix_ = None
        self.opModWattPF = opModWattPF
        self.opModWattPF_nsprefix_ = None
        self.opModWattVar = opModWattVar
        self.opModWattVar_nsprefix_ = None
        self.rampTms = rampTms
        self.validate_UInt16(self.rampTms)
        self.rampTms_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERControlBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERControlBase.subclass:
            return DERControlBase.subclass(*args_, **kwargs_)
        else:
            return DERControlBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_opModConnect(self):
        return self.opModConnect
    def set_opModConnect(self, opModConnect):
        self.opModConnect = opModConnect
    def get_opModEnergize(self):
        return self.opModEnergize
    def set_opModEnergize(self, opModEnergize):
        self.opModEnergize = opModEnergize
    def get_opModFixedPFAbsorbW(self):
        return self.opModFixedPFAbsorbW
    def set_opModFixedPFAbsorbW(self, opModFixedPFAbsorbW):
        self.opModFixedPFAbsorbW = opModFixedPFAbsorbW
    def get_opModFixedPFInjectW(self):
        return self.opModFixedPFInjectW
    def set_opModFixedPFInjectW(self, opModFixedPFInjectW):
        self.opModFixedPFInjectW = opModFixedPFInjectW
    def get_opModFixedVar(self):
        return self.opModFixedVar
    def set_opModFixedVar(self, opModFixedVar):
        self.opModFixedVar = opModFixedVar
    def get_opModFixedW(self):
        return self.opModFixedW
    def set_opModFixedW(self, opModFixedW):
        self.opModFixedW = opModFixedW
    def get_opModFreqDroop(self):
        return self.opModFreqDroop
    def set_opModFreqDroop(self, opModFreqDroop):
        self.opModFreqDroop = opModFreqDroop
    def get_opModFreqWatt(self):
        return self.opModFreqWatt
    def set_opModFreqWatt(self, opModFreqWatt):
        self.opModFreqWatt = opModFreqWatt
    def get_opModHFRTMayTrip(self):
        return self.opModHFRTMayTrip
    def set_opModHFRTMayTrip(self, opModHFRTMayTrip):
        self.opModHFRTMayTrip = opModHFRTMayTrip
    def get_opModHFRTMustTrip(self):
        return self.opModHFRTMustTrip
    def set_opModHFRTMustTrip(self, opModHFRTMustTrip):
        self.opModHFRTMustTrip = opModHFRTMustTrip
    def get_opModHVRTMayTrip(self):
        return self.opModHVRTMayTrip
    def set_opModHVRTMayTrip(self, opModHVRTMayTrip):
        self.opModHVRTMayTrip = opModHVRTMayTrip
    def get_opModHVRTMomentaryCessation(self):
        return self.opModHVRTMomentaryCessation
    def set_opModHVRTMomentaryCessation(self, opModHVRTMomentaryCessation):
        self.opModHVRTMomentaryCessation = opModHVRTMomentaryCessation
    def get_opModHVRTMustTrip(self):
        return self.opModHVRTMustTrip
    def set_opModHVRTMustTrip(self, opModHVRTMustTrip):
        self.opModHVRTMustTrip = opModHVRTMustTrip
    def get_opModLFRTMayTrip(self):
        return self.opModLFRTMayTrip
    def set_opModLFRTMayTrip(self, opModLFRTMayTrip):
        self.opModLFRTMayTrip = opModLFRTMayTrip
    def get_opModLFRTMustTrip(self):
        return self.opModLFRTMustTrip
    def set_opModLFRTMustTrip(self, opModLFRTMustTrip):
        self.opModLFRTMustTrip = opModLFRTMustTrip
    def get_opModLVRTMayTrip(self):
        return self.opModLVRTMayTrip
    def set_opModLVRTMayTrip(self, opModLVRTMayTrip):
        self.opModLVRTMayTrip = opModLVRTMayTrip
    def get_opModLVRTMomentaryCessation(self):
        return self.opModLVRTMomentaryCessation
    def set_opModLVRTMomentaryCessation(self, opModLVRTMomentaryCessation):
        self.opModLVRTMomentaryCessation = opModLVRTMomentaryCessation
    def get_opModLVRTMustTrip(self):
        return self.opModLVRTMustTrip
    def set_opModLVRTMustTrip(self, opModLVRTMustTrip):
        self.opModLVRTMustTrip = opModLVRTMustTrip
    def get_opModMaxLimW(self):
        return self.opModMaxLimW
    def set_opModMaxLimW(self, opModMaxLimW):
        self.opModMaxLimW = opModMaxLimW
    def get_opModTargetVar(self):
        return self.opModTargetVar
    def set_opModTargetVar(self, opModTargetVar):
        self.opModTargetVar = opModTargetVar
    def get_opModTargetW(self):
        return self.opModTargetW
    def set_opModTargetW(self, opModTargetW):
        self.opModTargetW = opModTargetW
    def get_opModVoltVar(self):
        return self.opModVoltVar
    def set_opModVoltVar(self, opModVoltVar):
        self.opModVoltVar = opModVoltVar
    def get_opModVoltWatt(self):
        return self.opModVoltWatt
    def set_opModVoltWatt(self, opModVoltWatt):
        self.opModVoltWatt = opModVoltWatt
    def get_opModWattPF(self):
        return self.opModWattPF
    def set_opModWattPF(self, opModWattPF):
        self.opModWattPF = opModWattPF
    def get_opModWattVar(self):
        return self.opModWattVar
    def set_opModWattVar(self, opModWattVar):
        self.opModWattVar = opModWattVar
    def get_rampTms(self):
        return self.rampTms
    def set_rampTms(self, rampTms):
        self.rampTms = rampTms
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.opModConnect is not None or
            self.opModEnergize is not None or
            self.opModFixedPFAbsorbW is not None or
            self.opModFixedPFInjectW is not None or
            self.opModFixedVar is not None or
            self.opModFixedW is not None or
            self.opModFreqDroop is not None or
            self.opModFreqWatt is not None or
            self.opModHFRTMayTrip is not None or
            self.opModHFRTMustTrip is not None or
            self.opModHVRTMayTrip is not None or
            self.opModHVRTMomentaryCessation is not None or
            self.opModHVRTMustTrip is not None or
            self.opModLFRTMayTrip is not None or
            self.opModLFRTMustTrip is not None or
            self.opModLVRTMayTrip is not None or
            self.opModLVRTMomentaryCessation is not None or
            self.opModLVRTMustTrip is not None or
            self.opModMaxLimW is not None or
            self.opModTargetVar is not None or
            self.opModTargetW is not None or
            self.opModVoltVar is not None or
            self.opModVoltWatt is not None or
            self.opModWattPF is not None or
            self.opModWattVar is not None or
            self.rampTms is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERControlBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERControlBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERControlBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControlBase')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERControlBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERControlBase'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERControlBase', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.opModConnect is not None:
            namespaceprefix_ = self.opModConnect_nsprefix_ + ':' if (UseCapturedNS_ and self.opModConnect_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopModConnect>%s</%sopModConnect>%s' % (namespaceprefix_ , self.gds_format_boolean(self.opModConnect, input_name='opModConnect'), namespaceprefix_ , eol_))
        if self.opModEnergize is not None:
            namespaceprefix_ = self.opModEnergize_nsprefix_ + ':' if (UseCapturedNS_ and self.opModEnergize_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopModEnergize>%s</%sopModEnergize>%s' % (namespaceprefix_ , self.gds_format_boolean(self.opModEnergize, input_name='opModEnergize'), namespaceprefix_ , eol_))
        if self.opModFixedPFAbsorbW is not None:
            namespaceprefix_ = self.opModFixedPFAbsorbW_nsprefix_ + ':' if (UseCapturedNS_ and self.opModFixedPFAbsorbW_nsprefix_) else ''
            self.opModFixedPFAbsorbW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModFixedPFAbsorbW', pretty_print=pretty_print)
        if self.opModFixedPFInjectW is not None:
            namespaceprefix_ = self.opModFixedPFInjectW_nsprefix_ + ':' if (UseCapturedNS_ and self.opModFixedPFInjectW_nsprefix_) else ''
            self.opModFixedPFInjectW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModFixedPFInjectW', pretty_print=pretty_print)
        if self.opModFixedVar is not None:
            namespaceprefix_ = self.opModFixedVar_nsprefix_ + ':' if (UseCapturedNS_ and self.opModFixedVar_nsprefix_) else ''
            self.opModFixedVar.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModFixedVar', pretty_print=pretty_print)
        if self.opModFixedW is not None:
            namespaceprefix_ = self.opModFixedW_nsprefix_ + ':' if (UseCapturedNS_ and self.opModFixedW_nsprefix_) else ''
            self.opModFixedW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModFixedW', pretty_print=pretty_print)
        if self.opModFreqDroop is not None:
            namespaceprefix_ = self.opModFreqDroop_nsprefix_ + ':' if (UseCapturedNS_ and self.opModFreqDroop_nsprefix_) else ''
            self.opModFreqDroop.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModFreqDroop', pretty_print=pretty_print)
        if self.opModFreqWatt is not None:
            namespaceprefix_ = self.opModFreqWatt_nsprefix_ + ':' if (UseCapturedNS_ and self.opModFreqWatt_nsprefix_) else ''
            self.opModFreqWatt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModFreqWatt', pretty_print=pretty_print)
        if self.opModHFRTMayTrip is not None:
            namespaceprefix_ = self.opModHFRTMayTrip_nsprefix_ + ':' if (UseCapturedNS_ and self.opModHFRTMayTrip_nsprefix_) else ''
            self.opModHFRTMayTrip.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModHFRTMayTrip', pretty_print=pretty_print)
        if self.opModHFRTMustTrip is not None:
            namespaceprefix_ = self.opModHFRTMustTrip_nsprefix_ + ':' if (UseCapturedNS_ and self.opModHFRTMustTrip_nsprefix_) else ''
            self.opModHFRTMustTrip.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModHFRTMustTrip', pretty_print=pretty_print)
        if self.opModHVRTMayTrip is not None:
            namespaceprefix_ = self.opModHVRTMayTrip_nsprefix_ + ':' if (UseCapturedNS_ and self.opModHVRTMayTrip_nsprefix_) else ''
            self.opModHVRTMayTrip.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModHVRTMayTrip', pretty_print=pretty_print)
        if self.opModHVRTMomentaryCessation is not None:
            namespaceprefix_ = self.opModHVRTMomentaryCessation_nsprefix_ + ':' if (UseCapturedNS_ and self.opModHVRTMomentaryCessation_nsprefix_) else ''
            self.opModHVRTMomentaryCessation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModHVRTMomentaryCessation', pretty_print=pretty_print)
        if self.opModHVRTMustTrip is not None:
            namespaceprefix_ = self.opModHVRTMustTrip_nsprefix_ + ':' if (UseCapturedNS_ and self.opModHVRTMustTrip_nsprefix_) else ''
            self.opModHVRTMustTrip.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModHVRTMustTrip', pretty_print=pretty_print)
        if self.opModLFRTMayTrip is not None:
            namespaceprefix_ = self.opModLFRTMayTrip_nsprefix_ + ':' if (UseCapturedNS_ and self.opModLFRTMayTrip_nsprefix_) else ''
            self.opModLFRTMayTrip.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModLFRTMayTrip', pretty_print=pretty_print)
        if self.opModLFRTMustTrip is not None:
            namespaceprefix_ = self.opModLFRTMustTrip_nsprefix_ + ':' if (UseCapturedNS_ and self.opModLFRTMustTrip_nsprefix_) else ''
            self.opModLFRTMustTrip.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModLFRTMustTrip', pretty_print=pretty_print)
        if self.opModLVRTMayTrip is not None:
            namespaceprefix_ = self.opModLVRTMayTrip_nsprefix_ + ':' if (UseCapturedNS_ and self.opModLVRTMayTrip_nsprefix_) else ''
            self.opModLVRTMayTrip.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModLVRTMayTrip', pretty_print=pretty_print)
        if self.opModLVRTMomentaryCessation is not None:
            namespaceprefix_ = self.opModLVRTMomentaryCessation_nsprefix_ + ':' if (UseCapturedNS_ and self.opModLVRTMomentaryCessation_nsprefix_) else ''
            self.opModLVRTMomentaryCessation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModLVRTMomentaryCessation', pretty_print=pretty_print)
        if self.opModLVRTMustTrip is not None:
            namespaceprefix_ = self.opModLVRTMustTrip_nsprefix_ + ':' if (UseCapturedNS_ and self.opModLVRTMustTrip_nsprefix_) else ''
            self.opModLVRTMustTrip.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModLVRTMustTrip', pretty_print=pretty_print)
        if self.opModMaxLimW is not None:
            namespaceprefix_ = self.opModMaxLimW_nsprefix_ + ':' if (UseCapturedNS_ and self.opModMaxLimW_nsprefix_) else ''
            self.opModMaxLimW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModMaxLimW', pretty_print=pretty_print)
        if self.opModTargetVar is not None:
            namespaceprefix_ = self.opModTargetVar_nsprefix_ + ':' if (UseCapturedNS_ and self.opModTargetVar_nsprefix_) else ''
            self.opModTargetVar.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModTargetVar', pretty_print=pretty_print)
        if self.opModTargetW is not None:
            namespaceprefix_ = self.opModTargetW_nsprefix_ + ':' if (UseCapturedNS_ and self.opModTargetW_nsprefix_) else ''
            self.opModTargetW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModTargetW', pretty_print=pretty_print)
        if self.opModVoltVar is not None:
            namespaceprefix_ = self.opModVoltVar_nsprefix_ + ':' if (UseCapturedNS_ and self.opModVoltVar_nsprefix_) else ''
            self.opModVoltVar.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModVoltVar', pretty_print=pretty_print)
        if self.opModVoltWatt is not None:
            namespaceprefix_ = self.opModVoltWatt_nsprefix_ + ':' if (UseCapturedNS_ and self.opModVoltWatt_nsprefix_) else ''
            self.opModVoltWatt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModVoltWatt', pretty_print=pretty_print)
        if self.opModWattPF is not None:
            namespaceprefix_ = self.opModWattPF_nsprefix_ + ':' if (UseCapturedNS_ and self.opModWattPF_nsprefix_) else ''
            self.opModWattPF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModWattPF', pretty_print=pretty_print)
        if self.opModWattVar is not None:
            namespaceprefix_ = self.opModWattVar_nsprefix_ + ':' if (UseCapturedNS_ and self.opModWattVar_nsprefix_) else ''
            self.opModWattVar.export(outfile, level, namespaceprefix_, namespacedef_='', name_='opModWattVar', pretty_print=pretty_print)
        if self.rampTms is not None:
            namespaceprefix_ = self.rampTms_nsprefix_ + ':' if (UseCapturedNS_ and self.rampTms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srampTms>%s</%srampTms>%s' % (namespaceprefix_ , self.gds_format_integer(self.rampTms, input_name='rampTms'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'opModConnect':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'opModConnect')
            ival_ = self.gds_validate_boolean(ival_, node, 'opModConnect')
            self.opModConnect = ival_
            self.opModConnect_nsprefix_ = child_.prefix
        elif nodeName_ == 'opModEnergize':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'opModEnergize')
            ival_ = self.gds_validate_boolean(ival_, node, 'opModEnergize')
            self.opModEnergize = ival_
            self.opModEnergize_nsprefix_ = child_.prefix
        elif nodeName_ == 'opModFixedPFAbsorbW':
            obj_ = PowerFactorWithExcitation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModFixedPFAbsorbW = obj_
            obj_.original_tagname_ = 'opModFixedPFAbsorbW'
        elif nodeName_ == 'opModFixedPFInjectW':
            obj_ = PowerFactorWithExcitation.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModFixedPFInjectW = obj_
            obj_.original_tagname_ = 'opModFixedPFInjectW'
        elif nodeName_ == 'opModFixedVar':
            obj_ = FixedVar.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModFixedVar = obj_
            obj_.original_tagname_ = 'opModFixedVar'
        elif nodeName_ == 'opModFixedW':
            obj_ = SignedPerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModFixedW = obj_
            obj_.original_tagname_ = 'opModFixedW'
        elif nodeName_ == 'opModFreqDroop':
            obj_ = FreqDroopType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModFreqDroop = obj_
            obj_.original_tagname_ = 'opModFreqDroop'
        elif nodeName_ == 'opModFreqWatt':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModFreqWatt = obj_
            obj_.original_tagname_ = 'opModFreqWatt'
        elif nodeName_ == 'opModHFRTMayTrip':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModHFRTMayTrip = obj_
            obj_.original_tagname_ = 'opModHFRTMayTrip'
        elif nodeName_ == 'opModHFRTMustTrip':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModHFRTMustTrip = obj_
            obj_.original_tagname_ = 'opModHFRTMustTrip'
        elif nodeName_ == 'opModHVRTMayTrip':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModHVRTMayTrip = obj_
            obj_.original_tagname_ = 'opModHVRTMayTrip'
        elif nodeName_ == 'opModHVRTMomentaryCessation':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModHVRTMomentaryCessation = obj_
            obj_.original_tagname_ = 'opModHVRTMomentaryCessation'
        elif nodeName_ == 'opModHVRTMustTrip':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModHVRTMustTrip = obj_
            obj_.original_tagname_ = 'opModHVRTMustTrip'
        elif nodeName_ == 'opModLFRTMayTrip':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModLFRTMayTrip = obj_
            obj_.original_tagname_ = 'opModLFRTMayTrip'
        elif nodeName_ == 'opModLFRTMustTrip':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModLFRTMustTrip = obj_
            obj_.original_tagname_ = 'opModLFRTMustTrip'
        elif nodeName_ == 'opModLVRTMayTrip':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModLVRTMayTrip = obj_
            obj_.original_tagname_ = 'opModLVRTMayTrip'
        elif nodeName_ == 'opModLVRTMomentaryCessation':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModLVRTMomentaryCessation = obj_
            obj_.original_tagname_ = 'opModLVRTMomentaryCessation'
        elif nodeName_ == 'opModLVRTMustTrip':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModLVRTMustTrip = obj_
            obj_.original_tagname_ = 'opModLVRTMustTrip'
        elif nodeName_ == 'opModMaxLimW':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModMaxLimW = obj_
            obj_.original_tagname_ = 'opModMaxLimW'
        elif nodeName_ == 'opModTargetVar':
            obj_ = ReactivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModTargetVar = obj_
            obj_.original_tagname_ = 'opModTargetVar'
        elif nodeName_ == 'opModTargetW':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModTargetW = obj_
            obj_.original_tagname_ = 'opModTargetW'
        elif nodeName_ == 'opModVoltVar':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModVoltVar = obj_
            obj_.original_tagname_ = 'opModVoltVar'
        elif nodeName_ == 'opModVoltWatt':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModVoltWatt = obj_
            obj_.original_tagname_ = 'opModVoltWatt'
        elif nodeName_ == 'opModWattPF':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModWattPF = obj_
            obj_.original_tagname_ = 'opModWattPF'
        elif nodeName_ == 'opModWattVar':
            obj_ = DERCurveLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.opModWattVar = obj_
            obj_.original_tagname_ = 'opModWattVar'
        elif nodeName_ == 'rampTms' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'rampTms')
            ival_ = self.gds_validate_integer(ival_, node, 'rampTms')
            self.rampTms = ival_
            self.rampTms_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.rampTms)
# end class DERControlBase


class DERControlType(GeneratedsSuper):
    """DERControlType -- Control modes supported by the DER.  Bit positions SHALL be defined as follows:
    0 - Charge mode
    1 - Discharge mode
    2 - opModConnect (Connect / Disconnect - implies galvanic isolation)
    3 - opModEnergize (Energize / De-Energize)
    4 - opModFixedPFAbsorbW (Fixed Power Factor Setpoint when absorbing active power)
    5 - opModFixedPFInjectW (Fixed Power Factor Setpoint when injecting active power)
    6 - opModFixedVar (Reactive Power Setpoint)
    7 - opModFixedW (Charge / Discharge Setpoint)
    8 - opModFreqDroop (Frequency-Watt Parameterized Mode)
    9 - opModFreqWatt (Frequency-Watt Curve Mode)
    10 - opModHFRTMayTrip (High Frequency Ride Through, May Trip Mode)
    11 - opModHFRTMustTrip (High Frequency Ride Through, Must Trip Mode)
    12 - opModHVRTMayTrip (High Voltage Ride Through, May Trip Mode)
    13 - opModHVRTMomentaryCessation (High Voltage Ride Through, Momentary Cessation Mode)
    14 - opModHVRTMustTrip (High Voltage Ride Through, Must Trip Mode)
    15 - opModLFRTMayTrip (Low Frequency Ride Through, May Trip Mode)
    16 - opModLFRTMustTrip (Low Frequency Ride Through, Must Trip Mode)
    17 - opModLVRTMayTrip (Low Voltage Ride Through, May Trip Mode)
    18 - opModLVRTMomentaryCessation (Low Voltage Ride Through, Momentary Cessation Mode)
    19 - opModLVRTMustTrip (Low Voltage Ride Through, Must Trip Mode)
    20 - opModMaxLimW (Maximum Active Power)
    21 - opModTargetVar (Target Reactive Power)
    22 - opModTargetW (Target Active Power)
    23 - opModVoltVar (Volt-Var Mode)
    24 - opModVoltWatt (Volt-Watt Mode)
    25 - opModWattPF (Watt-PowerFactor Mode)
    26 - opModWattVar (Watt-Var Mode)
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERControlType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERControlType.subclass:
            return DERControlType.subclass(*args_, **kwargs_)
        else:
            return DERControlType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexBinary32(self, value):
        result = True
        # Validate type HexBinary32, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary32' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERControlType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERControlType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERControlType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControlType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERControlType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERControlType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERControlType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DERControlType


class CurveData(GeneratedsSuper):
    """CurveData -- Data point values for defining a curve or schedule
    excitation -- If yvalue is Power Factor, then this field SHALL be present. If yvalue is not Power Factor, then this field SHALL NOT be present.
    True when DER is absorbing reactive power (under-excited), false
    when DER is injecting reactive power (over-excited).
    xvalue -- The data value of the X-axis (independent) variable, depending on the curve type. See definitions in DERControlBase for further information.
    yvalue -- The data value of the Y-axis (dependent) variable, depending on the curve type. See definitions in DERControlBase for further information. If yvalue is Power Factor, the excitation field SHALL be present and yvalue SHALL be a positive value. If yvalue is not Power Factor, the excitation field SHALL NOT be present.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, excitation=None, xvalue=None, yvalue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.excitation = excitation
        self.excitation_nsprefix_ = None
        self.xvalue = xvalue
        self.validate_Int32(self.xvalue)
        self.xvalue_nsprefix_ = None
        self.yvalue = yvalue
        self.validate_Int32(self.yvalue)
        self.yvalue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CurveData)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CurveData.subclass:
            return CurveData.subclass(*args_, **kwargs_)
        else:
            return CurveData(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_excitation(self):
        return self.excitation
    def set_excitation(self, excitation):
        self.excitation = excitation
    def get_xvalue(self):
        return self.xvalue
    def set_xvalue(self, xvalue):
        self.xvalue = xvalue
    def get_yvalue(self):
        return self.yvalue
    def set_yvalue(self, yvalue):
        self.yvalue = yvalue
    def validate_Int32(self, value):
        result = True
        # Validate type Int32, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.excitation is not None or
            self.xvalue is not None or
            self.yvalue is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CurveData', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CurveData')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CurveData':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CurveData')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CurveData', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CurveData'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CurveData', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.excitation is not None:
            namespaceprefix_ = self.excitation_nsprefix_ + ':' if (UseCapturedNS_ and self.excitation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexcitation>%s</%sexcitation>%s' % (namespaceprefix_ , self.gds_format_boolean(self.excitation, input_name='excitation'), namespaceprefix_ , eol_))
        if self.xvalue is not None:
            namespaceprefix_ = self.xvalue_nsprefix_ + ':' if (UseCapturedNS_ and self.xvalue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sxvalue>%s</%sxvalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.xvalue, input_name='xvalue'), namespaceprefix_ , eol_))
        if self.yvalue is not None:
            namespaceprefix_ = self.yvalue_nsprefix_ + ':' if (UseCapturedNS_ and self.yvalue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%syvalue>%s</%syvalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.yvalue, input_name='yvalue'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'excitation':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'excitation')
            ival_ = self.gds_validate_boolean(ival_, node, 'excitation')
            self.excitation = ival_
            self.excitation_nsprefix_ = child_.prefix
        elif nodeName_ == 'xvalue' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'xvalue')
            ival_ = self.gds_validate_integer(ival_, node, 'xvalue')
            self.xvalue = ival_
            self.xvalue_nsprefix_ = child_.prefix
            # validate type Int32
            self.validate_Int32(self.xvalue)
        elif nodeName_ == 'yvalue' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'yvalue')
            ival_ = self.gds_validate_integer(ival_, node, 'yvalue')
            self.yvalue = ival_
            self.yvalue_nsprefix_ = child_.prefix
            # validate type Int32
            self.validate_Int32(self.yvalue)
# end class CurveData


class DERCurveType(GeneratedsSuper):
    """DERCurveType -- 0 - opModFreqWatt (Frequency-Watt Curve Mode)
    1 - opModHFRTMayTrip (High Frequency Ride Through, May Trip Mode)
    2 - opModHFRTMustTrip (High Frequency Ride Through, Must Trip Mode)
    3 - opModHVRTMayTrip (High Voltage Ride Through, May Trip Mode)
    4 - opModHVRTMomentaryCessation (High Voltage Ride Through, Momentary Cessation Mode)
    5 - opModHVRTMustTrip (High Voltage Ride Through, Must Trip Mode)
    6 - opModLFRTMayTrip (Low Frequency Ride Through, May Trip Mode)
    7 - opModLFRTMustTrip (Low Frequency Ride Through, Must Trip Mode)
    8 - opModLVRTMayTrip (Low Voltage Ride Through, May Trip Mode)
    9 - opModLVRTMomentaryCessation (Low Voltage Ride Through, Momentary Cessation Mode)
    10 - opModLVRTMustTrip (Low Voltage Ride Through, Must Trip Mode)
    11 - opModVoltVar (Volt-Var Mode)
    12 - opModVoltWatt (Volt-Watt Mode)
    13 - opModWattPF (Watt-PowerFactor Mode)
    14 - opModWattVar (Watt-Var Mode)
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERCurveType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERCurveType.subclass:
            return DERCurveType.subclass(*args_, **kwargs_)
        else:
            return DERCurveType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERCurveType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERCurveType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERCurveType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCurveType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERCurveType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERCurveType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERCurveType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DERCurveType


class DERUnitRefType(GeneratedsSuper):
    """DERUnitRefType -- Specifies context for interpreting percent values:
    0 - N/A
    1 - %setMaxW
    2 - %setMaxVar
    3 - %statVarAvail
    4 - %setEffectiveV
    5 - %setMaxChargeRateW
    6 - %setMaxDischargeRateW
    7 - %statWAvail
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERUnitRefType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERUnitRefType.subclass:
            return DERUnitRefType.subclass(*args_, **kwargs_)
        else:
            return DERUnitRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERUnitRefType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERUnitRefType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERUnitRefType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERUnitRefType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERUnitRefType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERUnitRefType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERUnitRefType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DERUnitRefType


class CurrentRMS(GeneratedsSuper):
    """CurrentRMS -- Average flow of charge through a conductor.
    multiplier -- Specifies exponent of value.
    value -- Value in amperes RMS (uom 5)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_UInt16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CurrentRMS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CurrentRMS.subclass:
            return CurrentRMS.subclass(*args_, **kwargs_)
        else:
            return CurrentRMS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CurrentRMS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CurrentRMS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CurrentRMS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CurrentRMS')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CurrentRMS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CurrentRMS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CurrentRMS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.value)
# end class CurrentRMS


class FixedPointType(GeneratedsSuper):
    """FixedPointType -- Abstract type for specifying a fixed-point value without a given unit of measure.
    multiplier -- Specifies exponent of uom.
    value -- Dimensionless value
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_Int16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedPointType.subclass:
            return FixedPointType.subclass(*args_, **kwargs_)
        else:
            return FixedPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_Int16(self, value):
        result = True
        # Validate type Int16, a restriction on xs:short.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FixedPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FixedPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FixedPointType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FixedPointType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FixedPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FixedPointType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FixedPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.value)
# end class FixedPointType


class UnsignedFixedPointType(GeneratedsSuper):
    """UnsignedFixedPointType -- Abstract type for specifying an unsigned fixed-point value without a given unit of measure.
    multiplier -- Specifies exponent of uom.
    value -- Dimensionless value
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_UInt16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnsignedFixedPointType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnsignedFixedPointType.subclass:
            return UnsignedFixedPointType.subclass(*args_, **kwargs_)
        else:
            return UnsignedFixedPointType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UnsignedFixedPointType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnsignedFixedPointType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UnsignedFixedPointType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnsignedFixedPointType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnsignedFixedPointType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnsignedFixedPointType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UnsignedFixedPointType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.value)
# end class UnsignedFixedPointType


class ActivePower(GeneratedsSuper):
    """ActivePower -- The active (real) power P (in W) is the product of root-mean-square (RMS) voltage, RMS current, and cos(theta) where theta is the phase angle of current relative to voltage.  It is the primary measure of the rate of flow of energy.
    multiplier -- Specifies exponent for uom.
    value -- Value in watts (uom 38)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_Int16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActivePower)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActivePower.subclass:
            return ActivePower.subclass(*args_, **kwargs_)
        else:
            return ActivePower(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_Int16(self, value):
        result = True
        # Validate type Int16, a restriction on xs:short.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ActivePower', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActivePower')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActivePower':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActivePower')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActivePower', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActivePower'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ActivePower', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.value)
# end class ActivePower


class AmpereHour(GeneratedsSuper):
    """AmpereHour -- Available electric charge
    multiplier -- Specifies exponent of uom.
    value -- Value in ampere-hours (uom 106)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_UInt16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AmpereHour)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AmpereHour.subclass:
            return AmpereHour.subclass(*args_, **kwargs_)
        else:
            return AmpereHour(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AmpereHour', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AmpereHour')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AmpereHour':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AmpereHour')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AmpereHour', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AmpereHour'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AmpereHour', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.value)
# end class AmpereHour


class ApparentPower(GeneratedsSuper):
    """ApparentPower -- The apparent power S (in VA) is the product of root mean square (RMS) voltage and RMS current.
    multiplier -- Specifies exponent of uom.
    value -- Value in volt-amperes (uom 61)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_UInt16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ApparentPower)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ApparentPower.subclass:
            return ApparentPower.subclass(*args_, **kwargs_)
        else:
            return ApparentPower(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ApparentPower', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ApparentPower')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ApparentPower':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ApparentPower')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ApparentPower', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ApparentPower'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ApparentPower', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.value)
# end class ApparentPower


class ReactivePower(GeneratedsSuper):
    """ReactivePower -- The reactive power Q (in var) is the product of root mean square (RMS) voltage, RMS current, and sin(theta) where theta is the phase angle of current relative to voltage.
    multiplier -- Specifies exponent of uom.
    value -- Value in volt-amperes reactive (var) (uom 63)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_Int16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReactivePower)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReactivePower.subclass:
            return ReactivePower.subclass(*args_, **kwargs_)
        else:
            return ReactivePower(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_Int16(self, value):
        result = True
        # Validate type Int16, a restriction on xs:short.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReactivePower', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReactivePower')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReactivePower':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReactivePower')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReactivePower', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReactivePower'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReactivePower', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.value)
# end class ReactivePower


class ReactiveSusceptance(GeneratedsSuper):
    """ReactiveSusceptance -- Reactive susceptance
    multiplier -- Specifies exponent of uom.
    value -- Value in siemens (uom 53)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_UInt16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReactiveSusceptance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReactiveSusceptance.subclass:
            return ReactiveSusceptance.subclass(*args_, **kwargs_)
        else:
            return ReactiveSusceptance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReactiveSusceptance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReactiveSusceptance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReactiveSusceptance':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReactiveSusceptance')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReactiveSusceptance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReactiveSusceptance'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReactiveSusceptance', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.value)
# end class ReactiveSusceptance


class PowerFactor(GeneratedsSuper):
    """PowerFactor -- Specifies a setpoint for Displacement Power Factor, the ratio between apparent and active powers at the fundamental frequency (e.g. 60 Hz).
    displacement -- Significand of an unsigned value of cos(theta) between 0 and 1.0. E.g. a value of 0.95 may be specified as a displacement of 950 and a multiplier of -3.
    multiplier -- Specifies exponent of 'displacement'.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displacement=None, multiplier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.displacement = displacement
        self.validate_UInt16(self.displacement)
        self.displacement_nsprefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerFactor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerFactor.subclass:
            return PowerFactor.subclass(*args_, **kwargs_)
        else:
            return PowerFactor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displacement(self):
        return self.displacement
    def set_displacement(self, displacement):
        self.displacement = displacement
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.displacement is not None or
            self.multiplier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PowerFactor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PowerFactor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PowerFactor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerFactor')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PowerFactor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PowerFactor'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PowerFactor', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.displacement is not None:
            namespaceprefix_ = self.displacement_nsprefix_ + ':' if (UseCapturedNS_ and self.displacement_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplacement>%s</%sdisplacement>%s' % (namespaceprefix_ , self.gds_format_integer(self.displacement, input_name='displacement'), namespaceprefix_ , eol_))
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'displacement' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'displacement')
            ival_ = self.gds_validate_integer(ival_, node, 'displacement')
            self.displacement = ival_
            self.displacement_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.displacement)
        elif nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
# end class PowerFactor


class PowerFactorWithExcitation(GeneratedsSuper):
    """PowerFactorWithExcitation -- Specifies a setpoint for Displacement Power Factor, the ratio between apparent and active powers at the fundamental frequency (e.g. 60 Hz) and includes an excitation flag.
    displacement -- Significand of an unsigned value of cos(theta) between 0 and 1.0. E.g. a value of 0.95 may be specified as a displacement of 950 and a multiplier of -3.
    excitation -- True when DER is absorbing reactive power (under-excited), false
    when DER is injecting reactive power (over-excited).
    multiplier -- Specifies exponent of 'displacement'.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, displacement=None, excitation=None, multiplier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.displacement = displacement
        self.validate_UInt16(self.displacement)
        self.displacement_nsprefix_ = None
        self.excitation = excitation
        self.excitation_nsprefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerFactorWithExcitation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerFactorWithExcitation.subclass:
            return PowerFactorWithExcitation.subclass(*args_, **kwargs_)
        else:
            return PowerFactorWithExcitation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_displacement(self):
        return self.displacement
    def set_displacement(self, displacement):
        self.displacement = displacement
    def get_excitation(self):
        return self.excitation
    def set_excitation(self, excitation):
        self.excitation = excitation
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.displacement is not None or
            self.excitation is not None or
            self.multiplier is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PowerFactorWithExcitation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PowerFactorWithExcitation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PowerFactorWithExcitation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerFactorWithExcitation')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PowerFactorWithExcitation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PowerFactorWithExcitation'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PowerFactorWithExcitation', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.displacement is not None:
            namespaceprefix_ = self.displacement_nsprefix_ + ':' if (UseCapturedNS_ and self.displacement_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdisplacement>%s</%sdisplacement>%s' % (namespaceprefix_ , self.gds_format_integer(self.displacement, input_name='displacement'), namespaceprefix_ , eol_))
        if self.excitation is not None:
            namespaceprefix_ = self.excitation_nsprefix_ + ':' if (UseCapturedNS_ and self.excitation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sexcitation>%s</%sexcitation>%s' % (namespaceprefix_ , self.gds_format_boolean(self.excitation, input_name='excitation'), namespaceprefix_ , eol_))
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'displacement' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'displacement')
            ival_ = self.gds_validate_integer(ival_, node, 'displacement')
            self.displacement = ival_
            self.displacement_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.displacement)
        elif nodeName_ == 'excitation':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'excitation')
            ival_ = self.gds_validate_boolean(ival_, node, 'excitation')
            self.excitation = ival_
            self.excitation_nsprefix_ = child_.prefix
        elif nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
# end class PowerFactorWithExcitation


class FixedVar(GeneratedsSuper):
    """FixedVar -- Specifies a signed setpoint for reactive power.
    refType -- Indicates whether to interpret 'value' as %setMaxVar or %statVarAvail.
    value -- Specify a signed setpoint for reactive power in % (see 'refType' for context).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, refType=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.refType = refType
        self.refType_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FixedVar)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FixedVar.subclass:
            return FixedVar.subclass(*args_, **kwargs_)
        else:
            return FixedVar(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_refType(self):
        return self.refType
    def set_refType(self, refType):
        self.refType = refType
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def _hasContent(self):
        if (
            self.refType is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FixedVar', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FixedVar')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FixedVar':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FixedVar')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FixedVar', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FixedVar'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FixedVar', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.refType is not None:
            namespaceprefix_ = self.refType_nsprefix_ + ':' if (UseCapturedNS_ and self.refType_nsprefix_) else ''
            self.refType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='refType', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'refType':
            obj_ = DERUnitRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.refType = obj_
            obj_.original_tagname_ = 'refType'
        elif nodeName_ == 'value':
            obj_ = SignedPerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class FixedVar


class WattHour(GeneratedsSuper):
    """WattHour -- Active (real) energy
    multiplier -- Specifies exponent of uom.
    value -- Value in watt-hours (uom 72)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_UInt16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, WattHour)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if WattHour.subclass:
            return WattHour.subclass(*args_, **kwargs_)
        else:
            return WattHour(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='WattHour', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('WattHour')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'WattHour':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='WattHour')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='WattHour', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='WattHour'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='WattHour', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.value)
# end class WattHour


class VoltageRMS(GeneratedsSuper):
    """VoltageRMS -- Average electric potential difference between two points.
    multiplier -- Specifies exponent of uom.
    value -- Value in volts RMS (uom 29)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_UInt16(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VoltageRMS)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VoltageRMS.subclass:
            return VoltageRMS.subclass(*args_, **kwargs_)
        else:
            return VoltageRMS(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='VoltageRMS', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VoltageRMS')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VoltageRMS':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VoltageRMS')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VoltageRMS', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VoltageRMS'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='VoltageRMS', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.value)
# end class VoltageRMS


class ConnectStatusType(GeneratedsSuper):
    """ConnectStatusType -- DER ConnectStatus value (bitmap):
    0 - Connected
    1 - Available
    2 - Operating
    3 - Test
    4 - Fault / Error
    All other values reserved.
    dateTime -- The date and time at which the state applied.
    value -- The value indicating the state.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
        self.value = value
        self.validate_HexBinary8(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConnectStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConnectStatusType.subclass:
            return ConnectStatusType.subclass(*args_, **kwargs_)
        else:
            return ConnectStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_HexBinary8(self, value):
        result = True
        # Validate type HexBinary8, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary8' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ConnectStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConnectStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConnectStatusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConnectStatusType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConnectStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConnectStatusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ConnectStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.value_nsprefix_ = child_.prefix
            # validate type HexBinary8
            self.validate_HexBinary8(self.value)
# end class ConnectStatusType


class InverterStatusType(GeneratedsSuper):
    """InverterStatusType -- DER InverterStatus value:
    0 - N/A
    1 - off
    2 - sleeping (auto-shutdown) or DER is at low output power/voltage
    3 - starting up or ON but not producing power
    4 - tracking MPPT power point
    5 - forced power reduction/derating
    6 - shutting down
    7 - one or more faults exist
    8 - standby (service on unit) - DER may be at high output voltage/power
    9 - test mode
    10 - as defined in manufacturer status
    All other values reserved.
    dateTime -- The date and time at which the state applied.
    value -- The value indicating the state.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
        self.value = value
        self.validate_UInt8(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, InverterStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if InverterStatusType.subclass:
            return InverterStatusType.subclass(*args_, **kwargs_)
        else:
            return InverterStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='InverterStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('InverterStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'InverterStatusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='InverterStatusType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='InverterStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='InverterStatusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='InverterStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.value)
# end class InverterStatusType


class LocalControlModeStatusType(GeneratedsSuper):
    """LocalControlModeStatusType -- DER LocalControlModeStatus/value:
    0
    
    local control
    1
    
    remote control
    All other values reserved.
    dateTime -- The date and time at which the state applied.
    value -- The value indicating the state.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
        self.value = value
        self.validate_UInt8(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocalControlModeStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocalControlModeStatusType.subclass:
            return LocalControlModeStatusType.subclass(*args_, **kwargs_)
        else:
            return LocalControlModeStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LocalControlModeStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocalControlModeStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocalControlModeStatusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocalControlModeStatusType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocalControlModeStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LocalControlModeStatusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LocalControlModeStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.value)
# end class LocalControlModeStatusType


class ManufacturerStatusType(GeneratedsSuper):
    """ManufacturerStatusType -- DER ManufacturerStatus/value: String data type
    dateTime -- The date and time at which the state applied.
    value -- The value indicating the state.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
        self.value = value
        self.validate_String6(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ManufacturerStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ManufacturerStatusType.subclass:
            return ManufacturerStatusType.subclass(*args_, **kwargs_)
        else:
            return ManufacturerStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_String6(self, value):
        result = True
        # Validate type String6, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 6:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String6' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ManufacturerStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ManufacturerStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ManufacturerStatusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ManufacturerStatusType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ManufacturerStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ManufacturerStatusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ManufacturerStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.value), input_name='value')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'value')
            value_ = self.gds_validate_string(value_, node, 'value')
            self.value = value_
            self.value_nsprefix_ = child_.prefix
            # validate type String6
            self.validate_String6(self.value)
# end class ManufacturerStatusType


class OperationalModeStatusType(GeneratedsSuper):
    """OperationalModeStatusType -- DER OperationalModeStatus value:
    0 - Not applicable / Unknown
    1 - Off
    2 - Operational mode
    3 - Test mode
    All other values reserved.
    dateTime -- The date and time at which the state applied.
    value -- The value indicating the state.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
        self.value = value
        self.validate_UInt8(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OperationalModeStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OperationalModeStatusType.subclass:
            return OperationalModeStatusType.subclass(*args_, **kwargs_)
        else:
            return OperationalModeStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='OperationalModeStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OperationalModeStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OperationalModeStatusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OperationalModeStatusType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OperationalModeStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OperationalModeStatusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='OperationalModeStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.value)
# end class OperationalModeStatusType


class StateOfChargeStatusType(GeneratedsSuper):
    """StateOfChargeStatusType -- DER StateOfChargeStatus value: Percent data type
    dateTime -- The date and time at which the state applied.
    value -- The value indicating the state.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
        self.value = value
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StateOfChargeStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StateOfChargeStatusType.subclass:
            return StateOfChargeStatusType.subclass(*args_, **kwargs_)
        else:
            return StateOfChargeStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def _hasContent(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='StateOfChargeStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StateOfChargeStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StateOfChargeStatusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StateOfChargeStatusType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StateOfChargeStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StateOfChargeStatusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='StateOfChargeStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            self.value.export(outfile, level, namespaceprefix_, namespacedef_='', name_='value', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.value = obj_
            obj_.original_tagname_ = 'value'
# end class StateOfChargeStatusType


class StorageModeStatusType(GeneratedsSuper):
    """StorageModeStatusType -- DER StorageModeStatus value:
    0
    
    storage charging
    1
    
    storage discharging
    2
    
    storage holding
    All other values reserved.
    dateTime -- The date and time at which the state applied.
    value -- The value indicating the state.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, dateTime=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
        self.value = value
        self.validate_UInt8(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, StorageModeStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if StorageModeStatusType.subclass:
            return StorageModeStatusType.subclass(*args_, **kwargs_)
        else:
            return StorageModeStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.dateTime is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='StorageModeStatusType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('StorageModeStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'StorageModeStatusType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='StorageModeStatusType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='StorageModeStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='StorageModeStatusType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='StorageModeStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.value)
# end class StorageModeStatusType


class Link(GeneratedsSuper):
    """Link -- Links provide a reference, via URI, to another resource.
    href -- A URI reference.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Link)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Link.subclass:
            return Link.subclass(*args_, **kwargs_)
        else:
            return Link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Link', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Link')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Link':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Link')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Link', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Link'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Link', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Link


class ListLink(Link):
    """ListLink -- ListLinks provide a reference, via URI, to a List.
    all -- Indicates the total number of items in the referenced list. This attribute SHALL be present if the href is a local or relative URI. This attribute SHOULD NOT be present if the href is a remote or absolute URI, as the server may be unaware of changes to the value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, all=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ListLink"), self).__init__( **kwargs_)
        self.all = _cast(int, all)
        self.all_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ListLink.subclass:
            return ListLink.subclass(*args_, **kwargs_)
        else:
            return ListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_all(self):
        return self.all
    def set_all(self, all):
        self.all = all
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            super(ListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ListLink'):
        super(ListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ListLink')
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            outfile.write(' all="%s"' % self.gds_format_integer(self.all, input_name='all'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ListLink', fromsubclass_=False, pretty_print=True):
        super(ListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.add('all')
            self.all = self.gds_parse_integer(value, node, 'all')
            self.validate_UInt32(self.all)    # validate type UInt32
        super(ListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ListLink


class Resource(GeneratedsSuper):
    """Resource -- A resource is an addressable unit of information, either a collection (List) or instance of an object (identifiedObject, or simply, Resource)
    href -- A reference to the resource address (URI). Required in a response to a GET, ignored otherwise.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, href=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.href = _cast(None, href)
        self.href_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Resource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Resource.subclass:
            return Resource.subclass(*args_, **kwargs_)
        else:
            return Resource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_href(self):
        return self.href
    def set_href(self, href):
        self.href = href
    def _hasContent(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Resource', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Resource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Resource':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Resource')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Resource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Resource'):
        if self.href is not None and 'href' not in already_processed:
            already_processed.add('href')
            outfile.write(' href=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.href), input_name='href')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='Resource', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('href', node)
        if value is not None and 'href' not in already_processed:
            already_processed.add('href')
            self.href = value
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class Resource


class RespondableResource(Resource):
    """RespondableResource -- A Resource to which a Response can be requested.
    replyTo -- A reference to the response resource address (URI). Required on a response to a GET if responseRequired is "true".
    responseRequired -- Indicates whether or not a response is required upon receipt, creation or update of this resource. Responses shall be posted to the collection specified in "replyTo".
    If the resource has a deviceCategory field, devices that match one or more of the device types indicated in deviceCategory SHALL respond according to the rules listed below.  If the category does not match, the device SHALL NOT respond. If the resource does not have a deviceCategory field, a device receiving the resource SHALL respond according to the rules listed below.
    Value encoded as hex according to the following bit assignments, any combination is possible.
    See Table 27 for the list of appropriate Response status codes to be sent for these purposes.
    0 - End device shall indicate that message was received
    1 - End device shall indicate specific response.
    2 - End user / customer response is required.
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, replyTo=None, responseRequired='00', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RespondableResource"), self).__init__( **kwargs_)
        self.replyTo = _cast(None, replyTo)
        self.replyTo_nsprefix_ = None
        self.responseRequired = _cast(None, responseRequired)
        self.responseRequired_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RespondableResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RespondableResource.subclass:
            return RespondableResource.subclass(*args_, **kwargs_)
        else:
            return RespondableResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_replyTo(self):
        return self.replyTo
    def set_replyTo(self, replyTo):
        self.replyTo = replyTo
    def get_responseRequired(self):
        return self.responseRequired
    def set_responseRequired(self, responseRequired):
        self.responseRequired = responseRequired
    def validate_HexBinary8(self, value):
        # Validate type HexBinary8, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 2:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary8' % {"value": value, "lineno": lineno} )
                result = False
    def _hasContent(self):
        if (
            super(RespondableResource, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RespondableResource', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RespondableResource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RespondableResource':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RespondableResource')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RespondableResource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RespondableResource'):
        super(RespondableResource, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RespondableResource')
        if self.replyTo is not None and 'replyTo' not in already_processed:
            already_processed.add('replyTo')
            outfile.write(' replyTo=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.replyTo), input_name='replyTo')), ))
        if self.responseRequired != "00" and 'responseRequired' not in already_processed:
            already_processed.add('responseRequired')
            outfile.write(' responseRequired=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.responseRequired), input_name='responseRequired')), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RespondableResource', fromsubclass_=False, pretty_print=True):
        super(RespondableResource, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('replyTo', node)
        if value is not None and 'replyTo' not in already_processed:
            already_processed.add('replyTo')
            self.replyTo = value
        value = find_attr_value_('responseRequired', node)
        if value is not None and 'responseRequired' not in already_processed:
            already_processed.add('responseRequired')
            self.responseRequired = value
            self.validate_HexBinary8(self.responseRequired)    # validate type HexBinary8
        super(RespondableResource, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RespondableResource, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RespondableResource


class RespondableSubscribableIdentifiedObject(RespondableResource):
    """RespondableSubscribableIdentifiedObject -- An IdentifiedObject to which a Response can be requested.
    subscribable -- Indicates whether or not subscriptions are supported for this resource, and whether or not conditional (thresholds) are supported. If not specified, is "not subscribable" (0).
    mRID -- The global identifier of the object.
    description -- The description is a human readable text describing or naming the object.
    version -- Contains the version number of the object. See the type definition for details.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RespondableResource
    def __init__(self, subscribable='0', mRID=None, description=None, version=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RespondableSubscribableIdentifiedObject"), self).__init__( **kwargs_)
        self.subscribable = _cast(int, subscribable)
        self.subscribable_nsprefix_ = None
        self.mRID = mRID
        self.mRID_nsprefix_ = None
        self.description = description
        self.validate_String32(self.description)
        self.description_nsprefix_ = None
        self.version = version
        self.version_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RespondableSubscribableIdentifiedObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RespondableSubscribableIdentifiedObject.subclass:
            return RespondableSubscribableIdentifiedObject.subclass(*args_, **kwargs_)
        else:
            return RespondableSubscribableIdentifiedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mRID(self):
        return self.mRID
    def set_mRID(self, mRID):
        self.mRID = mRID
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_subscribable(self):
        return self.subscribable
    def set_subscribable(self, subscribable):
        self.subscribable = subscribable
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_SubscribableType(self, value):
        # Validate type SubscribableType, a restriction on UInt8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(RespondableSubscribableIdentifiedObject, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RespondableSubscribableIdentifiedObject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RespondableSubscribableIdentifiedObject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RespondableSubscribableIdentifiedObject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RespondableSubscribableIdentifiedObject')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RespondableSubscribableIdentifiedObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RespondableSubscribableIdentifiedObject'):
        super(RespondableSubscribableIdentifiedObject, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RespondableSubscribableIdentifiedObject')
        if self.subscribable != "0" and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            outfile.write(' subscribable=%s' % (quote_attrib(self.subscribable), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RespondableSubscribableIdentifiedObject', fromsubclass_=False, pretty_print=True):
        super(RespondableSubscribableIdentifiedObject, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            namespaceprefix_ = self.mRID_nsprefix_ + ':' if (UseCapturedNS_ and self.mRID_nsprefix_) else ''
            self.mRID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            self.version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='version', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subscribable', node)
        if value is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            self.subscribable = self.gds_parse_integer(value, node, 'subscribable')
            self.validate_SubscribableType(self.subscribable)    # validate type SubscribableType
        super(RespondableSubscribableIdentifiedObject, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.description)
        elif nodeName_ == 'version':
            obj_ = VersionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(RespondableSubscribableIdentifiedObject, self)._buildChildren(child_, node, nodeName_, True)
# end class RespondableSubscribableIdentifiedObject


class SubscribableResource(Resource):
    """SubscribableResource -- A Resource to which a Subscription can be requested.
    subscribable -- Indicates whether or not subscriptions are supported for this resource, and whether or not conditional (thresholds) are supported. If not specified, is "not subscribable" (0).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, subscribable='0', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubscribableResource"), self).__init__( **kwargs_)
        self.subscribable = _cast(int, subscribable)
        self.subscribable_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubscribableResource)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubscribableResource.subclass:
            return SubscribableResource.subclass(*args_, **kwargs_)
        else:
            return SubscribableResource(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_subscribable(self):
        return self.subscribable
    def set_subscribable(self, subscribable):
        self.subscribable = subscribable
    def validate_SubscribableType(self, value):
        # Validate type SubscribableType, a restriction on UInt8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            super(SubscribableResource, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubscribableResource', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubscribableResource')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubscribableResource':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscribableResource')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubscribableResource', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubscribableResource'):
        super(SubscribableResource, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscribableResource')
        if self.subscribable != "0" and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            outfile.write(' subscribable=%s' % (quote_attrib(self.subscribable), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubscribableResource', fromsubclass_=False, pretty_print=True):
        super(SubscribableResource, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subscribable', node)
        if value is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            self.subscribable = self.gds_parse_integer(value, node, 'subscribable')
            self.validate_SubscribableType(self.subscribable)    # validate type SubscribableType
        super(SubscribableResource, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SubscribableResource, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SubscribableResource


class Error(GeneratedsSuper):
    """Error -- Contains information about the nature of an error if a request could not be completed successfully.
    maxRetryDuration -- Contains the number of seconds the client SHOULD wait before retrying the request.
    reasonCode -- Code indicating the reason for failure.
    0 - Invalid request format
    1 - Invalid request values (e.g. invalid threshold values)
    2 - Resource limit reached
    3 - Conditional subscription field not supported
    4 - Maximum request frequency exceeded
    All other values reserved
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, maxRetryDuration=None, reasonCode=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.maxRetryDuration = maxRetryDuration
        self.validate_UInt16(self.maxRetryDuration)
        self.maxRetryDuration_nsprefix_ = None
        self.reasonCode = reasonCode
        self.validate_UInt16(self.reasonCode)
        self.reasonCode_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Error)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Error.subclass:
            return Error.subclass(*args_, **kwargs_)
        else:
            return Error(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_maxRetryDuration(self):
        return self.maxRetryDuration
    def set_maxRetryDuration(self, maxRetryDuration):
        self.maxRetryDuration = maxRetryDuration
    def get_reasonCode(self):
        return self.reasonCode
    def set_reasonCode(self, reasonCode):
        self.reasonCode = reasonCode
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.maxRetryDuration is not None or
            self.reasonCode is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Error', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Error')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Error':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Error')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Error', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Error'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Error', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.maxRetryDuration is not None:
            namespaceprefix_ = self.maxRetryDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.maxRetryDuration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxRetryDuration>%s</%smaxRetryDuration>%s' % (namespaceprefix_ , self.gds_format_integer(self.maxRetryDuration, input_name='maxRetryDuration'), namespaceprefix_ , eol_))
        if self.reasonCode is not None:
            namespaceprefix_ = self.reasonCode_nsprefix_ + ':' if (UseCapturedNS_ and self.reasonCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreasonCode>%s</%sreasonCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.reasonCode, input_name='reasonCode'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'maxRetryDuration' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'maxRetryDuration')
            ival_ = self.gds_validate_integer(ival_, node, 'maxRetryDuration')
            self.maxRetryDuration = ival_
            self.maxRetryDuration_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.maxRetryDuration)
        elif nodeName_ == 'reasonCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'reasonCode')
            ival_ = self.gds_validate_integer(ival_, node, 'reasonCode')
            self.reasonCode = ival_
            self.reasonCode_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.reasonCode)
# end class Error


class Event(RespondableSubscribableIdentifiedObject):
    """Event -- An Event indicates information that applies to a particular period of time. Events SHALL be executed relative to the time of the server, as described in the Time function set section 11.1.
    creationTime -- The time at which the Event was created.
    interval -- The period during which the Event applies.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RespondableSubscribableIdentifiedObject
    def __init__(self, creationTime=None, EventStatus=None, interval=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Event"), self).__init__( **kwargs_)
        self.creationTime = creationTime
        self.creationTime_nsprefix_ = None
        self.EventStatus = EventStatus
        self.EventStatus_nsprefix_ = None
        self.interval = interval
        self.interval_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Event)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Event.subclass:
            return Event.subclass(*args_, **kwargs_)
        else:
            return Event(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_creationTime(self):
        return self.creationTime
    def set_creationTime(self, creationTime):
        self.creationTime = creationTime
    def get_EventStatus(self):
        return self.EventStatus
    def set_EventStatus(self, EventStatus):
        self.EventStatus = EventStatus
    def get_interval(self):
        return self.interval
    def set_interval(self, interval):
        self.interval = interval
    def _hasContent(self):
        if (
            self.creationTime is not None or
            self.EventStatus is not None or
            self.interval is not None or
            super(Event, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Event', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Event')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Event':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Event')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Event', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Event'):
        super(Event, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Event')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Event', fromsubclass_=False, pretty_print=True):
        super(Event, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creationTime is not None:
            namespaceprefix_ = self.creationTime_nsprefix_ + ':' if (UseCapturedNS_ and self.creationTime_nsprefix_) else ''
            self.creationTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creationTime', pretty_print=pretty_print)
        if self.EventStatus is not None:
            namespaceprefix_ = self.EventStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.EventStatus_nsprefix_) else ''
            self.EventStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EventStatus', pretty_print=pretty_print)
        if self.interval is not None:
            namespaceprefix_ = self.interval_nsprefix_ + ':' if (UseCapturedNS_ and self.interval_nsprefix_) else ''
            self.interval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interval', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Event, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'creationTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creationTime = obj_
            obj_.original_tagname_ = 'creationTime'
        elif nodeName_ == 'EventStatus':
            obj_ = EventStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EventStatus = obj_
            obj_.original_tagname_ = 'EventStatus'
        elif nodeName_ == 'interval':
            obj_ = DateTimeInterval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interval = obj_
            obj_.original_tagname_ = 'interval'
        super(Event, self)._buildChildren(child_, node, nodeName_, True)
# end class Event


class EventStatus(GeneratedsSuper):
    """EventStatus -- Current status information relevant to a specific object. The Status object is used to indicate the current status of an Event. Devices can read the containing resource (e.g. TextMessage) to get the most up to date status of the event.  Devices can also subscribe to a specific resource instance to get updates when any of its attributes change, including the Status object.
    currentStatus -- Field representing the current status type.
    0 = Scheduled
    This status indicates that the event has been scheduled and the event has not yet started.  The server SHALL set the event to this status when the event is first scheduled and persist until the event has become active or has been cancelled.  For events with a start time less than or equal to the current time, this status SHALL never be indicated, the event SHALL start with a status of
    
    Active
    
    .
    1 = Active
    This status indicates that the event is currently active. The server SHALL set the event to this status when the event reaches its earliest Effective Start Time.
    2 = Cancelled
    When events are cancelled, the Status.dateTime attribute SHALL be set to the time the cancellation occurred, which cannot be in the future.  The server is responsible for maintaining the cancelled event in its collection for the duration of the original event, or until the server has run out of space and needs to store a new event. Client devices SHALL be aware of Cancelled events, determine if the Cancelled event applies to them, and cancel the event immediately if applicable.
    3 = Cancelled with Randomization
    The server is responsible for maintaining the cancelled event in its collection for the duration of the Effective Scheduled Period. Client devices SHALL be aware of Cancelled with Randomization events, determine if the Cancelled event applies to them, and cancel the event immediately, using the larger of (absolute value of randomizeStart) and (absolute value of randomizeDuration) as the end randomization, in seconds. This Status.type SHALL NOT be used with "regular" Events, only with specializations of RandomizableEvent.
    4 = Superseded
    Events marked as Superseded by servers are events that may have been replaced by new events from the same program that target the exact same set of deviceCategory's (if applicable) AND DERControl controls (e.g., opModTargetW) (if applicable) and overlap for a given period of time. Servers SHALL mark an event as Superseded at the earliest Effective Start Time of the overlapping event. Servers are responsible for maintaining the Superseded event in their collection for the duration of the Effective Scheduled Period.
    Client devices encountering a Superseded event SHALL terminate execution of the event immediately and commence execution of the new event immediately, unless the current time is within the start randomization window of the superseded event, in which case the client SHALL obey the start randomization of the new event. This Status.type SHALL NOT be used with TextMessage, since multiple text messages can be active.
    All other values reserved.
    dateTime -- The dateTime attribute will provide a timestamp of when the current status was defined. dateTime MUST be set to the time at which the status change occurred, not a time in the future or past.
    potentiallySuperseded -- Set to true by a server of this event if there are events that overlap this event in time and also overlap in some, but not all, deviceCategory's (if applicable) AND DERControl controls (e.g., opModTargetW) (if applicable) in the same function set instance.
    potentiallySupersededTime -- Indicates the time that the potentiallySuperseded flag was set.
    reason -- The Reason attribute allows a Service provider to provide a textual explanation of the status.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, currentStatus=None, dateTime=None, potentiallySuperseded=None, potentiallySupersededTime=None, reason=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.currentStatus = currentStatus
        self.validate_UInt8(self.currentStatus)
        self.currentStatus_nsprefix_ = None
        self.dateTime = dateTime
        self.dateTime_nsprefix_ = None
        self.potentiallySuperseded = potentiallySuperseded
        self.potentiallySuperseded_nsprefix_ = None
        self.potentiallySupersededTime = potentiallySupersededTime
        self.potentiallySupersededTime_nsprefix_ = None
        self.reason = reason
        self.validate_String192(self.reason)
        self.reason_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EventStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EventStatus.subclass:
            return EventStatus.subclass(*args_, **kwargs_)
        else:
            return EventStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currentStatus(self):
        return self.currentStatus
    def set_currentStatus(self, currentStatus):
        self.currentStatus = currentStatus
    def get_dateTime(self):
        return self.dateTime
    def set_dateTime(self, dateTime):
        self.dateTime = dateTime
    def get_potentiallySuperseded(self):
        return self.potentiallySuperseded
    def set_potentiallySuperseded(self, potentiallySuperseded):
        self.potentiallySuperseded = potentiallySuperseded
    def get_potentiallySupersededTime(self):
        return self.potentiallySupersededTime
    def set_potentiallySupersededTime(self, potentiallySupersededTime):
        self.potentiallySupersededTime = potentiallySupersededTime
    def get_reason(self):
        return self.reason
    def set_reason(self, reason):
        self.reason = reason
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_String192(self, value):
        result = True
        # Validate type String192, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 192:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String192' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.currentStatus is not None or
            self.dateTime is not None or
            self.potentiallySuperseded is not None or
            self.potentiallySupersededTime is not None or
            self.reason is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EventStatus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EventStatus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EventStatus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EventStatus')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EventStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EventStatus'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EventStatus', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentStatus is not None:
            namespaceprefix_ = self.currentStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.currentStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrentStatus>%s</%scurrentStatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.currentStatus, input_name='currentStatus'), namespaceprefix_ , eol_))
        if self.dateTime is not None:
            namespaceprefix_ = self.dateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTime_nsprefix_) else ''
            self.dateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTime', pretty_print=pretty_print)
        if self.potentiallySuperseded is not None:
            namespaceprefix_ = self.potentiallySuperseded_nsprefix_ + ':' if (UseCapturedNS_ and self.potentiallySuperseded_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spotentiallySuperseded>%s</%spotentiallySuperseded>%s' % (namespaceprefix_ , self.gds_format_boolean(self.potentiallySuperseded, input_name='potentiallySuperseded'), namespaceprefix_ , eol_))
        if self.potentiallySupersededTime is not None:
            namespaceprefix_ = self.potentiallySupersededTime_nsprefix_ + ':' if (UseCapturedNS_ and self.potentiallySupersededTime_nsprefix_) else ''
            self.potentiallySupersededTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='potentiallySupersededTime', pretty_print=pretty_print)
        if self.reason is not None:
            namespaceprefix_ = self.reason_nsprefix_ + ':' if (UseCapturedNS_ and self.reason_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sreason>%s</%sreason>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.reason), input_name='reason')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currentStatus' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'currentStatus')
            ival_ = self.gds_validate_integer(ival_, node, 'currentStatus')
            self.currentStatus = ival_
            self.currentStatus_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.currentStatus)
        elif nodeName_ == 'dateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTime = obj_
            obj_.original_tagname_ = 'dateTime'
        elif nodeName_ == 'potentiallySuperseded':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'potentiallySuperseded')
            ival_ = self.gds_validate_boolean(ival_, node, 'potentiallySuperseded')
            self.potentiallySuperseded = ival_
            self.potentiallySuperseded_nsprefix_ = child_.prefix
        elif nodeName_ == 'potentiallySupersededTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.potentiallySupersededTime = obj_
            obj_.original_tagname_ = 'potentiallySupersededTime'
        elif nodeName_ == 'reason':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'reason')
            value_ = self.gds_validate_string(value_, node, 'reason')
            self.reason = value_
            self.reason_nsprefix_ = child_.prefix
            # validate type String192
            self.validate_String192(self.reason)
# end class EventStatus


class RandomizableEvent(Event):
    """RandomizableEvent -- An Event that can indicate time ranges over which the start time and duration SHALL be randomized.
    randomizeDuration -- Number of seconds boundary inside which a random value must be selected to be applied to the associated interval duration, to avoid sudden synchronized demand changes. If related to price level changes, sign may be ignored. Valid range is -3600 to 3600. If not specified, 0 is the default.
    randomizeStart -- Number of seconds boundary inside which a random value must be selected to be applied to the associated interval start time, to avoid sudden synchronized demand changes. If related to price level changes, sign may be ignored. Valid range is -3600 to 3600. If not specified, 0 is the default.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Event
    def __init__(self, randomizeDuration=None, randomizeStart=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RandomizableEvent"), self).__init__( **kwargs_)
        self.randomizeDuration = randomizeDuration
        self.randomizeDuration_nsprefix_ = None
        self.randomizeStart = randomizeStart
        self.randomizeStart_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RandomizableEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RandomizableEvent.subclass:
            return RandomizableEvent.subclass(*args_, **kwargs_)
        else:
            return RandomizableEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_randomizeDuration(self):
        return self.randomizeDuration
    def set_randomizeDuration(self, randomizeDuration):
        self.randomizeDuration = randomizeDuration
    def get_randomizeStart(self):
        return self.randomizeStart
    def set_randomizeStart(self, randomizeStart):
        self.randomizeStart = randomizeStart
    def _hasContent(self):
        if (
            self.randomizeDuration is not None or
            self.randomizeStart is not None or
            super(RandomizableEvent, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RandomizableEvent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RandomizableEvent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RandomizableEvent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RandomizableEvent')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RandomizableEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RandomizableEvent'):
        super(RandomizableEvent, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RandomizableEvent')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RandomizableEvent', fromsubclass_=False, pretty_print=True):
        super(RandomizableEvent, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.randomizeDuration is not None:
            namespaceprefix_ = self.randomizeDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.randomizeDuration_nsprefix_) else ''
            self.randomizeDuration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='randomizeDuration', pretty_print=pretty_print)
        if self.randomizeStart is not None:
            namespaceprefix_ = self.randomizeStart_nsprefix_ + ':' if (UseCapturedNS_ and self.randomizeStart_nsprefix_) else ''
            self.randomizeStart.export(outfile, level, namespaceprefix_, namespacedef_='', name_='randomizeStart', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RandomizableEvent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'randomizeDuration':
            obj_ = OneHourRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.randomizeDuration = obj_
            obj_.original_tagname_ = 'randomizeDuration'
        elif nodeName_ == 'randomizeStart':
            obj_ = OneHourRangeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.randomizeStart = obj_
            obj_.original_tagname_ = 'randomizeStart'
        super(RandomizableEvent, self)._buildChildren(child_, node, nodeName_, True)
# end class RandomizableEvent


class AccumulationBehaviourType(GeneratedsSuper):
    """AccumulationBehaviourType -- 0 = Not Applicable (default, if not specified)
    3 = Cumulative
    The sum of the previous billing period values. Note:
    
    Cumulative
    
    is commonly used in conjunction with
    
    demand.
    
    Each demand reset causes the maximum demand value for the present billing period (since the last demand reset) to accumulate as an accumulative total of all maximum demands. So instead of
    
    zeroing
    
    the demand register, a demand reset has the affect of adding the present maximum demand to this accumulating total.
    4 = DeltaData
    The difference between the value at the end of the prescribed interval and the beginning of the interval. This is used for incremental interval data.
    Note: One common application would be for load profile data, another use might be to report the number of events within an interval (such as the number of equipment energizations within the specified period of time.)
    6 = Indicating
    As if a needle is swung out on the meter face to a value to indicate the current value. (Note: An
    
    indicating
    
    value is typically measured over hundreds of milliseconds or greater, or may imply a
    
    pusher
    
    mechanism to capture a value. Compare this to
    
    instantaneous
    
    which is measured over a shorter period of time.)
    9 = Summation
    A form of accumulation which is selective with respect to time.
    Note :
    
    Summation
    
    could be considered a specialization of
    
    Bulk Quantity
    
    according to the rules of inheritance where
    
    Summation
    
    selectively accumulates pulses over a timing pattern, and
    
    BulkQuantity
    
    accumulates pulses all of the time.
    12 = Instantaneous
    Typically measured over the fastest period of time allowed by the definition of the metric (usually milliseconds or tens of milliseconds.) (Note:
    
    Instantaneous
    
    was moved to attribute #3 in 61968-9Ed2 from attribute #1 in 61968-9Ed1.)
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccumulationBehaviourType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccumulationBehaviourType.subclass:
            return AccumulationBehaviourType.subclass(*args_, **kwargs_)
        else:
            return AccumulationBehaviourType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AccumulationBehaviourType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccumulationBehaviourType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AccumulationBehaviourType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccumulationBehaviourType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccumulationBehaviourType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccumulationBehaviourType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AccumulationBehaviourType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class AccumulationBehaviourType


class ApplianceLoadReductionType(GeneratedsSuper):
    """ApplianceLoadReductionType -- 0 - Delay Appliance Load
    Parameter requesting the appliance to respond by providing a moderate load reduction for the duration of a delay period.  Typically referring to a
    
    non-emergency
    
    event in which appliances can continue operating if already in a load consuming period.
    1 - Temporary Appliance Load Reduction
    Parameter requesting the appliance to respond by providing an aggressive load reduction for a short time period.  Typically referring to an
    
    emergency/spinning reserve
    
    event in which an appliance should start shedding load if currently in a load consuming period.
    * Full definition of how appliances react when receiving each parameter is document in the EPA document - ENERGY STAR
    
    Program Requirements, Product Specification for Residential Refrigerators and Freezers, Eligibility Criteria 5, Draft 2 Version 5.0.
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ApplianceLoadReductionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ApplianceLoadReductionType.subclass:
            return ApplianceLoadReductionType.subclass(*args_, **kwargs_)
        else:
            return ApplianceLoadReductionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ApplianceLoadReductionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ApplianceLoadReductionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ApplianceLoadReductionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ApplianceLoadReductionType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ApplianceLoadReductionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ApplianceLoadReductionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ApplianceLoadReductionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ApplianceLoadReductionType


class CommodityType(GeneratedsSuper):
    """CommodityType -- 0 = Not Applicable (default, if not specified)
    1 = Electricity secondary metered value (a premises meter is typically on the low voltage, or secondary, side of a service transformer)
    2 = Electricity primary metered value (measured on the high voltage, or primary, side of the service transformer)
    4 = Air
    7 = NaturalGas
    8 = Propane
    9 = PotableWater
    10 = Steam
    11 = WasteWater
    12 = HeatingFluid
    13 = CoolingFluid
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CommodityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CommodityType.subclass:
            return CommodityType.subclass(*args_, **kwargs_)
        else:
            return CommodityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommodityType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CommodityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CommodityType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CommodityType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CommodityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CommodityType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CommodityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CommodityType


class ConsumptionBlockType(GeneratedsSuper):
    """ConsumptionBlockType -- 0 = Not Applicable (default, if not specified)
    1 = Block 1
    2 = Block 2
    3 = Block 3
    4 = Block 4
    5 = Block 5
    6 = Block 6
    7 = Block 7
    8 = Block 8
    9 = Block 9
    10 = Block 10
    11 = Block 11
    12 = Block 12
    13 = Block 13
    14 = Block 14
    15 = Block 15
    16 = Block 16
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConsumptionBlockType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConsumptionBlockType.subclass:
            return ConsumptionBlockType.subclass(*args_, **kwargs_)
        else:
            return ConsumptionBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConsumptionBlockType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConsumptionBlockType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConsumptionBlockType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConsumptionBlockType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConsumptionBlockType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConsumptionBlockType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConsumptionBlockType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ConsumptionBlockType


class CurrencyCode(GeneratedsSuper):
    """CurrencyCode -- Follows codes defined in [ISO 4217].
    0 - Not Applicable (default, if not specified)
    36 - Australian Dollar
    124 - Canadian Dollar
    840 - US Dollar
    978 - Euro
    This is not a complete list.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CurrencyCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CurrencyCode.subclass:
            return CurrencyCode.subclass(*args_, **kwargs_)
        else:
            return CurrencyCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CurrencyCode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CurrencyCode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CurrencyCode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CurrencyCode')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CurrencyCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CurrencyCode'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CurrencyCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class CurrencyCode


class DataQualifierType(GeneratedsSuper):
    """DataQualifierType -- 0 = Not Applicable (default, if not specified)
    2 = Average
    8 = Maximum
    9 = Minimum
    12 = Normal
    29 = Standard Deviation of a Population (typically indicated by a lower case sigma)
    30 = Standard Deviation of a Sample Drawn from a Population (typically indicated by a lower case 's')
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DataQualifierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DataQualifierType.subclass:
            return DataQualifierType.subclass(*args_, **kwargs_)
        else:
            return DataQualifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DataQualifierType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DataQualifierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DataQualifierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DataQualifierType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DataQualifierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DataQualifierType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DataQualifierType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DataQualifierType


class DateTimeInterval(GeneratedsSuper):
    """DateTimeInterval -- Interval of date and time.
    duration -- Duration of the interval, in seconds.
    start -- Date and time of the start of the interval.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, duration=None, start=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.duration = duration
        self.validate_UInt32(self.duration)
        self.duration_nsprefix_ = None
        self.start = start
        self.start_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DateTimeInterval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DateTimeInterval.subclass:
            return DateTimeInterval.subclass(*args_, **kwargs_)
        else:
            return DateTimeInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_duration(self):
        return self.duration
    def set_duration(self, duration):
        self.duration = duration
    def get_start(self):
        return self.start
    def set_start(self, start):
        self.start = start
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.duration is not None or
            self.start is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DateTimeInterval', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DateTimeInterval')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DateTimeInterval':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DateTimeInterval')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DateTimeInterval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DateTimeInterval'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DateTimeInterval', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.duration is not None:
            namespaceprefix_ = self.duration_nsprefix_ + ':' if (UseCapturedNS_ and self.duration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sduration>%s</%sduration>%s' % (namespaceprefix_ , self.gds_format_integer(self.duration, input_name='duration'), namespaceprefix_ , eol_))
        if self.start is not None:
            namespaceprefix_ = self.start_nsprefix_ + ':' if (UseCapturedNS_ and self.start_nsprefix_) else ''
            self.start.export(outfile, level, namespaceprefix_, namespacedef_='', name_='start', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'duration' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'duration')
            ival_ = self.gds_validate_integer(ival_, node, 'duration')
            self.duration = ival_
            self.duration_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.duration)
        elif nodeName_ == 'start':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.start = obj_
            obj_.original_tagname_ = 'start'
# end class DateTimeInterval


class DeviceCategoryType(GeneratedsSuper):
    """DeviceCategoryType -- The Device category types defined.
    Bit positions SHALL be defined as follows:
    0 - Programmable Communicating Thermostat
    1 - Strip Heaters
    2 - Baseboard Heaters
    3 - Water Heater
    4 - Pool Pump
    5 - Sauna
    6 - Hot Tub
    7 - Smart Appliance
    8 - Irrigation Pump
    9 - Managed Commercial and Industrial (C
    &
    amp;I) Loads
    10 - Simple Misc. (Residential On/Off) Loads
    11 - Exterior Lighting
    12 - Interior Lighting
    13 - Load Control Switch
    14 - Energy Management System
    15 - Smart Energy Module
    16 - Electric Vehicle
    17 - EVSE
    18 - Virtual or Mixed DER
    19 - Reciprocating Engine
    20 - Fuel Cell
    21 - Photovoltaic System
    22 - Combined Heat and Power
    23 - Combined PV and Storage
    24 - Other Generation System
    25 - Other Storage System
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeviceCategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeviceCategoryType.subclass:
            return DeviceCategoryType.subclass(*args_, **kwargs_)
        else:
            return DeviceCategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexBinary32(self, value):
        result = True
        # Validate type HexBinary32, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary32' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DeviceCategoryType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeviceCategoryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeviceCategoryType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceCategoryType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeviceCategoryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DeviceCategoryType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DeviceCategoryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DeviceCategoryType


class DstRuleType(GeneratedsSuper):
    """DstRuleType -- Bit map encoded rule from which is calculated the start or end time, within the current year, to which daylight savings time offset must be applied.
    The rule encoding:
    Bits  0 - 11: seconds 0 - 3599
    Bits 12 - 16: hours 0 - 23
    Bits 17 - 19: day of the week 0 = not applicable, 1 - 7 (Monday = 1)
    Bits 20 - 24: day of the month 0 = not applicable, 1 - 31
    Bits 25 - 27: operator  (detailed below)
    Bits 28 - 31: month 1 - 12
    Rule value of 0xFFFFFFFF means rule processing/DST correction is disabled.
    The operators:
    0: DST starts/ends on the Day of the Month
    1: DST starts/ends on the Day of the Week that is on or after the Day of the Month
    2: DST starts/ends on the first occurrence of the Day of the Week in a month
    3: DST starts/ends on the second occurrence of the Day of the Week in a month
    4: DST starts/ends on the third occurrence of the Day of the Week in a month
    5: DST starts/ends on the forth occurrence of the Day of the Week in a month
    6: DST starts/ends on the fifth occurrence of the Day of the Week in a month
    7: DST starts/ends on the last occurrence of the Day of the Week in a month
    An example: DST starts on third Friday in March at 1:45 AM.  The rule...
    Seconds: 2700
    Hours: 1
    Day of Week: 5
    Day of Month: 0
    Operator: 4
    Month: 3
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DstRuleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DstRuleType.subclass:
            return DstRuleType.subclass(*args_, **kwargs_)
        else:
            return DstRuleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexBinary32(self, value):
        result = True
        # Validate type HexBinary32, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary32' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DstRuleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DstRuleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DstRuleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DstRuleType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DstRuleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DstRuleType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DstRuleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class DstRuleType


class FlowDirectionType(GeneratedsSuper):
    """FlowDirectionType -- 0 = Not Applicable (default, if not specified)
    1 = Forward (delivered to customer)
    19 = Reverse (received from customer)
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowDirectionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowDirectionType.subclass:
            return FlowDirectionType.subclass(*args_, **kwargs_)
        else:
            return FlowDirectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlowDirectionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowDirectionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlowDirectionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowDirectionType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlowDirectionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowDirectionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlowDirectionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class FlowDirectionType


class GPSLocationType(GeneratedsSuper):
    """GPSLocationType -- Specifies a GPS location, expressed in WGS 84 coordinates.
    lat -- Specifies the latitude from equator. -90 (south) to +90 (north) in decimal degrees.
    lon -- Specifies the longitude from Greenwich Meridian. -180 (west) to +180 (east) in decimal degrees.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, lat=None, lon=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.lat = lat
        self.validate_String32(self.lat)
        self.lat_nsprefix_ = None
        self.lon = lon
        self.validate_String32(self.lon)
        self.lon_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, GPSLocationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if GPSLocationType.subclass:
            return GPSLocationType.subclass(*args_, **kwargs_)
        else:
            return GPSLocationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lat(self):
        return self.lat
    def set_lat(self, lat):
        self.lat = lat
    def get_lon(self):
        return self.lon
    def set_lon(self, lon):
        self.lon = lon
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.lat is not None or
            self.lon is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='GPSLocationType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('GPSLocationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'GPSLocationType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='GPSLocationType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='GPSLocationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='GPSLocationType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='GPSLocationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lat is not None:
            namespaceprefix_ = self.lat_nsprefix_ + ':' if (UseCapturedNS_ and self.lat_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slat>%s</%slat>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lat), input_name='lat')), namespaceprefix_ , eol_))
        if self.lon is not None:
            namespaceprefix_ = self.lon_nsprefix_ + ':' if (UseCapturedNS_ and self.lon_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slon>%s</%slon>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lon), input_name='lon')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lat':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lat')
            value_ = self.gds_validate_string(value_, node, 'lat')
            self.lat = value_
            self.lat_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.lat)
        elif nodeName_ == 'lon':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lon')
            value_ = self.gds_validate_string(value_, node, 'lon')
            self.lon = value_
            self.lon_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.lon)
# end class GPSLocationType


class KindType(GeneratedsSuper):
    """KindType -- 0 = Not Applicable (default, if not specified)
    3 = Currency
    8 = Demand
    12 = Energy
    37 = Power
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, KindType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if KindType.subclass:
            return KindType.subclass(*args_, **kwargs_)
        else:
            return KindType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='KindType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('KindType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'KindType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='KindType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='KindType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='KindType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='KindType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class KindType


class LocaleType(GeneratedsSuper):
    """LocaleType -- [RFC 4646] identifier of a language-region
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LocaleType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LocaleType.subclass:
            return LocaleType.subclass(*args_, **kwargs_)
        else:
            return LocaleType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_String42(self, value):
        result = True
        # Validate type String42, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 42:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String42' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocaleType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LocaleType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LocaleType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LocaleType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LocaleType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LocaleType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LocaleType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class LocaleType


class mRIDType(GeneratedsSuper):
    """mRIDType -- A master resource identifier. The IANA PEN [PEN] provider ID SHALL be specified in bits 0-31, the least-significant bits, and objects created by that provider SHALL be assigned unique IDs with the remaining 96 bits.
    0xFFFFFFFFFFFFFFFFFFFFFFFF[XXXXXXXX], where [XXXXXXXX] is the PEN, is reserved for a object that is being created (e.g., a ReadingSet for the current time that is still accumulating).
    Except for this special reserved identifier, each modification of an object (resource) representation MUST have a different "version".
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, mRIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if mRIDType.subclass:
            return mRIDType.subclass(*args_, **kwargs_)
        else:
            return mRIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexBinary128(self, value):
        result = True
        # Validate type HexBinary128, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary128' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mRIDType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('mRIDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'mRIDType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='mRIDType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='mRIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='mRIDType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='mRIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class mRIDType


class OneHourRangeType(GeneratedsSuper):
    """OneHourRangeType -- A signed time offset, typically applied to a Time value, expressed in seconds, with range -3600 to 3600.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OneHourRangeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OneHourRangeType.subclass:
            return OneHourRangeType.subclass(*args_, **kwargs_)
        else:
            return OneHourRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_Int16(self, value):
        result = True
        # Validate type Int16, a restriction on xs:short.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OneHourRangeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OneHourRangeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'OneHourRangeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='OneHourRangeType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='OneHourRangeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='OneHourRangeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='OneHourRangeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class OneHourRangeType


class PENType(GeneratedsSuper):
    """PENType -- IANA Private Enterprise Number [PEN].
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PENType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PENType.subclass:
            return PENType.subclass(*args_, **kwargs_)
        else:
            return PENType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PENType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PENType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PENType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PENType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PENType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PENType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PENType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PENType


class PerCent(GeneratedsSuper):
    """PerCent -- Used for percentages, specified in hundredths of a percent, 0 - 10000. (10000 = 100%)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PerCent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PerCent.subclass:
            return PerCent.subclass(*args_, **kwargs_)
        else:
            return PerCent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PerCent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PerCent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PerCent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PerCent')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PerCent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PerCent'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PerCent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PerCent


class PhaseCode(GeneratedsSuper):
    """PhaseCode -- 0 = Not Applicable (default, if not specified)
    32 = Phase C (and S2)
    33 = Phase CN (and S2N)
    40 = Phase CA
    64 = Phase B
    65 = Phase BN
    66 = Phase BC
    128 = Phase A (and S1)
    129 = Phase AN (and S1N)
    132 = Phase AB
    224 = Phase ABC
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PhaseCode)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PhaseCode.subclass:
            return PhaseCode.subclass(*args_, **kwargs_)
        else:
            return PhaseCode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PhaseCode', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PhaseCode')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PhaseCode':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PhaseCode')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PhaseCode', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PhaseCode'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PhaseCode', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PhaseCode


class PINType(GeneratedsSuper):
    """PINType -- 6 digit unsigned decimal integer (0 - 999999).
    (Note that this only requires 20 bits, if it can be allocated.)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PINType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PINType.subclass:
            return PINType.subclass(*args_, **kwargs_)
        else:
            return PINType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PINType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PINType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PINType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PINType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PINType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PINType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PINType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PINType


class PowerOfTenMultiplierType(GeneratedsSuper):
    """PowerOfTenMultiplierType -- -9 = nano=x10^-9
    -6 = micro=x10^-6
    -3 = milli=x10^-3
    0 = none=x1 (default, if not specified)
    1 = deca=x10
    2 = hecto=x100
    3 = kilo=x1000
    6 = Mega=x10^6
    9 = Giga=x10^9
    This is not a complete list. Any integer between -9 and 9 SHALL be supported, indicating the power of ten multiplier for the units.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerOfTenMultiplierType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerOfTenMultiplierType.subclass:
            return PowerOfTenMultiplierType.subclass(*args_, **kwargs_)
        else:
            return PowerOfTenMultiplierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_Int8(self, value):
        result = True
        # Validate type Int8, a restriction on xs:byte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PowerOfTenMultiplierType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PowerOfTenMultiplierType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PowerOfTenMultiplierType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerOfTenMultiplierType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PowerOfTenMultiplierType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PowerOfTenMultiplierType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PowerOfTenMultiplierType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PowerOfTenMultiplierType


class PrimacyType(GeneratedsSuper):
    """PrimacyType -- Values possible for indication of "Primary" provider:
    0: In home energy management system
    1: Contracted premises service provider
    2: Non-contractual service provider
    3 - 64: Reserved
    65 - 191: User-defined
    192 - 255: Reserved
    Lower numbers indicate higher priority.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrimacyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrimacyType.subclass:
            return PrimacyType.subclass(*args_, **kwargs_)
        else:
            return PrimacyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrimacyType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrimacyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrimacyType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrimacyType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrimacyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrimacyType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrimacyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class PrimacyType


class RealEnergy(GeneratedsSuper):
    """RealEnergy -- Real electrical energy
    multiplier -- Multiplier for 'unit'.
    value -- Value of the energy in Watt-hours. (uom 72)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_UInt48(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RealEnergy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RealEnergy.subclass:
            return RealEnergy.subclass(*args_, **kwargs_)
        else:
            return RealEnergy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_UInt48(self, value):
        result = True
        # Validate type UInt48, a restriction on xs:unsignedLong.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value > 281474976710655:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on UInt48' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RealEnergy', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RealEnergy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RealEnergy':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RealEnergy')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RealEnergy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RealEnergy'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RealEnergy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type UInt48
            self.validate_UInt48(self.value)
# end class RealEnergy


class RoleFlagsType(GeneratedsSuper):
    """RoleFlagsType -- Specifies the roles that apply to a usage point.
    Bit 0 - isMirror - SHALL be set if the server is not the measurement device
    Bit 1 - isPremisesAggregationPoint - SHALL be set if the UsagePoint is the point of delivery for a premises
    Bit 2 - isPEV - SHALL be set if the usage applies to an electric vehicle
    Bit 3 - isDER - SHALL be set if the usage applies to a distributed energy resource, capable of delivering power to the grid.
    Bit 4 - isRevenueQuality - SHALL be set if usage was measured by a device certified as revenue quality
    Bit 5 - isDC - SHALL be set if the usage point measures direct current
    Bit 6 - isSubmeter - SHALL be set if the usage point is not a premises aggregation point
    Bit 7-15 - Reserved
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RoleFlagsType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RoleFlagsType.subclass:
            return RoleFlagsType.subclass(*args_, **kwargs_)
        else:
            return RoleFlagsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_HexBinary16(self, value):
        result = True
        # Validate type HexBinary16, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary16' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RoleFlagsType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RoleFlagsType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RoleFlagsType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RoleFlagsType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RoleFlagsType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RoleFlagsType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RoleFlagsType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class RoleFlagsType


class ServiceKind(GeneratedsSuper):
    """ServiceKind -- Service kind
    0 - electricity
    1 - gas
    2 - water
    3 - time
    4 - pressure
    5 - heat
    6 - cooling
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceKind)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceKind.subclass:
            return ServiceKind.subclass(*args_, **kwargs_)
        else:
            return ServiceKind(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceKind', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceKind')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceKind':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceKind')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceKind', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceKind'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceKind', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class ServiceKind


class SFDIType(GeneratedsSuper):
    """SFDIType -- Unsigned integer, max inclusive 687194767359, which is 2^36-1 (68719476735), with added check digit. See Section 8.3.2 for check digit calculation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SFDIType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SFDIType.subclass:
            return SFDIType.subclass(*args_, **kwargs_)
        else:
            return SFDIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt40(self, value):
        result = True
        # Validate type UInt40, a restriction on xs:unsignedLong.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value > 281474976710655:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on UInt40' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SFDIType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SFDIType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SFDIType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SFDIType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SFDIType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SFDIType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SFDIType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SFDIType


class SignedPerCent(GeneratedsSuper):
    """SignedPerCent -- Used for signed percentages, specified in hundredths of a percent, -10000 - 10000. (10000 = 100%)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedPerCent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedPerCent.subclass:
            return SignedPerCent.subclass(*args_, **kwargs_)
        else:
            return SignedPerCent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_Int16(self, value):
        result = True
        # Validate type Int16, a restriction on xs:short.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SignedPerCent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedPerCent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignedPerCent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignedPerCent')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignedPerCent', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SignedPerCent'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SignedPerCent', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class SignedPerCent


class SignedRealEnergy(GeneratedsSuper):
    """SignedRealEnergy -- Real electrical energy, signed.
    multiplier -- Multiplier for 'unit'.
    value -- Value of the energy in Watt-hours. (uom 72)
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.value = value
        self.validate_Int48(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SignedRealEnergy)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SignedRealEnergy.subclass:
            return SignedRealEnergy.subclass(*args_, **kwargs_)
        else:
            return SignedRealEnergy(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_Int48(self, value):
        result = True
        # Validate type Int48, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < -140737488355328:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Int48' % {"value": value, "lineno": lineno} )
                result = False
            if value > 140737488355328:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on Int48' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SignedRealEnergy', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SignedRealEnergy')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SignedRealEnergy':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SignedRealEnergy')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SignedRealEnergy', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SignedRealEnergy'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SignedRealEnergy', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type Int48
            self.validate_Int48(self.value)
# end class SignedRealEnergy


class TimeOffsetType(GeneratedsSuper):
    """TimeOffsetType -- A signed time offset, typically applied to a Time value, expressed in seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeOffsetType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeOffsetType.subclass:
            return TimeOffsetType.subclass(*args_, **kwargs_)
        else:
            return TimeOffsetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_Int32(self, value):
        result = True
        # Validate type Int32, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeOffsetType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeOffsetType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeOffsetType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeOffsetType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeOffsetType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeOffsetType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeOffsetType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TimeOffsetType


class TimeType(GeneratedsSuper):
    """TimeType -- Time is a signed 64 bit value representing the number of seconds since 0 hours, 0 minutes, 0 seconds, on the 1st of January, 1970, in UTC, not counting leap seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeType.subclass:
            return TimeType.subclass(*args_, **kwargs_)
        else:
            return TimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_Int64(self, value):
        result = True
        # Validate type Int64, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TimeType


class TOUType(GeneratedsSuper):
    """TOUType -- 0 = Not Applicable (default, if not specified)
    1 = TOU A
    2 = TOU B
    3 = TOU C
    4 = TOU D
    5 = TOU E
    6 = TOU F
    7 = TOU G
    8 = TOU H
    9 = TOU I
    10 = TOU J
    11 = TOU K
    12 = TOU L
    13 = TOU M
    14 = TOU N
    15 = TOU O
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TOUType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TOUType.subclass:
            return TOUType.subclass(*args_, **kwargs_)
        else:
            return TOUType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TOUType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TOUType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TOUType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TOUType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TOUType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TOUType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TOUType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class TOUType


class UnitType(GeneratedsSuper):
    """UnitType -- The unit types defined for end device control target reductions.
    0 - kWh
    1 - kW
    2 - Watts
    3 - Cubic Meters
    4 - Cubic Feet
    5 - US Gallons
    6 - Imperial Gallons
    7 - BTUs
    8 - Liters
    9 - kPA (gauge)
    10 - kPA (absolute)
    11 - Mega Joule
    12 - Unitless
    All other values reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitType.subclass:
            return UnitType.subclass(*args_, **kwargs_)
        else:
            return UnitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UnitType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UnitType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnitType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnitType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UnitType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UnitType


class UnitValueType(GeneratedsSuper):
    """UnitValueType -- Type for specification of a specific value, with units and power of ten multiplier.
    multiplier -- Multiplier for 'unit'.
    unit -- Unit in symbol
    value -- Value in units specified
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, multiplier=None, unit=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.multiplier = multiplier
        self.multiplier_nsprefix_ = None
        self.unit = unit
        self.unit_nsprefix_ = None
        self.value = value
        self.validate_Int32(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UnitValueType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UnitValueType.subclass:
            return UnitValueType.subclass(*args_, **kwargs_)
        else:
            return UnitValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_multiplier(self):
        return self.multiplier
    def set_multiplier(self, multiplier):
        self.multiplier = multiplier
    def get_unit(self):
        return self.unit
    def set_unit(self, unit):
        self.unit = unit
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_Int32(self, value):
        result = True
        # Validate type Int32, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.multiplier is not None or
            self.unit is not None or
            self.value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UnitValueType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UnitValueType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UnitValueType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UnitValueType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UnitValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UnitValueType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UnitValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.multiplier is not None:
            namespaceprefix_ = self.multiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.multiplier_nsprefix_) else ''
            self.multiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='multiplier', pretty_print=pretty_print)
        if self.unit is not None:
            namespaceprefix_ = self.unit_nsprefix_ + ':' if (UseCapturedNS_ and self.unit_nsprefix_) else ''
            self.unit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='unit', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'multiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.multiplier = obj_
            obj_.original_tagname_ = 'multiplier'
        elif nodeName_ == 'unit':
            obj_ = UomType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.unit = obj_
            obj_.original_tagname_ = 'unit'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type Int32
            self.validate_Int32(self.value)
# end class UnitValueType


class UomType(GeneratedsSuper):
    """UomType -- The following values are recommended values sourced from the unit of measure enumeration in IEC 61968-9 [61968]. Other values from the unit of measure enumeration in IEC 61968-9 [61968] MAY be used.
    0 = Not Applicable (default, if not specified)
    5 = A (Current in Amperes (RMS))
    6 = Kelvin (Temperature)
    23 = Degrees Celsius (Relative temperature)
    29 = Voltage
    31 = J (Energy joule)
    33 = Hz (Frequency)
    38 =W (Real power in Watts)
    42 = m3 (Cubic Meter)
    61 = VA (Apparent power)
    63 = var (Reactive power)
    65 = CosTheta (Displacement Power Factor)
    67 = V
    
    (Volts squared)
    69 = A
    
    (Amp squared)
    71 = VAh (Apparent energy)
    72 = Wh (Real energy in Watt-hours)
    73 = varh (Reactive energy)
    106 = Ah (Ampere-hours / Available Charge)
    119 = ft3 (Cubic Feet)
    122 = ft3/h (Cubic Feet per Hour)
    125 = m3/h (Cubic Meter per Hour)
    128 = US gl (US Gallons)
    129 = US gl/h (US Gallons per Hour)
    130 = IMP gl (Imperial Gallons)
    131 = IMP gl/h (Imperial Gallons per Hour)
    132 = BTU
    133 = BTU/h
    134 = Liter
    137 = L/h (Liters per Hour)
    140 = PA(gauge)
    155 = PA(absolute)
    169 = Therm
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UomType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UomType.subclass:
            return UomType.subclass(*args_, **kwargs_)
        else:
            return UomType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UomType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UomType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UomType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UomType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UomType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UomType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UomType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class UomType


class VersionType(GeneratedsSuper):
    """VersionType -- Version SHALL indicate a distinct identifier for each revision of an IdentifiedObject. If not specified, a default version of "0" (initial version) SHALL be assumed. Upon modification of any IdentifiedObject, the mRID SHALL remain the same, but the version SHALL be incremented. Servers MAY NOT modify objects that they did not create, unless they were notified of the change from the entity controlling the object's PEN.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None
    def __init__(self, valueOf_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, VersionType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if VersionType.subclass:
            return VersionType.subclass(*args_, **kwargs_)
        else:
            return VersionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VersionType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('VersionType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'VersionType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='VersionType')
        if self._hasContent():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='VersionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='VersionType'):
        pass
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='VersionType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        pass
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        pass
# end class VersionType


class ReadingBase(Resource):
    """ReadingBase -- Specific value measured by a meter or other asset. ReadingBase is abstract, used to define the elements common to Reading and IntervalReading.
    consumptionBlock -- Indicates the consumption block related to the reading. REQUIRED if ReadingType numberOfConsumptionBlocks is non-zero. If not specified, is assumed to be "0 - N/A".
    qualityFlags -- List of codes indicating the quality of the reading, using specification:
    Bit 0 - valid: data that has gone through all required validation checks and either passed them all or has been verified
    Bit 1 - manually edited: Replaced or approved by a human
    Bit 2 - estimated using reference day: data value was replaced by a machine computed value based on analysis of historical data using the same type of measurement.
    Bit 3 - estimated using linear interpolation: data value was computed using linear interpolation based on the readings before and after it
    Bit 4 - questionable: data that has failed one or more checks
    Bit 5 - derived: data that has been calculated (using logic or mathematical operations), not necessarily measured directly
    Bit 6 - projected (forecast): data that has been calculated as a projection or forecast of future readings
    timePeriod -- The time interval associated with the reading. If not specified, then defaults to the intervalLength specified in the associated ReadingType.
    touTier -- Indicates the time of use tier related to the reading. REQUIRED if ReadingType numberOfTouTiers is non-zero. If not specified, is assumed to be "0 - N/A".
    value -- Value in units specified by ReadingType
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, consumptionBlock=None, qualityFlags=None, timePeriod=None, touTier=None, value=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingBase"), self).__init__( **kwargs_)
        self.consumptionBlock = consumptionBlock
        self.consumptionBlock_nsprefix_ = None
        self.qualityFlags = qualityFlags
        self.validate_HexBinary16(self.qualityFlags)
        self.qualityFlags_nsprefix_ = None
        self.timePeriod = timePeriod
        self.timePeriod_nsprefix_ = None
        self.touTier = touTier
        self.touTier_nsprefix_ = None
        self.value = value
        self.validate_Int48(self.value)
        self.value_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingBase.subclass:
            return ReadingBase.subclass(*args_, **kwargs_)
        else:
            return ReadingBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_consumptionBlock(self):
        return self.consumptionBlock
    def set_consumptionBlock(self, consumptionBlock):
        self.consumptionBlock = consumptionBlock
    def get_qualityFlags(self):
        return self.qualityFlags
    def set_qualityFlags(self, qualityFlags):
        self.qualityFlags = qualityFlags
    def get_timePeriod(self):
        return self.timePeriod
    def set_timePeriod(self, timePeriod):
        self.timePeriod = timePeriod
    def get_touTier(self):
        return self.touTier
    def set_touTier(self, touTier):
        self.touTier = touTier
    def get_value(self):
        return self.value
    def set_value(self, value):
        self.value = value
    def validate_HexBinary16(self, value):
        result = True
        # Validate type HexBinary16, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary16' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_Int48(self, value):
        result = True
        # Validate type Int48, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < -140737488355328:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Int48' % {"value": value, "lineno": lineno} )
                result = False
            if value > 140737488355328:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on Int48' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.consumptionBlock is not None or
            self.qualityFlags is not None or
            self.timePeriod is not None or
            self.touTier is not None or
            self.value is not None or
            super(ReadingBase, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingBase')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingBase'):
        super(ReadingBase, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingBase')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingBase', fromsubclass_=False, pretty_print=True):
        super(ReadingBase, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.consumptionBlock is not None:
            namespaceprefix_ = self.consumptionBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.consumptionBlock_nsprefix_) else ''
            self.consumptionBlock.export(outfile, level, namespaceprefix_, namespacedef_='', name_='consumptionBlock', pretty_print=pretty_print)
        if self.qualityFlags is not None:
            namespaceprefix_ = self.qualityFlags_nsprefix_ + ':' if (UseCapturedNS_ and self.qualityFlags_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squalityFlags>%s</%squalityFlags>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.qualityFlags), input_name='qualityFlags')), namespaceprefix_ , eol_))
        if self.timePeriod is not None:
            namespaceprefix_ = self.timePeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.timePeriod_nsprefix_) else ''
            self.timePeriod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timePeriod', pretty_print=pretty_print)
        if self.touTier is not None:
            namespaceprefix_ = self.touTier_nsprefix_ + ':' if (UseCapturedNS_ and self.touTier_nsprefix_) else ''
            self.touTier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='touTier', pretty_print=pretty_print)
        if self.value is not None:
            namespaceprefix_ = self.value_nsprefix_ + ':' if (UseCapturedNS_ and self.value_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%svalue>%s</%svalue>%s' % (namespaceprefix_ , self.gds_format_integer(self.value, input_name='value'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingBase, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'consumptionBlock':
            obj_ = ConsumptionBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.consumptionBlock = obj_
            obj_.original_tagname_ = 'consumptionBlock'
        elif nodeName_ == 'qualityFlags':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'qualityFlags')
            value_ = self.gds_validate_string(value_, node, 'qualityFlags')
            self.qualityFlags = value_
            self.qualityFlags_nsprefix_ = child_.prefix
            # validate type HexBinary16
            self.validate_HexBinary16(self.qualityFlags)
        elif nodeName_ == 'timePeriod':
            obj_ = DateTimeInterval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timePeriod = obj_
            obj_.original_tagname_ = 'timePeriod'
        elif nodeName_ == 'touTier':
            obj_ = TOUType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.touTier = obj_
            obj_.original_tagname_ = 'touTier'
        elif nodeName_ == 'value' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'value')
            ival_ = self.gds_validate_integer(ival_, node, 'value')
            self.value = ival_
            self.value_nsprefix_ = child_.prefix
            # validate type Int48
            self.validate_Int48(self.value)
        super(ReadingBase, self)._buildChildren(child_, node, nodeName_, True)
# end class ReadingBase


class SubscribableList(SubscribableResource):
    """SubscribableList -- A List to which a Subscription can be requested.
    all -- The number specifying "all" of the items in the list. Required on GET, ignored otherwise.
    results -- Indicates the number of items in this page of results.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableResource
    def __init__(self, all=None, results=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubscribableList"), self).__init__( **kwargs_)
        self.all = _cast(int, all)
        self.all_nsprefix_ = None
        self.results = _cast(int, results)
        self.results_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubscribableList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubscribableList.subclass:
            return SubscribableList.subclass(*args_, **kwargs_)
        else:
            return SubscribableList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_all(self):
        return self.all
    def set_all(self, all):
        self.all = all
    def get_results(self):
        return self.results
    def set_results(self, results):
        self.results = results
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            super(SubscribableList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubscribableList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubscribableList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubscribableList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscribableList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubscribableList', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubscribableList'):
        super(SubscribableList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscribableList')
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            outfile.write(' all="%s"' % self.gds_format_integer(self.all, input_name='all'))
        if self.results is not None and 'results' not in already_processed:
            already_processed.add('results')
            outfile.write(' results="%s"' % self.gds_format_integer(self.results, input_name='results'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubscribableList', fromsubclass_=False, pretty_print=True):
        super(SubscribableList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.add('all')
            self.all = self.gds_parse_integer(value, node, 'all')
            self.validate_UInt32(self.all)    # validate type UInt32
        value = find_attr_value_('results', node)
        if value is not None and 'results' not in already_processed:
            already_processed.add('results')
            self.results = self.gds_parse_integer(value, node, 'results')
            self.validate_UInt32(self.results)    # validate type UInt32
        super(SubscribableList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SubscribableList, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SubscribableList


class SubscribableIdentifiedObject(SubscribableResource):
    """SubscribableIdentifiedObject -- An IdentifiedObject to which a Subscription can be requested.
    mRID -- The global identifier of the object.
    description -- The description is a human readable text describing or naming the object.
    version -- Contains the version number of the object. See the type definition for details.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableResource
    def __init__(self, mRID=None, description=None, version=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubscribableIdentifiedObject"), self).__init__( **kwargs_)
        self.mRID = mRID
        self.mRID_nsprefix_ = None
        self.description = description
        self.validate_String32(self.description)
        self.description_nsprefix_ = None
        self.version = version
        self.version_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubscribableIdentifiedObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubscribableIdentifiedObject.subclass:
            return SubscribableIdentifiedObject.subclass(*args_, **kwargs_)
        else:
            return SubscribableIdentifiedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mRID(self):
        return self.mRID
    def set_mRID(self, mRID):
        self.mRID = mRID
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(SubscribableIdentifiedObject, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SubscribableIdentifiedObject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubscribableIdentifiedObject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubscribableIdentifiedObject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscribableIdentifiedObject')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubscribableIdentifiedObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubscribableIdentifiedObject'):
        super(SubscribableIdentifiedObject, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscribableIdentifiedObject')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SubscribableIdentifiedObject', fromsubclass_=False, pretty_print=True):
        super(SubscribableIdentifiedObject, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            namespaceprefix_ = self.mRID_nsprefix_ + ':' if (UseCapturedNS_ and self.mRID_nsprefix_) else ''
            self.mRID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            self.version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='version', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SubscribableIdentifiedObject, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.description)
        elif nodeName_ == 'version':
            obj_ = VersionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(SubscribableIdentifiedObject, self)._buildChildren(child_, node, nodeName_, True)
# end class SubscribableIdentifiedObject


class RespondableIdentifiedObject(RespondableResource):
    """RespondableIdentifiedObject -- An IdentifiedObject to which a Response can be requested.
    mRID -- The global identifier of the object.
    description -- The description is a human readable text describing or naming the object.
    version -- Contains the version number of the object. See the type definition for details.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RespondableResource
    def __init__(self, mRID=None, description=None, version=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RespondableIdentifiedObject"), self).__init__( **kwargs_)
        self.mRID = mRID
        self.mRID_nsprefix_ = None
        self.description = description
        self.validate_String32(self.description)
        self.description_nsprefix_ = None
        self.version = version
        self.version_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RespondableIdentifiedObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RespondableIdentifiedObject.subclass:
            return RespondableIdentifiedObject.subclass(*args_, **kwargs_)
        else:
            return RespondableIdentifiedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mRID(self):
        return self.mRID
    def set_mRID(self, mRID):
        self.mRID = mRID
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(RespondableIdentifiedObject, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RespondableIdentifiedObject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RespondableIdentifiedObject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RespondableIdentifiedObject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RespondableIdentifiedObject')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RespondableIdentifiedObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RespondableIdentifiedObject'):
        super(RespondableIdentifiedObject, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RespondableIdentifiedObject')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RespondableIdentifiedObject', fromsubclass_=False, pretty_print=True):
        super(RespondableIdentifiedObject, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            namespaceprefix_ = self.mRID_nsprefix_ + ':' if (UseCapturedNS_ and self.mRID_nsprefix_) else ''
            self.mRID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            self.version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='version', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RespondableIdentifiedObject, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.description)
        elif nodeName_ == 'version':
            obj_ = VersionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(RespondableIdentifiedObject, self)._buildChildren(child_, node, nodeName_, True)
# end class RespondableIdentifiedObject


class List(Resource):
    """List -- Container to hold a collection of object instances or references. See Design Pattern section for additional details.
    all -- The number specifying "all" of the items in the list. Required on a response to a GET, ignored otherwise.
    results -- Indicates the number of items in this page of results.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, all=None, results=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("List"), self).__init__( **kwargs_)
        self.all = _cast(int, all)
        self.all_nsprefix_ = None
        self.results = _cast(int, results)
        self.results_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, List)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if List.subclass:
            return List.subclass(*args_, **kwargs_)
        else:
            return List(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_all(self):
        return self.all
    def set_all(self, all):
        self.all = all
    def get_results(self):
        return self.results
    def set_results(self, results):
        self.results = results
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            super(List, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='List', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('List')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'List':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='List')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='List', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='List'):
        super(List, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='List')
        if self.all is not None and 'all' not in already_processed:
            already_processed.add('all')
            outfile.write(' all="%s"' % self.gds_format_integer(self.all, input_name='all'))
        if self.results is not None and 'results' not in already_processed:
            already_processed.add('results')
            outfile.write(' results="%s"' % self.gds_format_integer(self.results, input_name='results'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='List', fromsubclass_=False, pretty_print=True):
        super(List, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('all', node)
        if value is not None and 'all' not in already_processed:
            already_processed.add('all')
            self.all = self.gds_parse_integer(value, node, 'all')
            self.validate_UInt32(self.all)    # validate type UInt32
        value = find_attr_value_('results', node)
        if value is not None and 'results' not in already_processed:
            already_processed.add('results')
            self.results = self.gds_parse_integer(value, node, 'results')
            self.validate_UInt32(self.results)    # validate type UInt32
        super(List, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(List, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class List


class IdentifiedObject(Resource):
    """IdentifiedObject -- This is a root class to provide common naming attributes for all classes needing naming attributes
    mRID -- The global identifier of the object.
    description -- The description is a human readable text describing or naming the object.
    version -- Contains the version number of the object. See the type definition for details.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, mRID=None, description=None, version=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IdentifiedObject"), self).__init__( **kwargs_)
        self.mRID = mRID
        self.mRID_nsprefix_ = None
        self.description = description
        self.validate_String32(self.description)
        self.description_nsprefix_ = None
        self.version = version
        self.version_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IdentifiedObject)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IdentifiedObject.subclass:
            return IdentifiedObject.subclass(*args_, **kwargs_)
        else:
            return IdentifiedObject(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mRID(self):
        return self.mRID
    def set_mRID(self, mRID):
        self.mRID = mRID
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(IdentifiedObject, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IdentifiedObject', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IdentifiedObject')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IdentifiedObject':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiedObject')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IdentifiedObject', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IdentifiedObject'):
        super(IdentifiedObject, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IdentifiedObject')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IdentifiedObject', fromsubclass_=False, pretty_print=True):
        super(IdentifiedObject, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            namespaceprefix_ = self.mRID_nsprefix_ + ':' if (UseCapturedNS_ and self.mRID_nsprefix_) else ''
            self.mRID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            self.version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='version', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IdentifiedObject, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.description)
        elif nodeName_ == 'version':
            obj_ = VersionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(IdentifiedObject, self)._buildChildren(child_, node, nodeName_, True)
# end class IdentifiedObject


class UsagePointListLink(ListLink):
    """UsagePointListLink -- SHALL contain a Link to a List of UsagePoint instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UsagePointListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UsagePointListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UsagePointListLink.subclass:
            return UsagePointListLink.subclass(*args_, **kwargs_)
        else:
            return UsagePointListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(UsagePointListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UsagePointListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UsagePointListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UsagePointListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePointListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UsagePointListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UsagePointListLink'):
        super(UsagePointListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePointListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UsagePointListLink', fromsubclass_=False, pretty_print=True):
        super(UsagePointListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(UsagePointListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(UsagePointListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class UsagePointListLink


class UsagePointLink(Link):
    """UsagePointLink -- SHALL contain a Link to an instance of UsagePoint.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UsagePointLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UsagePointLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UsagePointLink.subclass:
            return UsagePointLink.subclass(*args_, **kwargs_)
        else:
            return UsagePointLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(UsagePointLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UsagePointLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UsagePointLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UsagePointLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePointLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UsagePointLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UsagePointLink'):
        super(UsagePointLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePointLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='UsagePointLink', fromsubclass_=False, pretty_print=True):
        super(UsagePointLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(UsagePointLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(UsagePointLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class UsagePointLink


class TimeTariffIntervalListLink(ListLink):
    """TimeTariffIntervalListLink -- SHALL contain a Link to a List of TimeTariffInterval instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TimeTariffIntervalListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeTariffIntervalListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeTariffIntervalListLink.subclass:
            return TimeTariffIntervalListLink.subclass(*args_, **kwargs_)
        else:
            return TimeTariffIntervalListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TimeTariffIntervalListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeTariffIntervalListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeTariffIntervalListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeTariffIntervalListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeTariffIntervalListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeTariffIntervalListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeTariffIntervalListLink'):
        super(TimeTariffIntervalListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeTariffIntervalListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeTariffIntervalListLink', fromsubclass_=False, pretty_print=True):
        super(TimeTariffIntervalListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TimeTariffIntervalListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TimeTariffIntervalListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TimeTariffIntervalListLink


class TimeLink(Link):
    """TimeLink -- SHALL contain a Link to an instance of Time.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TimeLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeLink.subclass:
            return TimeLink.subclass(*args_, **kwargs_)
        else:
            return TimeLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TimeLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeLink'):
        super(TimeLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TimeLink', fromsubclass_=False, pretty_print=True):
        super(TimeLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TimeLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TimeLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TimeLink


class TextMessageListLink(ListLink):
    """TextMessageListLink -- SHALL contain a Link to a List of TextMessage instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TextMessageListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextMessageListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextMessageListLink.subclass:
            return TextMessageListLink.subclass(*args_, **kwargs_)
        else:
            return TextMessageListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TextMessageListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextMessageListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextMessageListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextMessageListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextMessageListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextMessageListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextMessageListLink'):
        super(TextMessageListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextMessageListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextMessageListLink', fromsubclass_=False, pretty_print=True):
        super(TextMessageListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TextMessageListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TextMessageListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TextMessageListLink


class TariffProfileListLink(ListLink):
    """TariffProfileListLink -- SHALL contain a Link to a List of TariffProfile instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TariffProfileListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TariffProfileListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TariffProfileListLink.subclass:
            return TariffProfileListLink.subclass(*args_, **kwargs_)
        else:
            return TariffProfileListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TariffProfileListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TariffProfileListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TariffProfileListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TariffProfileListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TariffProfileListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TariffProfileListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TariffProfileListLink'):
        super(TariffProfileListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TariffProfileListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TariffProfileListLink', fromsubclass_=False, pretty_print=True):
        super(TariffProfileListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TariffProfileListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TariffProfileListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TariffProfileListLink


class TariffProfileLink(Link):
    """TariffProfileLink -- SHALL contain a Link to an instance of TariffProfile.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TariffProfileLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TariffProfileLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TariffProfileLink.subclass:
            return TariffProfileLink.subclass(*args_, **kwargs_)
        else:
            return TariffProfileLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TariffProfileLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TariffProfileLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TariffProfileLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TariffProfileLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TariffProfileLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TariffProfileLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TariffProfileLink'):
        super(TariffProfileLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TariffProfileLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TariffProfileLink', fromsubclass_=False, pretty_print=True):
        super(TariffProfileLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TariffProfileLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TariffProfileLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TariffProfileLink


class TargetReadingListLink(ListLink):
    """TargetReadingListLink -- SHALL contain a Link to a List of TargetReading instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TargetReadingListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetReadingListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetReadingListLink.subclass:
            return TargetReadingListLink.subclass(*args_, **kwargs_)
        else:
            return TargetReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TargetReadingListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TargetReadingListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetReadingListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TargetReadingListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetReadingListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TargetReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TargetReadingListLink'):
        super(TargetReadingListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetReadingListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TargetReadingListLink', fromsubclass_=False, pretty_print=True):
        super(TargetReadingListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TargetReadingListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TargetReadingListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TargetReadingListLink


class SupportedLocaleListLink(ListLink):
    """SupportedLocaleListLink -- SHALL contain a Link to a List of SupportedLocale instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SupportedLocaleListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportedLocaleListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportedLocaleListLink.subclass:
            return SupportedLocaleListLink.subclass(*args_, **kwargs_)
        else:
            return SupportedLocaleListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(SupportedLocaleListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SupportedLocaleListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportedLocaleListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupportedLocaleListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportedLocaleListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupportedLocaleListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupportedLocaleListLink'):
        super(SupportedLocaleListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportedLocaleListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SupportedLocaleListLink', fromsubclass_=False, pretty_print=True):
        super(SupportedLocaleListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SupportedLocaleListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SupportedLocaleListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SupportedLocaleListLink


class SupplyInterruptionOverrideListLink(ListLink):
    """SupplyInterruptionOverrideListLink -- SHALL contain a Link to a List of SupplyInterruptionOverride instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SupplyInterruptionOverrideListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplyInterruptionOverrideListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplyInterruptionOverrideListLink.subclass:
            return SupplyInterruptionOverrideListLink.subclass(*args_, **kwargs_)
        else:
            return SupplyInterruptionOverrideListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(SupplyInterruptionOverrideListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SupplyInterruptionOverrideListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupplyInterruptionOverrideListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupplyInterruptionOverrideListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplyInterruptionOverrideListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupplyInterruptionOverrideListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupplyInterruptionOverrideListLink'):
        super(SupplyInterruptionOverrideListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplyInterruptionOverrideListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SupplyInterruptionOverrideListLink', fromsubclass_=False, pretty_print=True):
        super(SupplyInterruptionOverrideListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SupplyInterruptionOverrideListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SupplyInterruptionOverrideListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SupplyInterruptionOverrideListLink


class SubscriptionListLink(ListLink):
    """SubscriptionListLink -- SHALL contain a Link to a List of Subscription instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubscriptionListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubscriptionListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubscriptionListLink.subclass:
            return SubscriptionListLink.subclass(*args_, **kwargs_)
        else:
            return SubscriptionListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(SubscriptionListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubscriptionListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubscriptionListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubscriptionListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscriptionListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubscriptionListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubscriptionListLink'):
        super(SubscriptionListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscriptionListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SubscriptionListLink', fromsubclass_=False, pretty_print=True):
        super(SubscriptionListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SubscriptionListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SubscriptionListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SubscriptionListLink


class ServiceSupplierLink(Link):
    """ServiceSupplierLink -- SHALL contain a Link to an instance of ServiceSupplier.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ServiceSupplierLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceSupplierLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceSupplierLink.subclass:
            return ServiceSupplierLink.subclass(*args_, **kwargs_)
        else:
            return ServiceSupplierLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ServiceSupplierLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceSupplierLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceSupplierLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceSupplierLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceSupplierLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceSupplierLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceSupplierLink'):
        super(ServiceSupplierLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceSupplierLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ServiceSupplierLink', fromsubclass_=False, pretty_print=True):
        super(ServiceSupplierLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ServiceSupplierLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ServiceSupplierLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ServiceSupplierLink


class SelfDeviceLink(Link):
    """SelfDeviceLink -- SHALL contain a Link to an instance of SelfDevice.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SelfDeviceLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelfDeviceLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelfDeviceLink.subclass:
            return SelfDeviceLink.subclass(*args_, **kwargs_)
        else:
            return SelfDeviceLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(SelfDeviceLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SelfDeviceLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelfDeviceLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SelfDeviceLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelfDeviceLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SelfDeviceLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelfDeviceLink'):
        super(SelfDeviceLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelfDeviceLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SelfDeviceLink', fromsubclass_=False, pretty_print=True):
        super(SelfDeviceLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SelfDeviceLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SelfDeviceLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SelfDeviceLink


class RPLSourceRoutesListLink(ListLink):
    """RPLSourceRoutesListLink -- SHALL contain a Link to a List of RPLSourceRoutes instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RPLSourceRoutesListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RPLSourceRoutesListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RPLSourceRoutesListLink.subclass:
            return RPLSourceRoutesListLink.subclass(*args_, **kwargs_)
        else:
            return RPLSourceRoutesListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(RPLSourceRoutesListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RPLSourceRoutesListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RPLSourceRoutesListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RPLSourceRoutesListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLSourceRoutesListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RPLSourceRoutesListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RPLSourceRoutesListLink'):
        super(RPLSourceRoutesListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLSourceRoutesListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RPLSourceRoutesListLink', fromsubclass_=False, pretty_print=True):
        super(RPLSourceRoutesListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RPLSourceRoutesListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RPLSourceRoutesListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RPLSourceRoutesListLink


class RPLInstanceListLink(ListLink):
    """RPLInstanceListLink -- SHALL contain a Link to a List of RPLInterface instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RPLInstanceListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RPLInstanceListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RPLInstanceListLink.subclass:
            return RPLInstanceListLink.subclass(*args_, **kwargs_)
        else:
            return RPLInstanceListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(RPLInstanceListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RPLInstanceListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RPLInstanceListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RPLInstanceListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLInstanceListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RPLInstanceListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RPLInstanceListLink'):
        super(RPLInstanceListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLInstanceListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RPLInstanceListLink', fromsubclass_=False, pretty_print=True):
        super(RPLInstanceListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RPLInstanceListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RPLInstanceListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RPLInstanceListLink


class ResponseSetListLink(ListLink):
    """ResponseSetListLink -- SHALL contain a Link to a List of ResponseSet instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ResponseSetListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseSetListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseSetListLink.subclass:
            return ResponseSetListLink.subclass(*args_, **kwargs_)
        else:
            return ResponseSetListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ResponseSetListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResponseSetListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseSetListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResponseSetListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseSetListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResponseSetListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResponseSetListLink'):
        super(ResponseSetListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseSetListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResponseSetListLink', fromsubclass_=False, pretty_print=True):
        super(ResponseSetListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ResponseSetListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ResponseSetListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ResponseSetListLink


class ResponseListLink(ListLink):
    """ResponseListLink -- SHALL contain a Link to a List of Response instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ResponseListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseListLink.subclass:
            return ResponseListLink.subclass(*args_, **kwargs_)
        else:
            return ResponseListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ResponseListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResponseListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResponseListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResponseListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResponseListLink'):
        super(ResponseListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ResponseListLink', fromsubclass_=False, pretty_print=True):
        super(ResponseListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ResponseListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ResponseListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ResponseListLink


class RegistrationLink(Link):
    """RegistrationLink -- SHALL contain a Link to an instance of Registration.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RegistrationLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RegistrationLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RegistrationLink.subclass:
            return RegistrationLink.subclass(*args_, **kwargs_)
        else:
            return RegistrationLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(RegistrationLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RegistrationLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RegistrationLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RegistrationLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RegistrationLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RegistrationLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RegistrationLink'):
        super(RegistrationLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RegistrationLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RegistrationLink', fromsubclass_=False, pretty_print=True):
        super(RegistrationLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RegistrationLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RegistrationLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RegistrationLink


class ReadingTypeLink(Link):
    """ReadingTypeLink -- SHALL contain a Link to an instance of ReadingType.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingTypeLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingTypeLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingTypeLink.subclass:
            return ReadingTypeLink.subclass(*args_, **kwargs_)
        else:
            return ReadingTypeLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ReadingTypeLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadingTypeLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingTypeLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingTypeLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingTypeLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingTypeLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingTypeLink'):
        super(ReadingTypeLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingTypeLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadingTypeLink', fromsubclass_=False, pretty_print=True):
        super(ReadingTypeLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingTypeLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ReadingTypeLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ReadingTypeLink


class ReadingSetListLink(ListLink):
    """ReadingSetListLink -- SHALL contain a Link to a List of ReadingSet instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingSetListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingSetListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingSetListLink.subclass:
            return ReadingSetListLink.subclass(*args_, **kwargs_)
        else:
            return ReadingSetListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ReadingSetListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadingSetListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingSetListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingSetListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingSetListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingSetListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingSetListLink'):
        super(ReadingSetListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingSetListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadingSetListLink', fromsubclass_=False, pretty_print=True):
        super(ReadingSetListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingSetListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ReadingSetListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ReadingSetListLink


class ReadingListLink(ListLink):
    """ReadingListLink -- SHALL contain a Link to a List of Reading instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingListLink.subclass:
            return ReadingListLink.subclass(*args_, **kwargs_)
        else:
            return ReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ReadingListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadingListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingListLink'):
        super(ReadingListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadingListLink', fromsubclass_=False, pretty_print=True):
        super(ReadingListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ReadingListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ReadingListLink


class ReadingLink(Link):
    """ReadingLink -- A Link to a Reading.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingLink.subclass:
            return ReadingLink.subclass(*args_, **kwargs_)
        else:
            return ReadingLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ReadingLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadingLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingLink'):
        super(ReadingLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ReadingLink', fromsubclass_=False, pretty_print=True):
        super(ReadingLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ReadingLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ReadingLink


class RateComponentListLink(ListLink):
    """RateComponentListLink -- SHALL contain a Link to a List of RateComponent instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RateComponentListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateComponentListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateComponentListLink.subclass:
            return RateComponentListLink.subclass(*args_, **kwargs_)
        else:
            return RateComponentListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(RateComponentListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RateComponentListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RateComponentListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RateComponentListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateComponentListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RateComponentListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RateComponentListLink'):
        super(RateComponentListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateComponentListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RateComponentListLink', fromsubclass_=False, pretty_print=True):
        super(RateComponentListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RateComponentListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RateComponentListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RateComponentListLink


class RateComponentLink(Link):
    """RateComponentLink -- SHALL contain a Link to an instance of RateComponent.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RateComponentLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateComponentLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateComponentLink.subclass:
            return RateComponentLink.subclass(*args_, **kwargs_)
        else:
            return RateComponentLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(RateComponentLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RateComponentLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RateComponentLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RateComponentLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateComponentLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RateComponentLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RateComponentLink'):
        super(RateComponentLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateComponentLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='RateComponentLink', fromsubclass_=False, pretty_print=True):
        super(RateComponentLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RateComponentLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(RateComponentLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class RateComponentLink


class ProjectionReadingListLink(ListLink):
    """ProjectionReadingListLink -- SHALL contain a Link to a List of ProjectionReading instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ProjectionReadingListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectionReadingListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectionReadingListLink.subclass:
            return ProjectionReadingListLink.subclass(*args_, **kwargs_)
        else:
            return ProjectionReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ProjectionReadingListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProjectionReadingListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProjectionReadingListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProjectionReadingListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectionReadingListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProjectionReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProjectionReadingListLink'):
        super(ProjectionReadingListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectionReadingListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProjectionReadingListLink', fromsubclass_=False, pretty_print=True):
        super(ProjectionReadingListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ProjectionReadingListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ProjectionReadingListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ProjectionReadingListLink


class PriceResponseCfgListLink(ListLink):
    """PriceResponseCfgListLink -- SHALL contain a Link to a List of PriceResponseCfg instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PriceResponseCfgListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PriceResponseCfgListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PriceResponseCfgListLink.subclass:
            return PriceResponseCfgListLink.subclass(*args_, **kwargs_)
        else:
            return PriceResponseCfgListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(PriceResponseCfgListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PriceResponseCfgListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PriceResponseCfgListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PriceResponseCfgListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PriceResponseCfgListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PriceResponseCfgListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PriceResponseCfgListLink'):
        super(PriceResponseCfgListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PriceResponseCfgListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PriceResponseCfgListLink', fromsubclass_=False, pretty_print=True):
        super(PriceResponseCfgListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PriceResponseCfgListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PriceResponseCfgListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PriceResponseCfgListLink


class PrepayOperationStatusLink(Link):
    """PrepayOperationStatusLink -- SHALL contain a Link to an instance of PrepayOperationStatus.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PrepayOperationStatusLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrepayOperationStatusLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrepayOperationStatusLink.subclass:
            return PrepayOperationStatusLink.subclass(*args_, **kwargs_)
        else:
            return PrepayOperationStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(PrepayOperationStatusLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrepayOperationStatusLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrepayOperationStatusLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrepayOperationStatusLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepayOperationStatusLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrepayOperationStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrepayOperationStatusLink'):
        super(PrepayOperationStatusLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepayOperationStatusLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrepayOperationStatusLink', fromsubclass_=False, pretty_print=True):
        super(PrepayOperationStatusLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PrepayOperationStatusLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PrepayOperationStatusLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PrepayOperationStatusLink


class PrepaymentListLink(ListLink):
    """PrepaymentListLink -- SHALL contain a Link to a List of Prepayment instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PrepaymentListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrepaymentListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrepaymentListLink.subclass:
            return PrepaymentListLink.subclass(*args_, **kwargs_)
        else:
            return PrepaymentListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(PrepaymentListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrepaymentListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrepaymentListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrepaymentListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepaymentListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrepaymentListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrepaymentListLink'):
        super(PrepaymentListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepaymentListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrepaymentListLink', fromsubclass_=False, pretty_print=True):
        super(PrepaymentListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PrepaymentListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PrepaymentListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PrepaymentListLink


class PrepaymentLink(Link):
    """PrepaymentLink -- SHALL contain a Link to an instance of Prepayment.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PrepaymentLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrepaymentLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrepaymentLink.subclass:
            return PrepaymentLink.subclass(*args_, **kwargs_)
        else:
            return PrepaymentLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(PrepaymentLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrepaymentLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrepaymentLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrepaymentLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepaymentLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrepaymentLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrepaymentLink'):
        super(PrepaymentLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepaymentLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PrepaymentLink', fromsubclass_=False, pretty_print=True):
        super(PrepaymentLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PrepaymentLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PrepaymentLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PrepaymentLink


class PowerStatusLink(Link):
    """PowerStatusLink -- SHALL contain a Link to an instance of PowerStatus.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PowerStatusLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerStatusLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerStatusLink.subclass:
            return PowerStatusLink.subclass(*args_, **kwargs_)
        else:
            return PowerStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(PowerStatusLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PowerStatusLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PowerStatusLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PowerStatusLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerStatusLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PowerStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PowerStatusLink'):
        super(PowerStatusLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerStatusLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PowerStatusLink', fromsubclass_=False, pretty_print=True):
        super(PowerStatusLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PowerStatusLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PowerStatusLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PowerStatusLink


class NotificationListLink(ListLink):
    """NotificationListLink -- SHALL contain a Link to a List of Notification instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("NotificationListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotificationListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotificationListLink.subclass:
            return NotificationListLink.subclass(*args_, **kwargs_)
        else:
            return NotificationListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(NotificationListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NotificationListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NotificationListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NotificationListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NotificationListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NotificationListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NotificationListLink'):
        super(NotificationListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NotificationListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NotificationListLink', fromsubclass_=False, pretty_print=True):
        super(NotificationListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(NotificationListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NotificationListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class NotificationListLink


class NeighborListLink(ListLink):
    """NeighborListLink -- SHALL contain a Link to a List of Neighbor instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("NeighborListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeighborListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeighborListLink.subclass:
            return NeighborListLink.subclass(*args_, **kwargs_)
        else:
            return NeighborListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(NeighborListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NeighborListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeighborListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NeighborListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeighborListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NeighborListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NeighborListLink'):
        super(NeighborListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeighborListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='NeighborListLink', fromsubclass_=False, pretty_print=True):
        super(NeighborListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(NeighborListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(NeighborListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class NeighborListLink


class MirrorUsagePointListLink(ListLink):
    """MirrorUsagePointListLink -- SHALL contain a Link to a List of MirrorUsagePoint instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MirrorUsagePointListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MirrorUsagePointListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MirrorUsagePointListLink.subclass:
            return MirrorUsagePointListLink.subclass(*args_, **kwargs_)
        else:
            return MirrorUsagePointListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(MirrorUsagePointListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MirrorUsagePointListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MirrorUsagePointListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MirrorUsagePointListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorUsagePointListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MirrorUsagePointListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MirrorUsagePointListLink'):
        super(MirrorUsagePointListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorUsagePointListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MirrorUsagePointListLink', fromsubclass_=False, pretty_print=True):
        super(MirrorUsagePointListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MirrorUsagePointListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(MirrorUsagePointListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class MirrorUsagePointListLink


class MeterReadingListLink(ListLink):
    """MeterReadingListLink -- SHALL contain a Link to a List of MeterReading instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MeterReadingListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeterReadingListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeterReadingListLink.subclass:
            return MeterReadingListLink.subclass(*args_, **kwargs_)
        else:
            return MeterReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(MeterReadingListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeterReadingListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeterReadingListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MeterReadingListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReadingListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeterReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeterReadingListLink'):
        super(MeterReadingListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReadingListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeterReadingListLink', fromsubclass_=False, pretty_print=True):
        super(MeterReadingListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MeterReadingListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(MeterReadingListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class MeterReadingListLink


class MeterReadingLink(Link):
    """MeterReadingLink -- SHALL contain a Link to an instance of MeterReading.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MeterReadingLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeterReadingLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeterReadingLink.subclass:
            return MeterReadingLink.subclass(*args_, **kwargs_)
        else:
            return MeterReadingLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(MeterReadingLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeterReadingLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeterReadingLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MeterReadingLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReadingLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeterReadingLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeterReadingLink'):
        super(MeterReadingLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReadingLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeterReadingLink', fromsubclass_=False, pretty_print=True):
        super(MeterReadingLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MeterReadingLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(MeterReadingLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class MeterReadingLink


class MessagingProgramListLink(ListLink):
    """MessagingProgramListLink -- SHALL contain a Link to a List of MessagingProgram instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MessagingProgramListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessagingProgramListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessagingProgramListLink.subclass:
            return MessagingProgramListLink.subclass(*args_, **kwargs_)
        else:
            return MessagingProgramListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(MessagingProgramListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MessagingProgramListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessagingProgramListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MessagingProgramListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessagingProgramListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MessagingProgramListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessagingProgramListLink'):
        super(MessagingProgramListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessagingProgramListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MessagingProgramListLink', fromsubclass_=False, pretty_print=True):
        super(MessagingProgramListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MessagingProgramListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(MessagingProgramListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class MessagingProgramListLink


class LogEventListLink(ListLink):
    """LogEventListLink -- SHALL contain a Link to a List of LogEvent instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogEventListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogEventListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogEventListLink.subclass:
            return LogEventListLink.subclass(*args_, **kwargs_)
        else:
            return LogEventListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(LogEventListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LogEventListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LogEventListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LogEventListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LogEventListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LogEventListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LogEventListLink'):
        super(LogEventListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LogEventListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LogEventListLink', fromsubclass_=False, pretty_print=True):
        super(LogEventListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogEventListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LogEventListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class LogEventListLink


class LoadShedAvailabilityListLink(ListLink):
    """LoadShedAvailabilityListLink -- SHALL contain a Link to a List of LoadShedAvailability instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LoadShedAvailabilityListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LoadShedAvailabilityListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LoadShedAvailabilityListLink.subclass:
            return LoadShedAvailabilityListLink.subclass(*args_, **kwargs_)
        else:
            return LoadShedAvailabilityListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(LoadShedAvailabilityListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LoadShedAvailabilityListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LoadShedAvailabilityListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LoadShedAvailabilityListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LoadShedAvailabilityListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LoadShedAvailabilityListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LoadShedAvailabilityListLink'):
        super(LoadShedAvailabilityListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LoadShedAvailabilityListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LoadShedAvailabilityListLink', fromsubclass_=False, pretty_print=True):
        super(LoadShedAvailabilityListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LoadShedAvailabilityListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LoadShedAvailabilityListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class LoadShedAvailabilityListLink


class LLInterfaceListLink(ListLink):
    """LLInterfaceListLink -- SHALL contain a Link to a List of LLInterface instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LLInterfaceListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LLInterfaceListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LLInterfaceListLink.subclass:
            return LLInterfaceListLink.subclass(*args_, **kwargs_)
        else:
            return LLInterfaceListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(LLInterfaceListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LLInterfaceListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LLInterfaceListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LLInterfaceListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LLInterfaceListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LLInterfaceListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LLInterfaceListLink'):
        super(LLInterfaceListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LLInterfaceListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='LLInterfaceListLink', fromsubclass_=False, pretty_print=True):
        super(LLInterfaceListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LLInterfaceListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(LLInterfaceListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class LLInterfaceListLink


class IPInterfaceListLink(ListLink):
    """IPInterfaceListLink -- SHALL contain a Link to a List of IPInterface instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IPInterfaceListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPInterfaceListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPInterfaceListLink.subclass:
            return IPInterfaceListLink.subclass(*args_, **kwargs_)
        else:
            return IPInterfaceListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(IPInterfaceListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPInterfaceListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPInterfaceListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IPInterfaceListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPInterfaceListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPInterfaceListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPInterfaceListLink'):
        super(IPInterfaceListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPInterfaceListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPInterfaceListLink', fromsubclass_=False, pretty_print=True):
        super(IPInterfaceListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IPInterfaceListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IPInterfaceListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IPInterfaceListLink


class IPAddrListLink(ListLink):
    """IPAddrListLink -- SHALL contain a Link to a List of IPAddr instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IPAddrListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPAddrListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPAddrListLink.subclass:
            return IPAddrListLink.subclass(*args_, **kwargs_)
        else:
            return IPAddrListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(IPAddrListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPAddrListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPAddrListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IPAddrListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPAddrListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPAddrListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPAddrListLink'):
        super(IPAddrListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPAddrListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='IPAddrListLink', fromsubclass_=False, pretty_print=True):
        super(IPAddrListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IPAddrListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(IPAddrListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class IPAddrListLink


class HistoricalReadingListLink(ListLink):
    """HistoricalReadingListLink -- SHALL contain a Link to a List of HistoricalReading instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("HistoricalReadingListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HistoricalReadingListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HistoricalReadingListLink.subclass:
            return HistoricalReadingListLink.subclass(*args_, **kwargs_)
        else:
            return HistoricalReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(HistoricalReadingListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HistoricalReadingListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HistoricalReadingListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HistoricalReadingListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HistoricalReadingListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HistoricalReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HistoricalReadingListLink'):
        super(HistoricalReadingListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HistoricalReadingListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HistoricalReadingListLink', fromsubclass_=False, pretty_print=True):
        super(HistoricalReadingListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(HistoricalReadingListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(HistoricalReadingListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class HistoricalReadingListLink


class FunctionSetAssignmentsListLink(ListLink):
    """FunctionSetAssignmentsListLink -- SHALL contain a Link to a List of FunctionSetAssignments instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FunctionSetAssignmentsListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FunctionSetAssignmentsListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FunctionSetAssignmentsListLink.subclass:
            return FunctionSetAssignmentsListLink.subclass(*args_, **kwargs_)
        else:
            return FunctionSetAssignmentsListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(FunctionSetAssignmentsListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FunctionSetAssignmentsListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FunctionSetAssignmentsListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FunctionSetAssignmentsListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FunctionSetAssignmentsListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FunctionSetAssignmentsListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FunctionSetAssignmentsListLink'):
        super(FunctionSetAssignmentsListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FunctionSetAssignmentsListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FunctionSetAssignmentsListLink', fromsubclass_=False, pretty_print=True):
        super(FunctionSetAssignmentsListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FunctionSetAssignmentsListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FunctionSetAssignmentsListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class FunctionSetAssignmentsListLink


class FlowReservationResponseListLink(ListLink):
    """FlowReservationResponseListLink -- SHALL contain a Link to a List of FlowReservationResponse instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FlowReservationResponseListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowReservationResponseListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowReservationResponseListLink.subclass:
            return FlowReservationResponseListLink.subclass(*args_, **kwargs_)
        else:
            return FlowReservationResponseListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(FlowReservationResponseListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlowReservationResponseListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowReservationResponseListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlowReservationResponseListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationResponseListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlowReservationResponseListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowReservationResponseListLink'):
        super(FlowReservationResponseListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationResponseListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlowReservationResponseListLink', fromsubclass_=False, pretty_print=True):
        super(FlowReservationResponseListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationResponseListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FlowReservationResponseListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class FlowReservationResponseListLink


class FlowReservationRequestListLink(ListLink):
    """FlowReservationRequestListLink -- SHALL contain a Link to a List of FlowReservationRequest instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FlowReservationRequestListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowReservationRequestListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowReservationRequestListLink.subclass:
            return FlowReservationRequestListLink.subclass(*args_, **kwargs_)
        else:
            return FlowReservationRequestListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(FlowReservationRequestListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlowReservationRequestListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowReservationRequestListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlowReservationRequestListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationRequestListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlowReservationRequestListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowReservationRequestListLink'):
        super(FlowReservationRequestListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationRequestListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlowReservationRequestListLink', fromsubclass_=False, pretty_print=True):
        super(FlowReservationRequestListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationRequestListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FlowReservationRequestListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class FlowReservationRequestListLink


class FileStatusLink(Link):
    """FileStatusLink -- SHALL contain a Link to an instance of FileStatus.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FileStatusLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FileStatusLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FileStatusLink.subclass:
            return FileStatusLink.subclass(*args_, **kwargs_)
        else:
            return FileStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(FileStatusLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FileStatusLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FileStatusLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FileStatusLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileStatusLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FileStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FileStatusLink'):
        super(FileStatusLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileStatusLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FileStatusLink', fromsubclass_=False, pretty_print=True):
        super(FileStatusLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FileStatusLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FileStatusLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class FileStatusLink


class FileListLink(ListLink):
    """FileListLink -- SHALL contain a Link to a List of File instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FileListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FileListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FileListLink.subclass:
            return FileListLink.subclass(*args_, **kwargs_)
        else:
            return FileListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(FileListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FileListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FileListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FileListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FileListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FileListLink'):
        super(FileListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FileListLink', fromsubclass_=False, pretty_print=True):
        super(FileListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FileListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FileListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class FileListLink


class FileLink(Link):
    """FileLink -- This element MUST be set to the URI of the most recent File being loaded/activated by the LD. In the case of file status 0, this element MUST be omitted.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FileLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FileLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FileLink.subclass:
            return FileLink.subclass(*args_, **kwargs_)
        else:
            return FileLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(FileLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FileLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FileLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FileLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FileLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FileLink'):
        super(FileLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FileLink', fromsubclass_=False, pretty_print=True):
        super(FileLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FileLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FileLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class FileLink


class EndDeviceListLink(ListLink):
    """EndDeviceListLink -- SHALL contain a Link to a List of EndDevice instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EndDeviceListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndDeviceListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndDeviceListLink.subclass:
            return EndDeviceListLink.subclass(*args_, **kwargs_)
        else:
            return EndDeviceListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(EndDeviceListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndDeviceListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndDeviceListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndDeviceListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndDeviceListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndDeviceListLink'):
        super(EndDeviceListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndDeviceListLink', fromsubclass_=False, pretty_print=True):
        super(EndDeviceListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EndDeviceListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class EndDeviceListLink


class EndDeviceLink(Link):
    """EndDeviceLink -- SHALL contain a Link to an instance of EndDevice.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EndDeviceLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndDeviceLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndDeviceLink.subclass:
            return EndDeviceLink.subclass(*args_, **kwargs_)
        else:
            return EndDeviceLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(EndDeviceLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndDeviceLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndDeviceLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndDeviceLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndDeviceLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndDeviceLink'):
        super(EndDeviceLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndDeviceLink', fromsubclass_=False, pretty_print=True):
        super(EndDeviceLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EndDeviceLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class EndDeviceLink


class EndDeviceControlListLink(ListLink):
    """EndDeviceControlListLink -- SHALL contain a Link to a List of EndDeviceControl instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EndDeviceControlListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndDeviceControlListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndDeviceControlListLink.subclass:
            return EndDeviceControlListLink.subclass(*args_, **kwargs_)
        else:
            return EndDeviceControlListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(EndDeviceControlListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndDeviceControlListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndDeviceControlListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndDeviceControlListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceControlListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndDeviceControlListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndDeviceControlListLink'):
        super(EndDeviceControlListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceControlListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='EndDeviceControlListLink', fromsubclass_=False, pretty_print=True):
        super(EndDeviceControlListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceControlListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(EndDeviceControlListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class EndDeviceControlListLink


class DeviceStatusLink(Link):
    """DeviceStatusLink -- SHALL contain a Link to an instance of DeviceStatus.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DeviceStatusLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeviceStatusLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeviceStatusLink.subclass:
            return DeviceStatusLink.subclass(*args_, **kwargs_)
        else:
            return DeviceStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DeviceStatusLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DeviceStatusLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeviceStatusLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeviceStatusLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceStatusLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeviceStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DeviceStatusLink'):
        super(DeviceStatusLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceStatusLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DeviceStatusLink', fromsubclass_=False, pretty_print=True):
        super(DeviceStatusLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DeviceStatusLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DeviceStatusLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DeviceStatusLink


class DeviceInformationLink(Link):
    """DeviceInformationLink -- SHALL contain a Link to an instance of DeviceInformation.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DeviceInformationLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeviceInformationLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeviceInformationLink.subclass:
            return DeviceInformationLink.subclass(*args_, **kwargs_)
        else:
            return DeviceInformationLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DeviceInformationLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DeviceInformationLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeviceInformationLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeviceInformationLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceInformationLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeviceInformationLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DeviceInformationLink'):
        super(DeviceInformationLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceInformationLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DeviceInformationLink', fromsubclass_=False, pretty_print=True):
        super(DeviceInformationLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DeviceInformationLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DeviceInformationLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DeviceInformationLink


class DeviceCapabilityLink(Link):
    """DeviceCapabilityLink -- SHALL contain a Link to an instance of DeviceCapability.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DeviceCapabilityLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeviceCapabilityLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeviceCapabilityLink.subclass:
            return DeviceCapabilityLink.subclass(*args_, **kwargs_)
        else:
            return DeviceCapabilityLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DeviceCapabilityLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DeviceCapabilityLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeviceCapabilityLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeviceCapabilityLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceCapabilityLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeviceCapabilityLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DeviceCapabilityLink'):
        super(DeviceCapabilityLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceCapabilityLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DeviceCapabilityLink', fromsubclass_=False, pretty_print=True):
        super(DeviceCapabilityLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DeviceCapabilityLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DeviceCapabilityLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DeviceCapabilityLink


class DERStatusLink(Link):
    """DERStatusLink -- SHALL contain a Link to an instance of DERStatus.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERStatusLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERStatusLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERStatusLink.subclass:
            return DERStatusLink.subclass(*args_, **kwargs_)
        else:
            return DERStatusLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERStatusLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERStatusLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERStatusLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERStatusLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERStatusLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERStatusLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERStatusLink'):
        super(DERStatusLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERStatusLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERStatusLink', fromsubclass_=False, pretty_print=True):
        super(DERStatusLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERStatusLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERStatusLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERStatusLink


class DERSettingsLink(Link):
    """DERSettingsLink -- SHALL contain a Link to an instance of DERSettings.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERSettingsLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERSettingsLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERSettingsLink.subclass:
            return DERSettingsLink.subclass(*args_, **kwargs_)
        else:
            return DERSettingsLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERSettingsLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERSettingsLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERSettingsLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERSettingsLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERSettingsLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERSettingsLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERSettingsLink'):
        super(DERSettingsLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERSettingsLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERSettingsLink', fromsubclass_=False, pretty_print=True):
        super(DERSettingsLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERSettingsLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERSettingsLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERSettingsLink


class DERProgramListLink(ListLink):
    """DERProgramListLink -- SHALL contain a Link to a List of DERProgram instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERProgramListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERProgramListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERProgramListLink.subclass:
            return DERProgramListLink.subclass(*args_, **kwargs_)
        else:
            return DERProgramListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERProgramListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERProgramListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERProgramListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERProgramListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERProgramListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERProgramListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERProgramListLink'):
        super(DERProgramListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERProgramListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERProgramListLink', fromsubclass_=False, pretty_print=True):
        super(DERProgramListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERProgramListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERProgramListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERProgramListLink


class DERProgramLink(Link):
    """DERProgramLink -- SHALL contain a Link to an instance of DERProgram.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERProgramLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERProgramLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERProgramLink.subclass:
            return DERProgramLink.subclass(*args_, **kwargs_)
        else:
            return DERProgramLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERProgramLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERProgramLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERProgramLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERProgramLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERProgramLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERProgramLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERProgramLink'):
        super(DERProgramLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERProgramLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERProgramLink', fromsubclass_=False, pretty_print=True):
        super(DERProgramLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERProgramLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERProgramLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERProgramLink


class DERListLink(ListLink):
    """DERListLink -- SHALL contain a Link to a List of DER instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERListLink.subclass:
            return DERListLink.subclass(*args_, **kwargs_)
        else:
            return DERListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERListLink'):
        super(DERListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERListLink', fromsubclass_=False, pretty_print=True):
        super(DERListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERListLink


class DERLink(Link):
    """DERLink -- SHALL contain a Link to an instance of DER.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERLink.subclass:
            return DERLink.subclass(*args_, **kwargs_)
        else:
            return DERLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERLink'):
        super(DERLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERLink', fromsubclass_=False, pretty_print=True):
        super(DERLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERLink


class DERCurveListLink(ListLink):
    """DERCurveListLink -- SHALL contain a Link to a List of DERCurve instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERCurveListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERCurveListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERCurveListLink.subclass:
            return DERCurveListLink.subclass(*args_, **kwargs_)
        else:
            return DERCurveListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERCurveListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERCurveListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERCurveListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERCurveListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCurveListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERCurveListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERCurveListLink'):
        super(DERCurveListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCurveListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERCurveListLink', fromsubclass_=False, pretty_print=True):
        super(DERCurveListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERCurveListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERCurveListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERCurveListLink


class DERCurveLink(Link):
    """DERCurveLink -- SHALL contain a Link to an instance of DERCurve.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERCurveLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERCurveLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERCurveLink.subclass:
            return DERCurveLink.subclass(*args_, **kwargs_)
        else:
            return DERCurveLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERCurveLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERCurveLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERCurveLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERCurveLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCurveLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERCurveLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERCurveLink'):
        super(DERCurveLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCurveLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERCurveLink', fromsubclass_=False, pretty_print=True):
        super(DERCurveLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERCurveLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERCurveLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERCurveLink


class DERControlListLink(ListLink):
    """DERControlListLink -- SHALL contain a Link to a List of DERControl instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERControlListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERControlListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERControlListLink.subclass:
            return DERControlListLink.subclass(*args_, **kwargs_)
        else:
            return DERControlListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERControlListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERControlListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERControlListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERControlListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControlListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERControlListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERControlListLink'):
        super(DERControlListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControlListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERControlListLink', fromsubclass_=False, pretty_print=True):
        super(DERControlListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERControlListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERControlListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERControlListLink


class DERCapabilityLink(Link):
    """DERCapabilityLink -- SHALL contain a Link to an instance of DERCapability.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERCapabilityLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERCapabilityLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERCapabilityLink.subclass:
            return DERCapabilityLink.subclass(*args_, **kwargs_)
        else:
            return DERCapabilityLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERCapabilityLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERCapabilityLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERCapabilityLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERCapabilityLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCapabilityLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERCapabilityLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERCapabilityLink'):
        super(DERCapabilityLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCapabilityLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERCapabilityLink', fromsubclass_=False, pretty_print=True):
        super(DERCapabilityLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERCapabilityLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERCapabilityLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERCapabilityLink


class DefaultDERControlLink(Link):
    """DefaultDERControlLink -- SHALL contain a Link to an instance of DefaultDERControl. This is the default mode of the DER which MAY be overridden by DERControl events.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DefaultDERControlLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DefaultDERControlLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DefaultDERControlLink.subclass:
            return DefaultDERControlLink.subclass(*args_, **kwargs_)
        else:
            return DefaultDERControlLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DefaultDERControlLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DefaultDERControlLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DefaultDERControlLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DefaultDERControlLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DefaultDERControlLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DefaultDERControlLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DefaultDERControlLink'):
        super(DefaultDERControlLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DefaultDERControlLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DefaultDERControlLink', fromsubclass_=False, pretty_print=True):
        super(DefaultDERControlLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DefaultDERControlLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DefaultDERControlLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DefaultDERControlLink


class DERAvailabilityLink(Link):
    """DERAvailabilityLink -- SHALL contain a Link to an instance of DERAvailability.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERAvailabilityLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERAvailabilityLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERAvailabilityLink.subclass:
            return DERAvailabilityLink.subclass(*args_, **kwargs_)
        else:
            return DERAvailabilityLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERAvailabilityLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERAvailabilityLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERAvailabilityLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERAvailabilityLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERAvailabilityLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERAvailabilityLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERAvailabilityLink'):
        super(DERAvailabilityLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERAvailabilityLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERAvailabilityLink', fromsubclass_=False, pretty_print=True):
        super(DERAvailabilityLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERAvailabilityLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERAvailabilityLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERAvailabilityLink


class DemandResponseProgramListLink(ListLink):
    """DemandResponseProgramListLink -- SHALL contain a Link to a List of DemandResponseProgram instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DemandResponseProgramListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandResponseProgramListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandResponseProgramListLink.subclass:
            return DemandResponseProgramListLink.subclass(*args_, **kwargs_)
        else:
            return DemandResponseProgramListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DemandResponseProgramListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DemandResponseProgramListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DemandResponseProgramListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DemandResponseProgramListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseProgramListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DemandResponseProgramListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DemandResponseProgramListLink'):
        super(DemandResponseProgramListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseProgramListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DemandResponseProgramListLink', fromsubclass_=False, pretty_print=True):
        super(DemandResponseProgramListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DemandResponseProgramListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DemandResponseProgramListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DemandResponseProgramListLink


class DemandResponseProgramLink(Link):
    """DemandResponseProgramLink -- SHALL contain a Link to an instance of DemandResponseProgram.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DemandResponseProgramLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandResponseProgramLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandResponseProgramLink.subclass:
            return DemandResponseProgramLink.subclass(*args_, **kwargs_)
        else:
            return DemandResponseProgramLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DemandResponseProgramLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DemandResponseProgramLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DemandResponseProgramLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DemandResponseProgramLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseProgramLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DemandResponseProgramLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DemandResponseProgramLink'):
        super(DemandResponseProgramLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseProgramLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DemandResponseProgramLink', fromsubclass_=False, pretty_print=True):
        super(DemandResponseProgramLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DemandResponseProgramLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DemandResponseProgramLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DemandResponseProgramLink


class CustomerAgreementListLink(ListLink):
    """CustomerAgreementListLink -- SHALL contain a Link to a List of CustomerAgreement instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CustomerAgreementListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerAgreementListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerAgreementListLink.subclass:
            return CustomerAgreementListLink.subclass(*args_, **kwargs_)
        else:
            return CustomerAgreementListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(CustomerAgreementListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomerAgreementListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerAgreementListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerAgreementListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAgreementListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerAgreementListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerAgreementListLink'):
        super(CustomerAgreementListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAgreementListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomerAgreementListLink', fromsubclass_=False, pretty_print=True):
        super(CustomerAgreementListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CustomerAgreementListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CustomerAgreementListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class CustomerAgreementListLink


class CustomerAccountListLink(ListLink):
    """CustomerAccountListLink -- SHALL contain a Link to a List of CustomerAccount instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CustomerAccountListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerAccountListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerAccountListLink.subclass:
            return CustomerAccountListLink.subclass(*args_, **kwargs_)
        else:
            return CustomerAccountListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(CustomerAccountListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomerAccountListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerAccountListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerAccountListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAccountListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerAccountListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerAccountListLink'):
        super(CustomerAccountListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAccountListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomerAccountListLink', fromsubclass_=False, pretty_print=True):
        super(CustomerAccountListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CustomerAccountListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CustomerAccountListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class CustomerAccountListLink


class CustomerAccountLink(Link):
    """CustomerAccountLink -- SHALL contain a Link to an instance of CustomerAccount.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CustomerAccountLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerAccountLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerAccountLink.subclass:
            return CustomerAccountLink.subclass(*args_, **kwargs_)
        else:
            return CustomerAccountLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(CustomerAccountLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomerAccountLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerAccountLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerAccountLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAccountLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerAccountLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerAccountLink'):
        super(CustomerAccountLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAccountLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CustomerAccountLink', fromsubclass_=False, pretty_print=True):
        super(CustomerAccountLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CustomerAccountLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CustomerAccountLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class CustomerAccountLink


class CreditRegisterListLink(ListLink):
    """CreditRegisterListLink -- SHALL contain a Link to a List of CreditRegister instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CreditRegisterListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRegisterListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRegisterListLink.subclass:
            return CreditRegisterListLink.subclass(*args_, **kwargs_)
        else:
            return CreditRegisterListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(CreditRegisterListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CreditRegisterListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditRegisterListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditRegisterListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditRegisterListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditRegisterListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditRegisterListLink'):
        super(CreditRegisterListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditRegisterListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CreditRegisterListLink', fromsubclass_=False, pretty_print=True):
        super(CreditRegisterListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CreditRegisterListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CreditRegisterListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class CreditRegisterListLink


class ConsumptionTariffIntervalListLink(ListLink):
    """ConsumptionTariffIntervalListLink -- SHALL contain a Link to a List of ConsumptionTariffInterval instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConsumptionTariffIntervalListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConsumptionTariffIntervalListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConsumptionTariffIntervalListLink.subclass:
            return ConsumptionTariffIntervalListLink.subclass(*args_, **kwargs_)
        else:
            return ConsumptionTariffIntervalListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ConsumptionTariffIntervalListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConsumptionTariffIntervalListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConsumptionTariffIntervalListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConsumptionTariffIntervalListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConsumptionTariffIntervalListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConsumptionTariffIntervalListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConsumptionTariffIntervalListLink'):
        super(ConsumptionTariffIntervalListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConsumptionTariffIntervalListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConsumptionTariffIntervalListLink', fromsubclass_=False, pretty_print=True):
        super(ConsumptionTariffIntervalListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConsumptionTariffIntervalListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ConsumptionTariffIntervalListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ConsumptionTariffIntervalListLink


class ConfigurationLink(Link):
    """ConfigurationLink -- SHALL contain a Link to an instance of Configuration.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConfigurationLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConfigurationLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConfigurationLink.subclass:
            return ConfigurationLink.subclass(*args_, **kwargs_)
        else:
            return ConfigurationLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ConfigurationLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConfigurationLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConfigurationLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConfigurationLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConfigurationLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConfigurationLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConfigurationLink'):
        super(ConfigurationLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConfigurationLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ConfigurationLink', fromsubclass_=False, pretty_print=True):
        super(ConfigurationLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConfigurationLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ConfigurationLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ConfigurationLink


class BillingReadingSetListLink(ListLink):
    """BillingReadingSetListLink -- SHALL contain a Link to a List of BillingReadingSet instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingReadingSetListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingReadingSetListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingReadingSetListLink.subclass:
            return BillingReadingSetListLink.subclass(*args_, **kwargs_)
        else:
            return BillingReadingSetListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(BillingReadingSetListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BillingReadingSetListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingReadingSetListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingReadingSetListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingSetListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingReadingSetListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingReadingSetListLink'):
        super(BillingReadingSetListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingSetListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BillingReadingSetListLink', fromsubclass_=False, pretty_print=True):
        super(BillingReadingSetListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingSetListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BillingReadingSetListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BillingReadingSetListLink


class BillingReadingListLink(ListLink):
    """BillingReadingListLink -- SHALL contain a Link to a List of BillingReading instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingReadingListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingReadingListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingReadingListLink.subclass:
            return BillingReadingListLink.subclass(*args_, **kwargs_)
        else:
            return BillingReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(BillingReadingListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BillingReadingListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingReadingListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingReadingListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingReadingListLink'):
        super(BillingReadingListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BillingReadingListLink', fromsubclass_=False, pretty_print=True):
        super(BillingReadingListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BillingReadingListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BillingReadingListLink


class BillingPeriodListLink(ListLink):
    """BillingPeriodListLink -- SHALL contain a Link to a List of BillingPeriod instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingPeriodListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingPeriodListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingPeriodListLink.subclass:
            return BillingPeriodListLink.subclass(*args_, **kwargs_)
        else:
            return BillingPeriodListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(BillingPeriodListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BillingPeriodListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingPeriodListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingPeriodListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingPeriodListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingPeriodListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingPeriodListLink'):
        super(BillingPeriodListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingPeriodListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='BillingPeriodListLink', fromsubclass_=False, pretty_print=True):
        super(BillingPeriodListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingPeriodListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(BillingPeriodListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class BillingPeriodListLink


class AssociatedUsagePointLink(Link):
    """AssociatedUsagePointLink -- SHALL contain a Link to an instance of UsagePoint.  If present, this is the submeter that monitors the DER output.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AssociatedUsagePointLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociatedUsagePointLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociatedUsagePointLink.subclass:
            return AssociatedUsagePointLink.subclass(*args_, **kwargs_)
        else:
            return AssociatedUsagePointLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(AssociatedUsagePointLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssociatedUsagePointLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociatedUsagePointLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AssociatedUsagePointLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssociatedUsagePointLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssociatedUsagePointLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssociatedUsagePointLink'):
        super(AssociatedUsagePointLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssociatedUsagePointLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssociatedUsagePointLink', fromsubclass_=False, pretty_print=True):
        super(AssociatedUsagePointLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AssociatedUsagePointLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AssociatedUsagePointLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class AssociatedUsagePointLink


class AssociatedDERProgramListLink(ListLink):
    """AssociatedDERProgramListLink -- SHALL contain a Link to a List of DERPrograms having the DERControl(s) for this DER.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AssociatedDERProgramListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AssociatedDERProgramListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AssociatedDERProgramListLink.subclass:
            return AssociatedDERProgramListLink.subclass(*args_, **kwargs_)
        else:
            return AssociatedDERProgramListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(AssociatedDERProgramListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssociatedDERProgramListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AssociatedDERProgramListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AssociatedDERProgramListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssociatedDERProgramListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AssociatedDERProgramListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AssociatedDERProgramListLink'):
        super(AssociatedDERProgramListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AssociatedDERProgramListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AssociatedDERProgramListLink', fromsubclass_=False, pretty_print=True):
        super(AssociatedDERProgramListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AssociatedDERProgramListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AssociatedDERProgramListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class AssociatedDERProgramListLink


class ActiveTimeTariffIntervalListLink(ListLink):
    """ActiveTimeTariffIntervalListLink -- SHALL contain a Link to a List of active TimeTariffInterval instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveTimeTariffIntervalListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveTimeTariffIntervalListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveTimeTariffIntervalListLink.subclass:
            return ActiveTimeTariffIntervalListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveTimeTariffIntervalListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveTimeTariffIntervalListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveTimeTariffIntervalListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveTimeTariffIntervalListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveTimeTariffIntervalListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveTimeTariffIntervalListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveTimeTariffIntervalListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveTimeTariffIntervalListLink'):
        super(ActiveTimeTariffIntervalListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveTimeTariffIntervalListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveTimeTariffIntervalListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveTimeTariffIntervalListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveTimeTariffIntervalListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveTimeTariffIntervalListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveTimeTariffIntervalListLink


class ActiveTextMessageListLink(ListLink):
    """ActiveTextMessageListLink -- SHALL contain a Link to a List of active TextMessage instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveTextMessageListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveTextMessageListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveTextMessageListLink.subclass:
            return ActiveTextMessageListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveTextMessageListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveTextMessageListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveTextMessageListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveTextMessageListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveTextMessageListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveTextMessageListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveTextMessageListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveTextMessageListLink'):
        super(ActiveTextMessageListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveTextMessageListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveTextMessageListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveTextMessageListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveTextMessageListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveTextMessageListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveTextMessageListLink


class ActiveTargetReadingListLink(ListLink):
    """ActiveTargetReadingListLink -- SHALL contain a Link to a List of active TargetReading instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveTargetReadingListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveTargetReadingListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveTargetReadingListLink.subclass:
            return ActiveTargetReadingListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveTargetReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveTargetReadingListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveTargetReadingListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveTargetReadingListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveTargetReadingListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveTargetReadingListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveTargetReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveTargetReadingListLink'):
        super(ActiveTargetReadingListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveTargetReadingListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveTargetReadingListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveTargetReadingListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveTargetReadingListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveTargetReadingListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveTargetReadingListLink


class ActiveSupplyInterruptionOverrideListLink(ListLink):
    """ActiveSupplyInterruptionOverrideListLink -- SHALL contain a Link to a List of active SupplyInterruptionOverride instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveSupplyInterruptionOverrideListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveSupplyInterruptionOverrideListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveSupplyInterruptionOverrideListLink.subclass:
            return ActiveSupplyInterruptionOverrideListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveSupplyInterruptionOverrideListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveSupplyInterruptionOverrideListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveSupplyInterruptionOverrideListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveSupplyInterruptionOverrideListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveSupplyInterruptionOverrideListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveSupplyInterruptionOverrideListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveSupplyInterruptionOverrideListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveSupplyInterruptionOverrideListLink'):
        super(ActiveSupplyInterruptionOverrideListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveSupplyInterruptionOverrideListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveSupplyInterruptionOverrideListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveSupplyInterruptionOverrideListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveSupplyInterruptionOverrideListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveSupplyInterruptionOverrideListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveSupplyInterruptionOverrideListLink


class ActiveProjectionReadingListLink(ListLink):
    """ActiveProjectionReadingListLink -- SHALL contain a Link to a List of active ProjectionReading instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveProjectionReadingListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveProjectionReadingListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveProjectionReadingListLink.subclass:
            return ActiveProjectionReadingListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveProjectionReadingListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveProjectionReadingListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveProjectionReadingListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveProjectionReadingListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveProjectionReadingListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveProjectionReadingListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveProjectionReadingListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveProjectionReadingListLink'):
        super(ActiveProjectionReadingListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveProjectionReadingListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveProjectionReadingListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveProjectionReadingListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveProjectionReadingListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveProjectionReadingListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveProjectionReadingListLink


class ActiveFlowReservationListLink(ListLink):
    """ActiveFlowReservationListLink -- SHALL contain a Link to a List of active FlowReservation instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveFlowReservationListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveFlowReservationListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveFlowReservationListLink.subclass:
            return ActiveFlowReservationListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveFlowReservationListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveFlowReservationListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveFlowReservationListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveFlowReservationListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveFlowReservationListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveFlowReservationListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveFlowReservationListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveFlowReservationListLink'):
        super(ActiveFlowReservationListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveFlowReservationListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveFlowReservationListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveFlowReservationListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveFlowReservationListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveFlowReservationListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveFlowReservationListLink


class ActiveEndDeviceControlListLink(ListLink):
    """ActiveEndDeviceControlListLink -- SHALL contain a Link to a List of active EndDeviceControl instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveEndDeviceControlListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveEndDeviceControlListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveEndDeviceControlListLink.subclass:
            return ActiveEndDeviceControlListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveEndDeviceControlListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveEndDeviceControlListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveEndDeviceControlListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveEndDeviceControlListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveEndDeviceControlListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveEndDeviceControlListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveEndDeviceControlListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveEndDeviceControlListLink'):
        super(ActiveEndDeviceControlListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveEndDeviceControlListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveEndDeviceControlListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveEndDeviceControlListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveEndDeviceControlListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveEndDeviceControlListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveEndDeviceControlListLink


class ActiveDERControlListLink(ListLink):
    """ActiveDERControlListLink -- SHALL contain a Link to a List of active DERControl instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveDERControlListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveDERControlListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveDERControlListLink.subclass:
            return ActiveDERControlListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveDERControlListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveDERControlListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveDERControlListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveDERControlListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveDERControlListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveDERControlListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveDERControlListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveDERControlListLink'):
        super(ActiveDERControlListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveDERControlListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveDERControlListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveDERControlListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveDERControlListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveDERControlListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveDERControlListLink


class ActiveCreditRegisterListLink(ListLink):
    """ActiveCreditRegisterListLink -- SHALL contain a Link to a List of active CreditRegister instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveCreditRegisterListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveCreditRegisterListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveCreditRegisterListLink.subclass:
            return ActiveCreditRegisterListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveCreditRegisterListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveCreditRegisterListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveCreditRegisterListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveCreditRegisterListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveCreditRegisterListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveCreditRegisterListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveCreditRegisterListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveCreditRegisterListLink'):
        super(ActiveCreditRegisterListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveCreditRegisterListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveCreditRegisterListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveCreditRegisterListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveCreditRegisterListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveCreditRegisterListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveCreditRegisterListLink


class ActiveBillingPeriodListLink(ListLink):
    """ActiveBillingPeriodListLink -- SHALL contain a Link to a List of active BillingPeriod instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ListLink
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ActiveBillingPeriodListLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ActiveBillingPeriodListLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ActiveBillingPeriodListLink.subclass:
            return ActiveBillingPeriodListLink.subclass(*args_, **kwargs_)
        else:
            return ActiveBillingPeriodListLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ActiveBillingPeriodListLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveBillingPeriodListLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ActiveBillingPeriodListLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ActiveBillingPeriodListLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveBillingPeriodListLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ActiveBillingPeriodListLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ActiveBillingPeriodListLink'):
        super(ActiveBillingPeriodListLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ActiveBillingPeriodListLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ActiveBillingPeriodListLink', fromsubclass_=False, pretty_print=True):
        super(ActiveBillingPeriodListLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ActiveBillingPeriodListLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ActiveBillingPeriodListLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ActiveBillingPeriodListLink


class AccountBalanceLink(Link):
    """AccountBalanceLink -- SHALL contain a Link to an instance of AccountBalance.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AccountBalanceLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountBalanceLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountBalanceLink.subclass:
            return AccountBalanceLink.subclass(*args_, **kwargs_)
        else:
            return AccountBalanceLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(AccountBalanceLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AccountBalanceLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccountBalanceLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AccountBalanceLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccountBalanceLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccountBalanceLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccountBalanceLink'):
        super(AccountBalanceLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccountBalanceLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='AccountBalanceLink', fromsubclass_=False, pretty_print=True):
        super(AccountBalanceLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AccountBalanceLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(AccountBalanceLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class AccountBalanceLink


class DERStatus(SubscribableResource):
    """DERStatus -- DER status information.
    alarmStatus -- Bitmap indicating the status of DER alarms (see DER LogEvents for more details).
    0 - DER_FAULT_OVER_CURRENT
    1 - DER_FAULT_OVER_VOLTAGE
    2 - DER_FAULT_UNDER_VOLTAGE
    3 - DER_FAULT_OVER_FREQUENCY
    4 - DER_FAULT_UNDER_FREQUENCY
    5 - DER_FAULT_VOLTAGE_IMBALANCE
    6 - DER_FAULT_CURRENT_IMBALANCE
    7 - DER_FAULT_EMERGENCY_LOCAL
    8 - DER_FAULT_EMERGENCY_REMOTE
    9 - DER_FAULT_LOW_POWER_INPUT
    10 - DER_FAULT_PHASE_ROTATION
    11-31 - Reserved
    genConnectStatus -- Connect/status value for generator DER.
    See ConnectStatusType for values.
    inverterStatus -- DER InverterStatus/value.
    See InverterStatusType for values.
    localControlModeStatus -- The local control mode status.
    See LocalControlModeStatusType for values.
    manufacturerStatus -- Manufacturer status code.
    operationalModeStatus -- Operational mode currently in use.
    See OperationalModeStatusType for values.
    readingTime -- The timestamp when the current status was last updated.
    stateOfChargeStatus -- State of charge status.
    See StateOfChargeStatusType for values.
    storageModeStatus -- Storage mode status.
    See StorageModeStatusType for values.
    storConnectStatus -- Connect/status value for storage DER.
    See ConnectStatusType for values.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableResource
    def __init__(self, alarmStatus=None, genConnectStatus=None, inverterStatus=None, localControlModeStatus=None, manufacturerStatus=None, operationalModeStatus=None, readingTime=None, stateOfChargeStatus=None, storageModeStatus=None, storConnectStatus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERStatus"), self).__init__( **kwargs_)
        self.alarmStatus = alarmStatus
        self.validate_HexBinary32(self.alarmStatus)
        self.alarmStatus_nsprefix_ = None
        self.genConnectStatus = genConnectStatus
        self.genConnectStatus_nsprefix_ = None
        self.inverterStatus = inverterStatus
        self.inverterStatus_nsprefix_ = None
        self.localControlModeStatus = localControlModeStatus
        self.localControlModeStatus_nsprefix_ = None
        self.manufacturerStatus = manufacturerStatus
        self.manufacturerStatus_nsprefix_ = None
        self.operationalModeStatus = operationalModeStatus
        self.operationalModeStatus_nsprefix_ = None
        self.readingTime = readingTime
        self.readingTime_nsprefix_ = None
        self.stateOfChargeStatus = stateOfChargeStatus
        self.stateOfChargeStatus_nsprefix_ = None
        self.storageModeStatus = storageModeStatus
        self.storageModeStatus_nsprefix_ = None
        self.storConnectStatus = storConnectStatus
        self.storConnectStatus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERStatus.subclass:
            return DERStatus.subclass(*args_, **kwargs_)
        else:
            return DERStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_alarmStatus(self):
        return self.alarmStatus
    def set_alarmStatus(self, alarmStatus):
        self.alarmStatus = alarmStatus
    def get_genConnectStatus(self):
        return self.genConnectStatus
    def set_genConnectStatus(self, genConnectStatus):
        self.genConnectStatus = genConnectStatus
    def get_inverterStatus(self):
        return self.inverterStatus
    def set_inverterStatus(self, inverterStatus):
        self.inverterStatus = inverterStatus
    def get_localControlModeStatus(self):
        return self.localControlModeStatus
    def set_localControlModeStatus(self, localControlModeStatus):
        self.localControlModeStatus = localControlModeStatus
    def get_manufacturerStatus(self):
        return self.manufacturerStatus
    def set_manufacturerStatus(self, manufacturerStatus):
        self.manufacturerStatus = manufacturerStatus
    def get_operationalModeStatus(self):
        return self.operationalModeStatus
    def set_operationalModeStatus(self, operationalModeStatus):
        self.operationalModeStatus = operationalModeStatus
    def get_readingTime(self):
        return self.readingTime
    def set_readingTime(self, readingTime):
        self.readingTime = readingTime
    def get_stateOfChargeStatus(self):
        return self.stateOfChargeStatus
    def set_stateOfChargeStatus(self, stateOfChargeStatus):
        self.stateOfChargeStatus = stateOfChargeStatus
    def get_storageModeStatus(self):
        return self.storageModeStatus
    def set_storageModeStatus(self, storageModeStatus):
        self.storageModeStatus = storageModeStatus
    def get_storConnectStatus(self):
        return self.storConnectStatus
    def set_storConnectStatus(self, storConnectStatus):
        self.storConnectStatus = storConnectStatus
    def validate_HexBinary32(self, value):
        result = True
        # Validate type HexBinary32, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 8:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary32' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.alarmStatus is not None or
            self.genConnectStatus is not None or
            self.inverterStatus is not None or
            self.localControlModeStatus is not None or
            self.manufacturerStatus is not None or
            self.operationalModeStatus is not None or
            self.readingTime is not None or
            self.stateOfChargeStatus is not None or
            self.storageModeStatus is not None or
            self.storConnectStatus is not None or
            super(DERStatus, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERStatus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERStatus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERStatus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERStatus')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERStatus'):
        super(DERStatus, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERStatus')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERStatus', fromsubclass_=False, pretty_print=True):
        super(DERStatus, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.alarmStatus is not None:
            namespaceprefix_ = self.alarmStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.alarmStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%salarmStatus>%s</%salarmStatus>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.alarmStatus), input_name='alarmStatus')), namespaceprefix_ , eol_))
        if self.genConnectStatus is not None:
            namespaceprefix_ = self.genConnectStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.genConnectStatus_nsprefix_) else ''
            self.genConnectStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='genConnectStatus', pretty_print=pretty_print)
        if self.inverterStatus is not None:
            namespaceprefix_ = self.inverterStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.inverterStatus_nsprefix_) else ''
            self.inverterStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='inverterStatus', pretty_print=pretty_print)
        if self.localControlModeStatus is not None:
            namespaceprefix_ = self.localControlModeStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.localControlModeStatus_nsprefix_) else ''
            self.localControlModeStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='localControlModeStatus', pretty_print=pretty_print)
        if self.manufacturerStatus is not None:
            namespaceprefix_ = self.manufacturerStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.manufacturerStatus_nsprefix_) else ''
            self.manufacturerStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='manufacturerStatus', pretty_print=pretty_print)
        if self.operationalModeStatus is not None:
            namespaceprefix_ = self.operationalModeStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.operationalModeStatus_nsprefix_) else ''
            self.operationalModeStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='operationalModeStatus', pretty_print=pretty_print)
        if self.readingTime is not None:
            namespaceprefix_ = self.readingTime_nsprefix_ + ':' if (UseCapturedNS_ and self.readingTime_nsprefix_) else ''
            self.readingTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='readingTime', pretty_print=pretty_print)
        if self.stateOfChargeStatus is not None:
            namespaceprefix_ = self.stateOfChargeStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.stateOfChargeStatus_nsprefix_) else ''
            self.stateOfChargeStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='stateOfChargeStatus', pretty_print=pretty_print)
        if self.storageModeStatus is not None:
            namespaceprefix_ = self.storageModeStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.storageModeStatus_nsprefix_) else ''
            self.storageModeStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='storageModeStatus', pretty_print=pretty_print)
        if self.storConnectStatus is not None:
            namespaceprefix_ = self.storConnectStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.storConnectStatus_nsprefix_) else ''
            self.storConnectStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='storConnectStatus', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERStatus, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'alarmStatus':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'alarmStatus')
            value_ = self.gds_validate_string(value_, node, 'alarmStatus')
            self.alarmStatus = value_
            self.alarmStatus_nsprefix_ = child_.prefix
            # validate type HexBinary32
            self.validate_HexBinary32(self.alarmStatus)
        elif nodeName_ == 'genConnectStatus':
            obj_ = ConnectStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.genConnectStatus = obj_
            obj_.original_tagname_ = 'genConnectStatus'
        elif nodeName_ == 'inverterStatus':
            obj_ = InverterStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.inverterStatus = obj_
            obj_.original_tagname_ = 'inverterStatus'
        elif nodeName_ == 'localControlModeStatus':
            obj_ = LocalControlModeStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.localControlModeStatus = obj_
            obj_.original_tagname_ = 'localControlModeStatus'
        elif nodeName_ == 'manufacturerStatus':
            obj_ = ManufacturerStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.manufacturerStatus = obj_
            obj_.original_tagname_ = 'manufacturerStatus'
        elif nodeName_ == 'operationalModeStatus':
            obj_ = OperationalModeStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.operationalModeStatus = obj_
            obj_.original_tagname_ = 'operationalModeStatus'
        elif nodeName_ == 'readingTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.readingTime = obj_
            obj_.original_tagname_ = 'readingTime'
        elif nodeName_ == 'stateOfChargeStatus':
            obj_ = StateOfChargeStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.stateOfChargeStatus = obj_
            obj_.original_tagname_ = 'stateOfChargeStatus'
        elif nodeName_ == 'storageModeStatus':
            obj_ = StorageModeStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.storageModeStatus = obj_
            obj_.original_tagname_ = 'storageModeStatus'
        elif nodeName_ == 'storConnectStatus':
            obj_ = ConnectStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.storConnectStatus = obj_
            obj_.original_tagname_ = 'storConnectStatus'
        super(DERStatus, self)._buildChildren(child_, node, nodeName_, True)
# end class DERStatus


class DERProgramList(SubscribableList):
    """DERProgramList -- A List element to hold DERProgram objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', DERProgram=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERProgramList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if DERProgram is None:
            self.DERProgram = []
        else:
            self.DERProgram = DERProgram
        self.DERProgram_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERProgramList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERProgramList.subclass:
            return DERProgramList.subclass(*args_, **kwargs_)
        else:
            return DERProgramList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DERProgram(self):
        return self.DERProgram
    def set_DERProgram(self, DERProgram):
        self.DERProgram = DERProgram
    def add_DERProgram(self, value):
        self.DERProgram.append(value)
    def insert_DERProgram_at(self, index, value):
        self.DERProgram.insert(index, value)
    def replace_DERProgram_at(self, index, value):
        self.DERProgram[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.DERProgram or
            super(DERProgramList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERProgramList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERProgramList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERProgramList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERProgramList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERProgramList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERProgramList'):
        super(DERProgramList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERProgramList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERProgramList', fromsubclass_=False, pretty_print=True):
        super(DERProgramList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DERProgram_ in self.DERProgram:
            namespaceprefix_ = self.DERProgram_nsprefix_ + ':' if (UseCapturedNS_ and self.DERProgram_nsprefix_) else ''
            DERProgram_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERProgram', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(DERProgramList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DERProgram':
            obj_ = DERProgram.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERProgram.append(obj_)
            obj_.original_tagname_ = 'DERProgram'
        super(DERProgramList, self)._buildChildren(child_, node, nodeName_, True)
# end class DERProgramList


class DERProgram(SubscribableIdentifiedObject):
    """DERProgram -- Distributed Energy Resource program.
    primacy -- Indicates the relative primacy of the provider of this Program.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableIdentifiedObject
    def __init__(self, ActiveDERControlListLink=None, DefaultDERControlLink=None, DERControlListLink=None, DERCurveListLink=None, primacy=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERProgram"), self).__init__( **kwargs_)
        self.ActiveDERControlListLink = ActiveDERControlListLink
        self.ActiveDERControlListLink_nsprefix_ = None
        self.DefaultDERControlLink = DefaultDERControlLink
        self.DefaultDERControlLink_nsprefix_ = None
        self.DERControlListLink = DERControlListLink
        self.DERControlListLink_nsprefix_ = None
        self.DERCurveListLink = DERCurveListLink
        self.DERCurveListLink_nsprefix_ = None
        self.primacy = primacy
        self.primacy_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERProgram)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERProgram.subclass:
            return DERProgram.subclass(*args_, **kwargs_)
        else:
            return DERProgram(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ActiveDERControlListLink(self):
        return self.ActiveDERControlListLink
    def set_ActiveDERControlListLink(self, ActiveDERControlListLink):
        self.ActiveDERControlListLink = ActiveDERControlListLink
    def get_DefaultDERControlLink(self):
        return self.DefaultDERControlLink
    def set_DefaultDERControlLink(self, DefaultDERControlLink):
        self.DefaultDERControlLink = DefaultDERControlLink
    def get_DERControlListLink(self):
        return self.DERControlListLink
    def set_DERControlListLink(self, DERControlListLink):
        self.DERControlListLink = DERControlListLink
    def get_DERCurveListLink(self):
        return self.DERCurveListLink
    def set_DERCurveListLink(self, DERCurveListLink):
        self.DERCurveListLink = DERCurveListLink
    def get_primacy(self):
        return self.primacy
    def set_primacy(self, primacy):
        self.primacy = primacy
    def _hasContent(self):
        if (
            self.ActiveDERControlListLink is not None or
            self.DefaultDERControlLink is not None or
            self.DERControlListLink is not None or
            self.DERCurveListLink is not None or
            self.primacy is not None or
            super(DERProgram, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERProgram', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERProgram')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERProgram':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERProgram')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERProgram', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERProgram'):
        super(DERProgram, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERProgram')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERProgram', fromsubclass_=False, pretty_print=True):
        super(DERProgram, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveDERControlListLink is not None:
            namespaceprefix_ = self.ActiveDERControlListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveDERControlListLink_nsprefix_) else ''
            self.ActiveDERControlListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ActiveDERControlListLink', pretty_print=pretty_print)
        if self.DefaultDERControlLink is not None:
            namespaceprefix_ = self.DefaultDERControlLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DefaultDERControlLink_nsprefix_) else ''
            self.DefaultDERControlLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DefaultDERControlLink', pretty_print=pretty_print)
        if self.DERControlListLink is not None:
            namespaceprefix_ = self.DERControlListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DERControlListLink_nsprefix_) else ''
            self.DERControlListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERControlListLink', pretty_print=pretty_print)
        if self.DERCurveListLink is not None:
            namespaceprefix_ = self.DERCurveListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DERCurveListLink_nsprefix_) else ''
            self.DERCurveListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERCurveListLink', pretty_print=pretty_print)
        if self.primacy is not None:
            namespaceprefix_ = self.primacy_nsprefix_ + ':' if (UseCapturedNS_ and self.primacy_nsprefix_) else ''
            self.primacy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='primacy', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERProgram, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ActiveDERControlListLink':
            obj_ = ActiveDERControlListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ActiveDERControlListLink = obj_
            obj_.original_tagname_ = 'ActiveDERControlListLink'
        elif nodeName_ == 'DefaultDERControlLink':
            obj_ = DefaultDERControlLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DefaultDERControlLink = obj_
            obj_.original_tagname_ = 'DefaultDERControlLink'
        elif nodeName_ == 'DERControlListLink':
            obj_ = DERControlListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERControlListLink = obj_
            obj_.original_tagname_ = 'DERControlListLink'
        elif nodeName_ == 'DERCurveListLink':
            obj_ = DERCurveListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERCurveListLink = obj_
            obj_.original_tagname_ = 'DERCurveListLink'
        elif nodeName_ == 'primacy':
            obj_ = PrimacyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primacy = obj_
            obj_.original_tagname_ = 'primacy'
        super(DERProgram, self)._buildChildren(child_, node, nodeName_, True)
# end class DERProgram


class DERCurveList(List):
    """DERCurveList -- A List element to hold DERCurve objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, DERCurve=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERCurveList"), self).__init__( **kwargs_)
        if DERCurve is None:
            self.DERCurve = []
        else:
            self.DERCurve = DERCurve
        self.DERCurve_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERCurveList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERCurveList.subclass:
            return DERCurveList.subclass(*args_, **kwargs_)
        else:
            return DERCurveList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DERCurve(self):
        return self.DERCurve
    def set_DERCurve(self, DERCurve):
        self.DERCurve = DERCurve
    def add_DERCurve(self, value):
        self.DERCurve.append(value)
    def insert_DERCurve_at(self, index, value):
        self.DERCurve.insert(index, value)
    def replace_DERCurve_at(self, index, value):
        self.DERCurve[index] = value
    def _hasContent(self):
        if (
            self.DERCurve or
            super(DERCurveList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERCurveList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERCurveList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERCurveList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCurveList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERCurveList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERCurveList'):
        super(DERCurveList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCurveList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERCurveList', fromsubclass_=False, pretty_print=True):
        super(DERCurveList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DERCurve_ in self.DERCurve:
            namespaceprefix_ = self.DERCurve_nsprefix_ + ':' if (UseCapturedNS_ and self.DERCurve_nsprefix_) else ''
            DERCurve_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERCurve', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERCurveList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DERCurve':
            obj_ = DERCurve.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERCurve.append(obj_)
            obj_.original_tagname_ = 'DERCurve'
        super(DERCurveList, self)._buildChildren(child_, node, nodeName_, True)
# end class DERCurveList


class CurrentDERProgramLink(Link):
    """CurrentDERProgramLink -- SHALL contain a Link to an instance of DERProgram.  If present, this is the DERProgram containing the currently active DERControl.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Link
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CurrentDERProgramLink"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CurrentDERProgramLink)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CurrentDERProgramLink.subclass:
            return CurrentDERProgramLink.subclass(*args_, **kwargs_)
        else:
            return CurrentDERProgramLink(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(CurrentDERProgramLink, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CurrentDERProgramLink', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CurrentDERProgramLink')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CurrentDERProgramLink':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CurrentDERProgramLink')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CurrentDERProgramLink', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CurrentDERProgramLink'):
        super(CurrentDERProgramLink, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CurrentDERProgramLink')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='CurrentDERProgramLink', fromsubclass_=False, pretty_print=True):
        super(CurrentDERProgramLink, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CurrentDERProgramLink, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(CurrentDERProgramLink, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class CurrentDERProgramLink


class DERCurve(IdentifiedObject):
    """DERCurve -- DER related curves such as Volt-Var mode curves. Relationship between an independent variable (X-axis) and a dependent variable (Y-axis).
    autonomousVRefEnable -- If the curveType is opModVoltVar, then this field MAY be present. If the curveType is not opModVoltVar, then this field SHALL NOT be present. Enable/disable autonomous vRef adjustment. When enabled, the Volt-Var curve characteristic SHALL be adjusted autonomously as vRef changes and autonomousVRefTimeConstant SHALL be present. If a DER is able to support Volt-Var mode but is unable to support autonomous vRef adjustment, then the DER SHALL execute the curve without autonomous vRef adjustment. If not specified, then the value is false.
    autonomousVRefTimeConstant -- If the curveType is opModVoltVar, then this field MAY be present. If the curveType is not opModVoltVar, then this field SHALL NOT be present. Adjustment range for vRef time constant, in hundredths of a second.
    creationTime -- The time at which the object was created.
    curveType -- Specifies the associated curve-based control mode.
    openLoopTms -- Open loop response time, the time to ramp up to 90% of the new target in response to the change in voltage, in hundredths of a second. Resolution is 1/100 sec. A value of 0 is used to mean no limit. When not present, the device SHOULD follow its default behavior.
    rampDecTms -- Decreasing ramp rate, interpreted as a percentage change in output capability limit per second (e.g. %setMaxW / sec).  Resolution is in hundredths of a percent/second. A value of 0 means there is no limit. If absent, ramp rate defaults to setGradW.
    rampIncTms -- Increasing ramp rate, interpreted as a percentage change in output capability limit per second (e.g. %setMaxW / sec).  Resolution is in hundredths of a percent/second. A value of 0 means there is no limit. If absent, ramp rate defaults to rampDecTms.
    rampPT1Tms -- The configuration parameter for a low-pass filter, PT1 is a time, in hundredths of a second, in which the filter will settle to 95% of a step change in the input value. Resolution is 1/100 sec.
    vRef -- If the curveType is opModVoltVar, then this field MAY be present. If the curveType is not opModVoltVar, then this field SHALL NOT be present. The nominal AC voltage (RMS) adjustment to the voltage curve points for Volt-Var curves.
    xMultiplier -- Exponent for X-axis value.
    yMultiplier -- Exponent for Y-axis value.
    yRefType -- The Y-axis units context.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, autonomousVRefEnable=None, autonomousVRefTimeConstant=None, creationTime=None, CurveData=None, curveType=None, openLoopTms=None, rampDecTms=None, rampIncTms=None, rampPT1Tms=None, vRef=None, xMultiplier=None, yMultiplier=None, yRefType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERCurve"), self).__init__( **kwargs_)
        self.autonomousVRefEnable = autonomousVRefEnable
        self.autonomousVRefEnable_nsprefix_ = None
        self.autonomousVRefTimeConstant = autonomousVRefTimeConstant
        self.validate_UInt32(self.autonomousVRefTimeConstant)
        self.autonomousVRefTimeConstant_nsprefix_ = None
        self.creationTime = creationTime
        self.creationTime_nsprefix_ = None
        if CurveData is None:
            self.CurveData = []
        else:
            self.CurveData = CurveData
        self.CurveData_nsprefix_ = None
        self.curveType = curveType
        self.curveType_nsprefix_ = None
        self.openLoopTms = openLoopTms
        self.validate_UInt16(self.openLoopTms)
        self.openLoopTms_nsprefix_ = None
        self.rampDecTms = rampDecTms
        self.validate_UInt16(self.rampDecTms)
        self.rampDecTms_nsprefix_ = None
        self.rampIncTms = rampIncTms
        self.validate_UInt16(self.rampIncTms)
        self.rampIncTms_nsprefix_ = None
        self.rampPT1Tms = rampPT1Tms
        self.validate_UInt16(self.rampPT1Tms)
        self.rampPT1Tms_nsprefix_ = None
        self.vRef = vRef
        self.vRef_nsprefix_ = None
        self.xMultiplier = xMultiplier
        self.xMultiplier_nsprefix_ = None
        self.yMultiplier = yMultiplier
        self.yMultiplier_nsprefix_ = None
        self.yRefType = yRefType
        self.yRefType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERCurve)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERCurve.subclass:
            return DERCurve.subclass(*args_, **kwargs_)
        else:
            return DERCurve(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_autonomousVRefEnable(self):
        return self.autonomousVRefEnable
    def set_autonomousVRefEnable(self, autonomousVRefEnable):
        self.autonomousVRefEnable = autonomousVRefEnable
    def get_autonomousVRefTimeConstant(self):
        return self.autonomousVRefTimeConstant
    def set_autonomousVRefTimeConstant(self, autonomousVRefTimeConstant):
        self.autonomousVRefTimeConstant = autonomousVRefTimeConstant
    def get_creationTime(self):
        return self.creationTime
    def set_creationTime(self, creationTime):
        self.creationTime = creationTime
    def get_CurveData(self):
        return self.CurveData
    def set_CurveData(self, CurveData):
        self.CurveData = CurveData
    def add_CurveData(self, value):
        self.CurveData.append(value)
    def insert_CurveData_at(self, index, value):
        self.CurveData.insert(index, value)
    def replace_CurveData_at(self, index, value):
        self.CurveData[index] = value
    def get_curveType(self):
        return self.curveType
    def set_curveType(self, curveType):
        self.curveType = curveType
    def get_openLoopTms(self):
        return self.openLoopTms
    def set_openLoopTms(self, openLoopTms):
        self.openLoopTms = openLoopTms
    def get_rampDecTms(self):
        return self.rampDecTms
    def set_rampDecTms(self, rampDecTms):
        self.rampDecTms = rampDecTms
    def get_rampIncTms(self):
        return self.rampIncTms
    def set_rampIncTms(self, rampIncTms):
        self.rampIncTms = rampIncTms
    def get_rampPT1Tms(self):
        return self.rampPT1Tms
    def set_rampPT1Tms(self, rampPT1Tms):
        self.rampPT1Tms = rampPT1Tms
    def get_vRef(self):
        return self.vRef
    def set_vRef(self, vRef):
        self.vRef = vRef
    def get_xMultiplier(self):
        return self.xMultiplier
    def set_xMultiplier(self, xMultiplier):
        self.xMultiplier = xMultiplier
    def get_yMultiplier(self):
        return self.yMultiplier
    def set_yMultiplier(self, yMultiplier):
        self.yMultiplier = yMultiplier
    def get_yRefType(self):
        return self.yRefType
    def set_yRefType(self, yRefType):
        self.yRefType = yRefType
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.autonomousVRefEnable is not None or
            self.autonomousVRefTimeConstant is not None or
            self.creationTime is not None or
            self.CurveData or
            self.curveType is not None or
            self.openLoopTms is not None or
            self.rampDecTms is not None or
            self.rampIncTms is not None or
            self.rampPT1Tms is not None or
            self.vRef is not None or
            self.xMultiplier is not None or
            self.yMultiplier is not None or
            self.yRefType is not None or
            super(DERCurve, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERCurve', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERCurve')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERCurve':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCurve')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERCurve', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERCurve'):
        super(DERCurve, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCurve')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERCurve', fromsubclass_=False, pretty_print=True):
        super(DERCurve, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.autonomousVRefEnable is not None:
            namespaceprefix_ = self.autonomousVRefEnable_nsprefix_ + ':' if (UseCapturedNS_ and self.autonomousVRefEnable_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sautonomousVRefEnable>%s</%sautonomousVRefEnable>%s' % (namespaceprefix_ , self.gds_format_boolean(self.autonomousVRefEnable, input_name='autonomousVRefEnable'), namespaceprefix_ , eol_))
        if self.autonomousVRefTimeConstant is not None:
            namespaceprefix_ = self.autonomousVRefTimeConstant_nsprefix_ + ':' if (UseCapturedNS_ and self.autonomousVRefTimeConstant_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sautonomousVRefTimeConstant>%s</%sautonomousVRefTimeConstant>%s' % (namespaceprefix_ , self.gds_format_integer(self.autonomousVRefTimeConstant, input_name='autonomousVRefTimeConstant'), namespaceprefix_ , eol_))
        if self.creationTime is not None:
            namespaceprefix_ = self.creationTime_nsprefix_ + ':' if (UseCapturedNS_ and self.creationTime_nsprefix_) else ''
            self.creationTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creationTime', pretty_print=pretty_print)
        for CurveData_ in self.CurveData:
            namespaceprefix_ = self.CurveData_nsprefix_ + ':' if (UseCapturedNS_ and self.CurveData_nsprefix_) else ''
            CurveData_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CurveData', pretty_print=pretty_print)
        if self.curveType is not None:
            namespaceprefix_ = self.curveType_nsprefix_ + ':' if (UseCapturedNS_ and self.curveType_nsprefix_) else ''
            self.curveType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='curveType', pretty_print=pretty_print)
        if self.openLoopTms is not None:
            namespaceprefix_ = self.openLoopTms_nsprefix_ + ':' if (UseCapturedNS_ and self.openLoopTms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopenLoopTms>%s</%sopenLoopTms>%s' % (namespaceprefix_ , self.gds_format_integer(self.openLoopTms, input_name='openLoopTms'), namespaceprefix_ , eol_))
        if self.rampDecTms is not None:
            namespaceprefix_ = self.rampDecTms_nsprefix_ + ':' if (UseCapturedNS_ and self.rampDecTms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srampDecTms>%s</%srampDecTms>%s' % (namespaceprefix_ , self.gds_format_integer(self.rampDecTms, input_name='rampDecTms'), namespaceprefix_ , eol_))
        if self.rampIncTms is not None:
            namespaceprefix_ = self.rampIncTms_nsprefix_ + ':' if (UseCapturedNS_ and self.rampIncTms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srampIncTms>%s</%srampIncTms>%s' % (namespaceprefix_ , self.gds_format_integer(self.rampIncTms, input_name='rampIncTms'), namespaceprefix_ , eol_))
        if self.rampPT1Tms is not None:
            namespaceprefix_ = self.rampPT1Tms_nsprefix_ + ':' if (UseCapturedNS_ and self.rampPT1Tms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srampPT1Tms>%s</%srampPT1Tms>%s' % (namespaceprefix_ , self.gds_format_integer(self.rampPT1Tms, input_name='rampPT1Tms'), namespaceprefix_ , eol_))
        if self.vRef is not None:
            namespaceprefix_ = self.vRef_nsprefix_ + ':' if (UseCapturedNS_ and self.vRef_nsprefix_) else ''
            self.vRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='vRef', pretty_print=pretty_print)
        if self.xMultiplier is not None:
            namespaceprefix_ = self.xMultiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.xMultiplier_nsprefix_) else ''
            self.xMultiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='xMultiplier', pretty_print=pretty_print)
        if self.yMultiplier is not None:
            namespaceprefix_ = self.yMultiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.yMultiplier_nsprefix_) else ''
            self.yMultiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='yMultiplier', pretty_print=pretty_print)
        if self.yRefType is not None:
            namespaceprefix_ = self.yRefType_nsprefix_ + ':' if (UseCapturedNS_ and self.yRefType_nsprefix_) else ''
            self.yRefType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='yRefType', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERCurve, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'autonomousVRefEnable':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'autonomousVRefEnable')
            ival_ = self.gds_validate_boolean(ival_, node, 'autonomousVRefEnable')
            self.autonomousVRefEnable = ival_
            self.autonomousVRefEnable_nsprefix_ = child_.prefix
        elif nodeName_ == 'autonomousVRefTimeConstant' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'autonomousVRefTimeConstant')
            ival_ = self.gds_validate_integer(ival_, node, 'autonomousVRefTimeConstant')
            self.autonomousVRefTimeConstant = ival_
            self.autonomousVRefTimeConstant_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.autonomousVRefTimeConstant)
        elif nodeName_ == 'creationTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creationTime = obj_
            obj_.original_tagname_ = 'creationTime'
        elif nodeName_ == 'CurveData':
            obj_ = CurveData.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CurveData.append(obj_)
            obj_.original_tagname_ = 'CurveData'
        elif nodeName_ == 'curveType':
            obj_ = DERCurveType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.curveType = obj_
            obj_.original_tagname_ = 'curveType'
        elif nodeName_ == 'openLoopTms' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'openLoopTms')
            ival_ = self.gds_validate_integer(ival_, node, 'openLoopTms')
            self.openLoopTms = ival_
            self.openLoopTms_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.openLoopTms)
        elif nodeName_ == 'rampDecTms' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'rampDecTms')
            ival_ = self.gds_validate_integer(ival_, node, 'rampDecTms')
            self.rampDecTms = ival_
            self.rampDecTms_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.rampDecTms)
        elif nodeName_ == 'rampIncTms' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'rampIncTms')
            ival_ = self.gds_validate_integer(ival_, node, 'rampIncTms')
            self.rampIncTms = ival_
            self.rampIncTms_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.rampIncTms)
        elif nodeName_ == 'rampPT1Tms' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'rampPT1Tms')
            ival_ = self.gds_validate_integer(ival_, node, 'rampPT1Tms')
            self.rampPT1Tms = ival_
            self.rampPT1Tms_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.rampPT1Tms)
        elif nodeName_ == 'vRef':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.vRef = obj_
            obj_.original_tagname_ = 'vRef'
        elif nodeName_ == 'xMultiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.xMultiplier = obj_
            obj_.original_tagname_ = 'xMultiplier'
        elif nodeName_ == 'yMultiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.yMultiplier = obj_
            obj_.original_tagname_ = 'yMultiplier'
        elif nodeName_ == 'yRefType':
            obj_ = DERUnitRefType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.yRefType = obj_
            obj_.original_tagname_ = 'yRefType'
        super(DERCurve, self)._buildChildren(child_, node, nodeName_, True)
# end class DERCurve


class DERControlList(SubscribableList):
    """DERControlList -- A List element to hold DERControl objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, DERControl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERControlList"), self).__init__( **kwargs_)
        if DERControl is None:
            self.DERControl = []
        else:
            self.DERControl = DERControl
        self.DERControl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERControlList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERControlList.subclass:
            return DERControlList.subclass(*args_, **kwargs_)
        else:
            return DERControlList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DERControl(self):
        return self.DERControl
    def set_DERControl(self, DERControl):
        self.DERControl = DERControl
    def add_DERControl(self, value):
        self.DERControl.append(value)
    def insert_DERControl_at(self, index, value):
        self.DERControl.insert(index, value)
    def replace_DERControl_at(self, index, value):
        self.DERControl[index] = value
    def _hasContent(self):
        if (
            self.DERControl or
            super(DERControlList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERControlList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERControlList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERControlList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControlList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERControlList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERControlList'):
        super(DERControlList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControlList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERControlList', fromsubclass_=False, pretty_print=True):
        super(DERControlList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DERControl_ in self.DERControl:
            namespaceprefix_ = self.DERControl_nsprefix_ + ':' if (UseCapturedNS_ and self.DERControl_nsprefix_) else ''
            DERControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERControl', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERControlList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DERControl':
            obj_ = DERControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERControl.append(obj_)
            obj_.original_tagname_ = 'DERControl'
        super(DERControlList, self)._buildChildren(child_, node, nodeName_, True)
# end class DERControlList


class DERControl(RandomizableEvent):
    """DERControl -- Distributed Energy Resource (DER) time/event-based control.
    deviceCategory -- Specifies the bitmap indicating  the categories of devices that SHOULD respond. Devices SHOULD ignore events that do not indicate their device category. If not present, all devices SHOULD respond.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RandomizableEvent
    def __init__(self, DERControlBase=None, deviceCategory=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERControl"), self).__init__( **kwargs_)
        self.DERControlBase = DERControlBase
        self.DERControlBase_nsprefix_ = None
        self.deviceCategory = deviceCategory
        self.deviceCategory_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERControl.subclass:
            return DERControl.subclass(*args_, **kwargs_)
        else:
            return DERControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DERControlBase(self):
        return self.DERControlBase
    def set_DERControlBase(self, DERControlBase):
        self.DERControlBase = DERControlBase
    def get_deviceCategory(self):
        return self.deviceCategory
    def set_deviceCategory(self, deviceCategory):
        self.deviceCategory = deviceCategory
    def _hasContent(self):
        if (
            self.DERControlBase is not None or
            self.deviceCategory is not None or
            super(DERControl, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERControl', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERControl':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControl')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERControl'):
        super(DERControl, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControl')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERControl', fromsubclass_=False, pretty_print=True):
        super(DERControl, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DERControlBase is not None:
            namespaceprefix_ = self.DERControlBase_nsprefix_ + ':' if (UseCapturedNS_ and self.DERControlBase_nsprefix_) else ''
            self.DERControlBase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERControlBase', pretty_print=pretty_print)
        if self.deviceCategory is not None:
            namespaceprefix_ = self.deviceCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.deviceCategory_nsprefix_) else ''
            self.deviceCategory.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deviceCategory', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERControl, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DERControlBase':
            obj_ = DERControlBase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERControlBase = obj_
            obj_.original_tagname_ = 'DERControlBase'
        elif nodeName_ == 'deviceCategory':
            obj_ = DeviceCategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deviceCategory = obj_
            obj_.original_tagname_ = 'deviceCategory'
        super(DERControl, self)._buildChildren(child_, node, nodeName_, True)
# end class DERControl


class DERCapability(Resource):
    """DERCapability -- Distributed energy resource type and nameplate ratings.
    modesSupported -- Bitmap indicating the DER Controls implemented by the device. See DERControlType for values.
    rtgAbnormalCategory -- Abnormal operating performance category as defined by IEEE 1547-2018. One of:
    0 - not specified
    1 - Category I
    2 - Category II
    3 - Category III
    All other values reserved.
    rtgMaxA -- Maximum continuous AC current capability of the DER, in Amperes (RMS).
    rtgMaxAh -- Usable energy storage capacity of the DER, in AmpHours.
    rtgMaxChargeRateVA -- Maximum apparent power charge rating in Volt-Amperes. May differ from the maximum apparent power rating.
    rtgMaxChargeRateW -- Maximum rate of energy transfer received by the storage DER, in Watts.
    rtgMaxDischargeRateVA -- Maximum apparent power discharge rating in Volt-Amperes. May differ from the maximum apparent power rating.
    rtgMaxDischargeRateW -- Maximum rate of energy transfer delivered by the storage DER, in Watts. Required for combined generation/storage DERs (e.g. DERType == 83).
    rtgMaxV -- AC voltage maximum rating.
    rtgMaxVA -- Maximum continuous apparent power output capability of the DER, in VA.
    rtgMaxVar -- Maximum continuous reactive power delivered by the DER, in var.
    rtgMaxVarNeg -- Maximum continuous reactive power received by the DER, in var.  If absent, defaults to negative rtgMaxVar.
    rtgMaxW -- Maximum continuous active power output capability of the DER, in watts. Represents combined generation plus storage output if DERType == 83.
    rtgMaxWh -- Maximum energy storage capacity of the DER, in WattHours.
    rtgMinPFOverExcited -- Minimum Power Factor displacement capability of the DER when injecting reactive power (over-excited); SHALL be a positive value between 0.0 (typically
    &
    gt; 0.7) and 1.0. If absent, defaults to unity.
    rtgMinPFUnderExcited -- Minimum Power Factor displacement capability of the DER when absorbing reactive power (under-excited); SHALL be a positive value between 0.0 (typically
    &
    gt; 0.7) and 0.9999.  If absent, defaults to rtgMinPFOverExcited.
    rtgMinV -- AC voltage minimum rating.
    rtgNormalCategory -- Normal operating performance category as defined by IEEE 1547-2018. One of:
    0 - not specified
    1 - Category A
    2 - Category B
    All other values reserved.
    rtgOverExcitedPF -- Specified over-excited power factor.
    rtgOverExcitedW -- Active power rating in Watts at specified over-excited power factor (rtgOverExcitedPF). If present, rtgOverExcitedPF SHALL be present.
    rtgReactiveSusceptance -- Reactive susceptance that remains connected to the Area EPS in the cease to energize and trip state.
    rtgUnderExcitedPF -- Specified under-excited power factor.
    rtgUnderExcitedW -- Active power rating in Watts at specified under-excited power factor (rtgUnderExcitedPF). If present, rtgUnderExcitedPF SHALL be present.
    rtgVNom -- AC voltage nominal rating.
    type -- Type of DER; see DERType object
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, modesSupported=None, rtgAbnormalCategory=None, rtgMaxA=None, rtgMaxAh=None, rtgMaxChargeRateVA=None, rtgMaxChargeRateW=None, rtgMaxDischargeRateVA=None, rtgMaxDischargeRateW=None, rtgMaxV=None, rtgMaxVA=None, rtgMaxVar=None, rtgMaxVarNeg=None, rtgMaxW=None, rtgMaxWh=None, rtgMinPFOverExcited=None, rtgMinPFUnderExcited=None, rtgMinV=None, rtgNormalCategory=None, rtgOverExcitedPF=None, rtgOverExcitedW=None, rtgReactiveSusceptance=None, rtgUnderExcitedPF=None, rtgUnderExcitedW=None, rtgVNom=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERCapability"), self).__init__( **kwargs_)
        self.modesSupported = modesSupported
        self.modesSupported_nsprefix_ = None
        self.rtgAbnormalCategory = rtgAbnormalCategory
        self.validate_UInt8(self.rtgAbnormalCategory)
        self.rtgAbnormalCategory_nsprefix_ = None
        self.rtgMaxA = rtgMaxA
        self.rtgMaxA_nsprefix_ = None
        self.rtgMaxAh = rtgMaxAh
        self.rtgMaxAh_nsprefix_ = None
        self.rtgMaxChargeRateVA = rtgMaxChargeRateVA
        self.rtgMaxChargeRateVA_nsprefix_ = None
        self.rtgMaxChargeRateW = rtgMaxChargeRateW
        self.rtgMaxChargeRateW_nsprefix_ = None
        self.rtgMaxDischargeRateVA = rtgMaxDischargeRateVA
        self.rtgMaxDischargeRateVA_nsprefix_ = None
        self.rtgMaxDischargeRateW = rtgMaxDischargeRateW
        self.rtgMaxDischargeRateW_nsprefix_ = None
        self.rtgMaxV = rtgMaxV
        self.rtgMaxV_nsprefix_ = None
        self.rtgMaxVA = rtgMaxVA
        self.rtgMaxVA_nsprefix_ = None
        self.rtgMaxVar = rtgMaxVar
        self.rtgMaxVar_nsprefix_ = None
        self.rtgMaxVarNeg = rtgMaxVarNeg
        self.rtgMaxVarNeg_nsprefix_ = None
        self.rtgMaxW = rtgMaxW
        self.rtgMaxW_nsprefix_ = None
        self.rtgMaxWh = rtgMaxWh
        self.rtgMaxWh_nsprefix_ = None
        self.rtgMinPFOverExcited = rtgMinPFOverExcited
        self.rtgMinPFOverExcited_nsprefix_ = None
        self.rtgMinPFUnderExcited = rtgMinPFUnderExcited
        self.rtgMinPFUnderExcited_nsprefix_ = None
        self.rtgMinV = rtgMinV
        self.rtgMinV_nsprefix_ = None
        self.rtgNormalCategory = rtgNormalCategory
        self.validate_UInt8(self.rtgNormalCategory)
        self.rtgNormalCategory_nsprefix_ = None
        self.rtgOverExcitedPF = rtgOverExcitedPF
        self.rtgOverExcitedPF_nsprefix_ = None
        self.rtgOverExcitedW = rtgOverExcitedW
        self.rtgOverExcitedW_nsprefix_ = None
        self.rtgReactiveSusceptance = rtgReactiveSusceptance
        self.rtgReactiveSusceptance_nsprefix_ = None
        self.rtgUnderExcitedPF = rtgUnderExcitedPF
        self.rtgUnderExcitedPF_nsprefix_ = None
        self.rtgUnderExcitedW = rtgUnderExcitedW
        self.rtgUnderExcitedW_nsprefix_ = None
        self.rtgVNom = rtgVNom
        self.rtgVNom_nsprefix_ = None
        self.type_ = type_
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERCapability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERCapability.subclass:
            return DERCapability.subclass(*args_, **kwargs_)
        else:
            return DERCapability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_modesSupported(self):
        return self.modesSupported
    def set_modesSupported(self, modesSupported):
        self.modesSupported = modesSupported
    def get_rtgAbnormalCategory(self):
        return self.rtgAbnormalCategory
    def set_rtgAbnormalCategory(self, rtgAbnormalCategory):
        self.rtgAbnormalCategory = rtgAbnormalCategory
    def get_rtgMaxA(self):
        return self.rtgMaxA
    def set_rtgMaxA(self, rtgMaxA):
        self.rtgMaxA = rtgMaxA
    def get_rtgMaxAh(self):
        return self.rtgMaxAh
    def set_rtgMaxAh(self, rtgMaxAh):
        self.rtgMaxAh = rtgMaxAh
    def get_rtgMaxChargeRateVA(self):
        return self.rtgMaxChargeRateVA
    def set_rtgMaxChargeRateVA(self, rtgMaxChargeRateVA):
        self.rtgMaxChargeRateVA = rtgMaxChargeRateVA
    def get_rtgMaxChargeRateW(self):
        return self.rtgMaxChargeRateW
    def set_rtgMaxChargeRateW(self, rtgMaxChargeRateW):
        self.rtgMaxChargeRateW = rtgMaxChargeRateW
    def get_rtgMaxDischargeRateVA(self):
        return self.rtgMaxDischargeRateVA
    def set_rtgMaxDischargeRateVA(self, rtgMaxDischargeRateVA):
        self.rtgMaxDischargeRateVA = rtgMaxDischargeRateVA
    def get_rtgMaxDischargeRateW(self):
        return self.rtgMaxDischargeRateW
    def set_rtgMaxDischargeRateW(self, rtgMaxDischargeRateW):
        self.rtgMaxDischargeRateW = rtgMaxDischargeRateW
    def get_rtgMaxV(self):
        return self.rtgMaxV
    def set_rtgMaxV(self, rtgMaxV):
        self.rtgMaxV = rtgMaxV
    def get_rtgMaxVA(self):
        return self.rtgMaxVA
    def set_rtgMaxVA(self, rtgMaxVA):
        self.rtgMaxVA = rtgMaxVA
    def get_rtgMaxVar(self):
        return self.rtgMaxVar
    def set_rtgMaxVar(self, rtgMaxVar):
        self.rtgMaxVar = rtgMaxVar
    def get_rtgMaxVarNeg(self):
        return self.rtgMaxVarNeg
    def set_rtgMaxVarNeg(self, rtgMaxVarNeg):
        self.rtgMaxVarNeg = rtgMaxVarNeg
    def get_rtgMaxW(self):
        return self.rtgMaxW
    def set_rtgMaxW(self, rtgMaxW):
        self.rtgMaxW = rtgMaxW
    def get_rtgMaxWh(self):
        return self.rtgMaxWh
    def set_rtgMaxWh(self, rtgMaxWh):
        self.rtgMaxWh = rtgMaxWh
    def get_rtgMinPFOverExcited(self):
        return self.rtgMinPFOverExcited
    def set_rtgMinPFOverExcited(self, rtgMinPFOverExcited):
        self.rtgMinPFOverExcited = rtgMinPFOverExcited
    def get_rtgMinPFUnderExcited(self):
        return self.rtgMinPFUnderExcited
    def set_rtgMinPFUnderExcited(self, rtgMinPFUnderExcited):
        self.rtgMinPFUnderExcited = rtgMinPFUnderExcited
    def get_rtgMinV(self):
        return self.rtgMinV
    def set_rtgMinV(self, rtgMinV):
        self.rtgMinV = rtgMinV
    def get_rtgNormalCategory(self):
        return self.rtgNormalCategory
    def set_rtgNormalCategory(self, rtgNormalCategory):
        self.rtgNormalCategory = rtgNormalCategory
    def get_rtgOverExcitedPF(self):
        return self.rtgOverExcitedPF
    def set_rtgOverExcitedPF(self, rtgOverExcitedPF):
        self.rtgOverExcitedPF = rtgOverExcitedPF
    def get_rtgOverExcitedW(self):
        return self.rtgOverExcitedW
    def set_rtgOverExcitedW(self, rtgOverExcitedW):
        self.rtgOverExcitedW = rtgOverExcitedW
    def get_rtgReactiveSusceptance(self):
        return self.rtgReactiveSusceptance
    def set_rtgReactiveSusceptance(self, rtgReactiveSusceptance):
        self.rtgReactiveSusceptance = rtgReactiveSusceptance
    def get_rtgUnderExcitedPF(self):
        return self.rtgUnderExcitedPF
    def set_rtgUnderExcitedPF(self, rtgUnderExcitedPF):
        self.rtgUnderExcitedPF = rtgUnderExcitedPF
    def get_rtgUnderExcitedW(self):
        return self.rtgUnderExcitedW
    def set_rtgUnderExcitedW(self, rtgUnderExcitedW):
        self.rtgUnderExcitedW = rtgUnderExcitedW
    def get_rtgVNom(self):
        return self.rtgVNom
    def set_rtgVNom(self, rtgVNom):
        self.rtgVNom = rtgVNom
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.modesSupported is not None or
            self.rtgAbnormalCategory is not None or
            self.rtgMaxA is not None or
            self.rtgMaxAh is not None or
            self.rtgMaxChargeRateVA is not None or
            self.rtgMaxChargeRateW is not None or
            self.rtgMaxDischargeRateVA is not None or
            self.rtgMaxDischargeRateW is not None or
            self.rtgMaxV is not None or
            self.rtgMaxVA is not None or
            self.rtgMaxVar is not None or
            self.rtgMaxVarNeg is not None or
            self.rtgMaxW is not None or
            self.rtgMaxWh is not None or
            self.rtgMinPFOverExcited is not None or
            self.rtgMinPFUnderExcited is not None or
            self.rtgMinV is not None or
            self.rtgNormalCategory is not None or
            self.rtgOverExcitedPF is not None or
            self.rtgOverExcitedW is not None or
            self.rtgReactiveSusceptance is not None or
            self.rtgUnderExcitedPF is not None or
            self.rtgUnderExcitedW is not None or
            self.rtgVNom is not None or
            self.type_ is not None or
            super(DERCapability, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERCapability', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERCapability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERCapability':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCapability')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERCapability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERCapability'):
        super(DERCapability, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERCapability')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERCapability', fromsubclass_=False, pretty_print=True):
        super(DERCapability, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.modesSupported is not None:
            namespaceprefix_ = self.modesSupported_nsprefix_ + ':' if (UseCapturedNS_ and self.modesSupported_nsprefix_) else ''
            self.modesSupported.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modesSupported', pretty_print=pretty_print)
        if self.rtgAbnormalCategory is not None:
            namespaceprefix_ = self.rtgAbnormalCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgAbnormalCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtgAbnormalCategory>%s</%srtgAbnormalCategory>%s' % (namespaceprefix_ , self.gds_format_integer(self.rtgAbnormalCategory, input_name='rtgAbnormalCategory'), namespaceprefix_ , eol_))
        if self.rtgMaxA is not None:
            namespaceprefix_ = self.rtgMaxA_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxA_nsprefix_) else ''
            self.rtgMaxA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxA', pretty_print=pretty_print)
        if self.rtgMaxAh is not None:
            namespaceprefix_ = self.rtgMaxAh_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxAh_nsprefix_) else ''
            self.rtgMaxAh.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxAh', pretty_print=pretty_print)
        if self.rtgMaxChargeRateVA is not None:
            namespaceprefix_ = self.rtgMaxChargeRateVA_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxChargeRateVA_nsprefix_) else ''
            self.rtgMaxChargeRateVA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxChargeRateVA', pretty_print=pretty_print)
        if self.rtgMaxChargeRateW is not None:
            namespaceprefix_ = self.rtgMaxChargeRateW_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxChargeRateW_nsprefix_) else ''
            self.rtgMaxChargeRateW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxChargeRateW', pretty_print=pretty_print)
        if self.rtgMaxDischargeRateVA is not None:
            namespaceprefix_ = self.rtgMaxDischargeRateVA_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxDischargeRateVA_nsprefix_) else ''
            self.rtgMaxDischargeRateVA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxDischargeRateVA', pretty_print=pretty_print)
        if self.rtgMaxDischargeRateW is not None:
            namespaceprefix_ = self.rtgMaxDischargeRateW_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxDischargeRateW_nsprefix_) else ''
            self.rtgMaxDischargeRateW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxDischargeRateW', pretty_print=pretty_print)
        if self.rtgMaxV is not None:
            namespaceprefix_ = self.rtgMaxV_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxV_nsprefix_) else ''
            self.rtgMaxV.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxV', pretty_print=pretty_print)
        if self.rtgMaxVA is not None:
            namespaceprefix_ = self.rtgMaxVA_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxVA_nsprefix_) else ''
            self.rtgMaxVA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxVA', pretty_print=pretty_print)
        if self.rtgMaxVar is not None:
            namespaceprefix_ = self.rtgMaxVar_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxVar_nsprefix_) else ''
            self.rtgMaxVar.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxVar', pretty_print=pretty_print)
        if self.rtgMaxVarNeg is not None:
            namespaceprefix_ = self.rtgMaxVarNeg_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxVarNeg_nsprefix_) else ''
            self.rtgMaxVarNeg.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxVarNeg', pretty_print=pretty_print)
        if self.rtgMaxW is not None:
            namespaceprefix_ = self.rtgMaxW_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxW_nsprefix_) else ''
            self.rtgMaxW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxW', pretty_print=pretty_print)
        if self.rtgMaxWh is not None:
            namespaceprefix_ = self.rtgMaxWh_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMaxWh_nsprefix_) else ''
            self.rtgMaxWh.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMaxWh', pretty_print=pretty_print)
        if self.rtgMinPFOverExcited is not None:
            namespaceprefix_ = self.rtgMinPFOverExcited_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMinPFOverExcited_nsprefix_) else ''
            self.rtgMinPFOverExcited.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMinPFOverExcited', pretty_print=pretty_print)
        if self.rtgMinPFUnderExcited is not None:
            namespaceprefix_ = self.rtgMinPFUnderExcited_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMinPFUnderExcited_nsprefix_) else ''
            self.rtgMinPFUnderExcited.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMinPFUnderExcited', pretty_print=pretty_print)
        if self.rtgMinV is not None:
            namespaceprefix_ = self.rtgMinV_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgMinV_nsprefix_) else ''
            self.rtgMinV.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgMinV', pretty_print=pretty_print)
        if self.rtgNormalCategory is not None:
            namespaceprefix_ = self.rtgNormalCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgNormalCategory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srtgNormalCategory>%s</%srtgNormalCategory>%s' % (namespaceprefix_ , self.gds_format_integer(self.rtgNormalCategory, input_name='rtgNormalCategory'), namespaceprefix_ , eol_))
        if self.rtgOverExcitedPF is not None:
            namespaceprefix_ = self.rtgOverExcitedPF_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgOverExcitedPF_nsprefix_) else ''
            self.rtgOverExcitedPF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgOverExcitedPF', pretty_print=pretty_print)
        if self.rtgOverExcitedW is not None:
            namespaceprefix_ = self.rtgOverExcitedW_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgOverExcitedW_nsprefix_) else ''
            self.rtgOverExcitedW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgOverExcitedW', pretty_print=pretty_print)
        if self.rtgReactiveSusceptance is not None:
            namespaceprefix_ = self.rtgReactiveSusceptance_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgReactiveSusceptance_nsprefix_) else ''
            self.rtgReactiveSusceptance.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgReactiveSusceptance', pretty_print=pretty_print)
        if self.rtgUnderExcitedPF is not None:
            namespaceprefix_ = self.rtgUnderExcitedPF_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgUnderExcitedPF_nsprefix_) else ''
            self.rtgUnderExcitedPF.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgUnderExcitedPF', pretty_print=pretty_print)
        if self.rtgUnderExcitedW is not None:
            namespaceprefix_ = self.rtgUnderExcitedW_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgUnderExcitedW_nsprefix_) else ''
            self.rtgUnderExcitedW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgUnderExcitedW', pretty_print=pretty_print)
        if self.rtgVNom is not None:
            namespaceprefix_ = self.rtgVNom_nsprefix_ + ':' if (UseCapturedNS_ and self.rtgVNom_nsprefix_) else ''
            self.rtgVNom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='rtgVNom', pretty_print=pretty_print)
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            self.type_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='type', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERCapability, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'modesSupported':
            obj_ = DERControlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modesSupported = obj_
            obj_.original_tagname_ = 'modesSupported'
        elif nodeName_ == 'rtgAbnormalCategory' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'rtgAbnormalCategory')
            ival_ = self.gds_validate_integer(ival_, node, 'rtgAbnormalCategory')
            self.rtgAbnormalCategory = ival_
            self.rtgAbnormalCategory_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.rtgAbnormalCategory)
        elif nodeName_ == 'rtgMaxA':
            obj_ = CurrentRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxA = obj_
            obj_.original_tagname_ = 'rtgMaxA'
        elif nodeName_ == 'rtgMaxAh':
            obj_ = AmpereHour.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxAh = obj_
            obj_.original_tagname_ = 'rtgMaxAh'
        elif nodeName_ == 'rtgMaxChargeRateVA':
            obj_ = ApparentPower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxChargeRateVA = obj_
            obj_.original_tagname_ = 'rtgMaxChargeRateVA'
        elif nodeName_ == 'rtgMaxChargeRateW':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxChargeRateW = obj_
            obj_.original_tagname_ = 'rtgMaxChargeRateW'
        elif nodeName_ == 'rtgMaxDischargeRateVA':
            obj_ = ApparentPower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxDischargeRateVA = obj_
            obj_.original_tagname_ = 'rtgMaxDischargeRateVA'
        elif nodeName_ == 'rtgMaxDischargeRateW':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxDischargeRateW = obj_
            obj_.original_tagname_ = 'rtgMaxDischargeRateW'
        elif nodeName_ == 'rtgMaxV':
            obj_ = VoltageRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxV = obj_
            obj_.original_tagname_ = 'rtgMaxV'
        elif nodeName_ == 'rtgMaxVA':
            obj_ = ApparentPower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxVA = obj_
            obj_.original_tagname_ = 'rtgMaxVA'
        elif nodeName_ == 'rtgMaxVar':
            obj_ = ReactivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxVar = obj_
            obj_.original_tagname_ = 'rtgMaxVar'
        elif nodeName_ == 'rtgMaxVarNeg':
            obj_ = ReactivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxVarNeg = obj_
            obj_.original_tagname_ = 'rtgMaxVarNeg'
        elif nodeName_ == 'rtgMaxW':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxW = obj_
            obj_.original_tagname_ = 'rtgMaxW'
        elif nodeName_ == 'rtgMaxWh':
            obj_ = WattHour.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMaxWh = obj_
            obj_.original_tagname_ = 'rtgMaxWh'
        elif nodeName_ == 'rtgMinPFOverExcited':
            obj_ = PowerFactor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMinPFOverExcited = obj_
            obj_.original_tagname_ = 'rtgMinPFOverExcited'
        elif nodeName_ == 'rtgMinPFUnderExcited':
            obj_ = PowerFactor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMinPFUnderExcited = obj_
            obj_.original_tagname_ = 'rtgMinPFUnderExcited'
        elif nodeName_ == 'rtgMinV':
            obj_ = VoltageRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgMinV = obj_
            obj_.original_tagname_ = 'rtgMinV'
        elif nodeName_ == 'rtgNormalCategory' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'rtgNormalCategory')
            ival_ = self.gds_validate_integer(ival_, node, 'rtgNormalCategory')
            self.rtgNormalCategory = ival_
            self.rtgNormalCategory_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.rtgNormalCategory)
        elif nodeName_ == 'rtgOverExcitedPF':
            obj_ = PowerFactor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgOverExcitedPF = obj_
            obj_.original_tagname_ = 'rtgOverExcitedPF'
        elif nodeName_ == 'rtgOverExcitedW':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgOverExcitedW = obj_
            obj_.original_tagname_ = 'rtgOverExcitedW'
        elif nodeName_ == 'rtgReactiveSusceptance':
            obj_ = ReactiveSusceptance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgReactiveSusceptance = obj_
            obj_.original_tagname_ = 'rtgReactiveSusceptance'
        elif nodeName_ == 'rtgUnderExcitedPF':
            obj_ = PowerFactor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgUnderExcitedPF = obj_
            obj_.original_tagname_ = 'rtgUnderExcitedPF'
        elif nodeName_ == 'rtgUnderExcitedW':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgUnderExcitedW = obj_
            obj_.original_tagname_ = 'rtgUnderExcitedW'
        elif nodeName_ == 'rtgVNom':
            obj_ = VoltageRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.rtgVNom = obj_
            obj_.original_tagname_ = 'rtgVNom'
        elif nodeName_ == 'type':
            obj_ = DERType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.type_ = obj_
            obj_.original_tagname_ = 'type'
        super(DERCapability, self)._buildChildren(child_, node, nodeName_, True)
# end class DERCapability


class DERAvailability(SubscribableResource):
    """DERAvailability -- Indicates current reserve generation status
    availabilityDuration -- Indicates number of seconds the DER will be able to deliver active power at the reservePercent level.
    maxChargeDuration -- Indicates number of seconds the DER will be able to receive active power at the reserveChargePercent level.
    readingTime -- The timestamp when the DER availability was last updated.
    reserveChargePercent -- Percent of continuous received active power (%setMaxChargeRateW) that is estimated to be available in reserve.
    reservePercent -- Percent of continuous delivered active power (%setMaxW) that is estimated to be available in reserve.
    statVarAvail -- Estimated reserve reactive power, in var.  Represents the lesser of received or delivered reactive power.
    statWAvail -- Estimated reserve active power, in watts.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableResource
    def __init__(self, availabilityDuration=None, maxChargeDuration=None, readingTime=None, reserveChargePercent=None, reservePercent=None, statVarAvail=None, statWAvail=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERAvailability"), self).__init__( **kwargs_)
        self.availabilityDuration = availabilityDuration
        self.validate_UInt32(self.availabilityDuration)
        self.availabilityDuration_nsprefix_ = None
        self.maxChargeDuration = maxChargeDuration
        self.validate_UInt32(self.maxChargeDuration)
        self.maxChargeDuration_nsprefix_ = None
        self.readingTime = readingTime
        self.readingTime_nsprefix_ = None
        self.reserveChargePercent = reserveChargePercent
        self.reserveChargePercent_nsprefix_ = None
        self.reservePercent = reservePercent
        self.reservePercent_nsprefix_ = None
        self.statVarAvail = statVarAvail
        self.statVarAvail_nsprefix_ = None
        self.statWAvail = statWAvail
        self.statWAvail_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERAvailability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERAvailability.subclass:
            return DERAvailability.subclass(*args_, **kwargs_)
        else:
            return DERAvailability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_availabilityDuration(self):
        return self.availabilityDuration
    def set_availabilityDuration(self, availabilityDuration):
        self.availabilityDuration = availabilityDuration
    def get_maxChargeDuration(self):
        return self.maxChargeDuration
    def set_maxChargeDuration(self, maxChargeDuration):
        self.maxChargeDuration = maxChargeDuration
    def get_readingTime(self):
        return self.readingTime
    def set_readingTime(self, readingTime):
        self.readingTime = readingTime
    def get_reserveChargePercent(self):
        return self.reserveChargePercent
    def set_reserveChargePercent(self, reserveChargePercent):
        self.reserveChargePercent = reserveChargePercent
    def get_reservePercent(self):
        return self.reservePercent
    def set_reservePercent(self, reservePercent):
        self.reservePercent = reservePercent
    def get_statVarAvail(self):
        return self.statVarAvail
    def set_statVarAvail(self, statVarAvail):
        self.statVarAvail = statVarAvail
    def get_statWAvail(self):
        return self.statWAvail
    def set_statWAvail(self, statWAvail):
        self.statWAvail = statWAvail
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.availabilityDuration is not None or
            self.maxChargeDuration is not None or
            self.readingTime is not None or
            self.reserveChargePercent is not None or
            self.reservePercent is not None or
            self.statVarAvail is not None or
            self.statWAvail is not None or
            super(DERAvailability, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERAvailability', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERAvailability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERAvailability':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERAvailability')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERAvailability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERAvailability'):
        super(DERAvailability, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERAvailability')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERAvailability', fromsubclass_=False, pretty_print=True):
        super(DERAvailability, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.availabilityDuration is not None:
            namespaceprefix_ = self.availabilityDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityDuration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailabilityDuration>%s</%savailabilityDuration>%s' % (namespaceprefix_ , self.gds_format_integer(self.availabilityDuration, input_name='availabilityDuration'), namespaceprefix_ , eol_))
        if self.maxChargeDuration is not None:
            namespaceprefix_ = self.maxChargeDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.maxChargeDuration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxChargeDuration>%s</%smaxChargeDuration>%s' % (namespaceprefix_ , self.gds_format_integer(self.maxChargeDuration, input_name='maxChargeDuration'), namespaceprefix_ , eol_))
        if self.readingTime is not None:
            namespaceprefix_ = self.readingTime_nsprefix_ + ':' if (UseCapturedNS_ and self.readingTime_nsprefix_) else ''
            self.readingTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='readingTime', pretty_print=pretty_print)
        if self.reserveChargePercent is not None:
            namespaceprefix_ = self.reserveChargePercent_nsprefix_ + ':' if (UseCapturedNS_ and self.reserveChargePercent_nsprefix_) else ''
            self.reserveChargePercent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reserveChargePercent', pretty_print=pretty_print)
        if self.reservePercent is not None:
            namespaceprefix_ = self.reservePercent_nsprefix_ + ':' if (UseCapturedNS_ and self.reservePercent_nsprefix_) else ''
            self.reservePercent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='reservePercent', pretty_print=pretty_print)
        if self.statVarAvail is not None:
            namespaceprefix_ = self.statVarAvail_nsprefix_ + ':' if (UseCapturedNS_ and self.statVarAvail_nsprefix_) else ''
            self.statVarAvail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statVarAvail', pretty_print=pretty_print)
        if self.statWAvail is not None:
            namespaceprefix_ = self.statWAvail_nsprefix_ + ':' if (UseCapturedNS_ and self.statWAvail_nsprefix_) else ''
            self.statWAvail.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statWAvail', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERAvailability, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'availabilityDuration' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'availabilityDuration')
            ival_ = self.gds_validate_integer(ival_, node, 'availabilityDuration')
            self.availabilityDuration = ival_
            self.availabilityDuration_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.availabilityDuration)
        elif nodeName_ == 'maxChargeDuration' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'maxChargeDuration')
            ival_ = self.gds_validate_integer(ival_, node, 'maxChargeDuration')
            self.maxChargeDuration = ival_
            self.maxChargeDuration_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.maxChargeDuration)
        elif nodeName_ == 'readingTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.readingTime = obj_
            obj_.original_tagname_ = 'readingTime'
        elif nodeName_ == 'reserveChargePercent':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reserveChargePercent = obj_
            obj_.original_tagname_ = 'reserveChargePercent'
        elif nodeName_ == 'reservePercent':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.reservePercent = obj_
            obj_.original_tagname_ = 'reservePercent'
        elif nodeName_ == 'statVarAvail':
            obj_ = ReactivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statVarAvail = obj_
            obj_.original_tagname_ = 'statVarAvail'
        elif nodeName_ == 'statWAvail':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statWAvail = obj_
            obj_.original_tagname_ = 'statWAvail'
        super(DERAvailability, self)._buildChildren(child_, node, nodeName_, True)
# end class DERAvailability


class DERSettings(SubscribableResource):
    """DERSettings -- Distributed energy resource settings
    modesEnabled -- Bitmap indicating the DER Controls enabled on the device. See DERControlType for values. If a control is supported (see DERCapability::modesSupported), but not enabled, the control will not be executed if encountered.
    setESDelay -- Enter service delay, in hundredths of a second.
    setESHighFreq -- Enter service frequency high. Specified in hundredths of Hz.
    setESHighVolt -- Enter service voltage high. Specified as an effective percent voltage, defined as (100% * (locally measured voltage - setVRefOfs) / setVRef), in hundredths of a percent.
    setESLowFreq -- Enter service frequency low. Specified in hundredths of Hz.
    setESLowVolt -- Enter service voltage low. Specified as an effective percent voltage, defined as (100% * (locally measured voltage - setVRefOfs) / setVRef), in hundredths of a percent.
    setESRampTms -- Enter service ramp time, in hundredths of a second.
    setESRandomDelay -- Enter service randomized delay, in hundredths of a second.
    setGradW -- Set default rate of change (ramp rate) of active power output due to command or internal action, defined in %setWMax / second.  Resolution is in hundredths of a percent/second. A value of 0 means there is no limit. Interpreted as a percentage change in output capability limit per second when used as a default ramp rate.
    setMaxA -- AC current maximum. Maximum AC current in RMS Amperes.
    setMaxAh -- Maximum usable energy storage capacity of the DER, in AmpHours. Note: this may be different from physical capability.
    setMaxChargeRateVA -- Apparent power charge maximum. Maximum apparent power the DER can absorb from the grid in Volt-Amperes. May differ from the apparent power maximum (setMaxVA).
    setMaxChargeRateW -- Maximum rate of energy transfer received by the storage device, in Watts. Defaults to rtgMaxChargeRateW.
    setMaxDischargeRateVA -- Apparent power discharge maximum. Maximum apparent power the DER can deliver to the grid in Volt-Amperes. May differ from the apparent power maximum (setMaxVA).
    setMaxDischargeRateW -- Maximum rate of energy transfer delivered by the storage device, in Watts. Defaults to rtgMaxDischargeRateW.
    setMaxV -- AC voltage maximum setting.
    setMaxVA -- Set limit for maximum apparent power capability of the DER (in VA). Defaults to rtgMaxVA.
    setMaxVar -- Set limit for maximum reactive power delivered by the DER (in var). SHALL be a positive value
    &
    lt;= rtgMaxVar (default).
    setMaxVarNeg -- Set limit for maximum reactive power received by the DER (in var). If present, SHALL be a negative value
    &
    gt;= rtgMaxVarNeg (default). If absent, defaults to negative setMaxVar.
    setMaxW -- Set limit for maximum active power capability of the DER (in W). Defaults to rtgMaxW.
    setMaxWh -- Maximum energy storage capacity of the DER, in WattHours. Note: this may be different from physical capability.
    setMinPFOverExcited -- Set minimum Power Factor displacement limit of the DER when injecting reactive power (over-excited); SHALL be a positive value between 0.0 (typically
    &
    gt; 0.7) and 1.0.  SHALL be
    &
    gt;= rtgMinPFOverExcited (default).
    setMinPFUnderExcited -- Set minimum Power Factor displacement limit of the DER when absorbing reactive power (under-excited); SHALL be a positive value between 0.0 (typically
    &
    gt; 0.7) and 0.9999.  If present, SHALL be
    &
    gt;= rtgMinPFUnderExcited (default).  If absent, defaults to setMinPFOverExcited.
    setMinV -- AC voltage minimum setting.
    setSoftGradW -- Set soft-start rate of change (soft-start ramp rate) of active power output due to command or internal action, defined in %setWMax / second.  Resolution is in hundredths of a percent/second. A value of 0 means there is no limit. Interpreted as a percentage change in output capability limit per second when used as a ramp rate.
    setVNom -- AC voltage nominal setting.
    setVRef -- The nominal AC voltage (RMS) at the utility's point of common coupling.
    setVRefOfs -- The nominal AC voltage (RMS) offset between the DER's electrical connection point and the utility's point of common coupling.
    updatedTime -- Specifies the time at which the DER information was last updated.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableResource
    def __init__(self, modesEnabled=None, setESDelay=None, setESHighFreq=None, setESHighVolt=None, setESLowFreq=None, setESLowVolt=None, setESRampTms=None, setESRandomDelay=None, setGradW=None, setMaxA=None, setMaxAh=None, setMaxChargeRateVA=None, setMaxChargeRateW=None, setMaxDischargeRateVA=None, setMaxDischargeRateW=None, setMaxV=None, setMaxVA=None, setMaxVar=None, setMaxVarNeg=None, setMaxW=None, setMaxWh=None, setMinPFOverExcited=None, setMinPFUnderExcited=None, setMinV=None, setSoftGradW=None, setVNom=None, setVRef=None, setVRefOfs=None, updatedTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERSettings"), self).__init__( **kwargs_)
        self.modesEnabled = modesEnabled
        self.modesEnabled_nsprefix_ = None
        self.setESDelay = setESDelay
        self.validate_UInt32(self.setESDelay)
        self.setESDelay_nsprefix_ = None
        self.setESHighFreq = setESHighFreq
        self.validate_UInt16(self.setESHighFreq)
        self.setESHighFreq_nsprefix_ = None
        self.setESHighVolt = setESHighVolt
        self.validate_Int16(self.setESHighVolt)
        self.setESHighVolt_nsprefix_ = None
        self.setESLowFreq = setESLowFreq
        self.validate_UInt16(self.setESLowFreq)
        self.setESLowFreq_nsprefix_ = None
        self.setESLowVolt = setESLowVolt
        self.validate_Int16(self.setESLowVolt)
        self.setESLowVolt_nsprefix_ = None
        self.setESRampTms = setESRampTms
        self.validate_UInt32(self.setESRampTms)
        self.setESRampTms_nsprefix_ = None
        self.setESRandomDelay = setESRandomDelay
        self.validate_UInt32(self.setESRandomDelay)
        self.setESRandomDelay_nsprefix_ = None
        self.setGradW = setGradW
        self.validate_UInt16(self.setGradW)
        self.setGradW_nsprefix_ = None
        self.setMaxA = setMaxA
        self.setMaxA_nsprefix_ = None
        self.setMaxAh = setMaxAh
        self.setMaxAh_nsprefix_ = None
        self.setMaxChargeRateVA = setMaxChargeRateVA
        self.setMaxChargeRateVA_nsprefix_ = None
        self.setMaxChargeRateW = setMaxChargeRateW
        self.setMaxChargeRateW_nsprefix_ = None
        self.setMaxDischargeRateVA = setMaxDischargeRateVA
        self.setMaxDischargeRateVA_nsprefix_ = None
        self.setMaxDischargeRateW = setMaxDischargeRateW
        self.setMaxDischargeRateW_nsprefix_ = None
        self.setMaxV = setMaxV
        self.setMaxV_nsprefix_ = None
        self.setMaxVA = setMaxVA
        self.setMaxVA_nsprefix_ = None
        self.setMaxVar = setMaxVar
        self.setMaxVar_nsprefix_ = None
        self.setMaxVarNeg = setMaxVarNeg
        self.setMaxVarNeg_nsprefix_ = None
        self.setMaxW = setMaxW
        self.setMaxW_nsprefix_ = None
        self.setMaxWh = setMaxWh
        self.setMaxWh_nsprefix_ = None
        self.setMinPFOverExcited = setMinPFOverExcited
        self.setMinPFOverExcited_nsprefix_ = None
        self.setMinPFUnderExcited = setMinPFUnderExcited
        self.setMinPFUnderExcited_nsprefix_ = None
        self.setMinV = setMinV
        self.setMinV_nsprefix_ = None
        self.setSoftGradW = setSoftGradW
        self.validate_UInt16(self.setSoftGradW)
        self.setSoftGradW_nsprefix_ = None
        self.setVNom = setVNom
        self.setVNom_nsprefix_ = None
        self.setVRef = setVRef
        self.setVRef_nsprefix_ = None
        self.setVRefOfs = setVRefOfs
        self.setVRefOfs_nsprefix_ = None
        self.updatedTime = updatedTime
        self.updatedTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERSettings)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERSettings.subclass:
            return DERSettings.subclass(*args_, **kwargs_)
        else:
            return DERSettings(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_modesEnabled(self):
        return self.modesEnabled
    def set_modesEnabled(self, modesEnabled):
        self.modesEnabled = modesEnabled
    def get_setESDelay(self):
        return self.setESDelay
    def set_setESDelay(self, setESDelay):
        self.setESDelay = setESDelay
    def get_setESHighFreq(self):
        return self.setESHighFreq
    def set_setESHighFreq(self, setESHighFreq):
        self.setESHighFreq = setESHighFreq
    def get_setESHighVolt(self):
        return self.setESHighVolt
    def set_setESHighVolt(self, setESHighVolt):
        self.setESHighVolt = setESHighVolt
    def get_setESLowFreq(self):
        return self.setESLowFreq
    def set_setESLowFreq(self, setESLowFreq):
        self.setESLowFreq = setESLowFreq
    def get_setESLowVolt(self):
        return self.setESLowVolt
    def set_setESLowVolt(self, setESLowVolt):
        self.setESLowVolt = setESLowVolt
    def get_setESRampTms(self):
        return self.setESRampTms
    def set_setESRampTms(self, setESRampTms):
        self.setESRampTms = setESRampTms
    def get_setESRandomDelay(self):
        return self.setESRandomDelay
    def set_setESRandomDelay(self, setESRandomDelay):
        self.setESRandomDelay = setESRandomDelay
    def get_setGradW(self):
        return self.setGradW
    def set_setGradW(self, setGradW):
        self.setGradW = setGradW
    def get_setMaxA(self):
        return self.setMaxA
    def set_setMaxA(self, setMaxA):
        self.setMaxA = setMaxA
    def get_setMaxAh(self):
        return self.setMaxAh
    def set_setMaxAh(self, setMaxAh):
        self.setMaxAh = setMaxAh
    def get_setMaxChargeRateVA(self):
        return self.setMaxChargeRateVA
    def set_setMaxChargeRateVA(self, setMaxChargeRateVA):
        self.setMaxChargeRateVA = setMaxChargeRateVA
    def get_setMaxChargeRateW(self):
        return self.setMaxChargeRateW
    def set_setMaxChargeRateW(self, setMaxChargeRateW):
        self.setMaxChargeRateW = setMaxChargeRateW
    def get_setMaxDischargeRateVA(self):
        return self.setMaxDischargeRateVA
    def set_setMaxDischargeRateVA(self, setMaxDischargeRateVA):
        self.setMaxDischargeRateVA = setMaxDischargeRateVA
    def get_setMaxDischargeRateW(self):
        return self.setMaxDischargeRateW
    def set_setMaxDischargeRateW(self, setMaxDischargeRateW):
        self.setMaxDischargeRateW = setMaxDischargeRateW
    def get_setMaxV(self):
        return self.setMaxV
    def set_setMaxV(self, setMaxV):
        self.setMaxV = setMaxV
    def get_setMaxVA(self):
        return self.setMaxVA
    def set_setMaxVA(self, setMaxVA):
        self.setMaxVA = setMaxVA
    def get_setMaxVar(self):
        return self.setMaxVar
    def set_setMaxVar(self, setMaxVar):
        self.setMaxVar = setMaxVar
    def get_setMaxVarNeg(self):
        return self.setMaxVarNeg
    def set_setMaxVarNeg(self, setMaxVarNeg):
        self.setMaxVarNeg = setMaxVarNeg
    def get_setMaxW(self):
        return self.setMaxW
    def set_setMaxW(self, setMaxW):
        self.setMaxW = setMaxW
    def get_setMaxWh(self):
        return self.setMaxWh
    def set_setMaxWh(self, setMaxWh):
        self.setMaxWh = setMaxWh
    def get_setMinPFOverExcited(self):
        return self.setMinPFOverExcited
    def set_setMinPFOverExcited(self, setMinPFOverExcited):
        self.setMinPFOverExcited = setMinPFOverExcited
    def get_setMinPFUnderExcited(self):
        return self.setMinPFUnderExcited
    def set_setMinPFUnderExcited(self, setMinPFUnderExcited):
        self.setMinPFUnderExcited = setMinPFUnderExcited
    def get_setMinV(self):
        return self.setMinV
    def set_setMinV(self, setMinV):
        self.setMinV = setMinV
    def get_setSoftGradW(self):
        return self.setSoftGradW
    def set_setSoftGradW(self, setSoftGradW):
        self.setSoftGradW = setSoftGradW
    def get_setVNom(self):
        return self.setVNom
    def set_setVNom(self, setVNom):
        self.setVNom = setVNom
    def get_setVRef(self):
        return self.setVRef
    def set_setVRef(self, setVRef):
        self.setVRef = setVRef
    def get_setVRefOfs(self):
        return self.setVRefOfs
    def set_setVRefOfs(self, setVRefOfs):
        self.setVRefOfs = setVRefOfs
    def get_updatedTime(self):
        return self.updatedTime
    def set_updatedTime(self, updatedTime):
        self.updatedTime = updatedTime
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Int16(self, value):
        result = True
        # Validate type Int16, a restriction on xs:short.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.modesEnabled is not None or
            self.setESDelay is not None or
            self.setESHighFreq is not None or
            self.setESHighVolt is not None or
            self.setESLowFreq is not None or
            self.setESLowVolt is not None or
            self.setESRampTms is not None or
            self.setESRandomDelay is not None or
            self.setGradW is not None or
            self.setMaxA is not None or
            self.setMaxAh is not None or
            self.setMaxChargeRateVA is not None or
            self.setMaxChargeRateW is not None or
            self.setMaxDischargeRateVA is not None or
            self.setMaxDischargeRateW is not None or
            self.setMaxV is not None or
            self.setMaxVA is not None or
            self.setMaxVar is not None or
            self.setMaxVarNeg is not None or
            self.setMaxW is not None or
            self.setMaxWh is not None or
            self.setMinPFOverExcited is not None or
            self.setMinPFUnderExcited is not None or
            self.setMinV is not None or
            self.setSoftGradW is not None or
            self.setVNom is not None or
            self.setVRef is not None or
            self.setVRefOfs is not None or
            self.updatedTime is not None or
            super(DERSettings, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERSettings', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERSettings')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERSettings':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERSettings')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERSettings', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERSettings'):
        super(DERSettings, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERSettings')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERSettings', fromsubclass_=False, pretty_print=True):
        super(DERSettings, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.modesEnabled is not None:
            namespaceprefix_ = self.modesEnabled_nsprefix_ + ':' if (UseCapturedNS_ and self.modesEnabled_nsprefix_) else ''
            self.modesEnabled.export(outfile, level, namespaceprefix_, namespacedef_='', name_='modesEnabled', pretty_print=pretty_print)
        if self.setESDelay is not None:
            namespaceprefix_ = self.setESDelay_nsprefix_ + ':' if (UseCapturedNS_ and self.setESDelay_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESDelay>%s</%ssetESDelay>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESDelay, input_name='setESDelay'), namespaceprefix_ , eol_))
        if self.setESHighFreq is not None:
            namespaceprefix_ = self.setESHighFreq_nsprefix_ + ':' if (UseCapturedNS_ and self.setESHighFreq_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESHighFreq>%s</%ssetESHighFreq>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESHighFreq, input_name='setESHighFreq'), namespaceprefix_ , eol_))
        if self.setESHighVolt is not None:
            namespaceprefix_ = self.setESHighVolt_nsprefix_ + ':' if (UseCapturedNS_ and self.setESHighVolt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESHighVolt>%s</%ssetESHighVolt>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESHighVolt, input_name='setESHighVolt'), namespaceprefix_ , eol_))
        if self.setESLowFreq is not None:
            namespaceprefix_ = self.setESLowFreq_nsprefix_ + ':' if (UseCapturedNS_ and self.setESLowFreq_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESLowFreq>%s</%ssetESLowFreq>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESLowFreq, input_name='setESLowFreq'), namespaceprefix_ , eol_))
        if self.setESLowVolt is not None:
            namespaceprefix_ = self.setESLowVolt_nsprefix_ + ':' if (UseCapturedNS_ and self.setESLowVolt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESLowVolt>%s</%ssetESLowVolt>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESLowVolt, input_name='setESLowVolt'), namespaceprefix_ , eol_))
        if self.setESRampTms is not None:
            namespaceprefix_ = self.setESRampTms_nsprefix_ + ':' if (UseCapturedNS_ and self.setESRampTms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESRampTms>%s</%ssetESRampTms>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESRampTms, input_name='setESRampTms'), namespaceprefix_ , eol_))
        if self.setESRandomDelay is not None:
            namespaceprefix_ = self.setESRandomDelay_nsprefix_ + ':' if (UseCapturedNS_ and self.setESRandomDelay_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESRandomDelay>%s</%ssetESRandomDelay>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESRandomDelay, input_name='setESRandomDelay'), namespaceprefix_ , eol_))
        if self.setGradW is not None:
            namespaceprefix_ = self.setGradW_nsprefix_ + ':' if (UseCapturedNS_ and self.setGradW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetGradW>%s</%ssetGradW>%s' % (namespaceprefix_ , self.gds_format_integer(self.setGradW, input_name='setGradW'), namespaceprefix_ , eol_))
        if self.setMaxA is not None:
            namespaceprefix_ = self.setMaxA_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxA_nsprefix_) else ''
            self.setMaxA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxA', pretty_print=pretty_print)
        if self.setMaxAh is not None:
            namespaceprefix_ = self.setMaxAh_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxAh_nsprefix_) else ''
            self.setMaxAh.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxAh', pretty_print=pretty_print)
        if self.setMaxChargeRateVA is not None:
            namespaceprefix_ = self.setMaxChargeRateVA_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxChargeRateVA_nsprefix_) else ''
            self.setMaxChargeRateVA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxChargeRateVA', pretty_print=pretty_print)
        if self.setMaxChargeRateW is not None:
            namespaceprefix_ = self.setMaxChargeRateW_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxChargeRateW_nsprefix_) else ''
            self.setMaxChargeRateW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxChargeRateW', pretty_print=pretty_print)
        if self.setMaxDischargeRateVA is not None:
            namespaceprefix_ = self.setMaxDischargeRateVA_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxDischargeRateVA_nsprefix_) else ''
            self.setMaxDischargeRateVA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxDischargeRateVA', pretty_print=pretty_print)
        if self.setMaxDischargeRateW is not None:
            namespaceprefix_ = self.setMaxDischargeRateW_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxDischargeRateW_nsprefix_) else ''
            self.setMaxDischargeRateW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxDischargeRateW', pretty_print=pretty_print)
        if self.setMaxV is not None:
            namespaceprefix_ = self.setMaxV_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxV_nsprefix_) else ''
            self.setMaxV.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxV', pretty_print=pretty_print)
        if self.setMaxVA is not None:
            namespaceprefix_ = self.setMaxVA_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxVA_nsprefix_) else ''
            self.setMaxVA.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxVA', pretty_print=pretty_print)
        if self.setMaxVar is not None:
            namespaceprefix_ = self.setMaxVar_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxVar_nsprefix_) else ''
            self.setMaxVar.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxVar', pretty_print=pretty_print)
        if self.setMaxVarNeg is not None:
            namespaceprefix_ = self.setMaxVarNeg_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxVarNeg_nsprefix_) else ''
            self.setMaxVarNeg.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxVarNeg', pretty_print=pretty_print)
        if self.setMaxW is not None:
            namespaceprefix_ = self.setMaxW_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxW_nsprefix_) else ''
            self.setMaxW.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxW', pretty_print=pretty_print)
        if self.setMaxWh is not None:
            namespaceprefix_ = self.setMaxWh_nsprefix_ + ':' if (UseCapturedNS_ and self.setMaxWh_nsprefix_) else ''
            self.setMaxWh.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMaxWh', pretty_print=pretty_print)
        if self.setMinPFOverExcited is not None:
            namespaceprefix_ = self.setMinPFOverExcited_nsprefix_ + ':' if (UseCapturedNS_ and self.setMinPFOverExcited_nsprefix_) else ''
            self.setMinPFOverExcited.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMinPFOverExcited', pretty_print=pretty_print)
        if self.setMinPFUnderExcited is not None:
            namespaceprefix_ = self.setMinPFUnderExcited_nsprefix_ + ':' if (UseCapturedNS_ and self.setMinPFUnderExcited_nsprefix_) else ''
            self.setMinPFUnderExcited.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMinPFUnderExcited', pretty_print=pretty_print)
        if self.setMinV is not None:
            namespaceprefix_ = self.setMinV_nsprefix_ + ':' if (UseCapturedNS_ and self.setMinV_nsprefix_) else ''
            self.setMinV.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setMinV', pretty_print=pretty_print)
        if self.setSoftGradW is not None:
            namespaceprefix_ = self.setSoftGradW_nsprefix_ + ':' if (UseCapturedNS_ and self.setSoftGradW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetSoftGradW>%s</%ssetSoftGradW>%s' % (namespaceprefix_ , self.gds_format_integer(self.setSoftGradW, input_name='setSoftGradW'), namespaceprefix_ , eol_))
        if self.setVNom is not None:
            namespaceprefix_ = self.setVNom_nsprefix_ + ':' if (UseCapturedNS_ and self.setVNom_nsprefix_) else ''
            self.setVNom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setVNom', pretty_print=pretty_print)
        if self.setVRef is not None:
            namespaceprefix_ = self.setVRef_nsprefix_ + ':' if (UseCapturedNS_ and self.setVRef_nsprefix_) else ''
            self.setVRef.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setVRef', pretty_print=pretty_print)
        if self.setVRefOfs is not None:
            namespaceprefix_ = self.setVRefOfs_nsprefix_ + ':' if (UseCapturedNS_ and self.setVRefOfs_nsprefix_) else ''
            self.setVRefOfs.export(outfile, level, namespaceprefix_, namespacedef_='', name_='setVRefOfs', pretty_print=pretty_print)
        if self.updatedTime is not None:
            namespaceprefix_ = self.updatedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.updatedTime_nsprefix_) else ''
            self.updatedTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='updatedTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERSettings, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'modesEnabled':
            obj_ = DERControlType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.modesEnabled = obj_
            obj_.original_tagname_ = 'modesEnabled'
        elif nodeName_ == 'setESDelay' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESDelay')
            ival_ = self.gds_validate_integer(ival_, node, 'setESDelay')
            self.setESDelay = ival_
            self.setESDelay_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.setESDelay)
        elif nodeName_ == 'setESHighFreq' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESHighFreq')
            ival_ = self.gds_validate_integer(ival_, node, 'setESHighFreq')
            self.setESHighFreq = ival_
            self.setESHighFreq_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.setESHighFreq)
        elif nodeName_ == 'setESHighVolt' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESHighVolt')
            ival_ = self.gds_validate_integer(ival_, node, 'setESHighVolt')
            self.setESHighVolt = ival_
            self.setESHighVolt_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.setESHighVolt)
        elif nodeName_ == 'setESLowFreq' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESLowFreq')
            ival_ = self.gds_validate_integer(ival_, node, 'setESLowFreq')
            self.setESLowFreq = ival_
            self.setESLowFreq_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.setESLowFreq)
        elif nodeName_ == 'setESLowVolt' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESLowVolt')
            ival_ = self.gds_validate_integer(ival_, node, 'setESLowVolt')
            self.setESLowVolt = ival_
            self.setESLowVolt_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.setESLowVolt)
        elif nodeName_ == 'setESRampTms' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESRampTms')
            ival_ = self.gds_validate_integer(ival_, node, 'setESRampTms')
            self.setESRampTms = ival_
            self.setESRampTms_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.setESRampTms)
        elif nodeName_ == 'setESRandomDelay' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESRandomDelay')
            ival_ = self.gds_validate_integer(ival_, node, 'setESRandomDelay')
            self.setESRandomDelay = ival_
            self.setESRandomDelay_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.setESRandomDelay)
        elif nodeName_ == 'setGradW' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setGradW')
            ival_ = self.gds_validate_integer(ival_, node, 'setGradW')
            self.setGradW = ival_
            self.setGradW_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.setGradW)
        elif nodeName_ == 'setMaxA':
            obj_ = CurrentRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxA = obj_
            obj_.original_tagname_ = 'setMaxA'
        elif nodeName_ == 'setMaxAh':
            obj_ = AmpereHour.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxAh = obj_
            obj_.original_tagname_ = 'setMaxAh'
        elif nodeName_ == 'setMaxChargeRateVA':
            obj_ = ApparentPower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxChargeRateVA = obj_
            obj_.original_tagname_ = 'setMaxChargeRateVA'
        elif nodeName_ == 'setMaxChargeRateW':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxChargeRateW = obj_
            obj_.original_tagname_ = 'setMaxChargeRateW'
        elif nodeName_ == 'setMaxDischargeRateVA':
            obj_ = ApparentPower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxDischargeRateVA = obj_
            obj_.original_tagname_ = 'setMaxDischargeRateVA'
        elif nodeName_ == 'setMaxDischargeRateW':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxDischargeRateW = obj_
            obj_.original_tagname_ = 'setMaxDischargeRateW'
        elif nodeName_ == 'setMaxV':
            obj_ = VoltageRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxV = obj_
            obj_.original_tagname_ = 'setMaxV'
        elif nodeName_ == 'setMaxVA':
            obj_ = ApparentPower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxVA = obj_
            obj_.original_tagname_ = 'setMaxVA'
        elif nodeName_ == 'setMaxVar':
            obj_ = ReactivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxVar = obj_
            obj_.original_tagname_ = 'setMaxVar'
        elif nodeName_ == 'setMaxVarNeg':
            obj_ = ReactivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxVarNeg = obj_
            obj_.original_tagname_ = 'setMaxVarNeg'
        elif nodeName_ == 'setMaxW':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxW = obj_
            obj_.original_tagname_ = 'setMaxW'
        elif nodeName_ == 'setMaxWh':
            obj_ = WattHour.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMaxWh = obj_
            obj_.original_tagname_ = 'setMaxWh'
        elif nodeName_ == 'setMinPFOverExcited':
            obj_ = PowerFactor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMinPFOverExcited = obj_
            obj_.original_tagname_ = 'setMinPFOverExcited'
        elif nodeName_ == 'setMinPFUnderExcited':
            obj_ = PowerFactor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMinPFUnderExcited = obj_
            obj_.original_tagname_ = 'setMinPFUnderExcited'
        elif nodeName_ == 'setMinV':
            obj_ = VoltageRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setMinV = obj_
            obj_.original_tagname_ = 'setMinV'
        elif nodeName_ == 'setSoftGradW' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setSoftGradW')
            ival_ = self.gds_validate_integer(ival_, node, 'setSoftGradW')
            self.setSoftGradW = ival_
            self.setSoftGradW_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.setSoftGradW)
        elif nodeName_ == 'setVNom':
            obj_ = VoltageRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setVNom = obj_
            obj_.original_tagname_ = 'setVNom'
        elif nodeName_ == 'setVRef':
            obj_ = VoltageRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setVRef = obj_
            obj_.original_tagname_ = 'setVRef'
        elif nodeName_ == 'setVRefOfs':
            obj_ = VoltageRMS.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.setVRefOfs = obj_
            obj_.original_tagname_ = 'setVRefOfs'
        elif nodeName_ == 'updatedTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.updatedTime = obj_
            obj_.original_tagname_ = 'updatedTime'
        super(DERSettings, self)._buildChildren(child_, node, nodeName_, True)
# end class DERSettings


class DERList(List):
    """DERList -- A List element to hold DER objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, pollRate='900', DER=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if DER is None:
            self.DER = []
        else:
            self.DER = DER
        self.DER_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERList.subclass:
            return DERList.subclass(*args_, **kwargs_)
        else:
            return DERList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DER(self):
        return self.DER
    def set_DER(self, DER):
        self.DER = DER
    def add_DER(self, value):
        self.DER.append(value)
    def insert_DER_at(self, index, value):
        self.DER.insert(index, value)
    def replace_DER_at(self, index, value):
        self.DER[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.DER or
            super(DERList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERList'):
        super(DERList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DERList', fromsubclass_=False, pretty_print=True):
        super(DERList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DER_ in self.DER:
            namespaceprefix_ = self.DER_nsprefix_ + ':' if (UseCapturedNS_ and self.DER_nsprefix_) else ''
            DER_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DER', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(DERList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DER':
            obj_ = DER.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DER.append(obj_)
            obj_.original_tagname_ = 'DER'
        super(DERList, self)._buildChildren(child_, node, nodeName_, True)
# end class DERList


class DER(SubscribableResource):
    """DER -- Contains links to DER resources.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableResource
    def __init__(self, AssociatedDERProgramListLink=None, AssociatedUsagePointLink=None, CurrentDERProgramLink=None, DERAvailabilityLink=None, DERCapabilityLink=None, DERSettingsLink=None, DERStatusLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DER"), self).__init__( **kwargs_)
        self.AssociatedDERProgramListLink = AssociatedDERProgramListLink
        self.AssociatedDERProgramListLink_nsprefix_ = None
        self.AssociatedUsagePointLink = AssociatedUsagePointLink
        self.AssociatedUsagePointLink_nsprefix_ = None
        self.CurrentDERProgramLink = CurrentDERProgramLink
        self.CurrentDERProgramLink_nsprefix_ = None
        self.DERAvailabilityLink = DERAvailabilityLink
        self.DERAvailabilityLink_nsprefix_ = None
        self.DERCapabilityLink = DERCapabilityLink
        self.DERCapabilityLink_nsprefix_ = None
        self.DERSettingsLink = DERSettingsLink
        self.DERSettingsLink_nsprefix_ = None
        self.DERStatusLink = DERStatusLink
        self.DERStatusLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DER)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DER.subclass:
            return DER.subclass(*args_, **kwargs_)
        else:
            return DER(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AssociatedDERProgramListLink(self):
        return self.AssociatedDERProgramListLink
    def set_AssociatedDERProgramListLink(self, AssociatedDERProgramListLink):
        self.AssociatedDERProgramListLink = AssociatedDERProgramListLink
    def get_AssociatedUsagePointLink(self):
        return self.AssociatedUsagePointLink
    def set_AssociatedUsagePointLink(self, AssociatedUsagePointLink):
        self.AssociatedUsagePointLink = AssociatedUsagePointLink
    def get_CurrentDERProgramLink(self):
        return self.CurrentDERProgramLink
    def set_CurrentDERProgramLink(self, CurrentDERProgramLink):
        self.CurrentDERProgramLink = CurrentDERProgramLink
    def get_DERAvailabilityLink(self):
        return self.DERAvailabilityLink
    def set_DERAvailabilityLink(self, DERAvailabilityLink):
        self.DERAvailabilityLink = DERAvailabilityLink
    def get_DERCapabilityLink(self):
        return self.DERCapabilityLink
    def set_DERCapabilityLink(self, DERCapabilityLink):
        self.DERCapabilityLink = DERCapabilityLink
    def get_DERSettingsLink(self):
        return self.DERSettingsLink
    def set_DERSettingsLink(self, DERSettingsLink):
        self.DERSettingsLink = DERSettingsLink
    def get_DERStatusLink(self):
        return self.DERStatusLink
    def set_DERStatusLink(self, DERStatusLink):
        self.DERStatusLink = DERStatusLink
    def _hasContent(self):
        if (
            self.AssociatedDERProgramListLink is not None or
            self.AssociatedUsagePointLink is not None or
            self.CurrentDERProgramLink is not None or
            self.DERAvailabilityLink is not None or
            self.DERCapabilityLink is not None or
            self.DERSettingsLink is not None or
            self.DERStatusLink is not None or
            super(DER, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DER', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DER')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DER':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DER')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DER', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DER'):
        super(DER, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DER')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DER', fromsubclass_=False, pretty_print=True):
        super(DER, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AssociatedDERProgramListLink is not None:
            namespaceprefix_ = self.AssociatedDERProgramListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.AssociatedDERProgramListLink_nsprefix_) else ''
            self.AssociatedDERProgramListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssociatedDERProgramListLink', pretty_print=pretty_print)
        if self.AssociatedUsagePointLink is not None:
            namespaceprefix_ = self.AssociatedUsagePointLink_nsprefix_ + ':' if (UseCapturedNS_ and self.AssociatedUsagePointLink_nsprefix_) else ''
            self.AssociatedUsagePointLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AssociatedUsagePointLink', pretty_print=pretty_print)
        if self.CurrentDERProgramLink is not None:
            namespaceprefix_ = self.CurrentDERProgramLink_nsprefix_ + ':' if (UseCapturedNS_ and self.CurrentDERProgramLink_nsprefix_) else ''
            self.CurrentDERProgramLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CurrentDERProgramLink', pretty_print=pretty_print)
        if self.DERAvailabilityLink is not None:
            namespaceprefix_ = self.DERAvailabilityLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DERAvailabilityLink_nsprefix_) else ''
            self.DERAvailabilityLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERAvailabilityLink', pretty_print=pretty_print)
        if self.DERCapabilityLink is not None:
            namespaceprefix_ = self.DERCapabilityLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DERCapabilityLink_nsprefix_) else ''
            self.DERCapabilityLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERCapabilityLink', pretty_print=pretty_print)
        if self.DERSettingsLink is not None:
            namespaceprefix_ = self.DERSettingsLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DERSettingsLink_nsprefix_) else ''
            self.DERSettingsLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERSettingsLink', pretty_print=pretty_print)
        if self.DERStatusLink is not None:
            namespaceprefix_ = self.DERStatusLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DERStatusLink_nsprefix_) else ''
            self.DERStatusLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERStatusLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DER, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AssociatedDERProgramListLink':
            obj_ = AssociatedDERProgramListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssociatedDERProgramListLink = obj_
            obj_.original_tagname_ = 'AssociatedDERProgramListLink'
        elif nodeName_ == 'AssociatedUsagePointLink':
            obj_ = AssociatedUsagePointLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AssociatedUsagePointLink = obj_
            obj_.original_tagname_ = 'AssociatedUsagePointLink'
        elif nodeName_ == 'CurrentDERProgramLink':
            obj_ = CurrentDERProgramLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CurrentDERProgramLink = obj_
            obj_.original_tagname_ = 'CurrentDERProgramLink'
        elif nodeName_ == 'DERAvailabilityLink':
            obj_ = DERAvailabilityLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERAvailabilityLink = obj_
            obj_.original_tagname_ = 'DERAvailabilityLink'
        elif nodeName_ == 'DERCapabilityLink':
            obj_ = DERCapabilityLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERCapabilityLink = obj_
            obj_.original_tagname_ = 'DERCapabilityLink'
        elif nodeName_ == 'DERSettingsLink':
            obj_ = DERSettingsLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERSettingsLink = obj_
            obj_.original_tagname_ = 'DERSettingsLink'
        elif nodeName_ == 'DERStatusLink':
            obj_ = DERStatusLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERStatusLink = obj_
            obj_.original_tagname_ = 'DERStatusLink'
        super(DER, self)._buildChildren(child_, node, nodeName_, True)
# end class DER


class DefaultDERControl(SubscribableIdentifiedObject):
    """DefaultDERControl -- Contains control mode information to be used if no active DERControl is found.
    setESDelay -- Enter service delay, in hundredths of a second. When present, this value SHALL update the value of the corresponding setting (DERSettings::setESDelay).
    setESHighFreq -- Enter service frequency high. Specified in hundredths of Hz. When present, this value SHALL update the value of the corresponding setting (DERSettings::setESHighFreq).
    setESHighVolt -- Enter service voltage high. Specified as an effective percent voltage, defined as (100% * (locally measured voltage - setVRefOfs) / setVRef), in hundredths of a percent. When present, this value SHALL update the value of the corresponding setting (DERSettings::setESHighVolt).
    setESLowFreq -- Enter service frequency low. Specified in hundredths of Hz. When present, this value SHALL update the value of the corresponding setting (DERSettings::setESLowFreq).
    setESLowVolt -- Enter service voltage low. Specified as an effective percent voltage, defined as (100% * (locally measured voltage - setVRefOfs) / setVRef), in hundredths of a percent. When present, this value SHALL update the value of the corresponding setting (DERSettings::setESLowVolt).
    setESRampTms -- Enter service ramp time, in hundredths of a second. When present, this value SHALL update the value of the corresponding setting (DERSettings::setESRampTms).
    setESRandomDelay -- Enter service randomized delay, in hundredths of a second. When present, this value SHALL update the value of the corresponding setting (DERSettings::setESRandomDelay).
    setGradW -- Set default rate of change (ramp rate) of active power output due to command or internal action, defined in %setWMax / second.  Resolution is in hundredths of a percent/second. A value of 0 means there is no limit. Interpreted as a percentage change in output capability limit per second when used as a default ramp rate. When present, this value SHALL update the value of the corresponding setting (DERSettings::setGradW).
    setSoftGradW -- Set soft-start rate of change (soft-start ramp rate) of active power output due to command or internal action, defined in %setWMax / second.  Resolution is in hundredths of a percent/second. A value of 0 means there is no limit. Interpreted as a percentage change in output capability limit per second when used as a ramp rate. When present, this value SHALL update the value of the corresponding setting (DERSettings::setSoftGradW).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableIdentifiedObject
    def __init__(self, DERControlBase=None, setESDelay=None, setESHighFreq=None, setESHighVolt=None, setESLowFreq=None, setESLowVolt=None, setESRampTms=None, setESRandomDelay=None, setGradW=None, setSoftGradW=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DefaultDERControl"), self).__init__( **kwargs_)
        self.DERControlBase = DERControlBase
        self.DERControlBase_nsprefix_ = None
        self.setESDelay = setESDelay
        self.validate_UInt32(self.setESDelay)
        self.setESDelay_nsprefix_ = None
        self.setESHighFreq = setESHighFreq
        self.validate_UInt16(self.setESHighFreq)
        self.setESHighFreq_nsprefix_ = None
        self.setESHighVolt = setESHighVolt
        self.validate_Int16(self.setESHighVolt)
        self.setESHighVolt_nsprefix_ = None
        self.setESLowFreq = setESLowFreq
        self.validate_UInt16(self.setESLowFreq)
        self.setESLowFreq_nsprefix_ = None
        self.setESLowVolt = setESLowVolt
        self.validate_Int16(self.setESLowVolt)
        self.setESLowVolt_nsprefix_ = None
        self.setESRampTms = setESRampTms
        self.validate_UInt32(self.setESRampTms)
        self.setESRampTms_nsprefix_ = None
        self.setESRandomDelay = setESRandomDelay
        self.validate_UInt32(self.setESRandomDelay)
        self.setESRandomDelay_nsprefix_ = None
        self.setGradW = setGradW
        self.validate_UInt16(self.setGradW)
        self.setGradW_nsprefix_ = None
        self.setSoftGradW = setSoftGradW
        self.validate_UInt16(self.setSoftGradW)
        self.setSoftGradW_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DefaultDERControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DefaultDERControl.subclass:
            return DefaultDERControl.subclass(*args_, **kwargs_)
        else:
            return DefaultDERControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DERControlBase(self):
        return self.DERControlBase
    def set_DERControlBase(self, DERControlBase):
        self.DERControlBase = DERControlBase
    def get_setESDelay(self):
        return self.setESDelay
    def set_setESDelay(self, setESDelay):
        self.setESDelay = setESDelay
    def get_setESHighFreq(self):
        return self.setESHighFreq
    def set_setESHighFreq(self, setESHighFreq):
        self.setESHighFreq = setESHighFreq
    def get_setESHighVolt(self):
        return self.setESHighVolt
    def set_setESHighVolt(self, setESHighVolt):
        self.setESHighVolt = setESHighVolt
    def get_setESLowFreq(self):
        return self.setESLowFreq
    def set_setESLowFreq(self, setESLowFreq):
        self.setESLowFreq = setESLowFreq
    def get_setESLowVolt(self):
        return self.setESLowVolt
    def set_setESLowVolt(self, setESLowVolt):
        self.setESLowVolt = setESLowVolt
    def get_setESRampTms(self):
        return self.setESRampTms
    def set_setESRampTms(self, setESRampTms):
        self.setESRampTms = setESRampTms
    def get_setESRandomDelay(self):
        return self.setESRandomDelay
    def set_setESRandomDelay(self, setESRandomDelay):
        self.setESRandomDelay = setESRandomDelay
    def get_setGradW(self):
        return self.setGradW
    def set_setGradW(self, setGradW):
        self.setGradW = setGradW
    def get_setSoftGradW(self):
        return self.setSoftGradW
    def set_setSoftGradW(self, setSoftGradW):
        self.setSoftGradW = setSoftGradW
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Int16(self, value):
        result = True
        # Validate type Int16, a restriction on xs:short.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.DERControlBase is not None or
            self.setESDelay is not None or
            self.setESHighFreq is not None or
            self.setESHighVolt is not None or
            self.setESLowFreq is not None or
            self.setESLowVolt is not None or
            self.setESRampTms is not None or
            self.setESRandomDelay is not None or
            self.setGradW is not None or
            self.setSoftGradW is not None or
            super(DefaultDERControl, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DefaultDERControl', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DefaultDERControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DefaultDERControl':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DefaultDERControl')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DefaultDERControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DefaultDERControl'):
        super(DefaultDERControl, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DefaultDERControl')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DefaultDERControl', fromsubclass_=False, pretty_print=True):
        super(DefaultDERControl, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DERControlBase is not None:
            namespaceprefix_ = self.DERControlBase_nsprefix_ + ':' if (UseCapturedNS_ and self.DERControlBase_nsprefix_) else ''
            self.DERControlBase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERControlBase', pretty_print=pretty_print)
        if self.setESDelay is not None:
            namespaceprefix_ = self.setESDelay_nsprefix_ + ':' if (UseCapturedNS_ and self.setESDelay_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESDelay>%s</%ssetESDelay>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESDelay, input_name='setESDelay'), namespaceprefix_ , eol_))
        if self.setESHighFreq is not None:
            namespaceprefix_ = self.setESHighFreq_nsprefix_ + ':' if (UseCapturedNS_ and self.setESHighFreq_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESHighFreq>%s</%ssetESHighFreq>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESHighFreq, input_name='setESHighFreq'), namespaceprefix_ , eol_))
        if self.setESHighVolt is not None:
            namespaceprefix_ = self.setESHighVolt_nsprefix_ + ':' if (UseCapturedNS_ and self.setESHighVolt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESHighVolt>%s</%ssetESHighVolt>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESHighVolt, input_name='setESHighVolt'), namespaceprefix_ , eol_))
        if self.setESLowFreq is not None:
            namespaceprefix_ = self.setESLowFreq_nsprefix_ + ':' if (UseCapturedNS_ and self.setESLowFreq_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESLowFreq>%s</%ssetESLowFreq>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESLowFreq, input_name='setESLowFreq'), namespaceprefix_ , eol_))
        if self.setESLowVolt is not None:
            namespaceprefix_ = self.setESLowVolt_nsprefix_ + ':' if (UseCapturedNS_ and self.setESLowVolt_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESLowVolt>%s</%ssetESLowVolt>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESLowVolt, input_name='setESLowVolt'), namespaceprefix_ , eol_))
        if self.setESRampTms is not None:
            namespaceprefix_ = self.setESRampTms_nsprefix_ + ':' if (UseCapturedNS_ and self.setESRampTms_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESRampTms>%s</%ssetESRampTms>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESRampTms, input_name='setESRampTms'), namespaceprefix_ , eol_))
        if self.setESRandomDelay is not None:
            namespaceprefix_ = self.setESRandomDelay_nsprefix_ + ':' if (UseCapturedNS_ and self.setESRandomDelay_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetESRandomDelay>%s</%ssetESRandomDelay>%s' % (namespaceprefix_ , self.gds_format_integer(self.setESRandomDelay, input_name='setESRandomDelay'), namespaceprefix_ , eol_))
        if self.setGradW is not None:
            namespaceprefix_ = self.setGradW_nsprefix_ + ':' if (UseCapturedNS_ and self.setGradW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetGradW>%s</%ssetGradW>%s' % (namespaceprefix_ , self.gds_format_integer(self.setGradW, input_name='setGradW'), namespaceprefix_ , eol_))
        if self.setSoftGradW is not None:
            namespaceprefix_ = self.setSoftGradW_nsprefix_ + ':' if (UseCapturedNS_ and self.setSoftGradW_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssetSoftGradW>%s</%ssetSoftGradW>%s' % (namespaceprefix_ , self.gds_format_integer(self.setSoftGradW, input_name='setSoftGradW'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DefaultDERControl, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DERControlBase':
            obj_ = DERControlBase.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERControlBase = obj_
            obj_.original_tagname_ = 'DERControlBase'
        elif nodeName_ == 'setESDelay' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESDelay')
            ival_ = self.gds_validate_integer(ival_, node, 'setESDelay')
            self.setESDelay = ival_
            self.setESDelay_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.setESDelay)
        elif nodeName_ == 'setESHighFreq' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESHighFreq')
            ival_ = self.gds_validate_integer(ival_, node, 'setESHighFreq')
            self.setESHighFreq = ival_
            self.setESHighFreq_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.setESHighFreq)
        elif nodeName_ == 'setESHighVolt' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESHighVolt')
            ival_ = self.gds_validate_integer(ival_, node, 'setESHighVolt')
            self.setESHighVolt = ival_
            self.setESHighVolt_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.setESHighVolt)
        elif nodeName_ == 'setESLowFreq' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESLowFreq')
            ival_ = self.gds_validate_integer(ival_, node, 'setESLowFreq')
            self.setESLowFreq = ival_
            self.setESLowFreq_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.setESLowFreq)
        elif nodeName_ == 'setESLowVolt' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESLowVolt')
            ival_ = self.gds_validate_integer(ival_, node, 'setESLowVolt')
            self.setESLowVolt = ival_
            self.setESLowVolt_nsprefix_ = child_.prefix
            # validate type Int16
            self.validate_Int16(self.setESLowVolt)
        elif nodeName_ == 'setESRampTms' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESRampTms')
            ival_ = self.gds_validate_integer(ival_, node, 'setESRampTms')
            self.setESRampTms = ival_
            self.setESRampTms_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.setESRampTms)
        elif nodeName_ == 'setESRandomDelay' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setESRandomDelay')
            ival_ = self.gds_validate_integer(ival_, node, 'setESRandomDelay')
            self.setESRandomDelay = ival_
            self.setESRandomDelay_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.setESRandomDelay)
        elif nodeName_ == 'setGradW' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setGradW')
            ival_ = self.gds_validate_integer(ival_, node, 'setGradW')
            self.setGradW = ival_
            self.setGradW_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.setGradW)
        elif nodeName_ == 'setSoftGradW' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'setSoftGradW')
            ival_ = self.gds_validate_integer(ival_, node, 'setSoftGradW')
            self.setSoftGradW = ival_
            self.setSoftGradW_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.setSoftGradW)
        super(DefaultDERControl, self)._buildChildren(child_, node, nodeName_, True)
# end class DefaultDERControl


class FlowReservationResponseList(SubscribableList):
    """FlowReservationResponseList -- A List element to hold FlowReservationResponse objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', FlowReservationResponse=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FlowReservationResponseList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if FlowReservationResponse is None:
            self.FlowReservationResponse = []
        else:
            self.FlowReservationResponse = FlowReservationResponse
        self.FlowReservationResponse_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowReservationResponseList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowReservationResponseList.subclass:
            return FlowReservationResponseList.subclass(*args_, **kwargs_)
        else:
            return FlowReservationResponseList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FlowReservationResponse(self):
        return self.FlowReservationResponse
    def set_FlowReservationResponse(self, FlowReservationResponse):
        self.FlowReservationResponse = FlowReservationResponse
    def add_FlowReservationResponse(self, value):
        self.FlowReservationResponse.append(value)
    def insert_FlowReservationResponse_at(self, index, value):
        self.FlowReservationResponse.insert(index, value)
    def replace_FlowReservationResponse_at(self, index, value):
        self.FlowReservationResponse[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.FlowReservationResponse or
            super(FlowReservationResponseList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FlowReservationResponseList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowReservationResponseList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlowReservationResponseList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationResponseList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlowReservationResponseList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowReservationResponseList'):
        super(FlowReservationResponseList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationResponseList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FlowReservationResponseList', fromsubclass_=False, pretty_print=True):
        super(FlowReservationResponseList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FlowReservationResponse_ in self.FlowReservationResponse:
            namespaceprefix_ = self.FlowReservationResponse_nsprefix_ + ':' if (UseCapturedNS_ and self.FlowReservationResponse_nsprefix_) else ''
            FlowReservationResponse_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FlowReservationResponse', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(FlowReservationResponseList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FlowReservationResponse':
            obj_ = FlowReservationResponse.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FlowReservationResponse.append(obj_)
            obj_.original_tagname_ = 'FlowReservationResponse'
        super(FlowReservationResponseList, self)._buildChildren(child_, node, nodeName_, True)
# end class FlowReservationResponseList


class FlowReservationResponse(Event):
    """FlowReservationResponse -- The server may modify the charging or discharging parameters and interval to provide a lower aggregated demand at the premises, or within a larger part of the distribution system.
    energyAvailable -- Indicates the amount of energy available.
    powerAvailable -- Indicates the amount of power available.
    subject -- The subject field provides a method to match the response with the originating event. It is populated with the mRID of the corresponding FlowReservationRequest object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Event
    def __init__(self, energyAvailable=None, powerAvailable=None, subject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FlowReservationResponse"), self).__init__( **kwargs_)
        self.energyAvailable = energyAvailable
        self.energyAvailable_nsprefix_ = None
        self.powerAvailable = powerAvailable
        self.powerAvailable_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowReservationResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowReservationResponse.subclass:
            return FlowReservationResponse.subclass(*args_, **kwargs_)
        else:
            return FlowReservationResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_energyAvailable(self):
        return self.energyAvailable
    def set_energyAvailable(self, energyAvailable):
        self.energyAvailable = energyAvailable
    def get_powerAvailable(self):
        return self.powerAvailable
    def set_powerAvailable(self, powerAvailable):
        self.powerAvailable = powerAvailable
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def _hasContent(self):
        if (
            self.energyAvailable is not None or
            self.powerAvailable is not None or
            self.subject is not None or
            super(FlowReservationResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FlowReservationResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowReservationResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlowReservationResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlowReservationResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowReservationResponse'):
        super(FlowReservationResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FlowReservationResponse', fromsubclass_=False, pretty_print=True):
        super(FlowReservationResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.energyAvailable is not None:
            namespaceprefix_ = self.energyAvailable_nsprefix_ + ':' if (UseCapturedNS_ and self.energyAvailable_nsprefix_) else ''
            self.energyAvailable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='energyAvailable', pretty_print=pretty_print)
        if self.powerAvailable is not None:
            namespaceprefix_ = self.powerAvailable_nsprefix_ + ':' if (UseCapturedNS_ and self.powerAvailable_nsprefix_) else ''
            self.powerAvailable.export(outfile, level, namespaceprefix_, namespacedef_='', name_='powerAvailable', pretty_print=pretty_print)
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'energyAvailable':
            obj_ = SignedRealEnergy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.energyAvailable = obj_
            obj_.original_tagname_ = 'energyAvailable'
        elif nodeName_ == 'powerAvailable':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.powerAvailable = obj_
            obj_.original_tagname_ = 'powerAvailable'
        elif nodeName_ == 'subject':
            obj_ = mRIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        super(FlowReservationResponse, self)._buildChildren(child_, node, nodeName_, True)
# end class FlowReservationResponse


class FlowReservationRequestList(List):
    """FlowReservationRequestList -- A List element to hold FlowReservationRequest objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, pollRate='900', FlowReservationRequest=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FlowReservationRequestList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if FlowReservationRequest is None:
            self.FlowReservationRequest = []
        else:
            self.FlowReservationRequest = FlowReservationRequest
        self.FlowReservationRequest_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowReservationRequestList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowReservationRequestList.subclass:
            return FlowReservationRequestList.subclass(*args_, **kwargs_)
        else:
            return FlowReservationRequestList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FlowReservationRequest(self):
        return self.FlowReservationRequest
    def set_FlowReservationRequest(self, FlowReservationRequest):
        self.FlowReservationRequest = FlowReservationRequest
    def add_FlowReservationRequest(self, value):
        self.FlowReservationRequest.append(value)
    def insert_FlowReservationRequest_at(self, index, value):
        self.FlowReservationRequest.insert(index, value)
    def replace_FlowReservationRequest_at(self, index, value):
        self.FlowReservationRequest[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.FlowReservationRequest or
            super(FlowReservationRequestList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FlowReservationRequestList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowReservationRequestList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlowReservationRequestList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationRequestList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlowReservationRequestList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowReservationRequestList'):
        super(FlowReservationRequestList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationRequestList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FlowReservationRequestList', fromsubclass_=False, pretty_print=True):
        super(FlowReservationRequestList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FlowReservationRequest_ in self.FlowReservationRequest:
            namespaceprefix_ = self.FlowReservationRequest_nsprefix_ + ':' if (UseCapturedNS_ and self.FlowReservationRequest_nsprefix_) else ''
            FlowReservationRequest_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FlowReservationRequest', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(FlowReservationRequestList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FlowReservationRequest':
            obj_ = FlowReservationRequest.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FlowReservationRequest.append(obj_)
            obj_.original_tagname_ = 'FlowReservationRequest'
        super(FlowReservationRequestList, self)._buildChildren(child_, node, nodeName_, True)
# end class FlowReservationRequestList


class FlowReservationRequest(IdentifiedObject):
    """FlowReservationRequest -- Used to request flow transactions. Client EndDevices submit a request for charging or discharging from the server. The server creates an associated FlowReservationResponse containing the charging parameters and interval to provide a lower aggregated demand at the premises, or within a larger part of the distribution system.
    creationTime -- The time at which the request was created.
    durationRequested -- A value that is calculated by the storage device that defines the minimum duration, in seconds, that it will take to complete the actual flow transaction, including any ramp times and conditioning times, if applicable.
    energyRequested -- Indicates the total amount of energy, in Watt-Hours, requested to be transferred between the storage device and the electric power system. Positive values indicate charging and negative values indicate discharging. This sign convention is different than for the DER function where discharging is positive.  Note that the energyRequestNow attribute in the PowerStatus Object must always represent a charging solution and it is not allowed to have a negative value.
    intervalRequested -- The time window during which the flow reservation is needed. For example, if an electric vehicle is set with a 7:00 AM time charge is needed, and price drops to the lowest tier at 11:00 PM, then this window would likely be from 11:00 PM until 7:00 AM.
    powerRequested -- Indicates the sustained level of power, in Watts, that is requested. For charging this is calculated by the storage device and it represents the charging system capability (which for an electric vehicle must also account for any power limitations due to the EVSE control pilot). For discharging, a lower value than the inverter capability can be used as a target.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, creationTime=None, durationRequested=None, energyRequested=None, intervalRequested=None, powerRequested=None, RequestStatus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FlowReservationRequest"), self).__init__( **kwargs_)
        self.creationTime = creationTime
        self.creationTime_nsprefix_ = None
        self.durationRequested = durationRequested
        self.validate_UInt16(self.durationRequested)
        self.durationRequested_nsprefix_ = None
        self.energyRequested = energyRequested
        self.energyRequested_nsprefix_ = None
        self.intervalRequested = intervalRequested
        self.intervalRequested_nsprefix_ = None
        self.powerRequested = powerRequested
        self.powerRequested_nsprefix_ = None
        self.RequestStatus = RequestStatus
        self.RequestStatus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowReservationRequest)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowReservationRequest.subclass:
            return FlowReservationRequest.subclass(*args_, **kwargs_)
        else:
            return FlowReservationRequest(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_creationTime(self):
        return self.creationTime
    def set_creationTime(self, creationTime):
        self.creationTime = creationTime
    def get_durationRequested(self):
        return self.durationRequested
    def set_durationRequested(self, durationRequested):
        self.durationRequested = durationRequested
    def get_energyRequested(self):
        return self.energyRequested
    def set_energyRequested(self, energyRequested):
        self.energyRequested = energyRequested
    def get_intervalRequested(self):
        return self.intervalRequested
    def set_intervalRequested(self, intervalRequested):
        self.intervalRequested = intervalRequested
    def get_powerRequested(self):
        return self.powerRequested
    def set_powerRequested(self, powerRequested):
        self.powerRequested = powerRequested
    def get_RequestStatus(self):
        return self.RequestStatus
    def set_RequestStatus(self, RequestStatus):
        self.RequestStatus = RequestStatus
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.creationTime is not None or
            self.durationRequested is not None or
            self.energyRequested is not None or
            self.intervalRequested is not None or
            self.powerRequested is not None or
            self.RequestStatus is not None or
            super(FlowReservationRequest, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FlowReservationRequest', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowReservationRequest')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlowReservationRequest':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationRequest')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlowReservationRequest', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowReservationRequest'):
        super(FlowReservationRequest, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationRequest')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FlowReservationRequest', fromsubclass_=False, pretty_print=True):
        super(FlowReservationRequest, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creationTime is not None:
            namespaceprefix_ = self.creationTime_nsprefix_ + ':' if (UseCapturedNS_ and self.creationTime_nsprefix_) else ''
            self.creationTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creationTime', pretty_print=pretty_print)
        if self.durationRequested is not None:
            namespaceprefix_ = self.durationRequested_nsprefix_ + ':' if (UseCapturedNS_ and self.durationRequested_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdurationRequested>%s</%sdurationRequested>%s' % (namespaceprefix_ , self.gds_format_integer(self.durationRequested, input_name='durationRequested'), namespaceprefix_ , eol_))
        if self.energyRequested is not None:
            namespaceprefix_ = self.energyRequested_nsprefix_ + ':' if (UseCapturedNS_ and self.energyRequested_nsprefix_) else ''
            self.energyRequested.export(outfile, level, namespaceprefix_, namespacedef_='', name_='energyRequested', pretty_print=pretty_print)
        if self.intervalRequested is not None:
            namespaceprefix_ = self.intervalRequested_nsprefix_ + ':' if (UseCapturedNS_ and self.intervalRequested_nsprefix_) else ''
            self.intervalRequested.export(outfile, level, namespaceprefix_, namespacedef_='', name_='intervalRequested', pretty_print=pretty_print)
        if self.powerRequested is not None:
            namespaceprefix_ = self.powerRequested_nsprefix_ + ':' if (UseCapturedNS_ and self.powerRequested_nsprefix_) else ''
            self.powerRequested.export(outfile, level, namespaceprefix_, namespacedef_='', name_='powerRequested', pretty_print=pretty_print)
        if self.RequestStatus is not None:
            namespaceprefix_ = self.RequestStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.RequestStatus_nsprefix_) else ''
            self.RequestStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RequestStatus', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationRequest, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'creationTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creationTime = obj_
            obj_.original_tagname_ = 'creationTime'
        elif nodeName_ == 'durationRequested' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'durationRequested')
            ival_ = self.gds_validate_integer(ival_, node, 'durationRequested')
            self.durationRequested = ival_
            self.durationRequested_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.durationRequested)
        elif nodeName_ == 'energyRequested':
            obj_ = SignedRealEnergy.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.energyRequested = obj_
            obj_.original_tagname_ = 'energyRequested'
        elif nodeName_ == 'intervalRequested':
            obj_ = DateTimeInterval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.intervalRequested = obj_
            obj_.original_tagname_ = 'intervalRequested'
        elif nodeName_ == 'powerRequested':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.powerRequested = obj_
            obj_.original_tagname_ = 'powerRequested'
        elif nodeName_ == 'RequestStatus':
            obj_ = RequestStatus.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RequestStatus = obj_
            obj_.original_tagname_ = 'RequestStatus'
        super(FlowReservationRequest, self)._buildChildren(child_, node, nodeName_, True)
# end class FlowReservationRequest


class SupplyInterruptionOverrideList(List):
    """SupplyInterruptionOverrideList -- A List element to hold SupplyInterruptionOverride objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, SupplyInterruptionOverride=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SupplyInterruptionOverrideList"), self).__init__( **kwargs_)
        if SupplyInterruptionOverride is None:
            self.SupplyInterruptionOverride = []
        else:
            self.SupplyInterruptionOverride = SupplyInterruptionOverride
        self.SupplyInterruptionOverride_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplyInterruptionOverrideList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplyInterruptionOverrideList.subclass:
            return SupplyInterruptionOverrideList.subclass(*args_, **kwargs_)
        else:
            return SupplyInterruptionOverrideList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SupplyInterruptionOverride(self):
        return self.SupplyInterruptionOverride
    def set_SupplyInterruptionOverride(self, SupplyInterruptionOverride):
        self.SupplyInterruptionOverride = SupplyInterruptionOverride
    def add_SupplyInterruptionOverride(self, value):
        self.SupplyInterruptionOverride.append(value)
    def insert_SupplyInterruptionOverride_at(self, index, value):
        self.SupplyInterruptionOverride.insert(index, value)
    def replace_SupplyInterruptionOverride_at(self, index, value):
        self.SupplyInterruptionOverride[index] = value
    def _hasContent(self):
        if (
            self.SupplyInterruptionOverride or
            super(SupplyInterruptionOverrideList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SupplyInterruptionOverrideList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupplyInterruptionOverrideList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupplyInterruptionOverrideList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplyInterruptionOverrideList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupplyInterruptionOverrideList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupplyInterruptionOverrideList'):
        super(SupplyInterruptionOverrideList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplyInterruptionOverrideList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SupplyInterruptionOverrideList', fromsubclass_=False, pretty_print=True):
        super(SupplyInterruptionOverrideList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SupplyInterruptionOverride_ in self.SupplyInterruptionOverride:
            namespaceprefix_ = self.SupplyInterruptionOverride_nsprefix_ + ':' if (UseCapturedNS_ and self.SupplyInterruptionOverride_nsprefix_) else ''
            SupplyInterruptionOverride_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SupplyInterruptionOverride', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SupplyInterruptionOverrideList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SupplyInterruptionOverride':
            obj_ = SupplyInterruptionOverride.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SupplyInterruptionOverride.append(obj_)
            obj_.original_tagname_ = 'SupplyInterruptionOverride'
        super(SupplyInterruptionOverrideList, self)._buildChildren(child_, node, nodeName_, True)
# end class SupplyInterruptionOverrideList


class SupplyInterruptionOverride(Resource):
    """SupplyInterruptionOverride -- SupplyInterruptionOverride: There may be periods of time when social, regulatory or other concerns mean that service should not be interrupted, even when available credit has been exhausted. Each Prepayment instance links to a List of SupplyInterruptionOverride instances. Each SupplyInterruptionOverride defines a contiguous period of time during which supply SHALL NOT be interrupted.
    description -- The description is a human readable text describing or naming the object.
    interval -- Interval defines the period of time during which supply should not be interrupted.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, description=None, interval=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SupplyInterruptionOverride"), self).__init__( **kwargs_)
        self.description = description
        self.validate_String32(self.description)
        self.description_nsprefix_ = None
        self.interval = interval
        self.interval_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupplyInterruptionOverride)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupplyInterruptionOverride.subclass:
            return SupplyInterruptionOverride.subclass(*args_, **kwargs_)
        else:
            return SupplyInterruptionOverride(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_interval(self):
        return self.interval
    def set_interval(self, interval):
        self.interval = interval
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.description is not None or
            self.interval is not None or
            super(SupplyInterruptionOverride, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SupplyInterruptionOverride', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupplyInterruptionOverride')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupplyInterruptionOverride':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplyInterruptionOverride')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupplyInterruptionOverride', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupplyInterruptionOverride'):
        super(SupplyInterruptionOverride, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupplyInterruptionOverride')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SupplyInterruptionOverride', fromsubclass_=False, pretty_print=True):
        super(SupplyInterruptionOverride, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.interval is not None:
            namespaceprefix_ = self.interval_nsprefix_ + ':' if (UseCapturedNS_ and self.interval_nsprefix_) else ''
            self.interval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interval', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SupplyInterruptionOverride, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.description)
        elif nodeName_ == 'interval':
            obj_ = DateTimeInterval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interval = obj_
            obj_.original_tagname_ = 'interval'
        super(SupplyInterruptionOverride, self)._buildChildren(child_, node, nodeName_, True)
# end class SupplyInterruptionOverride


class PrepayOperationStatus(Resource):
    """PrepayOperationStatus -- PrepayOperationStatus describes the status of the service or commodity being conditionally controlled by the Prepayment function set.
    creditTypeChange -- CreditTypeChange is used to define a pending change of creditTypeInUse, which will activate at a specified time.
    creditTypeInUse -- CreditTypeInUse identifies whether the present mode of operation is consuming regular credit or emergency credit.
    serviceChange -- ServiceChange is used to define a pending change of serviceStatus, which will activate at a specified time.
    serviceStatus -- ServiceStatus identifies whether the service is connected or disconnected, or armed for connection or disconnection.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, creditTypeChange=None, creditTypeInUse=None, serviceChange=None, serviceStatus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PrepayOperationStatus"), self).__init__( **kwargs_)
        self.creditTypeChange = creditTypeChange
        self.creditTypeChange_nsprefix_ = None
        self.creditTypeInUse = creditTypeInUse
        self.creditTypeInUse_nsprefix_ = None
        self.serviceChange = serviceChange
        self.serviceChange_nsprefix_ = None
        self.serviceStatus = serviceStatus
        self.serviceStatus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrepayOperationStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrepayOperationStatus.subclass:
            return PrepayOperationStatus.subclass(*args_, **kwargs_)
        else:
            return PrepayOperationStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_creditTypeChange(self):
        return self.creditTypeChange
    def set_creditTypeChange(self, creditTypeChange):
        self.creditTypeChange = creditTypeChange
    def get_creditTypeInUse(self):
        return self.creditTypeInUse
    def set_creditTypeInUse(self, creditTypeInUse):
        self.creditTypeInUse = creditTypeInUse
    def get_serviceChange(self):
        return self.serviceChange
    def set_serviceChange(self, serviceChange):
        self.serviceChange = serviceChange
    def get_serviceStatus(self):
        return self.serviceStatus
    def set_serviceStatus(self, serviceStatus):
        self.serviceStatus = serviceStatus
    def _hasContent(self):
        if (
            self.creditTypeChange is not None or
            self.creditTypeInUse is not None or
            self.serviceChange is not None or
            self.serviceStatus is not None or
            super(PrepayOperationStatus, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PrepayOperationStatus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrepayOperationStatus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrepayOperationStatus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepayOperationStatus')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrepayOperationStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrepayOperationStatus'):
        super(PrepayOperationStatus, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepayOperationStatus')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PrepayOperationStatus', fromsubclass_=False, pretty_print=True):
        super(PrepayOperationStatus, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creditTypeChange is not None:
            namespaceprefix_ = self.creditTypeChange_nsprefix_ + ':' if (UseCapturedNS_ and self.creditTypeChange_nsprefix_) else ''
            self.creditTypeChange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creditTypeChange', pretty_print=pretty_print)
        if self.creditTypeInUse is not None:
            namespaceprefix_ = self.creditTypeInUse_nsprefix_ + ':' if (UseCapturedNS_ and self.creditTypeInUse_nsprefix_) else ''
            self.creditTypeInUse.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creditTypeInUse', pretty_print=pretty_print)
        if self.serviceChange is not None:
            namespaceprefix_ = self.serviceChange_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceChange_nsprefix_) else ''
            self.serviceChange.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceChange', pretty_print=pretty_print)
        if self.serviceStatus is not None:
            namespaceprefix_ = self.serviceStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceStatus_nsprefix_) else ''
            self.serviceStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceStatus', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PrepayOperationStatus, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'creditTypeChange':
            obj_ = CreditTypeChange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creditTypeChange = obj_
            obj_.original_tagname_ = 'creditTypeChange'
        elif nodeName_ == 'creditTypeInUse':
            obj_ = CreditTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creditTypeInUse = obj_
            obj_.original_tagname_ = 'creditTypeInUse'
        elif nodeName_ == 'serviceChange':
            obj_ = ServiceChange.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceChange = obj_
            obj_.original_tagname_ = 'serviceChange'
        elif nodeName_ == 'serviceStatus':
            obj_ = ServiceStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceStatus = obj_
            obj_.original_tagname_ = 'serviceStatus'
        super(PrepayOperationStatus, self)._buildChildren(child_, node, nodeName_, True)
# end class PrepayOperationStatus


class PrepaymentList(SubscribableList):
    """PrepaymentList -- A List element to hold Prepayment objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', Prepayment=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PrepaymentList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if Prepayment is None:
            self.Prepayment = []
        else:
            self.Prepayment = Prepayment
        self.Prepayment_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PrepaymentList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PrepaymentList.subclass:
            return PrepaymentList.subclass(*args_, **kwargs_)
        else:
            return PrepaymentList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Prepayment(self):
        return self.Prepayment
    def set_Prepayment(self, Prepayment):
        self.Prepayment = Prepayment
    def add_Prepayment(self, value):
        self.Prepayment.append(value)
    def insert_Prepayment_at(self, index, value):
        self.Prepayment.insert(index, value)
    def replace_Prepayment_at(self, index, value):
        self.Prepayment[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Prepayment or
            super(PrepaymentList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PrepaymentList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PrepaymentList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PrepaymentList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepaymentList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PrepaymentList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PrepaymentList'):
        super(PrepaymentList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PrepaymentList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PrepaymentList', fromsubclass_=False, pretty_print=True):
        super(PrepaymentList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Prepayment_ in self.Prepayment:
            namespaceprefix_ = self.Prepayment_nsprefix_ + ':' if (UseCapturedNS_ and self.Prepayment_nsprefix_) else ''
            Prepayment_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Prepayment', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(PrepaymentList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Prepayment':
            obj_ = Prepayment.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Prepayment.append(obj_)
            obj_.original_tagname_ = 'Prepayment'
        super(PrepaymentList, self)._buildChildren(child_, node, nodeName_, True)
# end class PrepaymentList


class Prepayment(IdentifiedObject):
    """Prepayment -- Prepayment (inherited from CIM SDPAccountingFunction)
    creditExpiryLevel -- CreditExpiryLevel is the set point for availableCredit at which the service level may be changed. The typical value for this attribute is 0, regardless of whether the account balance is measured in a monetary or commodity basis. The units for this attribute SHALL match the units used for availableCredit.
    lowCreditWarningLevel -- LowCreditWarningLevel is the set point for availableCredit at which the creditStatus attribute in the AccountBalance resource SHALL indicate that available credit is low. The units for this attribute SHALL match the units used for availableCredit. Typically, this value is set by the service provider.
    lowEmergencyCreditWarningLevel -- LowEmergencyCreditWarningLevel is the set point for emergencyCredit at which the creditStatus attribute in the AccountBalance resource SHALL indicate that emergencycredit is low. The units for this attribute SHALL match the units used for availableCredit. Typically, this value is set by the service provider.
    prepayMode -- PrepayMode specifies whether the given Prepayment instance is operating in Credit, Central Wallet, ESI, or Local prepayment mode. The Credit mode indicates that prepayment is not presently in effect. The other modes are described in the Overview Section above.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, AccountBalanceLink=None, ActiveCreditRegisterListLink=None, ActiveSupplyInterruptionOverrideListLink=None, creditExpiryLevel=None, CreditRegisterListLink=None, lowCreditWarningLevel=None, lowEmergencyCreditWarningLevel=None, prepayMode=None, PrepayOperationStatusLink=None, SupplyInterruptionOverrideListLink=None, UsagePoint=None, UsagePointLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Prepayment"), self).__init__( **kwargs_)
        self.AccountBalanceLink = AccountBalanceLink
        self.AccountBalanceLink_nsprefix_ = None
        self.ActiveCreditRegisterListLink = ActiveCreditRegisterListLink
        self.ActiveCreditRegisterListLink_nsprefix_ = None
        self.ActiveSupplyInterruptionOverrideListLink = ActiveSupplyInterruptionOverrideListLink
        self.ActiveSupplyInterruptionOverrideListLink_nsprefix_ = None
        self.creditExpiryLevel = creditExpiryLevel
        self.creditExpiryLevel_nsprefix_ = None
        self.CreditRegisterListLink = CreditRegisterListLink
        self.CreditRegisterListLink_nsprefix_ = None
        self.lowCreditWarningLevel = lowCreditWarningLevel
        self.lowCreditWarningLevel_nsprefix_ = None
        self.lowEmergencyCreditWarningLevel = lowEmergencyCreditWarningLevel
        self.lowEmergencyCreditWarningLevel_nsprefix_ = None
        self.prepayMode = prepayMode
        self.prepayMode_nsprefix_ = None
        self.PrepayOperationStatusLink = PrepayOperationStatusLink
        self.PrepayOperationStatusLink_nsprefix_ = None
        self.SupplyInterruptionOverrideListLink = SupplyInterruptionOverrideListLink
        self.SupplyInterruptionOverrideListLink_nsprefix_ = None
        if UsagePoint is None:
            self.UsagePoint = []
        else:
            self.UsagePoint = UsagePoint
        self.UsagePoint_nsprefix_ = None
        self.UsagePointLink = UsagePointLink
        self.UsagePointLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Prepayment)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Prepayment.subclass:
            return Prepayment.subclass(*args_, **kwargs_)
        else:
            return Prepayment(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_AccountBalanceLink(self):
        return self.AccountBalanceLink
    def set_AccountBalanceLink(self, AccountBalanceLink):
        self.AccountBalanceLink = AccountBalanceLink
    def get_ActiveCreditRegisterListLink(self):
        return self.ActiveCreditRegisterListLink
    def set_ActiveCreditRegisterListLink(self, ActiveCreditRegisterListLink):
        self.ActiveCreditRegisterListLink = ActiveCreditRegisterListLink
    def get_ActiveSupplyInterruptionOverrideListLink(self):
        return self.ActiveSupplyInterruptionOverrideListLink
    def set_ActiveSupplyInterruptionOverrideListLink(self, ActiveSupplyInterruptionOverrideListLink):
        self.ActiveSupplyInterruptionOverrideListLink = ActiveSupplyInterruptionOverrideListLink
    def get_creditExpiryLevel(self):
        return self.creditExpiryLevel
    def set_creditExpiryLevel(self, creditExpiryLevel):
        self.creditExpiryLevel = creditExpiryLevel
    def get_CreditRegisterListLink(self):
        return self.CreditRegisterListLink
    def set_CreditRegisterListLink(self, CreditRegisterListLink):
        self.CreditRegisterListLink = CreditRegisterListLink
    def get_lowCreditWarningLevel(self):
        return self.lowCreditWarningLevel
    def set_lowCreditWarningLevel(self, lowCreditWarningLevel):
        self.lowCreditWarningLevel = lowCreditWarningLevel
    def get_lowEmergencyCreditWarningLevel(self):
        return self.lowEmergencyCreditWarningLevel
    def set_lowEmergencyCreditWarningLevel(self, lowEmergencyCreditWarningLevel):
        self.lowEmergencyCreditWarningLevel = lowEmergencyCreditWarningLevel
    def get_prepayMode(self):
        return self.prepayMode
    def set_prepayMode(self, prepayMode):
        self.prepayMode = prepayMode
    def get_PrepayOperationStatusLink(self):
        return self.PrepayOperationStatusLink
    def set_PrepayOperationStatusLink(self, PrepayOperationStatusLink):
        self.PrepayOperationStatusLink = PrepayOperationStatusLink
    def get_SupplyInterruptionOverrideListLink(self):
        return self.SupplyInterruptionOverrideListLink
    def set_SupplyInterruptionOverrideListLink(self, SupplyInterruptionOverrideListLink):
        self.SupplyInterruptionOverrideListLink = SupplyInterruptionOverrideListLink
    def get_UsagePoint(self):
        return self.UsagePoint
    def set_UsagePoint(self, UsagePoint):
        self.UsagePoint = UsagePoint
    def add_UsagePoint(self, value):
        self.UsagePoint.append(value)
    def insert_UsagePoint_at(self, index, value):
        self.UsagePoint.insert(index, value)
    def replace_UsagePoint_at(self, index, value):
        self.UsagePoint[index] = value
    def get_UsagePointLink(self):
        return self.UsagePointLink
    def set_UsagePointLink(self, UsagePointLink):
        self.UsagePointLink = UsagePointLink
    def _hasContent(self):
        if (
            self.AccountBalanceLink is not None or
            self.ActiveCreditRegisterListLink is not None or
            self.ActiveSupplyInterruptionOverrideListLink is not None or
            self.creditExpiryLevel is not None or
            self.CreditRegisterListLink is not None or
            self.lowCreditWarningLevel is not None or
            self.lowEmergencyCreditWarningLevel is not None or
            self.prepayMode is not None or
            self.PrepayOperationStatusLink is not None or
            self.SupplyInterruptionOverrideListLink is not None or
            self.UsagePoint or
            self.UsagePointLink is not None or
            super(Prepayment, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Prepayment', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Prepayment')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Prepayment':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Prepayment')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Prepayment', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Prepayment'):
        super(Prepayment, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Prepayment')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Prepayment', fromsubclass_=False, pretty_print=True):
        super(Prepayment, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AccountBalanceLink is not None:
            namespaceprefix_ = self.AccountBalanceLink_nsprefix_ + ':' if (UseCapturedNS_ and self.AccountBalanceLink_nsprefix_) else ''
            self.AccountBalanceLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AccountBalanceLink', pretty_print=pretty_print)
        if self.ActiveCreditRegisterListLink is not None:
            namespaceprefix_ = self.ActiveCreditRegisterListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveCreditRegisterListLink_nsprefix_) else ''
            self.ActiveCreditRegisterListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ActiveCreditRegisterListLink', pretty_print=pretty_print)
        if self.ActiveSupplyInterruptionOverrideListLink is not None:
            namespaceprefix_ = self.ActiveSupplyInterruptionOverrideListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveSupplyInterruptionOverrideListLink_nsprefix_) else ''
            self.ActiveSupplyInterruptionOverrideListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ActiveSupplyInterruptionOverrideListLink', pretty_print=pretty_print)
        if self.creditExpiryLevel is not None:
            namespaceprefix_ = self.creditExpiryLevel_nsprefix_ + ':' if (UseCapturedNS_ and self.creditExpiryLevel_nsprefix_) else ''
            self.creditExpiryLevel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creditExpiryLevel', pretty_print=pretty_print)
        if self.CreditRegisterListLink is not None:
            namespaceprefix_ = self.CreditRegisterListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.CreditRegisterListLink_nsprefix_) else ''
            self.CreditRegisterListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CreditRegisterListLink', pretty_print=pretty_print)
        if self.lowCreditWarningLevel is not None:
            namespaceprefix_ = self.lowCreditWarningLevel_nsprefix_ + ':' if (UseCapturedNS_ and self.lowCreditWarningLevel_nsprefix_) else ''
            self.lowCreditWarningLevel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lowCreditWarningLevel', pretty_print=pretty_print)
        if self.lowEmergencyCreditWarningLevel is not None:
            namespaceprefix_ = self.lowEmergencyCreditWarningLevel_nsprefix_ + ':' if (UseCapturedNS_ and self.lowEmergencyCreditWarningLevel_nsprefix_) else ''
            self.lowEmergencyCreditWarningLevel.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lowEmergencyCreditWarningLevel', pretty_print=pretty_print)
        if self.prepayMode is not None:
            namespaceprefix_ = self.prepayMode_nsprefix_ + ':' if (UseCapturedNS_ and self.prepayMode_nsprefix_) else ''
            self.prepayMode.export(outfile, level, namespaceprefix_, namespacedef_='', name_='prepayMode', pretty_print=pretty_print)
        if self.PrepayOperationStatusLink is not None:
            namespaceprefix_ = self.PrepayOperationStatusLink_nsprefix_ + ':' if (UseCapturedNS_ and self.PrepayOperationStatusLink_nsprefix_) else ''
            self.PrepayOperationStatusLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrepayOperationStatusLink', pretty_print=pretty_print)
        if self.SupplyInterruptionOverrideListLink is not None:
            namespaceprefix_ = self.SupplyInterruptionOverrideListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.SupplyInterruptionOverrideListLink_nsprefix_) else ''
            self.SupplyInterruptionOverrideListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SupplyInterruptionOverrideListLink', pretty_print=pretty_print)
        for UsagePoint_ in self.UsagePoint:
            namespaceprefix_ = self.UsagePoint_nsprefix_ + ':' if (UseCapturedNS_ and self.UsagePoint_nsprefix_) else ''
            UsagePoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UsagePoint', pretty_print=pretty_print)
        if self.UsagePointLink is not None:
            namespaceprefix_ = self.UsagePointLink_nsprefix_ + ':' if (UseCapturedNS_ and self.UsagePointLink_nsprefix_) else ''
            self.UsagePointLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UsagePointLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Prepayment, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'AccountBalanceLink':
            obj_ = AccountBalanceLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AccountBalanceLink = obj_
            obj_.original_tagname_ = 'AccountBalanceLink'
        elif nodeName_ == 'ActiveCreditRegisterListLink':
            obj_ = ActiveCreditRegisterListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ActiveCreditRegisterListLink = obj_
            obj_.original_tagname_ = 'ActiveCreditRegisterListLink'
        elif nodeName_ == 'ActiveSupplyInterruptionOverrideListLink':
            obj_ = ActiveSupplyInterruptionOverrideListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ActiveSupplyInterruptionOverrideListLink = obj_
            obj_.original_tagname_ = 'ActiveSupplyInterruptionOverrideListLink'
        elif nodeName_ == 'creditExpiryLevel':
            obj_ = AccountingUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creditExpiryLevel = obj_
            obj_.original_tagname_ = 'creditExpiryLevel'
        elif nodeName_ == 'CreditRegisterListLink':
            obj_ = CreditRegisterListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CreditRegisterListLink = obj_
            obj_.original_tagname_ = 'CreditRegisterListLink'
        elif nodeName_ == 'lowCreditWarningLevel':
            obj_ = AccountingUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lowCreditWarningLevel = obj_
            obj_.original_tagname_ = 'lowCreditWarningLevel'
        elif nodeName_ == 'lowEmergencyCreditWarningLevel':
            obj_ = AccountingUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lowEmergencyCreditWarningLevel = obj_
            obj_.original_tagname_ = 'lowEmergencyCreditWarningLevel'
        elif nodeName_ == 'prepayMode':
            obj_ = PrepayModeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.prepayMode = obj_
            obj_.original_tagname_ = 'prepayMode'
        elif nodeName_ == 'PrepayOperationStatusLink':
            obj_ = PrepayOperationStatusLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrepayOperationStatusLink = obj_
            obj_.original_tagname_ = 'PrepayOperationStatusLink'
        elif nodeName_ == 'SupplyInterruptionOverrideListLink':
            obj_ = SupplyInterruptionOverrideListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SupplyInterruptionOverrideListLink = obj_
            obj_.original_tagname_ = 'SupplyInterruptionOverrideListLink'
        elif nodeName_ == 'UsagePoint':
            obj_ = UsagePoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UsagePoint.append(obj_)
            obj_.original_tagname_ = 'UsagePoint'
        elif nodeName_ == 'UsagePointLink':
            obj_ = UsagePointLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UsagePointLink = obj_
            obj_.original_tagname_ = 'UsagePointLink'
        super(Prepayment, self)._buildChildren(child_, node, nodeName_, True)
# end class Prepayment


class CreditRegisterList(List):
    """CreditRegisterList -- A List element to hold CreditRegister objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, CreditRegister=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CreditRegisterList"), self).__init__( **kwargs_)
        if CreditRegister is None:
            self.CreditRegister = []
        else:
            self.CreditRegister = CreditRegister
        self.CreditRegister_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRegisterList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRegisterList.subclass:
            return CreditRegisterList.subclass(*args_, **kwargs_)
        else:
            return CreditRegisterList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CreditRegister(self):
        return self.CreditRegister
    def set_CreditRegister(self, CreditRegister):
        self.CreditRegister = CreditRegister
    def add_CreditRegister(self, value):
        self.CreditRegister.append(value)
    def insert_CreditRegister_at(self, index, value):
        self.CreditRegister.insert(index, value)
    def replace_CreditRegister_at(self, index, value):
        self.CreditRegister[index] = value
    def _hasContent(self):
        if (
            self.CreditRegister or
            super(CreditRegisterList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CreditRegisterList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditRegisterList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditRegisterList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditRegisterList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditRegisterList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditRegisterList'):
        super(CreditRegisterList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditRegisterList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CreditRegisterList', fromsubclass_=False, pretty_print=True):
        super(CreditRegisterList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CreditRegister_ in self.CreditRegister:
            namespaceprefix_ = self.CreditRegister_nsprefix_ + ':' if (UseCapturedNS_ and self.CreditRegister_nsprefix_) else ''
            CreditRegister_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CreditRegister', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CreditRegisterList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CreditRegister':
            obj_ = CreditRegister.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CreditRegister.append(obj_)
            obj_.original_tagname_ = 'CreditRegister'
        super(CreditRegisterList, self)._buildChildren(child_, node, nodeName_, True)
# end class CreditRegisterList


class CreditRegister(IdentifiedObject):
    """CreditRegister -- CreditRegister instances define a credit-modifying transaction. Typically this would be a credit-adding transaction, but may be a subtracting transaction (perhaps in response to an out-of-band debt signal).
    creditAmount -- CreditAmount is the amount of credit being added by a particular CreditRegister transaction. Negative values indicate that credit is being subtracted.
    creditType -- CreditType indicates whether the credit transaction applies to regular or emergency credit.
    effectiveTime -- EffectiveTime identifies the time at which the credit transaction goes into effect. For credit addition transactions, this is typically the moment at which the transaction takes place. For credit subtraction transactions, (e.g., non-fuel debt recovery transactions initiated from a back-haul or ESI) this may be a future time at which credit is deducted.
    token -- Token is security data that authenticates the legitimacy of the transaction. The details of this token are not defined by IEEE 2030.5. How a Prepayment server handles this field is left as vendor specific implementation or will be defined by one or more other standards.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, creditAmount=None, creditType=None, effectiveTime=None, token=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CreditRegister"), self).__init__( **kwargs_)
        self.creditAmount = creditAmount
        self.creditAmount_nsprefix_ = None
        self.creditType = creditType
        self.creditType_nsprefix_ = None
        self.effectiveTime = effectiveTime
        self.effectiveTime_nsprefix_ = None
        self.token = token
        self.validate_String32(self.token)
        self.token_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CreditRegister)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CreditRegister.subclass:
            return CreditRegister.subclass(*args_, **kwargs_)
        else:
            return CreditRegister(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_creditAmount(self):
        return self.creditAmount
    def set_creditAmount(self, creditAmount):
        self.creditAmount = creditAmount
    def get_creditType(self):
        return self.creditType
    def set_creditType(self, creditType):
        self.creditType = creditType
    def get_effectiveTime(self):
        return self.effectiveTime
    def set_effectiveTime(self, effectiveTime):
        self.effectiveTime = effectiveTime
    def get_token(self):
        return self.token
    def set_token(self, token):
        self.token = token
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.creditAmount is not None or
            self.creditType is not None or
            self.effectiveTime is not None or
            self.token is not None or
            super(CreditRegister, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CreditRegister', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CreditRegister')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CreditRegister':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditRegister')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CreditRegister', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CreditRegister'):
        super(CreditRegister, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CreditRegister')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CreditRegister', fromsubclass_=False, pretty_print=True):
        super(CreditRegister, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.creditAmount is not None:
            namespaceprefix_ = self.creditAmount_nsprefix_ + ':' if (UseCapturedNS_ and self.creditAmount_nsprefix_) else ''
            self.creditAmount.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creditAmount', pretty_print=pretty_print)
        if self.creditType is not None:
            namespaceprefix_ = self.creditType_nsprefix_ + ':' if (UseCapturedNS_ and self.creditType_nsprefix_) else ''
            self.creditType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creditType', pretty_print=pretty_print)
        if self.effectiveTime is not None:
            namespaceprefix_ = self.effectiveTime_nsprefix_ + ':' if (UseCapturedNS_ and self.effectiveTime_nsprefix_) else ''
            self.effectiveTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='effectiveTime', pretty_print=pretty_print)
        if self.token is not None:
            namespaceprefix_ = self.token_nsprefix_ + ':' if (UseCapturedNS_ and self.token_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stoken>%s</%stoken>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.token), input_name='token')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CreditRegister, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'creditAmount':
            obj_ = AccountingUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creditAmount = obj_
            obj_.original_tagname_ = 'creditAmount'
        elif nodeName_ == 'creditType':
            obj_ = CreditTypeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creditType = obj_
            obj_.original_tagname_ = 'creditType'
        elif nodeName_ == 'effectiveTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.effectiveTime = obj_
            obj_.original_tagname_ = 'effectiveTime'
        elif nodeName_ == 'token':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'token')
            value_ = self.gds_validate_string(value_, node, 'token')
            self.token = value_
            self.token_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.token)
        super(CreditRegister, self)._buildChildren(child_, node, nodeName_, True)
# end class CreditRegister


class AccountBalance(Resource):
    """AccountBalance -- AccountBalance contains the regular credit and emergency credit balance for this given service or commodity prepay instance. It may also contain status information concerning the balance data.
    availableCredit -- AvailableCredit shows the balance of the sum of credits minus the sum of charges. In a Central Wallet mode this value may be passed down to the Prepayment server via an out-of-band mechanism. In Local or ESI modes, this value may be calculated based upon summation of CreditRegister transactions minus consumption charges calculated using Metering (and possibly Pricing) function set data. This value may be negative; for instance, if disconnection is prevented due to a Supply Interruption Override.
    creditStatus -- CreditStatus identifies whether the present value of availableCredit is considered OK, low, exhausted, or negative.
    emergencyCredit -- EmergencyCredit is the amount of credit still available for the given service or commodity prepayment instance. If both availableCredit and emergyCredit are exhausted, then service will typically be disconnected.
    emergencyCreditStatus -- EmergencyCreditStatus identifies whether the present value of emergencyCredit is considered OK, low, exhausted, or negative.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, availableCredit=None, creditStatus=None, emergencyCredit=None, emergencyCreditStatus=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AccountBalance"), self).__init__( **kwargs_)
        self.availableCredit = availableCredit
        self.availableCredit_nsprefix_ = None
        self.creditStatus = creditStatus
        self.creditStatus_nsprefix_ = None
        self.emergencyCredit = emergencyCredit
        self.emergencyCredit_nsprefix_ = None
        self.emergencyCreditStatus = emergencyCreditStatus
        self.emergencyCreditStatus_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AccountBalance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AccountBalance.subclass:
            return AccountBalance.subclass(*args_, **kwargs_)
        else:
            return AccountBalance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_availableCredit(self):
        return self.availableCredit
    def set_availableCredit(self, availableCredit):
        self.availableCredit = availableCredit
    def get_creditStatus(self):
        return self.creditStatus
    def set_creditStatus(self, creditStatus):
        self.creditStatus = creditStatus
    def get_emergencyCredit(self):
        return self.emergencyCredit
    def set_emergencyCredit(self, emergencyCredit):
        self.emergencyCredit = emergencyCredit
    def get_emergencyCreditStatus(self):
        return self.emergencyCreditStatus
    def set_emergencyCreditStatus(self, emergencyCreditStatus):
        self.emergencyCreditStatus = emergencyCreditStatus
    def _hasContent(self):
        if (
            self.availableCredit is not None or
            self.creditStatus is not None or
            self.emergencyCredit is not None or
            self.emergencyCreditStatus is not None or
            super(AccountBalance, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AccountBalance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AccountBalance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AccountBalance':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccountBalance')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AccountBalance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AccountBalance'):
        super(AccountBalance, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AccountBalance')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AccountBalance', fromsubclass_=False, pretty_print=True):
        super(AccountBalance, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.availableCredit is not None:
            namespaceprefix_ = self.availableCredit_nsprefix_ + ':' if (UseCapturedNS_ and self.availableCredit_nsprefix_) else ''
            self.availableCredit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availableCredit', pretty_print=pretty_print)
        if self.creditStatus is not None:
            namespaceprefix_ = self.creditStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.creditStatus_nsprefix_) else ''
            self.creditStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='creditStatus', pretty_print=pretty_print)
        if self.emergencyCredit is not None:
            namespaceprefix_ = self.emergencyCredit_nsprefix_ + ':' if (UseCapturedNS_ and self.emergencyCredit_nsprefix_) else ''
            self.emergencyCredit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emergencyCredit', pretty_print=pretty_print)
        if self.emergencyCreditStatus is not None:
            namespaceprefix_ = self.emergencyCreditStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.emergencyCreditStatus_nsprefix_) else ''
            self.emergencyCreditStatus.export(outfile, level, namespaceprefix_, namespacedef_='', name_='emergencyCreditStatus', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AccountBalance, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'availableCredit':
            obj_ = AccountingUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availableCredit = obj_
            obj_.original_tagname_ = 'availableCredit'
        elif nodeName_ == 'creditStatus':
            obj_ = CreditStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.creditStatus = obj_
            obj_.original_tagname_ = 'creditStatus'
        elif nodeName_ == 'emergencyCredit':
            obj_ = AccountingUnit.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emergencyCredit = obj_
            obj_.original_tagname_ = 'emergencyCredit'
        elif nodeName_ == 'emergencyCreditStatus':
            obj_ = CreditStatusType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.emergencyCreditStatus = obj_
            obj_.original_tagname_ = 'emergencyCreditStatus'
        super(AccountBalance, self)._buildChildren(child_, node, nodeName_, True)
# end class AccountBalance


class ServiceSupplierList(List):
    """ServiceSupplierList -- A List element to hold ServiceSupplier objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, ServiceSupplier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ServiceSupplierList"), self).__init__( **kwargs_)
        if ServiceSupplier is None:
            self.ServiceSupplier = []
        else:
            self.ServiceSupplier = ServiceSupplier
        self.ServiceSupplier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceSupplierList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceSupplierList.subclass:
            return ServiceSupplierList.subclass(*args_, **kwargs_)
        else:
            return ServiceSupplierList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ServiceSupplier(self):
        return self.ServiceSupplier
    def set_ServiceSupplier(self, ServiceSupplier):
        self.ServiceSupplier = ServiceSupplier
    def add_ServiceSupplier(self, value):
        self.ServiceSupplier.append(value)
    def insert_ServiceSupplier_at(self, index, value):
        self.ServiceSupplier.insert(index, value)
    def replace_ServiceSupplier_at(self, index, value):
        self.ServiceSupplier[index] = value
    def _hasContent(self):
        if (
            self.ServiceSupplier or
            super(ServiceSupplierList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ServiceSupplierList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceSupplierList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceSupplierList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceSupplierList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceSupplierList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceSupplierList'):
        super(ServiceSupplierList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceSupplierList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ServiceSupplierList', fromsubclass_=False, pretty_print=True):
        super(ServiceSupplierList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ServiceSupplier_ in self.ServiceSupplier:
            namespaceprefix_ = self.ServiceSupplier_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceSupplier_nsprefix_) else ''
            ServiceSupplier_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceSupplier', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ServiceSupplierList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ServiceSupplier':
            obj_ = ServiceSupplier.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceSupplier.append(obj_)
            obj_.original_tagname_ = 'ServiceSupplier'
        super(ServiceSupplierList, self)._buildChildren(child_, node, nodeName_, True)
# end class ServiceSupplierList


class ServiceSupplier(IdentifiedObject):
    """ServiceSupplier -- Organisation that provides services to Customers.
    email -- E-mail address for this service supplier.
    phone -- Human-readable phone number for this service supplier.
    providerID -- Contains the IANA PEN for the commodity provider.
    web -- Website URI address for this service supplier.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, email=None, phone=None, providerID=None, web=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ServiceSupplier"), self).__init__( **kwargs_)
        self.email = email
        self.validate_String32(self.email)
        self.email_nsprefix_ = None
        self.phone = phone
        self.validate_String20(self.phone)
        self.phone_nsprefix_ = None
        self.providerID = providerID
        self.validate_UInt32(self.providerID)
        self.providerID_nsprefix_ = None
        self.web = web
        self.validate_String42(self.web)
        self.web_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ServiceSupplier)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ServiceSupplier.subclass:
            return ServiceSupplier.subclass(*args_, **kwargs_)
        else:
            return ServiceSupplier(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_email(self):
        return self.email
    def set_email(self, email):
        self.email = email
    def get_phone(self):
        return self.phone
    def set_phone(self, phone):
        self.phone = phone
    def get_providerID(self):
        return self.providerID
    def set_providerID(self, providerID):
        self.providerID = providerID
    def get_web(self):
        return self.web
    def set_web(self, web):
        self.web = web
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_String20(self, value):
        result = True
        # Validate type String20, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String20' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_String42(self, value):
        result = True
        # Validate type String42, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 42:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String42' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.email is not None or
            self.phone is not None or
            self.providerID is not None or
            self.web is not None or
            super(ServiceSupplier, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ServiceSupplier', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ServiceSupplier')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ServiceSupplier':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceSupplier')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ServiceSupplier', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ServiceSupplier'):
        super(ServiceSupplier, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ServiceSupplier')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ServiceSupplier', fromsubclass_=False, pretty_print=True):
        super(ServiceSupplier, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.email is not None:
            namespaceprefix_ = self.email_nsprefix_ + ':' if (UseCapturedNS_ and self.email_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%semail>%s</%semail>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.email), input_name='email')), namespaceprefix_ , eol_))
        if self.phone is not None:
            namespaceprefix_ = self.phone_nsprefix_ + ':' if (UseCapturedNS_ and self.phone_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sphone>%s</%sphone>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.phone), input_name='phone')), namespaceprefix_ , eol_))
        if self.providerID is not None:
            namespaceprefix_ = self.providerID_nsprefix_ + ':' if (UseCapturedNS_ and self.providerID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sproviderID>%s</%sproviderID>%s' % (namespaceprefix_ , self.gds_format_integer(self.providerID, input_name='providerID'), namespaceprefix_ , eol_))
        if self.web is not None:
            namespaceprefix_ = self.web_nsprefix_ + ':' if (UseCapturedNS_ and self.web_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sweb>%s</%sweb>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.web), input_name='web')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ServiceSupplier, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'email':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'email')
            value_ = self.gds_validate_string(value_, node, 'email')
            self.email = value_
            self.email_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.email)
        elif nodeName_ == 'phone':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'phone')
            value_ = self.gds_validate_string(value_, node, 'phone')
            self.phone = value_
            self.phone_nsprefix_ = child_.prefix
            # validate type String20
            self.validate_String20(self.phone)
        elif nodeName_ == 'providerID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'providerID')
            ival_ = self.gds_validate_integer(ival_, node, 'providerID')
            self.providerID = ival_
            self.providerID_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.providerID)
        elif nodeName_ == 'web':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'web')
            value_ = self.gds_validate_string(value_, node, 'web')
            self.web = value_
            self.web_nsprefix_ = child_.prefix
            # validate type String42
            self.validate_String42(self.web)
        super(ServiceSupplier, self)._buildChildren(child_, node, nodeName_, True)
# end class ServiceSupplier


class TargetReadingList(List):
    """TargetReadingList -- A List element to hold TargetReading objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, TargetReading=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TargetReadingList"), self).__init__( **kwargs_)
        if TargetReading is None:
            self.TargetReading = []
        else:
            self.TargetReading = TargetReading
        self.TargetReading_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetReadingList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetReadingList.subclass:
            return TargetReadingList.subclass(*args_, **kwargs_)
        else:
            return TargetReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TargetReading(self):
        return self.TargetReading
    def set_TargetReading(self, TargetReading):
        self.TargetReading = TargetReading
    def add_TargetReading(self, value):
        self.TargetReading.append(value)
    def insert_TargetReading_at(self, index, value):
        self.TargetReading.insert(index, value)
    def replace_TargetReading_at(self, index, value):
        self.TargetReading[index] = value
    def _hasContent(self):
        if (
            self.TargetReading or
            super(TargetReadingList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TargetReadingList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetReadingList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TargetReadingList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetReadingList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TargetReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TargetReadingList'):
        super(TargetReadingList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetReadingList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TargetReadingList', fromsubclass_=False, pretty_print=True):
        super(TargetReadingList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TargetReading_ in self.TargetReading:
            namespaceprefix_ = self.TargetReading_nsprefix_ + ':' if (UseCapturedNS_ and self.TargetReading_nsprefix_) else ''
            TargetReading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TargetReading', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TargetReadingList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TargetReading':
            obj_ = TargetReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TargetReading.append(obj_)
            obj_.original_tagname_ = 'TargetReading'
        super(TargetReadingList, self)._buildChildren(child_, node, nodeName_, True)
# end class TargetReadingList


class ProjectionReadingList(List):
    """ProjectionReadingList -- A List element to hold ProjectionReading objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, ProjectionReading=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ProjectionReadingList"), self).__init__( **kwargs_)
        if ProjectionReading is None:
            self.ProjectionReading = []
        else:
            self.ProjectionReading = ProjectionReading
        self.ProjectionReading_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectionReadingList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectionReadingList.subclass:
            return ProjectionReadingList.subclass(*args_, **kwargs_)
        else:
            return ProjectionReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ProjectionReading(self):
        return self.ProjectionReading
    def set_ProjectionReading(self, ProjectionReading):
        self.ProjectionReading = ProjectionReading
    def add_ProjectionReading(self, value):
        self.ProjectionReading.append(value)
    def insert_ProjectionReading_at(self, index, value):
        self.ProjectionReading.insert(index, value)
    def replace_ProjectionReading_at(self, index, value):
        self.ProjectionReading[index] = value
    def _hasContent(self):
        if (
            self.ProjectionReading or
            super(ProjectionReadingList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ProjectionReadingList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProjectionReadingList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProjectionReadingList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectionReadingList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProjectionReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProjectionReadingList'):
        super(ProjectionReadingList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectionReadingList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ProjectionReadingList', fromsubclass_=False, pretty_print=True):
        super(ProjectionReadingList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProjectionReading_ in self.ProjectionReading:
            namespaceprefix_ = self.ProjectionReading_nsprefix_ + ':' if (UseCapturedNS_ and self.ProjectionReading_nsprefix_) else ''
            ProjectionReading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ProjectionReading', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ProjectionReadingList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ProjectionReading':
            obj_ = ProjectionReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ProjectionReading.append(obj_)
            obj_.original_tagname_ = 'ProjectionReading'
        super(ProjectionReadingList, self)._buildChildren(child_, node, nodeName_, True)
# end class ProjectionReadingList


class HistoricalReadingList(List):
    """HistoricalReadingList -- A List element to hold HistoricalReading objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, HistoricalReading=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("HistoricalReadingList"), self).__init__( **kwargs_)
        if HistoricalReading is None:
            self.HistoricalReading = []
        else:
            self.HistoricalReading = HistoricalReading
        self.HistoricalReading_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HistoricalReadingList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HistoricalReadingList.subclass:
            return HistoricalReadingList.subclass(*args_, **kwargs_)
        else:
            return HistoricalReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_HistoricalReading(self):
        return self.HistoricalReading
    def set_HistoricalReading(self, HistoricalReading):
        self.HistoricalReading = HistoricalReading
    def add_HistoricalReading(self, value):
        self.HistoricalReading.append(value)
    def insert_HistoricalReading_at(self, index, value):
        self.HistoricalReading.insert(index, value)
    def replace_HistoricalReading_at(self, index, value):
        self.HistoricalReading[index] = value
    def _hasContent(self):
        if (
            self.HistoricalReading or
            super(HistoricalReadingList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='HistoricalReadingList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HistoricalReadingList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HistoricalReadingList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HistoricalReadingList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HistoricalReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HistoricalReadingList'):
        super(HistoricalReadingList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HistoricalReadingList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='HistoricalReadingList', fromsubclass_=False, pretty_print=True):
        super(HistoricalReadingList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HistoricalReading_ in self.HistoricalReading:
            namespaceprefix_ = self.HistoricalReading_nsprefix_ + ':' if (UseCapturedNS_ and self.HistoricalReading_nsprefix_) else ''
            HistoricalReading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HistoricalReading', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(HistoricalReadingList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'HistoricalReading':
            obj_ = HistoricalReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HistoricalReading.append(obj_)
            obj_.original_tagname_ = 'HistoricalReading'
        super(HistoricalReadingList, self)._buildChildren(child_, node, nodeName_, True)
# end class HistoricalReadingList


class CustomerAgreementList(SubscribableList):
    """CustomerAgreementList -- A List element to hold CustomerAgreement objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, CustomerAgreement=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CustomerAgreementList"), self).__init__( **kwargs_)
        if CustomerAgreement is None:
            self.CustomerAgreement = []
        else:
            self.CustomerAgreement = CustomerAgreement
        self.CustomerAgreement_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerAgreementList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerAgreementList.subclass:
            return CustomerAgreementList.subclass(*args_, **kwargs_)
        else:
            return CustomerAgreementList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CustomerAgreement(self):
        return self.CustomerAgreement
    def set_CustomerAgreement(self, CustomerAgreement):
        self.CustomerAgreement = CustomerAgreement
    def add_CustomerAgreement(self, value):
        self.CustomerAgreement.append(value)
    def insert_CustomerAgreement_at(self, index, value):
        self.CustomerAgreement.insert(index, value)
    def replace_CustomerAgreement_at(self, index, value):
        self.CustomerAgreement[index] = value
    def _hasContent(self):
        if (
            self.CustomerAgreement or
            super(CustomerAgreementList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CustomerAgreementList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerAgreementList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerAgreementList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAgreementList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerAgreementList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerAgreementList'):
        super(CustomerAgreementList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAgreementList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CustomerAgreementList', fromsubclass_=False, pretty_print=True):
        super(CustomerAgreementList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CustomerAgreement_ in self.CustomerAgreement:
            namespaceprefix_ = self.CustomerAgreement_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomerAgreement_nsprefix_) else ''
            CustomerAgreement_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomerAgreement', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CustomerAgreementList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CustomerAgreement':
            obj_ = CustomerAgreement.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomerAgreement.append(obj_)
            obj_.original_tagname_ = 'CustomerAgreement'
        super(CustomerAgreementList, self)._buildChildren(child_, node, nodeName_, True)
# end class CustomerAgreementList


class CustomerAgreement(IdentifiedObject):
    """CustomerAgreement -- Agreement between the customer and the service supplier to pay for service at a specific service location. It records certain billing information about the type of service provided at the service location and is used during charge creation to determine the type of service.
    serviceAccount -- The account number of the service account (if applicable).
    serviceLocation -- The address or textual description of the service location.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, ActiveBillingPeriodListLink=None, ActiveProjectionReadingListLink=None, ActiveTargetReadingListLink=None, BillingPeriodListLink=None, HistoricalReadingListLink=None, PrepaymentLink=None, ProjectionReadingListLink=None, serviceAccount=None, serviceLocation=None, TargetReadingListLink=None, TariffProfileLink=None, UsagePointLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CustomerAgreement"), self).__init__( **kwargs_)
        self.ActiveBillingPeriodListLink = ActiveBillingPeriodListLink
        self.ActiveBillingPeriodListLink_nsprefix_ = None
        self.ActiveProjectionReadingListLink = ActiveProjectionReadingListLink
        self.ActiveProjectionReadingListLink_nsprefix_ = None
        self.ActiveTargetReadingListLink = ActiveTargetReadingListLink
        self.ActiveTargetReadingListLink_nsprefix_ = None
        self.BillingPeriodListLink = BillingPeriodListLink
        self.BillingPeriodListLink_nsprefix_ = None
        self.HistoricalReadingListLink = HistoricalReadingListLink
        self.HistoricalReadingListLink_nsprefix_ = None
        self.PrepaymentLink = PrepaymentLink
        self.PrepaymentLink_nsprefix_ = None
        self.ProjectionReadingListLink = ProjectionReadingListLink
        self.ProjectionReadingListLink_nsprefix_ = None
        self.serviceAccount = serviceAccount
        self.validate_String42(self.serviceAccount)
        self.serviceAccount_nsprefix_ = None
        self.serviceLocation = serviceLocation
        self.validate_String42(self.serviceLocation)
        self.serviceLocation_nsprefix_ = None
        self.TargetReadingListLink = TargetReadingListLink
        self.TargetReadingListLink_nsprefix_ = None
        self.TariffProfileLink = TariffProfileLink
        self.TariffProfileLink_nsprefix_ = None
        self.UsagePointLink = UsagePointLink
        self.UsagePointLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerAgreement)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerAgreement.subclass:
            return CustomerAgreement.subclass(*args_, **kwargs_)
        else:
            return CustomerAgreement(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ActiveBillingPeriodListLink(self):
        return self.ActiveBillingPeriodListLink
    def set_ActiveBillingPeriodListLink(self, ActiveBillingPeriodListLink):
        self.ActiveBillingPeriodListLink = ActiveBillingPeriodListLink
    def get_ActiveProjectionReadingListLink(self):
        return self.ActiveProjectionReadingListLink
    def set_ActiveProjectionReadingListLink(self, ActiveProjectionReadingListLink):
        self.ActiveProjectionReadingListLink = ActiveProjectionReadingListLink
    def get_ActiveTargetReadingListLink(self):
        return self.ActiveTargetReadingListLink
    def set_ActiveTargetReadingListLink(self, ActiveTargetReadingListLink):
        self.ActiveTargetReadingListLink = ActiveTargetReadingListLink
    def get_BillingPeriodListLink(self):
        return self.BillingPeriodListLink
    def set_BillingPeriodListLink(self, BillingPeriodListLink):
        self.BillingPeriodListLink = BillingPeriodListLink
    def get_HistoricalReadingListLink(self):
        return self.HistoricalReadingListLink
    def set_HistoricalReadingListLink(self, HistoricalReadingListLink):
        self.HistoricalReadingListLink = HistoricalReadingListLink
    def get_PrepaymentLink(self):
        return self.PrepaymentLink
    def set_PrepaymentLink(self, PrepaymentLink):
        self.PrepaymentLink = PrepaymentLink
    def get_ProjectionReadingListLink(self):
        return self.ProjectionReadingListLink
    def set_ProjectionReadingListLink(self, ProjectionReadingListLink):
        self.ProjectionReadingListLink = ProjectionReadingListLink
    def get_serviceAccount(self):
        return self.serviceAccount
    def set_serviceAccount(self, serviceAccount):
        self.serviceAccount = serviceAccount
    def get_serviceLocation(self):
        return self.serviceLocation
    def set_serviceLocation(self, serviceLocation):
        self.serviceLocation = serviceLocation
    def get_TargetReadingListLink(self):
        return self.TargetReadingListLink
    def set_TargetReadingListLink(self, TargetReadingListLink):
        self.TargetReadingListLink = TargetReadingListLink
    def get_TariffProfileLink(self):
        return self.TariffProfileLink
    def set_TariffProfileLink(self, TariffProfileLink):
        self.TariffProfileLink = TariffProfileLink
    def get_UsagePointLink(self):
        return self.UsagePointLink
    def set_UsagePointLink(self, UsagePointLink):
        self.UsagePointLink = UsagePointLink
    def validate_String42(self, value):
        result = True
        # Validate type String42, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 42:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String42' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.ActiveBillingPeriodListLink is not None or
            self.ActiveProjectionReadingListLink is not None or
            self.ActiveTargetReadingListLink is not None or
            self.BillingPeriodListLink is not None or
            self.HistoricalReadingListLink is not None or
            self.PrepaymentLink is not None or
            self.ProjectionReadingListLink is not None or
            self.serviceAccount is not None or
            self.serviceLocation is not None or
            self.TargetReadingListLink is not None or
            self.TariffProfileLink is not None or
            self.UsagePointLink is not None or
            super(CustomerAgreement, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CustomerAgreement', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerAgreement')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerAgreement':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAgreement')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerAgreement', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerAgreement'):
        super(CustomerAgreement, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAgreement')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CustomerAgreement', fromsubclass_=False, pretty_print=True):
        super(CustomerAgreement, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveBillingPeriodListLink is not None:
            namespaceprefix_ = self.ActiveBillingPeriodListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveBillingPeriodListLink_nsprefix_) else ''
            self.ActiveBillingPeriodListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ActiveBillingPeriodListLink', pretty_print=pretty_print)
        if self.ActiveProjectionReadingListLink is not None:
            namespaceprefix_ = self.ActiveProjectionReadingListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveProjectionReadingListLink_nsprefix_) else ''
            self.ActiveProjectionReadingListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ActiveProjectionReadingListLink', pretty_print=pretty_print)
        if self.ActiveTargetReadingListLink is not None:
            namespaceprefix_ = self.ActiveTargetReadingListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveTargetReadingListLink_nsprefix_) else ''
            self.ActiveTargetReadingListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ActiveTargetReadingListLink', pretty_print=pretty_print)
        if self.BillingPeriodListLink is not None:
            namespaceprefix_ = self.BillingPeriodListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.BillingPeriodListLink_nsprefix_) else ''
            self.BillingPeriodListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BillingPeriodListLink', pretty_print=pretty_print)
        if self.HistoricalReadingListLink is not None:
            namespaceprefix_ = self.HistoricalReadingListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.HistoricalReadingListLink_nsprefix_) else ''
            self.HistoricalReadingListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='HistoricalReadingListLink', pretty_print=pretty_print)
        if self.PrepaymentLink is not None:
            namespaceprefix_ = self.PrepaymentLink_nsprefix_ + ':' if (UseCapturedNS_ and self.PrepaymentLink_nsprefix_) else ''
            self.PrepaymentLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrepaymentLink', pretty_print=pretty_print)
        if self.ProjectionReadingListLink is not None:
            namespaceprefix_ = self.ProjectionReadingListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ProjectionReadingListLink_nsprefix_) else ''
            self.ProjectionReadingListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ProjectionReadingListLink', pretty_print=pretty_print)
        if self.serviceAccount is not None:
            namespaceprefix_ = self.serviceAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserviceAccount>%s</%sserviceAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serviceAccount), input_name='serviceAccount')), namespaceprefix_ , eol_))
        if self.serviceLocation is not None:
            namespaceprefix_ = self.serviceLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceLocation_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sserviceLocation>%s</%sserviceLocation>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.serviceLocation), input_name='serviceLocation')), namespaceprefix_ , eol_))
        if self.TargetReadingListLink is not None:
            namespaceprefix_ = self.TargetReadingListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.TargetReadingListLink_nsprefix_) else ''
            self.TargetReadingListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TargetReadingListLink', pretty_print=pretty_print)
        if self.TariffProfileLink is not None:
            namespaceprefix_ = self.TariffProfileLink_nsprefix_ + ':' if (UseCapturedNS_ and self.TariffProfileLink_nsprefix_) else ''
            self.TariffProfileLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TariffProfileLink', pretty_print=pretty_print)
        if self.UsagePointLink is not None:
            namespaceprefix_ = self.UsagePointLink_nsprefix_ + ':' if (UseCapturedNS_ and self.UsagePointLink_nsprefix_) else ''
            self.UsagePointLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UsagePointLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CustomerAgreement, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ActiveBillingPeriodListLink':
            obj_ = ActiveBillingPeriodListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ActiveBillingPeriodListLink = obj_
            obj_.original_tagname_ = 'ActiveBillingPeriodListLink'
        elif nodeName_ == 'ActiveProjectionReadingListLink':
            obj_ = ActiveProjectionReadingListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ActiveProjectionReadingListLink = obj_
            obj_.original_tagname_ = 'ActiveProjectionReadingListLink'
        elif nodeName_ == 'ActiveTargetReadingListLink':
            obj_ = ActiveTargetReadingListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ActiveTargetReadingListLink = obj_
            obj_.original_tagname_ = 'ActiveTargetReadingListLink'
        elif nodeName_ == 'BillingPeriodListLink':
            obj_ = BillingPeriodListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BillingPeriodListLink = obj_
            obj_.original_tagname_ = 'BillingPeriodListLink'
        elif nodeName_ == 'HistoricalReadingListLink':
            obj_ = HistoricalReadingListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.HistoricalReadingListLink = obj_
            obj_.original_tagname_ = 'HistoricalReadingListLink'
        elif nodeName_ == 'PrepaymentLink':
            obj_ = PrepaymentLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrepaymentLink = obj_
            obj_.original_tagname_ = 'PrepaymentLink'
        elif nodeName_ == 'ProjectionReadingListLink':
            obj_ = ProjectionReadingListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ProjectionReadingListLink = obj_
            obj_.original_tagname_ = 'ProjectionReadingListLink'
        elif nodeName_ == 'serviceAccount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serviceAccount')
            value_ = self.gds_validate_string(value_, node, 'serviceAccount')
            self.serviceAccount = value_
            self.serviceAccount_nsprefix_ = child_.prefix
            # validate type String42
            self.validate_String42(self.serviceAccount)
        elif nodeName_ == 'serviceLocation':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'serviceLocation')
            value_ = self.gds_validate_string(value_, node, 'serviceLocation')
            self.serviceLocation = value_
            self.serviceLocation_nsprefix_ = child_.prefix
            # validate type String42
            self.validate_String42(self.serviceLocation)
        elif nodeName_ == 'TargetReadingListLink':
            obj_ = TargetReadingListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TargetReadingListLink = obj_
            obj_.original_tagname_ = 'TargetReadingListLink'
        elif nodeName_ == 'TariffProfileLink':
            obj_ = TariffProfileLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TariffProfileLink = obj_
            obj_.original_tagname_ = 'TariffProfileLink'
        elif nodeName_ == 'UsagePointLink':
            obj_ = UsagePointLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UsagePointLink = obj_
            obj_.original_tagname_ = 'UsagePointLink'
        super(CustomerAgreement, self)._buildChildren(child_, node, nodeName_, True)
# end class CustomerAgreement


class CustomerAccountList(SubscribableList):
    """CustomerAccountList -- A List element to hold CustomerAccount objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', CustomerAccount=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CustomerAccountList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if CustomerAccount is None:
            self.CustomerAccount = []
        else:
            self.CustomerAccount = CustomerAccount
        self.CustomerAccount_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerAccountList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerAccountList.subclass:
            return CustomerAccountList.subclass(*args_, **kwargs_)
        else:
            return CustomerAccountList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CustomerAccount(self):
        return self.CustomerAccount
    def set_CustomerAccount(self, CustomerAccount):
        self.CustomerAccount = CustomerAccount
    def add_CustomerAccount(self, value):
        self.CustomerAccount.append(value)
    def insert_CustomerAccount_at(self, index, value):
        self.CustomerAccount.insert(index, value)
    def replace_CustomerAccount_at(self, index, value):
        self.CustomerAccount[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.CustomerAccount or
            super(CustomerAccountList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CustomerAccountList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerAccountList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerAccountList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAccountList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerAccountList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerAccountList'):
        super(CustomerAccountList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAccountList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CustomerAccountList', fromsubclass_=False, pretty_print=True):
        super(CustomerAccountList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CustomerAccount_ in self.CustomerAccount:
            namespaceprefix_ = self.CustomerAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomerAccount_nsprefix_) else ''
            CustomerAccount_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomerAccount', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(CustomerAccountList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CustomerAccount':
            obj_ = CustomerAccount.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomerAccount.append(obj_)
            obj_.original_tagname_ = 'CustomerAccount'
        super(CustomerAccountList, self)._buildChildren(child_, node, nodeName_, True)
# end class CustomerAccountList


class CustomerAccount(IdentifiedObject):
    """CustomerAccount -- Assignment of a group of products and services purchased by the Customer through a CustomerAgreement, used as a mechanism for customer billing and payment. It contains common information from the various types of CustomerAgreements to create billings (invoices) for a Customer and receive payment.
    currency -- The ISO 4217 code indicating the currency applicable to the bill amounts in the summary. See list at http://www.unece.org/cefact/recommendations/rec09/rec09_ecetrd203.pdf
    customerAccount -- The account number for the customer (if applicable).
    customerName -- The name of the customer.
    pricePowerOfTenMultiplier -- Indicates the power of ten multiplier for the prices in this function set.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, currency=None, customerAccount=None, CustomerAgreementListLink=None, customerName=None, pricePowerOfTenMultiplier=None, ServiceSupplierLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("CustomerAccount"), self).__init__( **kwargs_)
        self.currency = currency
        self.validate_UInt16(self.currency)
        self.currency_nsprefix_ = None
        self.customerAccount = customerAccount
        self.validate_String42(self.customerAccount)
        self.customerAccount_nsprefix_ = None
        self.CustomerAgreementListLink = CustomerAgreementListLink
        self.CustomerAgreementListLink_nsprefix_ = None
        self.customerName = customerName
        self.validate_String42(self.customerName)
        self.customerName_nsprefix_ = None
        self.pricePowerOfTenMultiplier = pricePowerOfTenMultiplier
        self.pricePowerOfTenMultiplier_nsprefix_ = None
        self.ServiceSupplierLink = ServiceSupplierLink
        self.ServiceSupplierLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, CustomerAccount)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if CustomerAccount.subclass:
            return CustomerAccount.subclass(*args_, **kwargs_)
        else:
            return CustomerAccount(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currency(self):
        return self.currency
    def set_currency(self, currency):
        self.currency = currency
    def get_customerAccount(self):
        return self.customerAccount
    def set_customerAccount(self, customerAccount):
        self.customerAccount = customerAccount
    def get_CustomerAgreementListLink(self):
        return self.CustomerAgreementListLink
    def set_CustomerAgreementListLink(self, CustomerAgreementListLink):
        self.CustomerAgreementListLink = CustomerAgreementListLink
    def get_customerName(self):
        return self.customerName
    def set_customerName(self, customerName):
        self.customerName = customerName
    def get_pricePowerOfTenMultiplier(self):
        return self.pricePowerOfTenMultiplier
    def set_pricePowerOfTenMultiplier(self, pricePowerOfTenMultiplier):
        self.pricePowerOfTenMultiplier = pricePowerOfTenMultiplier
    def get_ServiceSupplierLink(self):
        return self.ServiceSupplierLink
    def set_ServiceSupplierLink(self, ServiceSupplierLink):
        self.ServiceSupplierLink = ServiceSupplierLink
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_String42(self, value):
        result = True
        # Validate type String42, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 42:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String42' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.currency is not None or
            self.customerAccount is not None or
            self.CustomerAgreementListLink is not None or
            self.customerName is not None or
            self.pricePowerOfTenMultiplier is not None or
            self.ServiceSupplierLink is not None or
            super(CustomerAccount, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CustomerAccount', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('CustomerAccount')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'CustomerAccount':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAccount')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='CustomerAccount', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='CustomerAccount'):
        super(CustomerAccount, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='CustomerAccount')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='CustomerAccount', fromsubclass_=False, pretty_print=True):
        super(CustomerAccount, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            namespaceprefix_ = self.currency_nsprefix_ + ':' if (UseCapturedNS_ and self.currency_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scurrency>%s</%scurrency>%s' % (namespaceprefix_ , self.gds_format_integer(self.currency, input_name='currency'), namespaceprefix_ , eol_))
        if self.customerAccount is not None:
            namespaceprefix_ = self.customerAccount_nsprefix_ + ':' if (UseCapturedNS_ and self.customerAccount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerAccount>%s</%scustomerAccount>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customerAccount), input_name='customerAccount')), namespaceprefix_ , eol_))
        if self.CustomerAgreementListLink is not None:
            namespaceprefix_ = self.CustomerAgreementListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomerAgreementListLink_nsprefix_) else ''
            self.CustomerAgreementListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomerAgreementListLink', pretty_print=pretty_print)
        if self.customerName is not None:
            namespaceprefix_ = self.customerName_nsprefix_ + ':' if (UseCapturedNS_ and self.customerName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%scustomerName>%s</%scustomerName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.customerName), input_name='customerName')), namespaceprefix_ , eol_))
        if self.pricePowerOfTenMultiplier is not None:
            namespaceprefix_ = self.pricePowerOfTenMultiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.pricePowerOfTenMultiplier_nsprefix_) else ''
            self.pricePowerOfTenMultiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pricePowerOfTenMultiplier', pretty_print=pretty_print)
        if self.ServiceSupplierLink is not None:
            namespaceprefix_ = self.ServiceSupplierLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ServiceSupplierLink_nsprefix_) else ''
            self.ServiceSupplierLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ServiceSupplierLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(CustomerAccount, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'currency')
            ival_ = self.gds_validate_integer(ival_, node, 'currency')
            self.currency = ival_
            self.currency_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.currency)
        elif nodeName_ == 'customerAccount':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerAccount')
            value_ = self.gds_validate_string(value_, node, 'customerAccount')
            self.customerAccount = value_
            self.customerAccount_nsprefix_ = child_.prefix
            # validate type String42
            self.validate_String42(self.customerAccount)
        elif nodeName_ == 'CustomerAgreementListLink':
            obj_ = CustomerAgreementListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomerAgreementListLink = obj_
            obj_.original_tagname_ = 'CustomerAgreementListLink'
        elif nodeName_ == 'customerName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'customerName')
            value_ = self.gds_validate_string(value_, node, 'customerName')
            self.customerName = value_
            self.customerName_nsprefix_ = child_.prefix
            # validate type String42
            self.validate_String42(self.customerName)
        elif nodeName_ == 'pricePowerOfTenMultiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pricePowerOfTenMultiplier = obj_
            obj_.original_tagname_ = 'pricePowerOfTenMultiplier'
        elif nodeName_ == 'ServiceSupplierLink':
            obj_ = ServiceSupplierLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ServiceSupplierLink = obj_
            obj_.original_tagname_ = 'ServiceSupplierLink'
        super(CustomerAccount, self)._buildChildren(child_, node, nodeName_, True)
# end class CustomerAccount


class BillingReadingSetList(SubscribableList):
    """BillingReadingSetList -- A List element to hold BillingReadingSet objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, BillingReadingSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingReadingSetList"), self).__init__( **kwargs_)
        if BillingReadingSet is None:
            self.BillingReadingSet = []
        else:
            self.BillingReadingSet = BillingReadingSet
        self.BillingReadingSet_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingReadingSetList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingReadingSetList.subclass:
            return BillingReadingSetList.subclass(*args_, **kwargs_)
        else:
            return BillingReadingSetList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BillingReadingSet(self):
        return self.BillingReadingSet
    def set_BillingReadingSet(self, BillingReadingSet):
        self.BillingReadingSet = BillingReadingSet
    def add_BillingReadingSet(self, value):
        self.BillingReadingSet.append(value)
    def insert_BillingReadingSet_at(self, index, value):
        self.BillingReadingSet.insert(index, value)
    def replace_BillingReadingSet_at(self, index, value):
        self.BillingReadingSet[index] = value
    def _hasContent(self):
        if (
            self.BillingReadingSet or
            super(BillingReadingSetList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingReadingSetList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingReadingSetList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingReadingSetList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingSetList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingReadingSetList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingReadingSetList'):
        super(BillingReadingSetList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingSetList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingReadingSetList', fromsubclass_=False, pretty_print=True):
        super(BillingReadingSetList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BillingReadingSet_ in self.BillingReadingSet:
            namespaceprefix_ = self.BillingReadingSet_nsprefix_ + ':' if (UseCapturedNS_ and self.BillingReadingSet_nsprefix_) else ''
            BillingReadingSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BillingReadingSet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingSetList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BillingReadingSet':
            obj_ = BillingReadingSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BillingReadingSet.append(obj_)
            obj_.original_tagname_ = 'BillingReadingSet'
        super(BillingReadingSetList, self)._buildChildren(child_, node, nodeName_, True)
# end class BillingReadingSetList


class BillingReadingList(List):
    """BillingReadingList -- A List element to hold BillingReading objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, BillingReading=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingReadingList"), self).__init__( **kwargs_)
        if BillingReading is None:
            self.BillingReading = []
        else:
            self.BillingReading = BillingReading
        self.BillingReading_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingReadingList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingReadingList.subclass:
            return BillingReadingList.subclass(*args_, **kwargs_)
        else:
            return BillingReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BillingReading(self):
        return self.BillingReading
    def set_BillingReading(self, BillingReading):
        self.BillingReading = BillingReading
    def add_BillingReading(self, value):
        self.BillingReading.append(value)
    def insert_BillingReading_at(self, index, value):
        self.BillingReading.insert(index, value)
    def replace_BillingReading_at(self, index, value):
        self.BillingReading[index] = value
    def _hasContent(self):
        if (
            self.BillingReading or
            super(BillingReadingList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingReadingList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingReadingList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingReadingList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingReadingList'):
        super(BillingReadingList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingReadingList', fromsubclass_=False, pretty_print=True):
        super(BillingReadingList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BillingReading_ in self.BillingReading:
            namespaceprefix_ = self.BillingReading_nsprefix_ + ':' if (UseCapturedNS_ and self.BillingReading_nsprefix_) else ''
            BillingReading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BillingReading', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BillingReading':
            obj_ = BillingReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BillingReading.append(obj_)
            obj_.original_tagname_ = 'BillingReading'
        super(BillingReadingList, self)._buildChildren(child_, node, nodeName_, True)
# end class BillingReadingList


class BillingReading(ReadingBase):
    """BillingReading -- Data captured at regular intervals of time. Interval data could be captured as incremental data, absolute data, or relative data. The source for the data is usually a tariff quantity or an engineering quantity. Data is typically captured in time-tagged, uniform, fixed-length intervals of 5 min, 10 min, 15 min, 30 min, or 60 min. However, consumption aggregations can also be represented with this class.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReadingBase
    def __init__(self, Charge=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingReading"), self).__init__( **kwargs_)
        if Charge is None:
            self.Charge = []
        else:
            self.Charge = Charge
        self.Charge_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingReading)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingReading.subclass:
            return BillingReading.subclass(*args_, **kwargs_)
        else:
            return BillingReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Charge(self):
        return self.Charge
    def set_Charge(self, Charge):
        self.Charge = Charge
    def add_Charge(self, value):
        self.Charge.append(value)
    def insert_Charge_at(self, index, value):
        self.Charge.insert(index, value)
    def replace_Charge_at(self, index, value):
        self.Charge[index] = value
    def _hasContent(self):
        if (
            self.Charge or
            super(BillingReading, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingReading', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingReading')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingReading':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReading')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingReading', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingReading'):
        super(BillingReading, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReading')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingReading', fromsubclass_=False, pretty_print=True):
        super(BillingReading, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Charge_ in self.Charge:
            namespaceprefix_ = self.Charge_nsprefix_ + ':' if (UseCapturedNS_ and self.Charge_nsprefix_) else ''
            Charge_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Charge', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingReading, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Charge':
            obj_ = Charge.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Charge.append(obj_)
            obj_.original_tagname_ = 'Charge'
        super(BillingReading, self)._buildChildren(child_, node, nodeName_, True)
# end class BillingReading


class BillingPeriodList(SubscribableList):
    """BillingPeriodList -- A List element to hold BillingPeriod objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, BillingPeriod=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingPeriodList"), self).__init__( **kwargs_)
        if BillingPeriod is None:
            self.BillingPeriod = []
        else:
            self.BillingPeriod = BillingPeriod
        self.BillingPeriod_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingPeriodList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingPeriodList.subclass:
            return BillingPeriodList.subclass(*args_, **kwargs_)
        else:
            return BillingPeriodList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BillingPeriod(self):
        return self.BillingPeriod
    def set_BillingPeriod(self, BillingPeriod):
        self.BillingPeriod = BillingPeriod
    def add_BillingPeriod(self, value):
        self.BillingPeriod.append(value)
    def insert_BillingPeriod_at(self, index, value):
        self.BillingPeriod.insert(index, value)
    def replace_BillingPeriod_at(self, index, value):
        self.BillingPeriod[index] = value
    def _hasContent(self):
        if (
            self.BillingPeriod or
            super(BillingPeriodList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingPeriodList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingPeriodList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingPeriodList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingPeriodList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingPeriodList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingPeriodList'):
        super(BillingPeriodList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingPeriodList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingPeriodList', fromsubclass_=False, pretty_print=True):
        super(BillingPeriodList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BillingPeriod_ in self.BillingPeriod:
            namespaceprefix_ = self.BillingPeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.BillingPeriod_nsprefix_) else ''
            BillingPeriod_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BillingPeriod', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingPeriodList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BillingPeriod':
            obj_ = BillingPeriod.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BillingPeriod.append(obj_)
            obj_.original_tagname_ = 'BillingPeriod'
        super(BillingPeriodList, self)._buildChildren(child_, node, nodeName_, True)
# end class BillingPeriodList


class BillingPeriod(Resource):
    """BillingPeriod -- A Billing Period relates to the period of time on which a customer is billed.  As an example the billing period interval for a particular customer might be 31 days starting on July 1, 2011. The start date and interval can change on each billing period. There may also be multiple billing periods related to a customer agreement to support different tariff structures.
    billLastPeriod -- The amount of the bill for the previous billing period.
    billToDate -- The bill amount related to the billing period as of the statusTimeStamp.
    interval -- The time interval for this billing period.
    statusTimeStamp -- The date / time of the last update of this resource.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, billLastPeriod=None, billToDate=None, interval=None, statusTimeStamp=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingPeriod"), self).__init__( **kwargs_)
        self.billLastPeriod = billLastPeriod
        self.validate_Int48(self.billLastPeriod)
        self.billLastPeriod_nsprefix_ = None
        self.billToDate = billToDate
        self.validate_Int48(self.billToDate)
        self.billToDate_nsprefix_ = None
        self.interval = interval
        self.interval_nsprefix_ = None
        self.statusTimeStamp = statusTimeStamp
        self.statusTimeStamp_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingPeriod)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingPeriod.subclass:
            return BillingPeriod.subclass(*args_, **kwargs_)
        else:
            return BillingPeriod(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_billLastPeriod(self):
        return self.billLastPeriod
    def set_billLastPeriod(self, billLastPeriod):
        self.billLastPeriod = billLastPeriod
    def get_billToDate(self):
        return self.billToDate
    def set_billToDate(self, billToDate):
        self.billToDate = billToDate
    def get_interval(self):
        return self.interval
    def set_interval(self, interval):
        self.interval = interval
    def get_statusTimeStamp(self):
        return self.statusTimeStamp
    def set_statusTimeStamp(self, statusTimeStamp):
        self.statusTimeStamp = statusTimeStamp
    def validate_Int48(self, value):
        result = True
        # Validate type Int48, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value < -140737488355328:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd minInclusive restriction on Int48' % {"value": value, "lineno": lineno} )
                result = False
            if value > 140737488355328:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on Int48' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.billLastPeriod is not None or
            self.billToDate is not None or
            self.interval is not None or
            self.statusTimeStamp is not None or
            super(BillingPeriod, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingPeriod', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingPeriod')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingPeriod':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingPeriod')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingPeriod', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingPeriod'):
        super(BillingPeriod, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingPeriod')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingPeriod', fromsubclass_=False, pretty_print=True):
        super(BillingPeriod, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.billLastPeriod is not None:
            namespaceprefix_ = self.billLastPeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.billLastPeriod_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbillLastPeriod>%s</%sbillLastPeriod>%s' % (namespaceprefix_ , self.gds_format_integer(self.billLastPeriod, input_name='billLastPeriod'), namespaceprefix_ , eol_))
        if self.billToDate is not None:
            namespaceprefix_ = self.billToDate_nsprefix_ + ':' if (UseCapturedNS_ and self.billToDate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbillToDate>%s</%sbillToDate>%s' % (namespaceprefix_ , self.gds_format_integer(self.billToDate, input_name='billToDate'), namespaceprefix_ , eol_))
        if self.interval is not None:
            namespaceprefix_ = self.interval_nsprefix_ + ':' if (UseCapturedNS_ and self.interval_nsprefix_) else ''
            self.interval.export(outfile, level, namespaceprefix_, namespacedef_='', name_='interval', pretty_print=pretty_print)
        if self.statusTimeStamp is not None:
            namespaceprefix_ = self.statusTimeStamp_nsprefix_ + ':' if (UseCapturedNS_ and self.statusTimeStamp_nsprefix_) else ''
            self.statusTimeStamp.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusTimeStamp', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingPeriod, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'billLastPeriod' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'billLastPeriod')
            ival_ = self.gds_validate_integer(ival_, node, 'billLastPeriod')
            self.billLastPeriod = ival_
            self.billLastPeriod_nsprefix_ = child_.prefix
            # validate type Int48
            self.validate_Int48(self.billLastPeriod)
        elif nodeName_ == 'billToDate' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'billToDate')
            ival_ = self.gds_validate_integer(ival_, node, 'billToDate')
            self.billToDate = ival_
            self.billToDate_nsprefix_ = child_.prefix
            # validate type Int48
            self.validate_Int48(self.billToDate)
        elif nodeName_ == 'interval':
            obj_ = DateTimeInterval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.interval = obj_
            obj_.original_tagname_ = 'interval'
        elif nodeName_ == 'statusTimeStamp':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusTimeStamp = obj_
            obj_.original_tagname_ = 'statusTimeStamp'
        super(BillingPeriod, self)._buildChildren(child_, node, nodeName_, True)
# end class BillingPeriod


class TextMessageList(SubscribableList):
    """TextMessageList -- A List element to hold TextMessage objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, TextMessage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TextMessageList"), self).__init__( **kwargs_)
        if TextMessage is None:
            self.TextMessage = []
        else:
            self.TextMessage = TextMessage
        self.TextMessage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextMessageList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextMessageList.subclass:
            return TextMessageList.subclass(*args_, **kwargs_)
        else:
            return TextMessageList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TextMessage(self):
        return self.TextMessage
    def set_TextMessage(self, TextMessage):
        self.TextMessage = TextMessage
    def add_TextMessage(self, value):
        self.TextMessage.append(value)
    def insert_TextMessage_at(self, index, value):
        self.TextMessage.insert(index, value)
    def replace_TextMessage_at(self, index, value):
        self.TextMessage[index] = value
    def _hasContent(self):
        if (
            self.TextMessage or
            super(TextMessageList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TextMessageList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextMessageList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextMessageList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextMessageList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextMessageList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextMessageList'):
        super(TextMessageList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextMessageList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TextMessageList', fromsubclass_=False, pretty_print=True):
        super(TextMessageList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TextMessage_ in self.TextMessage:
            namespaceprefix_ = self.TextMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.TextMessage_nsprefix_) else ''
            TextMessage_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextMessage', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TextMessageList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TextMessage':
            obj_ = TextMessage.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextMessage.append(obj_)
            obj_.original_tagname_ = 'TextMessage'
        super(TextMessageList, self)._buildChildren(child_, node, nodeName_, True)
# end class TextMessageList


class TextMessage(Event):
    """TextMessage -- Text message such as a notification.
    originator -- Indicates the human-readable name of the publisher of the message
    priority -- The priority is used to inform the client of the priority of the particular message.  Devices with constrained or limited resources for displaying Messages should use this attribute to determine how to handle displaying currently active Messages (e.g. if a device uses a scrolling method with a single Message viewable at a time it MAY want to push a low priority Message to the background and bring a newly received higher priority Message to the foreground).
    textMessage -- The textMessage attribute contains the actual UTF-8 encoded text to be displayed in conjunction with the messageLength attribute which contains the overall length of the textMessage attribute.  Clients and servers SHALL support a reception of a Message of 100 bytes in length.  Messages that exceed the clients display size will be left to the client to choose what method to handle the message (truncation, scrolling, etc.).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Event
    def __init__(self, originator=None, priority=None, textMessage=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TextMessage"), self).__init__( **kwargs_)
        self.originator = originator
        self.validate_String20(self.originator)
        self.originator_nsprefix_ = None
        self.priority = priority
        self.priority_nsprefix_ = None
        self.textMessage = textMessage
        self.textMessage_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextMessage)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextMessage.subclass:
            return TextMessage.subclass(*args_, **kwargs_)
        else:
            return TextMessage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_originator(self):
        return self.originator
    def set_originator(self, originator):
        self.originator = originator
    def get_priority(self):
        return self.priority
    def set_priority(self, priority):
        self.priority = priority
    def get_textMessage(self):
        return self.textMessage
    def set_textMessage(self, textMessage):
        self.textMessage = textMessage
    def validate_String20(self, value):
        result = True
        # Validate type String20, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String20' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.originator is not None or
            self.priority is not None or
            self.textMessage is not None or
            super(TextMessage, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TextMessage', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextMessage')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextMessage':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextMessage')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextMessage', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextMessage'):
        super(TextMessage, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextMessage')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TextMessage', fromsubclass_=False, pretty_print=True):
        super(TextMessage, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.originator is not None:
            namespaceprefix_ = self.originator_nsprefix_ + ':' if (UseCapturedNS_ and self.originator_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soriginator>%s</%soriginator>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.originator), input_name='originator')), namespaceprefix_ , eol_))
        if self.priority is not None:
            namespaceprefix_ = self.priority_nsprefix_ + ':' if (UseCapturedNS_ and self.priority_nsprefix_) else ''
            self.priority.export(outfile, level, namespaceprefix_, namespacedef_='', name_='priority', pretty_print=pretty_print)
        if self.textMessage is not None:
            namespaceprefix_ = self.textMessage_nsprefix_ + ':' if (UseCapturedNS_ and self.textMessage_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stextMessage>%s</%stextMessage>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.textMessage), input_name='textMessage')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TextMessage, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'originator':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'originator')
            value_ = self.gds_validate_string(value_, node, 'originator')
            self.originator = value_
            self.originator_nsprefix_ = child_.prefix
            # validate type String20
            self.validate_String20(self.originator)
        elif nodeName_ == 'priority':
            obj_ = PriorityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.priority = obj_
            obj_.original_tagname_ = 'priority'
        elif nodeName_ == 'textMessage':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'textMessage')
            value_ = self.gds_validate_string(value_, node, 'textMessage')
            self.textMessage = value_
            self.textMessage_nsprefix_ = child_.prefix
        super(TextMessage, self)._buildChildren(child_, node, nodeName_, True)
# end class TextMessage


class MessagingProgramList(SubscribableList):
    """MessagingProgramList -- A List element to hold MessagingProgram objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', MessagingProgram=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MessagingProgramList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if MessagingProgram is None:
            self.MessagingProgram = []
        else:
            self.MessagingProgram = MessagingProgram
        self.MessagingProgram_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessagingProgramList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessagingProgramList.subclass:
            return MessagingProgramList.subclass(*args_, **kwargs_)
        else:
            return MessagingProgramList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MessagingProgram(self):
        return self.MessagingProgram
    def set_MessagingProgram(self, MessagingProgram):
        self.MessagingProgram = MessagingProgram
    def add_MessagingProgram(self, value):
        self.MessagingProgram.append(value)
    def insert_MessagingProgram_at(self, index, value):
        self.MessagingProgram.insert(index, value)
    def replace_MessagingProgram_at(self, index, value):
        self.MessagingProgram[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.MessagingProgram or
            super(MessagingProgramList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MessagingProgramList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessagingProgramList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MessagingProgramList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessagingProgramList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MessagingProgramList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessagingProgramList'):
        super(MessagingProgramList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessagingProgramList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MessagingProgramList', fromsubclass_=False, pretty_print=True):
        super(MessagingProgramList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MessagingProgram_ in self.MessagingProgram:
            namespaceprefix_ = self.MessagingProgram_nsprefix_ + ':' if (UseCapturedNS_ and self.MessagingProgram_nsprefix_) else ''
            MessagingProgram_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MessagingProgram', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(MessagingProgramList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MessagingProgram':
            obj_ = MessagingProgram.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MessagingProgram.append(obj_)
            obj_.original_tagname_ = 'MessagingProgram'
        super(MessagingProgramList, self)._buildChildren(child_, node, nodeName_, True)
# end class MessagingProgramList


class MessagingProgram(SubscribableIdentifiedObject):
    """MessagingProgram -- Provides a container for collections of text messages.
    locale -- Indicates the language and region of the messages in this collection.
    primacy -- Indicates the relative primacy of the provider of this program.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableIdentifiedObject
    def __init__(self, ActiveTextMessageListLink=None, locale=None, primacy=None, TextMessageListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MessagingProgram"), self).__init__( **kwargs_)
        self.ActiveTextMessageListLink = ActiveTextMessageListLink
        self.ActiveTextMessageListLink_nsprefix_ = None
        self.locale = locale
        self.locale_nsprefix_ = None
        self.primacy = primacy
        self.primacy_nsprefix_ = None
        self.TextMessageListLink = TextMessageListLink
        self.TextMessageListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MessagingProgram)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MessagingProgram.subclass:
            return MessagingProgram.subclass(*args_, **kwargs_)
        else:
            return MessagingProgram(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ActiveTextMessageListLink(self):
        return self.ActiveTextMessageListLink
    def set_ActiveTextMessageListLink(self, ActiveTextMessageListLink):
        self.ActiveTextMessageListLink = ActiveTextMessageListLink
    def get_locale(self):
        return self.locale
    def set_locale(self, locale):
        self.locale = locale
    def get_primacy(self):
        return self.primacy
    def set_primacy(self, primacy):
        self.primacy = primacy
    def get_TextMessageListLink(self):
        return self.TextMessageListLink
    def set_TextMessageListLink(self, TextMessageListLink):
        self.TextMessageListLink = TextMessageListLink
    def _hasContent(self):
        if (
            self.ActiveTextMessageListLink is not None or
            self.locale is not None or
            self.primacy is not None or
            self.TextMessageListLink is not None or
            super(MessagingProgram, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MessagingProgram', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MessagingProgram')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MessagingProgram':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessagingProgram')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MessagingProgram', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MessagingProgram'):
        super(MessagingProgram, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MessagingProgram')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MessagingProgram', fromsubclass_=False, pretty_print=True):
        super(MessagingProgram, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveTextMessageListLink is not None:
            namespaceprefix_ = self.ActiveTextMessageListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveTextMessageListLink_nsprefix_) else ''
            self.ActiveTextMessageListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ActiveTextMessageListLink', pretty_print=pretty_print)
        if self.locale is not None:
            namespaceprefix_ = self.locale_nsprefix_ + ':' if (UseCapturedNS_ and self.locale_nsprefix_) else ''
            self.locale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='locale', pretty_print=pretty_print)
        if self.primacy is not None:
            namespaceprefix_ = self.primacy_nsprefix_ + ':' if (UseCapturedNS_ and self.primacy_nsprefix_) else ''
            self.primacy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='primacy', pretty_print=pretty_print)
        if self.TextMessageListLink is not None:
            namespaceprefix_ = self.TextMessageListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.TextMessageListLink_nsprefix_) else ''
            self.TextMessageListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TextMessageListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MessagingProgram, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ActiveTextMessageListLink':
            obj_ = ActiveTextMessageListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ActiveTextMessageListLink = obj_
            obj_.original_tagname_ = 'ActiveTextMessageListLink'
        elif nodeName_ == 'locale':
            obj_ = LocaleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.locale = obj_
            obj_.original_tagname_ = 'locale'
        elif nodeName_ == 'primacy':
            obj_ = PrimacyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primacy = obj_
            obj_.original_tagname_ = 'primacy'
        elif nodeName_ == 'TextMessageListLink':
            obj_ = TextMessageListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TextMessageListLink = obj_
            obj_.original_tagname_ = 'TextMessageListLink'
        super(MessagingProgram, self)._buildChildren(child_, node, nodeName_, True)
# end class MessagingProgram


class TimeTariffIntervalList(SubscribableList):
    """TimeTariffIntervalList -- A List element to hold TimeTariffInterval objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, TimeTariffInterval=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TimeTariffIntervalList"), self).__init__( **kwargs_)
        if TimeTariffInterval is None:
            self.TimeTariffInterval = []
        else:
            self.TimeTariffInterval = TimeTariffInterval
        self.TimeTariffInterval_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeTariffIntervalList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeTariffIntervalList.subclass:
            return TimeTariffIntervalList.subclass(*args_, **kwargs_)
        else:
            return TimeTariffIntervalList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TimeTariffInterval(self):
        return self.TimeTariffInterval
    def set_TimeTariffInterval(self, TimeTariffInterval):
        self.TimeTariffInterval = TimeTariffInterval
    def add_TimeTariffInterval(self, value):
        self.TimeTariffInterval.append(value)
    def insert_TimeTariffInterval_at(self, index, value):
        self.TimeTariffInterval.insert(index, value)
    def replace_TimeTariffInterval_at(self, index, value):
        self.TimeTariffInterval[index] = value
    def _hasContent(self):
        if (
            self.TimeTariffInterval or
            super(TimeTariffIntervalList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TimeTariffIntervalList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeTariffIntervalList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeTariffIntervalList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeTariffIntervalList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeTariffIntervalList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeTariffIntervalList'):
        super(TimeTariffIntervalList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeTariffIntervalList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TimeTariffIntervalList', fromsubclass_=False, pretty_print=True):
        super(TimeTariffIntervalList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TimeTariffInterval_ in self.TimeTariffInterval:
            namespaceprefix_ = self.TimeTariffInterval_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeTariffInterval_nsprefix_) else ''
            TimeTariffInterval_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeTariffInterval', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TimeTariffIntervalList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TimeTariffInterval':
            obj_ = TimeTariffInterval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeTariffInterval.append(obj_)
            obj_.original_tagname_ = 'TimeTariffInterval'
        super(TimeTariffIntervalList, self)._buildChildren(child_, node, nodeName_, True)
# end class TimeTariffIntervalList


class TimeTariffInterval(RandomizableEvent):
    """TimeTariffInterval -- Describes the time-differentiated portion of the RateComponent, if applicable, and provides the ability to specify multiple time intervals, each with its own consumption-based components and other attributes.
    touTier -- Indicates the time of use tier related to the reading. If not specified, is assumed to be "0 - N/A".
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RandomizableEvent
    def __init__(self, ConsumptionTariffIntervalListLink=None, touTier=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TimeTariffInterval"), self).__init__( **kwargs_)
        self.ConsumptionTariffIntervalListLink = ConsumptionTariffIntervalListLink
        self.ConsumptionTariffIntervalListLink_nsprefix_ = None
        self.touTier = touTier
        self.touTier_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TimeTariffInterval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TimeTariffInterval.subclass:
            return TimeTariffInterval.subclass(*args_, **kwargs_)
        else:
            return TimeTariffInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ConsumptionTariffIntervalListLink(self):
        return self.ConsumptionTariffIntervalListLink
    def set_ConsumptionTariffIntervalListLink(self, ConsumptionTariffIntervalListLink):
        self.ConsumptionTariffIntervalListLink = ConsumptionTariffIntervalListLink
    def get_touTier(self):
        return self.touTier
    def set_touTier(self, touTier):
        self.touTier = touTier
    def _hasContent(self):
        if (
            self.ConsumptionTariffIntervalListLink is not None or
            self.touTier is not None or
            super(TimeTariffInterval, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TimeTariffInterval', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TimeTariffInterval')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TimeTariffInterval':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeTariffInterval')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TimeTariffInterval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TimeTariffInterval'):
        super(TimeTariffInterval, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TimeTariffInterval')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TimeTariffInterval', fromsubclass_=False, pretty_print=True):
        super(TimeTariffInterval, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConsumptionTariffIntervalListLink is not None:
            namespaceprefix_ = self.ConsumptionTariffIntervalListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ConsumptionTariffIntervalListLink_nsprefix_) else ''
            self.ConsumptionTariffIntervalListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConsumptionTariffIntervalListLink', pretty_print=pretty_print)
        if self.touTier is not None:
            namespaceprefix_ = self.touTier_nsprefix_ + ':' if (UseCapturedNS_ and self.touTier_nsprefix_) else ''
            self.touTier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='touTier', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TimeTariffInterval, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ConsumptionTariffIntervalListLink':
            obj_ = ConsumptionTariffIntervalListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConsumptionTariffIntervalListLink = obj_
            obj_.original_tagname_ = 'ConsumptionTariffIntervalListLink'
        elif nodeName_ == 'touTier':
            obj_ = TOUType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.touTier = obj_
            obj_.original_tagname_ = 'touTier'
        super(TimeTariffInterval, self)._buildChildren(child_, node, nodeName_, True)
# end class TimeTariffInterval


class TariffProfileList(SubscribableList):
    """TariffProfileList -- A List element to hold TariffProfile objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', TariffProfile=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TariffProfileList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if TariffProfile is None:
            self.TariffProfile = []
        else:
            self.TariffProfile = TariffProfile
        self.TariffProfile_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TariffProfileList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TariffProfileList.subclass:
            return TariffProfileList.subclass(*args_, **kwargs_)
        else:
            return TariffProfileList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_TariffProfile(self):
        return self.TariffProfile
    def set_TariffProfile(self, TariffProfile):
        self.TariffProfile = TariffProfile
    def add_TariffProfile(self, value):
        self.TariffProfile.append(value)
    def insert_TariffProfile_at(self, index, value):
        self.TariffProfile.insert(index, value)
    def replace_TariffProfile_at(self, index, value):
        self.TariffProfile[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.TariffProfile or
            super(TariffProfileList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TariffProfileList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TariffProfileList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TariffProfileList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TariffProfileList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TariffProfileList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TariffProfileList'):
        super(TariffProfileList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TariffProfileList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TariffProfileList', fromsubclass_=False, pretty_print=True):
        super(TariffProfileList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for TariffProfile_ in self.TariffProfile:
            namespaceprefix_ = self.TariffProfile_nsprefix_ + ':' if (UseCapturedNS_ and self.TariffProfile_nsprefix_) else ''
            TariffProfile_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TariffProfile', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(TariffProfileList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'TariffProfile':
            obj_ = TariffProfile.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TariffProfile.append(obj_)
            obj_.original_tagname_ = 'TariffProfile'
        super(TariffProfileList, self)._buildChildren(child_, node, nodeName_, True)
# end class TariffProfileList


class TariffProfile(IdentifiedObject):
    """TariffProfile -- A schedule of charges; structure that allows the definition of tariff structures such as step (block) and time of use (tier) when used in conjunction with TimeTariffInterval and ConsumptionTariffInterval.
    currency -- The currency code indicating the currency for this TariffProfile.
    pricePowerOfTenMultiplier -- Indicates the power of ten multiplier for the price attribute.
    primacy -- Indicates the relative primacy of the provider of this program.
    rateCode -- The rate code for this tariff profile.  Provided by the Pricing service provider per its internal business needs and practices and provides a method to identify the specific rate code for the TariffProfile instance.  This would typically not be communicated to the user except to facilitate troubleshooting due to its service provider-specific technical nature.
    serviceCategoryKind -- The kind of service provided by this usage point.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, currency=None, pricePowerOfTenMultiplier=None, primacy=None, rateCode=None, RateComponentListLink=None, serviceCategoryKind=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TariffProfile"), self).__init__( **kwargs_)
        self.currency = currency
        self.currency_nsprefix_ = None
        self.pricePowerOfTenMultiplier = pricePowerOfTenMultiplier
        self.pricePowerOfTenMultiplier_nsprefix_ = None
        self.primacy = primacy
        self.primacy_nsprefix_ = None
        self.rateCode = rateCode
        self.validate_String20(self.rateCode)
        self.rateCode_nsprefix_ = None
        self.RateComponentListLink = RateComponentListLink
        self.RateComponentListLink_nsprefix_ = None
        self.serviceCategoryKind = serviceCategoryKind
        self.serviceCategoryKind_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TariffProfile)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TariffProfile.subclass:
            return TariffProfile.subclass(*args_, **kwargs_)
        else:
            return TariffProfile(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currency(self):
        return self.currency
    def set_currency(self, currency):
        self.currency = currency
    def get_pricePowerOfTenMultiplier(self):
        return self.pricePowerOfTenMultiplier
    def set_pricePowerOfTenMultiplier(self, pricePowerOfTenMultiplier):
        self.pricePowerOfTenMultiplier = pricePowerOfTenMultiplier
    def get_primacy(self):
        return self.primacy
    def set_primacy(self, primacy):
        self.primacy = primacy
    def get_rateCode(self):
        return self.rateCode
    def set_rateCode(self, rateCode):
        self.rateCode = rateCode
    def get_RateComponentListLink(self):
        return self.RateComponentListLink
    def set_RateComponentListLink(self, RateComponentListLink):
        self.RateComponentListLink = RateComponentListLink
    def get_serviceCategoryKind(self):
        return self.serviceCategoryKind
    def set_serviceCategoryKind(self, serviceCategoryKind):
        self.serviceCategoryKind = serviceCategoryKind
    def validate_String20(self, value):
        result = True
        # Validate type String20, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 20:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String20' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.currency is not None or
            self.pricePowerOfTenMultiplier is not None or
            self.primacy is not None or
            self.rateCode is not None or
            self.RateComponentListLink is not None or
            self.serviceCategoryKind is not None or
            super(TariffProfile, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TariffProfile', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TariffProfile')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TariffProfile':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TariffProfile')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TariffProfile', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TariffProfile'):
        super(TariffProfile, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TariffProfile')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='TariffProfile', fromsubclass_=False, pretty_print=True):
        super(TariffProfile, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currency is not None:
            namespaceprefix_ = self.currency_nsprefix_ + ':' if (UseCapturedNS_ and self.currency_nsprefix_) else ''
            self.currency.export(outfile, level, namespaceprefix_, namespacedef_='', name_='currency', pretty_print=pretty_print)
        if self.pricePowerOfTenMultiplier is not None:
            namespaceprefix_ = self.pricePowerOfTenMultiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.pricePowerOfTenMultiplier_nsprefix_) else ''
            self.pricePowerOfTenMultiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pricePowerOfTenMultiplier', pretty_print=pretty_print)
        if self.primacy is not None:
            namespaceprefix_ = self.primacy_nsprefix_ + ':' if (UseCapturedNS_ and self.primacy_nsprefix_) else ''
            self.primacy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='primacy', pretty_print=pretty_print)
        if self.rateCode is not None:
            namespaceprefix_ = self.rateCode_nsprefix_ + ':' if (UseCapturedNS_ and self.rateCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srateCode>%s</%srateCode>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.rateCode), input_name='rateCode')), namespaceprefix_ , eol_))
        if self.RateComponentListLink is not None:
            namespaceprefix_ = self.RateComponentListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.RateComponentListLink_nsprefix_) else ''
            self.RateComponentListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RateComponentListLink', pretty_print=pretty_print)
        if self.serviceCategoryKind is not None:
            namespaceprefix_ = self.serviceCategoryKind_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceCategoryKind_nsprefix_) else ''
            self.serviceCategoryKind.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceCategoryKind', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TariffProfile, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currency':
            obj_ = CurrencyCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currency = obj_
            obj_.original_tagname_ = 'currency'
        elif nodeName_ == 'pricePowerOfTenMultiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pricePowerOfTenMultiplier = obj_
            obj_.original_tagname_ = 'pricePowerOfTenMultiplier'
        elif nodeName_ == 'primacy':
            obj_ = PrimacyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primacy = obj_
            obj_.original_tagname_ = 'primacy'
        elif nodeName_ == 'rateCode':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'rateCode')
            value_ = self.gds_validate_string(value_, node, 'rateCode')
            self.rateCode = value_
            self.rateCode_nsprefix_ = child_.prefix
            # validate type String20
            self.validate_String20(self.rateCode)
        elif nodeName_ == 'RateComponentListLink':
            obj_ = RateComponentListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RateComponentListLink = obj_
            obj_.original_tagname_ = 'RateComponentListLink'
        elif nodeName_ == 'serviceCategoryKind':
            obj_ = ServiceKind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceCategoryKind = obj_
            obj_.original_tagname_ = 'serviceCategoryKind'
        super(TariffProfile, self)._buildChildren(child_, node, nodeName_, True)
# end class TariffProfile


class RateComponentList(List):
    """RateComponentList -- A List element to hold RateComponent objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, RateComponent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RateComponentList"), self).__init__( **kwargs_)
        if RateComponent is None:
            self.RateComponent = []
        else:
            self.RateComponent = RateComponent
        self.RateComponent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateComponentList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateComponentList.subclass:
            return RateComponentList.subclass(*args_, **kwargs_)
        else:
            return RateComponentList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RateComponent(self):
        return self.RateComponent
    def set_RateComponent(self, RateComponent):
        self.RateComponent = RateComponent
    def add_RateComponent(self, value):
        self.RateComponent.append(value)
    def insert_RateComponent_at(self, index, value):
        self.RateComponent.insert(index, value)
    def replace_RateComponent_at(self, index, value):
        self.RateComponent[index] = value
    def _hasContent(self):
        if (
            self.RateComponent or
            super(RateComponentList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RateComponentList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RateComponentList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RateComponentList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateComponentList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RateComponentList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RateComponentList'):
        super(RateComponentList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateComponentList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RateComponentList', fromsubclass_=False, pretty_print=True):
        super(RateComponentList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RateComponent_ in self.RateComponent:
            namespaceprefix_ = self.RateComponent_nsprefix_ + ':' if (UseCapturedNS_ and self.RateComponent_nsprefix_) else ''
            RateComponent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RateComponent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RateComponentList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RateComponent':
            obj_ = RateComponent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RateComponent.append(obj_)
            obj_.original_tagname_ = 'RateComponent'
        super(RateComponentList, self)._buildChildren(child_, node, nodeName_, True)
# end class RateComponentList


class RateComponent(IdentifiedObject):
    """RateComponent -- Specifies the applicable charges for a single component of the rate, which could be generation price or consumption price, for example.
    flowRateEndLimit -- Specifies the maximum flow rate (e.g. kW for electricity) for which this RateComponent applies, for the usage point and given rate / tariff.
    In combination with flowRateStartLimit, allows a service provider to define the demand or output characteristics for the particular tariff design.  If a server includes the flowRateEndLimit attribute, then it SHALL also include flowRateStartLimit attribute.
    For example, a service provider
    
    s tariff limits customers to 20 kWs of demand for the given rate structure.  Above this threshold (from 20-50 kWs), there are different demand charges per unit of consumption.  The service provider can use flowRateStartLimit and flowRateEndLimit to describe the demand characteristics of the different rates.  Similarly, these attributes can be used to describe limits on premises DERs that might be producing a commodity and sending it back into the distribution network.
    Note: At the time of writing, service provider tariffs with demand-based components were not originally identified as being in scope, and service provider tariffs vary widely in their use of demand components and the method for computing charges.  It is expected that industry groups (e.g., OpenSG) will document requirements in the future that the IEEE 2030.5 community can then use as source material for the next version of IEEE 2030.5.
    flowRateStartLimit -- Specifies the minimum flow rate (e.g., kW for electricity) for which this RateComponent applies, for the usage point and given rate / tariff.
    In combination with flowRateEndLimit, allows a service provider to define the demand or output characteristics for the particular tariff design.  If a server includes the flowRateStartLimit attribute, then it SHALL also include flowRateEndLimit attribute.
    ReadingTypeLink -- Provides indication of the ReadingType with which this price is associated.
    roleFlags -- Specifies the roles that this usage point has been assigned.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, ActiveTimeTariffIntervalListLink=None, flowRateEndLimit=None, flowRateStartLimit=None, ReadingTypeLink=None, roleFlags=None, TimeTariffIntervalListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RateComponent"), self).__init__( **kwargs_)
        self.ActiveTimeTariffIntervalListLink = ActiveTimeTariffIntervalListLink
        self.ActiveTimeTariffIntervalListLink_nsprefix_ = None
        self.flowRateEndLimit = flowRateEndLimit
        self.flowRateEndLimit_nsprefix_ = None
        self.flowRateStartLimit = flowRateStartLimit
        self.flowRateStartLimit_nsprefix_ = None
        self.ReadingTypeLink = ReadingTypeLink
        self.ReadingTypeLink_nsprefix_ = None
        self.roleFlags = roleFlags
        self.roleFlags_nsprefix_ = None
        self.TimeTariffIntervalListLink = TimeTariffIntervalListLink
        self.TimeTariffIntervalListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RateComponent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RateComponent.subclass:
            return RateComponent.subclass(*args_, **kwargs_)
        else:
            return RateComponent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ActiveTimeTariffIntervalListLink(self):
        return self.ActiveTimeTariffIntervalListLink
    def set_ActiveTimeTariffIntervalListLink(self, ActiveTimeTariffIntervalListLink):
        self.ActiveTimeTariffIntervalListLink = ActiveTimeTariffIntervalListLink
    def get_flowRateEndLimit(self):
        return self.flowRateEndLimit
    def set_flowRateEndLimit(self, flowRateEndLimit):
        self.flowRateEndLimit = flowRateEndLimit
    def get_flowRateStartLimit(self):
        return self.flowRateStartLimit
    def set_flowRateStartLimit(self, flowRateStartLimit):
        self.flowRateStartLimit = flowRateStartLimit
    def get_ReadingTypeLink(self):
        return self.ReadingTypeLink
    def set_ReadingTypeLink(self, ReadingTypeLink):
        self.ReadingTypeLink = ReadingTypeLink
    def get_roleFlags(self):
        return self.roleFlags
    def set_roleFlags(self, roleFlags):
        self.roleFlags = roleFlags
    def get_TimeTariffIntervalListLink(self):
        return self.TimeTariffIntervalListLink
    def set_TimeTariffIntervalListLink(self, TimeTariffIntervalListLink):
        self.TimeTariffIntervalListLink = TimeTariffIntervalListLink
    def _hasContent(self):
        if (
            self.ActiveTimeTariffIntervalListLink is not None or
            self.flowRateEndLimit is not None or
            self.flowRateStartLimit is not None or
            self.ReadingTypeLink is not None or
            self.roleFlags is not None or
            self.TimeTariffIntervalListLink is not None or
            super(RateComponent, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RateComponent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RateComponent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RateComponent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateComponent')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RateComponent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RateComponent'):
        super(RateComponent, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RateComponent')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RateComponent', fromsubclass_=False, pretty_print=True):
        super(RateComponent, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveTimeTariffIntervalListLink is not None:
            namespaceprefix_ = self.ActiveTimeTariffIntervalListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveTimeTariffIntervalListLink_nsprefix_) else ''
            self.ActiveTimeTariffIntervalListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ActiveTimeTariffIntervalListLink', pretty_print=pretty_print)
        if self.flowRateEndLimit is not None:
            namespaceprefix_ = self.flowRateEndLimit_nsprefix_ + ':' if (UseCapturedNS_ and self.flowRateEndLimit_nsprefix_) else ''
            self.flowRateEndLimit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flowRateEndLimit', pretty_print=pretty_print)
        if self.flowRateStartLimit is not None:
            namespaceprefix_ = self.flowRateStartLimit_nsprefix_ + ':' if (UseCapturedNS_ and self.flowRateStartLimit_nsprefix_) else ''
            self.flowRateStartLimit.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flowRateStartLimit', pretty_print=pretty_print)
        if self.ReadingTypeLink is not None:
            namespaceprefix_ = self.ReadingTypeLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ReadingTypeLink_nsprefix_) else ''
            self.ReadingTypeLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReadingTypeLink', pretty_print=pretty_print)
        if self.roleFlags is not None:
            namespaceprefix_ = self.roleFlags_nsprefix_ + ':' if (UseCapturedNS_ and self.roleFlags_nsprefix_) else ''
            self.roleFlags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='roleFlags', pretty_print=pretty_print)
        if self.TimeTariffIntervalListLink is not None:
            namespaceprefix_ = self.TimeTariffIntervalListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeTariffIntervalListLink_nsprefix_) else ''
            self.TimeTariffIntervalListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeTariffIntervalListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RateComponent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ActiveTimeTariffIntervalListLink':
            obj_ = ActiveTimeTariffIntervalListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ActiveTimeTariffIntervalListLink = obj_
            obj_.original_tagname_ = 'ActiveTimeTariffIntervalListLink'
        elif nodeName_ == 'flowRateEndLimit':
            obj_ = UnitValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flowRateEndLimit = obj_
            obj_.original_tagname_ = 'flowRateEndLimit'
        elif nodeName_ == 'flowRateStartLimit':
            obj_ = UnitValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flowRateStartLimit = obj_
            obj_.original_tagname_ = 'flowRateStartLimit'
        elif nodeName_ == 'ReadingTypeLink':
            obj_ = ReadingTypeLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReadingTypeLink = obj_
            obj_.original_tagname_ = 'ReadingTypeLink'
        elif nodeName_ == 'roleFlags':
            obj_ = RoleFlagsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.roleFlags = obj_
            obj_.original_tagname_ = 'roleFlags'
        elif nodeName_ == 'TimeTariffIntervalListLink':
            obj_ = TimeTariffIntervalListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeTariffIntervalListLink = obj_
            obj_.original_tagname_ = 'TimeTariffIntervalListLink'
        super(RateComponent, self)._buildChildren(child_, node, nodeName_, True)
# end class RateComponent


class ConsumptionTariffIntervalList(List):
    """ConsumptionTariffIntervalList -- A List element to hold ConsumptionTariffInterval objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, ConsumptionTariffInterval=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConsumptionTariffIntervalList"), self).__init__( **kwargs_)
        if ConsumptionTariffInterval is None:
            self.ConsumptionTariffInterval = []
        else:
            self.ConsumptionTariffInterval = ConsumptionTariffInterval
        self.ConsumptionTariffInterval_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConsumptionTariffIntervalList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConsumptionTariffIntervalList.subclass:
            return ConsumptionTariffIntervalList.subclass(*args_, **kwargs_)
        else:
            return ConsumptionTariffIntervalList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ConsumptionTariffInterval(self):
        return self.ConsumptionTariffInterval
    def set_ConsumptionTariffInterval(self, ConsumptionTariffInterval):
        self.ConsumptionTariffInterval = ConsumptionTariffInterval
    def add_ConsumptionTariffInterval(self, value):
        self.ConsumptionTariffInterval.append(value)
    def insert_ConsumptionTariffInterval_at(self, index, value):
        self.ConsumptionTariffInterval.insert(index, value)
    def replace_ConsumptionTariffInterval_at(self, index, value):
        self.ConsumptionTariffInterval[index] = value
    def _hasContent(self):
        if (
            self.ConsumptionTariffInterval or
            super(ConsumptionTariffIntervalList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ConsumptionTariffIntervalList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConsumptionTariffIntervalList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConsumptionTariffIntervalList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConsumptionTariffIntervalList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConsumptionTariffIntervalList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConsumptionTariffIntervalList'):
        super(ConsumptionTariffIntervalList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConsumptionTariffIntervalList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ConsumptionTariffIntervalList', fromsubclass_=False, pretty_print=True):
        super(ConsumptionTariffIntervalList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ConsumptionTariffInterval_ in self.ConsumptionTariffInterval:
            namespaceprefix_ = self.ConsumptionTariffInterval_nsprefix_ + ':' if (UseCapturedNS_ and self.ConsumptionTariffInterval_nsprefix_) else ''
            ConsumptionTariffInterval_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConsumptionTariffInterval', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConsumptionTariffIntervalList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ConsumptionTariffInterval':
            obj_ = ConsumptionTariffInterval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConsumptionTariffInterval.append(obj_)
            obj_.original_tagname_ = 'ConsumptionTariffInterval'
        super(ConsumptionTariffIntervalList, self)._buildChildren(child_, node, nodeName_, True)
# end class ConsumptionTariffIntervalList


class ConsumptionTariffInterval(Resource):
    """ConsumptionTariffInterval -- One of a sequence of thresholds defined in terms of consumption quantity of a service such as electricity, water, gas, etc. It defines the steps or blocks in a step tariff structure, where startValue simultaneously defines the entry value of this step and the closing value of the previous step. Where consumption is greater than startValue, it falls within this block and where consumption is less than or equal to startValue, it falls within one of the previous blocks.
    consumptionBlock -- Indicates the consumption block related to the reading. If not specified, is assumed to be "0 - N/A".
    price -- The charge for this rate component, per unit of measure defined by the associated ReadingType, in currency specified in TariffProfile.
    The Pricing service provider determines the appropriate price attribute value based on its applicable regulatory rules. For example, price could be net or inclusive of applicable taxes, fees, or levies.
    The Billing function set provides the ability to represent billing information in a more detailed manner.
    startValue -- The lowest level of consumption that defines the starting point of this consumption step or block. Thresholds start at zero for each billing period.
    If specified, the first ConsumptionTariffInterval.startValue for a TimeTariffInteral instance SHALL begin at "0." Subsequent ConsumptionTariffInterval.startValue elements SHALL be greater than the previous one.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, consumptionBlock=None, EnvironmentalCost=None, price=None, startValue=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ConsumptionTariffInterval"), self).__init__( **kwargs_)
        self.consumptionBlock = consumptionBlock
        self.consumptionBlock_nsprefix_ = None
        if EnvironmentalCost is None:
            self.EnvironmentalCost = []
        else:
            self.EnvironmentalCost = EnvironmentalCost
        self.EnvironmentalCost_nsprefix_ = None
        self.price = price
        self.validate_Int32(self.price)
        self.price_nsprefix_ = None
        self.startValue = startValue
        self.validate_UInt48(self.startValue)
        self.startValue_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ConsumptionTariffInterval)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ConsumptionTariffInterval.subclass:
            return ConsumptionTariffInterval.subclass(*args_, **kwargs_)
        else:
            return ConsumptionTariffInterval(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_consumptionBlock(self):
        return self.consumptionBlock
    def set_consumptionBlock(self, consumptionBlock):
        self.consumptionBlock = consumptionBlock
    def get_EnvironmentalCost(self):
        return self.EnvironmentalCost
    def set_EnvironmentalCost(self, EnvironmentalCost):
        self.EnvironmentalCost = EnvironmentalCost
    def add_EnvironmentalCost(self, value):
        self.EnvironmentalCost.append(value)
    def insert_EnvironmentalCost_at(self, index, value):
        self.EnvironmentalCost.insert(index, value)
    def replace_EnvironmentalCost_at(self, index, value):
        self.EnvironmentalCost[index] = value
    def get_price(self):
        return self.price
    def set_price(self, price):
        self.price = price
    def get_startValue(self):
        return self.startValue
    def set_startValue(self, startValue):
        self.startValue = startValue
    def validate_Int32(self, value):
        result = True
        # Validate type Int32, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt48(self, value):
        result = True
        # Validate type UInt48, a restriction on xs:unsignedLong.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value > 281474976710655:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on UInt48' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.consumptionBlock is not None or
            self.EnvironmentalCost or
            self.price is not None or
            self.startValue is not None or
            super(ConsumptionTariffInterval, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ConsumptionTariffInterval', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ConsumptionTariffInterval')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ConsumptionTariffInterval':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConsumptionTariffInterval')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ConsumptionTariffInterval', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ConsumptionTariffInterval'):
        super(ConsumptionTariffInterval, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ConsumptionTariffInterval')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ConsumptionTariffInterval', fromsubclass_=False, pretty_print=True):
        super(ConsumptionTariffInterval, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.consumptionBlock is not None:
            namespaceprefix_ = self.consumptionBlock_nsprefix_ + ':' if (UseCapturedNS_ and self.consumptionBlock_nsprefix_) else ''
            self.consumptionBlock.export(outfile, level, namespaceprefix_, namespacedef_='', name_='consumptionBlock', pretty_print=pretty_print)
        for EnvironmentalCost_ in self.EnvironmentalCost:
            namespaceprefix_ = self.EnvironmentalCost_nsprefix_ + ':' if (UseCapturedNS_ and self.EnvironmentalCost_nsprefix_) else ''
            EnvironmentalCost_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EnvironmentalCost', pretty_print=pretty_print)
        if self.price is not None:
            namespaceprefix_ = self.price_nsprefix_ + ':' if (UseCapturedNS_ and self.price_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprice>%s</%sprice>%s' % (namespaceprefix_ , self.gds_format_integer(self.price, input_name='price'), namespaceprefix_ , eol_))
        if self.startValue is not None:
            namespaceprefix_ = self.startValue_nsprefix_ + ':' if (UseCapturedNS_ and self.startValue_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstartValue>%s</%sstartValue>%s' % (namespaceprefix_ , self.gds_format_integer(self.startValue, input_name='startValue'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ConsumptionTariffInterval, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'consumptionBlock':
            obj_ = ConsumptionBlockType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.consumptionBlock = obj_
            obj_.original_tagname_ = 'consumptionBlock'
        elif nodeName_ == 'EnvironmentalCost':
            obj_ = EnvironmentalCost.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EnvironmentalCost.append(obj_)
            obj_.original_tagname_ = 'EnvironmentalCost'
        elif nodeName_ == 'price' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'price')
            ival_ = self.gds_validate_integer(ival_, node, 'price')
            self.price = ival_
            self.price_nsprefix_ = child_.prefix
            # validate type Int32
            self.validate_Int32(self.price)
        elif nodeName_ == 'startValue' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'startValue')
            ival_ = self.gds_validate_integer(ival_, node, 'startValue')
            self.startValue = ival_
            self.startValue_nsprefix_ = child_.prefix
            # validate type UInt48
            self.validate_UInt48(self.startValue)
        super(ConsumptionTariffInterval, self)._buildChildren(child_, node, nodeName_, True)
# end class ConsumptionTariffInterval


class UsagePointList(SubscribableList):
    """UsagePointList -- A List element to hold UsagePoint objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', UsagePoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UsagePointList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if UsagePoint is None:
            self.UsagePoint = []
        else:
            self.UsagePoint = UsagePoint
        self.UsagePoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UsagePointList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UsagePointList.subclass:
            return UsagePointList.subclass(*args_, **kwargs_)
        else:
            return UsagePointList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_UsagePoint(self):
        return self.UsagePoint
    def set_UsagePoint(self, UsagePoint):
        self.UsagePoint = UsagePoint
    def add_UsagePoint(self, value):
        self.UsagePoint.append(value)
    def insert_UsagePoint_at(self, index, value):
        self.UsagePoint.insert(index, value)
    def replace_UsagePoint_at(self, index, value):
        self.UsagePoint[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.UsagePoint or
            super(UsagePointList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UsagePointList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UsagePointList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UsagePointList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePointList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UsagePointList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UsagePointList'):
        super(UsagePointList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePointList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UsagePointList', fromsubclass_=False, pretty_print=True):
        super(UsagePointList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for UsagePoint_ in self.UsagePoint:
            namespaceprefix_ = self.UsagePoint_nsprefix_ + ':' if (UseCapturedNS_ and self.UsagePoint_nsprefix_) else ''
            UsagePoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UsagePoint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(UsagePointList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'UsagePoint':
            obj_ = UsagePoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UsagePoint.append(obj_)
            obj_.original_tagname_ = 'UsagePoint'
        super(UsagePointList, self)._buildChildren(child_, node, nodeName_, True)
# end class UsagePointList


class ReadingType(Resource):
    """ReadingType -- Type of data conveyed by a specific Reading. See IEC 61968 Part 9 Annex C for full definitions of these values.
    accumulationBehaviour -- The
    
    accumulation behaviour
    
    indicates how the value is represented to accumulate over time.
    calorificValue -- The amount of heat generated when a given mass of fuel is completely burned. The CalorificValue is used to convert the measured volume or mass of gas into kWh. The CalorificValue attribute represents the current active value.
    commodity -- Indicates the commodity applicable to this ReadingType.
    conversionFactor -- Accounts for changes in the volume of gas based on temperature and pressure. The ConversionFactor attribute represents the current active value. The ConversionFactor is dimensionless. The default value for the ConversionFactor is 1, which means no conversion is applied. A price server can advertise a new/different value at any time.
    dataQualifier -- The data type can be used to describe a salient attribute of the data. Possible values are average, absolute, and etc.
    flowDirection -- Anything involving current might have a flow direction. Possible values include forward and reverse.
    intervalLength -- Default interval length specified in seconds.
    kind -- Compound class that contains kindCategory and kindIndex
    maxNumberOfIntervals -- To be populated for mirrors of interval data to set the expected number of intervals per ReadingSet. Servers may discard intervals received that exceed this number.
    numberOfConsumptionBlocks -- Number of consumption blocks. 0 means not applicable, and is the default if not specified. The value needs to be at least 1 if any actual prices are provided.
    numberOfTouTiers -- The number of TOU tiers that can be used by any resource configured by this ReadingType. Servers SHALL populate this value with the largest touTier value that will
    <
    i
    >
    ever
    <
    /i
    >
    be used while this ReadingType is in effect. Servers SHALL set numberOfTouTiers equal to the number of standard TOU tiers plus the number of CPP tiers that may be used while this ReadingType is in effect. Servers SHALL specify a value between 0 and 255 (inclusive) for numberOfTouTiers (servers providing flat rate pricing SHOULD set numberOfTouTiers to 0, as in practice there is no difference between having no tiers and having one tier).
    phase -- Contains phase information associated with the type.
    powerOfTenMultiplier -- Indicates the power of ten multiplier applicable to the unit of measure of this ReadingType.
    subIntervalLength -- Default sub-interval length specified in seconds for Readings of ReadingType. Some demand calculations are done over a number of smaller intervals. For example, in a rolling demand calculation, the demand value is defined as the rolling sum of smaller intervals over the intervalLength. The subintervalLength is the length of the smaller interval in this calculation. It SHALL be an integral division of the intervalLength. The number of sub-intervals can be calculated by dividing the intervalLength by the subintervalLength.
    supplyLimit -- Reflects the supply limit set in the meter. This value can be compared to the Reading value to understand if limits are being approached or exceeded. Units follow the same definition as in this ReadingType.
    tieredConsumptionBlocks -- Specifies whether or not the consumption blocks are differentiated by TOUTier or not. Default is false, if not specified.
    true = consumption accumulated over individual tiers
    false = consumption accumulated over all tiers
    uom -- Indicates the measurement type for the units of measure for the readings of this type.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, accumulationBehaviour=None, calorificValue=None, commodity=None, conversionFactor=None, dataQualifier=None, flowDirection=None, intervalLength=None, kind=None, maxNumberOfIntervals=None, numberOfConsumptionBlocks=None, numberOfTouTiers=None, phase=None, powerOfTenMultiplier=None, subIntervalLength=None, supplyLimit=None, tieredConsumptionBlocks=None, uom=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingType"), self).__init__( **kwargs_)
        self.accumulationBehaviour = accumulationBehaviour
        self.accumulationBehaviour_nsprefix_ = None
        self.calorificValue = calorificValue
        self.calorificValue_nsprefix_ = None
        self.commodity = commodity
        self.commodity_nsprefix_ = None
        self.conversionFactor = conversionFactor
        self.conversionFactor_nsprefix_ = None
        self.dataQualifier = dataQualifier
        self.dataQualifier_nsprefix_ = None
        self.flowDirection = flowDirection
        self.flowDirection_nsprefix_ = None
        self.intervalLength = intervalLength
        self.validate_UInt32(self.intervalLength)
        self.intervalLength_nsprefix_ = None
        self.kind = kind
        self.kind_nsprefix_ = None
        self.maxNumberOfIntervals = maxNumberOfIntervals
        self.validate_UInt8(self.maxNumberOfIntervals)
        self.maxNumberOfIntervals_nsprefix_ = None
        self.numberOfConsumptionBlocks = numberOfConsumptionBlocks
        self.validate_UInt8(self.numberOfConsumptionBlocks)
        self.numberOfConsumptionBlocks_nsprefix_ = None
        self.numberOfTouTiers = numberOfTouTiers
        self.validate_UInt8(self.numberOfTouTiers)
        self.numberOfTouTiers_nsprefix_ = None
        self.phase = phase
        self.phase_nsprefix_ = None
        self.powerOfTenMultiplier = powerOfTenMultiplier
        self.powerOfTenMultiplier_nsprefix_ = None
        self.subIntervalLength = subIntervalLength
        self.validate_UInt32(self.subIntervalLength)
        self.subIntervalLength_nsprefix_ = None
        self.supplyLimit = supplyLimit
        self.validate_UInt48(self.supplyLimit)
        self.supplyLimit_nsprefix_ = None
        self.tieredConsumptionBlocks = tieredConsumptionBlocks
        self.tieredConsumptionBlocks_nsprefix_ = None
        self.uom = uom
        self.uom_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingType.subclass:
            return ReadingType.subclass(*args_, **kwargs_)
        else:
            return ReadingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_accumulationBehaviour(self):
        return self.accumulationBehaviour
    def set_accumulationBehaviour(self, accumulationBehaviour):
        self.accumulationBehaviour = accumulationBehaviour
    def get_calorificValue(self):
        return self.calorificValue
    def set_calorificValue(self, calorificValue):
        self.calorificValue = calorificValue
    def get_commodity(self):
        return self.commodity
    def set_commodity(self, commodity):
        self.commodity = commodity
    def get_conversionFactor(self):
        return self.conversionFactor
    def set_conversionFactor(self, conversionFactor):
        self.conversionFactor = conversionFactor
    def get_dataQualifier(self):
        return self.dataQualifier
    def set_dataQualifier(self, dataQualifier):
        self.dataQualifier = dataQualifier
    def get_flowDirection(self):
        return self.flowDirection
    def set_flowDirection(self, flowDirection):
        self.flowDirection = flowDirection
    def get_intervalLength(self):
        return self.intervalLength
    def set_intervalLength(self, intervalLength):
        self.intervalLength = intervalLength
    def get_kind(self):
        return self.kind
    def set_kind(self, kind):
        self.kind = kind
    def get_maxNumberOfIntervals(self):
        return self.maxNumberOfIntervals
    def set_maxNumberOfIntervals(self, maxNumberOfIntervals):
        self.maxNumberOfIntervals = maxNumberOfIntervals
    def get_numberOfConsumptionBlocks(self):
        return self.numberOfConsumptionBlocks
    def set_numberOfConsumptionBlocks(self, numberOfConsumptionBlocks):
        self.numberOfConsumptionBlocks = numberOfConsumptionBlocks
    def get_numberOfTouTiers(self):
        return self.numberOfTouTiers
    def set_numberOfTouTiers(self, numberOfTouTiers):
        self.numberOfTouTiers = numberOfTouTiers
    def get_phase(self):
        return self.phase
    def set_phase(self, phase):
        self.phase = phase
    def get_powerOfTenMultiplier(self):
        return self.powerOfTenMultiplier
    def set_powerOfTenMultiplier(self, powerOfTenMultiplier):
        self.powerOfTenMultiplier = powerOfTenMultiplier
    def get_subIntervalLength(self):
        return self.subIntervalLength
    def set_subIntervalLength(self, subIntervalLength):
        self.subIntervalLength = subIntervalLength
    def get_supplyLimit(self):
        return self.supplyLimit
    def set_supplyLimit(self, supplyLimit):
        self.supplyLimit = supplyLimit
    def get_tieredConsumptionBlocks(self):
        return self.tieredConsumptionBlocks
    def set_tieredConsumptionBlocks(self, tieredConsumptionBlocks):
        self.tieredConsumptionBlocks = tieredConsumptionBlocks
    def get_uom(self):
        return self.uom
    def set_uom(self, uom):
        self.uom = uom
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt48(self, value):
        result = True
        # Validate type UInt48, a restriction on xs:unsignedLong.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            if value > 281474976710655:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxInclusive restriction on UInt48' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.accumulationBehaviour is not None or
            self.calorificValue is not None or
            self.commodity is not None or
            self.conversionFactor is not None or
            self.dataQualifier is not None or
            self.flowDirection is not None or
            self.intervalLength is not None or
            self.kind is not None or
            self.maxNumberOfIntervals is not None or
            self.numberOfConsumptionBlocks is not None or
            self.numberOfTouTiers is not None or
            self.phase is not None or
            self.powerOfTenMultiplier is not None or
            self.subIntervalLength is not None or
            self.supplyLimit is not None or
            self.tieredConsumptionBlocks is not None or
            self.uom is not None or
            super(ReadingType, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingType', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingType':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingType')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingType'):
        super(ReadingType, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingType')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingType', fromsubclass_=False, pretty_print=True):
        super(ReadingType, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.accumulationBehaviour is not None:
            namespaceprefix_ = self.accumulationBehaviour_nsprefix_ + ':' if (UseCapturedNS_ and self.accumulationBehaviour_nsprefix_) else ''
            self.accumulationBehaviour.export(outfile, level, namespaceprefix_, namespacedef_='', name_='accumulationBehaviour', pretty_print=pretty_print)
        if self.calorificValue is not None:
            namespaceprefix_ = self.calorificValue_nsprefix_ + ':' if (UseCapturedNS_ and self.calorificValue_nsprefix_) else ''
            self.calorificValue.export(outfile, level, namespaceprefix_, namespacedef_='', name_='calorificValue', pretty_print=pretty_print)
        if self.commodity is not None:
            namespaceprefix_ = self.commodity_nsprefix_ + ':' if (UseCapturedNS_ and self.commodity_nsprefix_) else ''
            self.commodity.export(outfile, level, namespaceprefix_, namespacedef_='', name_='commodity', pretty_print=pretty_print)
        if self.conversionFactor is not None:
            namespaceprefix_ = self.conversionFactor_nsprefix_ + ':' if (UseCapturedNS_ and self.conversionFactor_nsprefix_) else ''
            self.conversionFactor.export(outfile, level, namespaceprefix_, namespacedef_='', name_='conversionFactor', pretty_print=pretty_print)
        if self.dataQualifier is not None:
            namespaceprefix_ = self.dataQualifier_nsprefix_ + ':' if (UseCapturedNS_ and self.dataQualifier_nsprefix_) else ''
            self.dataQualifier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dataQualifier', pretty_print=pretty_print)
        if self.flowDirection is not None:
            namespaceprefix_ = self.flowDirection_nsprefix_ + ':' if (UseCapturedNS_ and self.flowDirection_nsprefix_) else ''
            self.flowDirection.export(outfile, level, namespaceprefix_, namespacedef_='', name_='flowDirection', pretty_print=pretty_print)
        if self.intervalLength is not None:
            namespaceprefix_ = self.intervalLength_nsprefix_ + ':' if (UseCapturedNS_ and self.intervalLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sintervalLength>%s</%sintervalLength>%s' % (namespaceprefix_ , self.gds_format_integer(self.intervalLength, input_name='intervalLength'), namespaceprefix_ , eol_))
        if self.kind is not None:
            namespaceprefix_ = self.kind_nsprefix_ + ':' if (UseCapturedNS_ and self.kind_nsprefix_) else ''
            self.kind.export(outfile, level, namespaceprefix_, namespacedef_='', name_='kind', pretty_print=pretty_print)
        if self.maxNumberOfIntervals is not None:
            namespaceprefix_ = self.maxNumberOfIntervals_nsprefix_ + ':' if (UseCapturedNS_ and self.maxNumberOfIntervals_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxNumberOfIntervals>%s</%smaxNumberOfIntervals>%s' % (namespaceprefix_ , self.gds_format_integer(self.maxNumberOfIntervals, input_name='maxNumberOfIntervals'), namespaceprefix_ , eol_))
        if self.numberOfConsumptionBlocks is not None:
            namespaceprefix_ = self.numberOfConsumptionBlocks_nsprefix_ + ':' if (UseCapturedNS_ and self.numberOfConsumptionBlocks_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfConsumptionBlocks>%s</%snumberOfConsumptionBlocks>%s' % (namespaceprefix_ , self.gds_format_integer(self.numberOfConsumptionBlocks, input_name='numberOfConsumptionBlocks'), namespaceprefix_ , eol_))
        if self.numberOfTouTiers is not None:
            namespaceprefix_ = self.numberOfTouTiers_nsprefix_ + ':' if (UseCapturedNS_ and self.numberOfTouTiers_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snumberOfTouTiers>%s</%snumberOfTouTiers>%s' % (namespaceprefix_ , self.gds_format_integer(self.numberOfTouTiers, input_name='numberOfTouTiers'), namespaceprefix_ , eol_))
        if self.phase is not None:
            namespaceprefix_ = self.phase_nsprefix_ + ':' if (UseCapturedNS_ and self.phase_nsprefix_) else ''
            self.phase.export(outfile, level, namespaceprefix_, namespacedef_='', name_='phase', pretty_print=pretty_print)
        if self.powerOfTenMultiplier is not None:
            namespaceprefix_ = self.powerOfTenMultiplier_nsprefix_ + ':' if (UseCapturedNS_ and self.powerOfTenMultiplier_nsprefix_) else ''
            self.powerOfTenMultiplier.export(outfile, level, namespaceprefix_, namespacedef_='', name_='powerOfTenMultiplier', pretty_print=pretty_print)
        if self.subIntervalLength is not None:
            namespaceprefix_ = self.subIntervalLength_nsprefix_ + ':' if (UseCapturedNS_ and self.subIntervalLength_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubIntervalLength>%s</%ssubIntervalLength>%s' % (namespaceprefix_ , self.gds_format_integer(self.subIntervalLength, input_name='subIntervalLength'), namespaceprefix_ , eol_))
        if self.supplyLimit is not None:
            namespaceprefix_ = self.supplyLimit_nsprefix_ + ':' if (UseCapturedNS_ and self.supplyLimit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssupplyLimit>%s</%ssupplyLimit>%s' % (namespaceprefix_ , self.gds_format_integer(self.supplyLimit, input_name='supplyLimit'), namespaceprefix_ , eol_))
        if self.tieredConsumptionBlocks is not None:
            namespaceprefix_ = self.tieredConsumptionBlocks_nsprefix_ + ':' if (UseCapturedNS_ and self.tieredConsumptionBlocks_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stieredConsumptionBlocks>%s</%stieredConsumptionBlocks>%s' % (namespaceprefix_ , self.gds_format_boolean(self.tieredConsumptionBlocks, input_name='tieredConsumptionBlocks'), namespaceprefix_ , eol_))
        if self.uom is not None:
            namespaceprefix_ = self.uom_nsprefix_ + ':' if (UseCapturedNS_ and self.uom_nsprefix_) else ''
            self.uom.export(outfile, level, namespaceprefix_, namespacedef_='', name_='uom', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingType, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'accumulationBehaviour':
            obj_ = AccumulationBehaviourType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.accumulationBehaviour = obj_
            obj_.original_tagname_ = 'accumulationBehaviour'
        elif nodeName_ == 'calorificValue':
            obj_ = UnitValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.calorificValue = obj_
            obj_.original_tagname_ = 'calorificValue'
        elif nodeName_ == 'commodity':
            obj_ = CommodityType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.commodity = obj_
            obj_.original_tagname_ = 'commodity'
        elif nodeName_ == 'conversionFactor':
            obj_ = UnitValueType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.conversionFactor = obj_
            obj_.original_tagname_ = 'conversionFactor'
        elif nodeName_ == 'dataQualifier':
            obj_ = DataQualifierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dataQualifier = obj_
            obj_.original_tagname_ = 'dataQualifier'
        elif nodeName_ == 'flowDirection':
            obj_ = FlowDirectionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.flowDirection = obj_
            obj_.original_tagname_ = 'flowDirection'
        elif nodeName_ == 'intervalLength' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'intervalLength')
            ival_ = self.gds_validate_integer(ival_, node, 'intervalLength')
            self.intervalLength = ival_
            self.intervalLength_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.intervalLength)
        elif nodeName_ == 'kind':
            obj_ = KindType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.kind = obj_
            obj_.original_tagname_ = 'kind'
        elif nodeName_ == 'maxNumberOfIntervals' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'maxNumberOfIntervals')
            ival_ = self.gds_validate_integer(ival_, node, 'maxNumberOfIntervals')
            self.maxNumberOfIntervals = ival_
            self.maxNumberOfIntervals_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.maxNumberOfIntervals)
        elif nodeName_ == 'numberOfConsumptionBlocks' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'numberOfConsumptionBlocks')
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfConsumptionBlocks')
            self.numberOfConsumptionBlocks = ival_
            self.numberOfConsumptionBlocks_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.numberOfConsumptionBlocks)
        elif nodeName_ == 'numberOfTouTiers' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'numberOfTouTiers')
            ival_ = self.gds_validate_integer(ival_, node, 'numberOfTouTiers')
            self.numberOfTouTiers = ival_
            self.numberOfTouTiers_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.numberOfTouTiers)
        elif nodeName_ == 'phase':
            obj_ = PhaseCode.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.phase = obj_
            obj_.original_tagname_ = 'phase'
        elif nodeName_ == 'powerOfTenMultiplier':
            obj_ = PowerOfTenMultiplierType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.powerOfTenMultiplier = obj_
            obj_.original_tagname_ = 'powerOfTenMultiplier'
        elif nodeName_ == 'subIntervalLength' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'subIntervalLength')
            ival_ = self.gds_validate_integer(ival_, node, 'subIntervalLength')
            self.subIntervalLength = ival_
            self.subIntervalLength_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.subIntervalLength)
        elif nodeName_ == 'supplyLimit' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'supplyLimit')
            ival_ = self.gds_validate_integer(ival_, node, 'supplyLimit')
            self.supplyLimit = ival_
            self.supplyLimit_nsprefix_ = child_.prefix
            # validate type UInt48
            self.validate_UInt48(self.supplyLimit)
        elif nodeName_ == 'tieredConsumptionBlocks':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'tieredConsumptionBlocks')
            ival_ = self.gds_validate_boolean(ival_, node, 'tieredConsumptionBlocks')
            self.tieredConsumptionBlocks = ival_
            self.tieredConsumptionBlocks_nsprefix_ = child_.prefix
        elif nodeName_ == 'uom':
            obj_ = UomType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.uom = obj_
            obj_.original_tagname_ = 'uom'
        super(ReadingType, self)._buildChildren(child_, node, nodeName_, True)
# end class ReadingType


class ReadingSetList(SubscribableList):
    """ReadingSetList -- A List element to hold ReadingSet objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, ReadingSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingSetList"), self).__init__( **kwargs_)
        if ReadingSet is None:
            self.ReadingSet = []
        else:
            self.ReadingSet = ReadingSet
        self.ReadingSet_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingSetList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingSetList.subclass:
            return ReadingSetList.subclass(*args_, **kwargs_)
        else:
            return ReadingSetList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ReadingSet(self):
        return self.ReadingSet
    def set_ReadingSet(self, ReadingSet):
        self.ReadingSet = ReadingSet
    def add_ReadingSet(self, value):
        self.ReadingSet.append(value)
    def insert_ReadingSet_at(self, index, value):
        self.ReadingSet.insert(index, value)
    def replace_ReadingSet_at(self, index, value):
        self.ReadingSet[index] = value
    def _hasContent(self):
        if (
            self.ReadingSet or
            super(ReadingSetList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingSetList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingSetList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingSetList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingSetList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingSetList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingSetList'):
        super(ReadingSetList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingSetList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingSetList', fromsubclass_=False, pretty_print=True):
        super(ReadingSetList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ReadingSet_ in self.ReadingSet:
            namespaceprefix_ = self.ReadingSet_nsprefix_ + ':' if (UseCapturedNS_ and self.ReadingSet_nsprefix_) else ''
            ReadingSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReadingSet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingSetList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ReadingSet':
            obj_ = ReadingSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReadingSet.append(obj_)
            obj_.original_tagname_ = 'ReadingSet'
        super(ReadingSetList, self)._buildChildren(child_, node, nodeName_, True)
# end class ReadingSetList


class ReadingList(SubscribableList):
    """ReadingList -- A List element to hold Reading objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, Reading=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingList"), self).__init__( **kwargs_)
        if Reading is None:
            self.Reading = []
        else:
            self.Reading = Reading
        self.Reading_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingList.subclass:
            return ReadingList.subclass(*args_, **kwargs_)
        else:
            return ReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Reading(self):
        return self.Reading
    def set_Reading(self, Reading):
        self.Reading = Reading
    def add_Reading(self, value):
        self.Reading.append(value)
    def insert_Reading_at(self, index, value):
        self.Reading.insert(index, value)
    def replace_Reading_at(self, index, value):
        self.Reading[index] = value
    def _hasContent(self):
        if (
            self.Reading or
            super(ReadingList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingList'):
        super(ReadingList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingList', fromsubclass_=False, pretty_print=True):
        super(ReadingList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reading_ in self.Reading:
            namespaceprefix_ = self.Reading_nsprefix_ + ':' if (UseCapturedNS_ and self.Reading_nsprefix_) else ''
            Reading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reading', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Reading':
            obj_ = Reading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reading.append(obj_)
            obj_.original_tagname_ = 'Reading'
        super(ReadingList, self)._buildChildren(child_, node, nodeName_, True)
# end class ReadingList


class Reading(ReadingBase):
    """Reading -- Specific value measured by a meter or other asset.
    subscribable -- Indicates whether or not subscriptions are supported for this resource, and whether or not conditional (thresholds) are supported. If not specified, is "not subscribable" (0).
    localID -- The local identifier for this reading within the reading set. localIDs are assigned in order of creation time. For interval data, this value SHALL increase with each interval time, and for block/tier readings, localID SHALL not be specified.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReadingBase
    def __init__(self, subscribable='0', localID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Reading"), self).__init__( **kwargs_)
        self.subscribable = _cast(int, subscribable)
        self.subscribable_nsprefix_ = None
        self.localID = localID
        self.validate_HexBinary16(self.localID)
        self.localID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Reading)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Reading.subclass:
            return Reading.subclass(*args_, **kwargs_)
        else:
            return Reading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_localID(self):
        return self.localID
    def set_localID(self, localID):
        self.localID = localID
    def get_subscribable(self):
        return self.subscribable
    def set_subscribable(self, subscribable):
        self.subscribable = subscribable
    def validate_HexBinary16(self, value):
        result = True
        # Validate type HexBinary16, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary16' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_SubscribableType(self, value):
        # Validate type SubscribableType, a restriction on UInt8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.localID is not None or
            super(Reading, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Reading', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Reading')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Reading':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Reading')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Reading', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Reading'):
        super(Reading, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Reading')
        if self.subscribable != "0" and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            outfile.write(' subscribable=%s' % (quote_attrib(self.subscribable), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Reading', fromsubclass_=False, pretty_print=True):
        super(Reading, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.localID is not None:
            namespaceprefix_ = self.localID_nsprefix_ + ':' if (UseCapturedNS_ and self.localID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slocalID>%s</%slocalID>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.localID), input_name='localID')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subscribable', node)
        if value is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            self.subscribable = self.gds_parse_integer(value, node, 'subscribable')
            self.validate_SubscribableType(self.subscribable)    # validate type SubscribableType
        super(Reading, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'localID':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'localID')
            value_ = self.gds_validate_string(value_, node, 'localID')
            self.localID = value_
            self.localID_nsprefix_ = child_.prefix
            # validate type HexBinary16
            self.validate_HexBinary16(self.localID)
        super(Reading, self)._buildChildren(child_, node, nodeName_, True)
# end class Reading


class MeterReadingList(SubscribableList):
    """MeterReadingList -- A List element to hold MeterReading objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, MeterReading=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MeterReadingList"), self).__init__( **kwargs_)
        if MeterReading is None:
            self.MeterReading = []
        else:
            self.MeterReading = MeterReading
        self.MeterReading_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeterReadingList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeterReadingList.subclass:
            return MeterReadingList.subclass(*args_, **kwargs_)
        else:
            return MeterReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MeterReading(self):
        return self.MeterReading
    def set_MeterReading(self, MeterReading):
        self.MeterReading = MeterReading
    def add_MeterReading(self, value):
        self.MeterReading.append(value)
    def insert_MeterReading_at(self, index, value):
        self.MeterReading.insert(index, value)
    def replace_MeterReading_at(self, index, value):
        self.MeterReading[index] = value
    def _hasContent(self):
        if (
            self.MeterReading or
            super(MeterReadingList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MeterReadingList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeterReadingList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MeterReadingList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReadingList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeterReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeterReadingList'):
        super(MeterReadingList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReadingList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MeterReadingList', fromsubclass_=False, pretty_print=True):
        super(MeterReadingList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MeterReading_ in self.MeterReading:
            namespaceprefix_ = self.MeterReading_nsprefix_ + ':' if (UseCapturedNS_ and self.MeterReading_nsprefix_) else ''
            MeterReading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeterReading', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MeterReadingList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MeterReading':
            obj_ = MeterReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeterReading.append(obj_)
            obj_.original_tagname_ = 'MeterReading'
        super(MeterReadingList, self)._buildChildren(child_, node, nodeName_, True)
# end class MeterReadingList


class LoadShedAvailability(Resource):
    """LoadShedAvailability -- Indicates current consumption status and ability to shed load.
    availabilityDuration -- Indicates for how many seconds the consuming device will be able to reduce consumption at the maximum response level.
    sheddablePercent -- Maximum percent of current operating load that is estimated to be sheddable.
    sheddablePower -- Maximum amount of current operating load that is estimated to be sheddable, in Watts.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, availabilityDuration=None, DemandResponseProgramLink=None, sheddablePercent=None, sheddablePower=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LoadShedAvailability"), self).__init__( **kwargs_)
        self.availabilityDuration = availabilityDuration
        self.validate_UInt32(self.availabilityDuration)
        self.availabilityDuration_nsprefix_ = None
        self.DemandResponseProgramLink = DemandResponseProgramLink
        self.DemandResponseProgramLink_nsprefix_ = None
        self.sheddablePercent = sheddablePercent
        self.sheddablePercent_nsprefix_ = None
        self.sheddablePower = sheddablePower
        self.sheddablePower_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LoadShedAvailability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LoadShedAvailability.subclass:
            return LoadShedAvailability.subclass(*args_, **kwargs_)
        else:
            return LoadShedAvailability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_availabilityDuration(self):
        return self.availabilityDuration
    def set_availabilityDuration(self, availabilityDuration):
        self.availabilityDuration = availabilityDuration
    def get_DemandResponseProgramLink(self):
        return self.DemandResponseProgramLink
    def set_DemandResponseProgramLink(self, DemandResponseProgramLink):
        self.DemandResponseProgramLink = DemandResponseProgramLink
    def get_sheddablePercent(self):
        return self.sheddablePercent
    def set_sheddablePercent(self, sheddablePercent):
        self.sheddablePercent = sheddablePercent
    def get_sheddablePower(self):
        return self.sheddablePower
    def set_sheddablePower(self, sheddablePower):
        self.sheddablePower = sheddablePower
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.availabilityDuration is not None or
            self.DemandResponseProgramLink is not None or
            self.sheddablePercent is not None or
            self.sheddablePower is not None or
            super(LoadShedAvailability, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LoadShedAvailability', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LoadShedAvailability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LoadShedAvailability':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LoadShedAvailability')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LoadShedAvailability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LoadShedAvailability'):
        super(LoadShedAvailability, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LoadShedAvailability')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LoadShedAvailability', fromsubclass_=False, pretty_print=True):
        super(LoadShedAvailability, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.availabilityDuration is not None:
            namespaceprefix_ = self.availabilityDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityDuration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%savailabilityDuration>%s</%savailabilityDuration>%s' % (namespaceprefix_ , self.gds_format_integer(self.availabilityDuration, input_name='availabilityDuration'), namespaceprefix_ , eol_))
        if self.DemandResponseProgramLink is not None:
            namespaceprefix_ = self.DemandResponseProgramLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DemandResponseProgramLink_nsprefix_) else ''
            self.DemandResponseProgramLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DemandResponseProgramLink', pretty_print=pretty_print)
        if self.sheddablePercent is not None:
            namespaceprefix_ = self.sheddablePercent_nsprefix_ + ':' if (UseCapturedNS_ and self.sheddablePercent_nsprefix_) else ''
            self.sheddablePercent.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sheddablePercent', pretty_print=pretty_print)
        if self.sheddablePower is not None:
            namespaceprefix_ = self.sheddablePower_nsprefix_ + ':' if (UseCapturedNS_ and self.sheddablePower_nsprefix_) else ''
            self.sheddablePower.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sheddablePower', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LoadShedAvailability, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'availabilityDuration' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'availabilityDuration')
            ival_ = self.gds_validate_integer(ival_, node, 'availabilityDuration')
            self.availabilityDuration = ival_
            self.availabilityDuration_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.availabilityDuration)
        elif nodeName_ == 'DemandResponseProgramLink':
            obj_ = DemandResponseProgramLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DemandResponseProgramLink = obj_
            obj_.original_tagname_ = 'DemandResponseProgramLink'
        elif nodeName_ == 'sheddablePercent':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sheddablePercent = obj_
            obj_.original_tagname_ = 'sheddablePercent'
        elif nodeName_ == 'sheddablePower':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sheddablePower = obj_
            obj_.original_tagname_ = 'sheddablePower'
        super(LoadShedAvailability, self)._buildChildren(child_, node, nodeName_, True)
# end class LoadShedAvailability


class EndDeviceControlList(SubscribableList):
    """EndDeviceControlList -- A List element to hold EndDeviceControl objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, EndDeviceControl=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EndDeviceControlList"), self).__init__( **kwargs_)
        if EndDeviceControl is None:
            self.EndDeviceControl = []
        else:
            self.EndDeviceControl = EndDeviceControl
        self.EndDeviceControl_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndDeviceControlList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndDeviceControlList.subclass:
            return EndDeviceControlList.subclass(*args_, **kwargs_)
        else:
            return EndDeviceControlList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EndDeviceControl(self):
        return self.EndDeviceControl
    def set_EndDeviceControl(self, EndDeviceControl):
        self.EndDeviceControl = EndDeviceControl
    def add_EndDeviceControl(self, value):
        self.EndDeviceControl.append(value)
    def insert_EndDeviceControl_at(self, index, value):
        self.EndDeviceControl.insert(index, value)
    def replace_EndDeviceControl_at(self, index, value):
        self.EndDeviceControl[index] = value
    def _hasContent(self):
        if (
            self.EndDeviceControl or
            super(EndDeviceControlList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EndDeviceControlList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndDeviceControlList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndDeviceControlList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceControlList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndDeviceControlList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndDeviceControlList'):
        super(EndDeviceControlList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceControlList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EndDeviceControlList', fromsubclass_=False, pretty_print=True):
        super(EndDeviceControlList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EndDeviceControl_ in self.EndDeviceControl:
            namespaceprefix_ = self.EndDeviceControl_nsprefix_ + ':' if (UseCapturedNS_ and self.EndDeviceControl_nsprefix_) else ''
            EndDeviceControl_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndDeviceControl', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceControlList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EndDeviceControl':
            obj_ = EndDeviceControl.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndDeviceControl.append(obj_)
            obj_.original_tagname_ = 'EndDeviceControl'
        super(EndDeviceControlList, self)._buildChildren(child_, node, nodeName_, True)
# end class EndDeviceControlList


class EndDeviceControl(RandomizableEvent):
    """EndDeviceControl -- Instructs an EndDevice to perform a specified action.
    deviceCategory -- Specifies the bitmap indicating  the categories of devices that SHOULD respond. Devices SHOULD ignore events that do not indicate their device category.
    drProgramMandatory -- A flag to indicate if the EndDeviceControl is considered a mandatory event as defined by the service provider issuing the EndDeviceControl. The drProgramMandatory flag alerts the client/user that they will be subject to penalty or ineligibility based on the service provider
    
    s program rules for that deviceCategory.
    loadShiftForward -- Indicates that the event intends to increase consumption. A value of true indicates the intention to increase usage value, and a value of false indicates the intention to decrease usage.
    overrideDuration -- The overrideDuration attribute provides a duration, in seconds, for which a client device is allowed to override this EndDeviceControl and still meet the contractual agreement with a service provider without opting out. If overrideDuration is not specified, then it SHALL default to 0.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = RandomizableEvent
    def __init__(self, ApplianceLoadReduction=None, deviceCategory=None, drProgramMandatory=None, DutyCycle=None, loadShiftForward=None, Offset=None, overrideDuration=None, SetPoint=None, TargetReduction=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EndDeviceControl"), self).__init__( **kwargs_)
        self.ApplianceLoadReduction = ApplianceLoadReduction
        self.ApplianceLoadReduction_nsprefix_ = None
        self.deviceCategory = deviceCategory
        self.deviceCategory_nsprefix_ = None
        self.drProgramMandatory = drProgramMandatory
        self.drProgramMandatory_nsprefix_ = None
        self.DutyCycle = DutyCycle
        self.DutyCycle_nsprefix_ = None
        self.loadShiftForward = loadShiftForward
        self.loadShiftForward_nsprefix_ = None
        self.Offset = Offset
        self.Offset_nsprefix_ = None
        self.overrideDuration = overrideDuration
        self.validate_UInt16(self.overrideDuration)
        self.overrideDuration_nsprefix_ = None
        self.SetPoint = SetPoint
        self.SetPoint_nsprefix_ = None
        self.TargetReduction = TargetReduction
        self.TargetReduction_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndDeviceControl)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndDeviceControl.subclass:
            return EndDeviceControl.subclass(*args_, **kwargs_)
        else:
            return EndDeviceControl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ApplianceLoadReduction(self):
        return self.ApplianceLoadReduction
    def set_ApplianceLoadReduction(self, ApplianceLoadReduction):
        self.ApplianceLoadReduction = ApplianceLoadReduction
    def get_deviceCategory(self):
        return self.deviceCategory
    def set_deviceCategory(self, deviceCategory):
        self.deviceCategory = deviceCategory
    def get_drProgramMandatory(self):
        return self.drProgramMandatory
    def set_drProgramMandatory(self, drProgramMandatory):
        self.drProgramMandatory = drProgramMandatory
    def get_DutyCycle(self):
        return self.DutyCycle
    def set_DutyCycle(self, DutyCycle):
        self.DutyCycle = DutyCycle
    def get_loadShiftForward(self):
        return self.loadShiftForward
    def set_loadShiftForward(self, loadShiftForward):
        self.loadShiftForward = loadShiftForward
    def get_Offset(self):
        return self.Offset
    def set_Offset(self, Offset):
        self.Offset = Offset
    def get_overrideDuration(self):
        return self.overrideDuration
    def set_overrideDuration(self, overrideDuration):
        self.overrideDuration = overrideDuration
    def get_SetPoint(self):
        return self.SetPoint
    def set_SetPoint(self, SetPoint):
        self.SetPoint = SetPoint
    def get_TargetReduction(self):
        return self.TargetReduction
    def set_TargetReduction(self, TargetReduction):
        self.TargetReduction = TargetReduction
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.ApplianceLoadReduction is not None or
            self.deviceCategory is not None or
            self.drProgramMandatory is not None or
            self.DutyCycle is not None or
            self.loadShiftForward is not None or
            self.Offset is not None or
            self.overrideDuration is not None or
            self.SetPoint is not None or
            self.TargetReduction is not None or
            super(EndDeviceControl, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EndDeviceControl', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndDeviceControl')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndDeviceControl':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceControl')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndDeviceControl', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndDeviceControl'):
        super(EndDeviceControl, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceControl')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EndDeviceControl', fromsubclass_=False, pretty_print=True):
        super(EndDeviceControl, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ApplianceLoadReduction is not None:
            namespaceprefix_ = self.ApplianceLoadReduction_nsprefix_ + ':' if (UseCapturedNS_ and self.ApplianceLoadReduction_nsprefix_) else ''
            self.ApplianceLoadReduction.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ApplianceLoadReduction', pretty_print=pretty_print)
        if self.deviceCategory is not None:
            namespaceprefix_ = self.deviceCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.deviceCategory_nsprefix_) else ''
            self.deviceCategory.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deviceCategory', pretty_print=pretty_print)
        if self.drProgramMandatory is not None:
            namespaceprefix_ = self.drProgramMandatory_nsprefix_ + ':' if (UseCapturedNS_ and self.drProgramMandatory_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdrProgramMandatory>%s</%sdrProgramMandatory>%s' % (namespaceprefix_ , self.gds_format_boolean(self.drProgramMandatory, input_name='drProgramMandatory'), namespaceprefix_ , eol_))
        if self.DutyCycle is not None:
            namespaceprefix_ = self.DutyCycle_nsprefix_ + ':' if (UseCapturedNS_ and self.DutyCycle_nsprefix_) else ''
            self.DutyCycle.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DutyCycle', pretty_print=pretty_print)
        if self.loadShiftForward is not None:
            namespaceprefix_ = self.loadShiftForward_nsprefix_ + ':' if (UseCapturedNS_ and self.loadShiftForward_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadShiftForward>%s</%sloadShiftForward>%s' % (namespaceprefix_ , self.gds_format_boolean(self.loadShiftForward, input_name='loadShiftForward'), namespaceprefix_ , eol_))
        if self.Offset is not None:
            namespaceprefix_ = self.Offset_nsprefix_ + ':' if (UseCapturedNS_ and self.Offset_nsprefix_) else ''
            self.Offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Offset', pretty_print=pretty_print)
        if self.overrideDuration is not None:
            namespaceprefix_ = self.overrideDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.overrideDuration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverrideDuration>%s</%soverrideDuration>%s' % (namespaceprefix_ , self.gds_format_integer(self.overrideDuration, input_name='overrideDuration'), namespaceprefix_ , eol_))
        if self.SetPoint is not None:
            namespaceprefix_ = self.SetPoint_nsprefix_ + ':' if (UseCapturedNS_ and self.SetPoint_nsprefix_) else ''
            self.SetPoint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SetPoint', pretty_print=pretty_print)
        if self.TargetReduction is not None:
            namespaceprefix_ = self.TargetReduction_nsprefix_ + ':' if (UseCapturedNS_ and self.TargetReduction_nsprefix_) else ''
            self.TargetReduction.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TargetReduction', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EndDeviceControl, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ApplianceLoadReduction':
            obj_ = ApplianceLoadReduction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ApplianceLoadReduction = obj_
            obj_.original_tagname_ = 'ApplianceLoadReduction'
        elif nodeName_ == 'deviceCategory':
            obj_ = DeviceCategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deviceCategory = obj_
            obj_.original_tagname_ = 'deviceCategory'
        elif nodeName_ == 'drProgramMandatory':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'drProgramMandatory')
            ival_ = self.gds_validate_boolean(ival_, node, 'drProgramMandatory')
            self.drProgramMandatory = ival_
            self.drProgramMandatory_nsprefix_ = child_.prefix
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'loadShiftForward':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'loadShiftForward')
            ival_ = self.gds_validate_boolean(ival_, node, 'loadShiftForward')
            self.loadShiftForward = ival_
            self.loadShiftForward_nsprefix_ = child_.prefix
        elif nodeName_ == 'Offset':
            obj_ = Offset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Offset = obj_
            obj_.original_tagname_ = 'Offset'
        elif nodeName_ == 'overrideDuration' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'overrideDuration')
            ival_ = self.gds_validate_integer(ival_, node, 'overrideDuration')
            self.overrideDuration = ival_
            self.overrideDuration_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.overrideDuration)
        elif nodeName_ == 'SetPoint':
            obj_ = SetPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SetPoint = obj_
            obj_.original_tagname_ = 'SetPoint'
        elif nodeName_ == 'TargetReduction':
            obj_ = TargetReduction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TargetReduction = obj_
            obj_.original_tagname_ = 'TargetReduction'
        super(EndDeviceControl, self)._buildChildren(child_, node, nodeName_, True)
# end class EndDeviceControl


class DemandResponseProgramList(SubscribableList):
    """DemandResponseProgramList -- A List element to hold DemandResponseProgram objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', DemandResponseProgram=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DemandResponseProgramList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if DemandResponseProgram is None:
            self.DemandResponseProgram = []
        else:
            self.DemandResponseProgram = DemandResponseProgram
        self.DemandResponseProgram_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandResponseProgramList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandResponseProgramList.subclass:
            return DemandResponseProgramList.subclass(*args_, **kwargs_)
        else:
            return DemandResponseProgramList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DemandResponseProgram(self):
        return self.DemandResponseProgram
    def set_DemandResponseProgram(self, DemandResponseProgram):
        self.DemandResponseProgram = DemandResponseProgram
    def add_DemandResponseProgram(self, value):
        self.DemandResponseProgram.append(value)
    def insert_DemandResponseProgram_at(self, index, value):
        self.DemandResponseProgram.insert(index, value)
    def replace_DemandResponseProgram_at(self, index, value):
        self.DemandResponseProgram[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.DemandResponseProgram or
            super(DemandResponseProgramList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DemandResponseProgramList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DemandResponseProgramList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DemandResponseProgramList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseProgramList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DemandResponseProgramList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DemandResponseProgramList'):
        super(DemandResponseProgramList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseProgramList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DemandResponseProgramList', fromsubclass_=False, pretty_print=True):
        super(DemandResponseProgramList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DemandResponseProgram_ in self.DemandResponseProgram:
            namespaceprefix_ = self.DemandResponseProgram_nsprefix_ + ':' if (UseCapturedNS_ and self.DemandResponseProgram_nsprefix_) else ''
            DemandResponseProgram_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DemandResponseProgram', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(DemandResponseProgramList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DemandResponseProgram':
            obj_ = DemandResponseProgram.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DemandResponseProgram.append(obj_)
            obj_.original_tagname_ = 'DemandResponseProgram'
        super(DemandResponseProgramList, self)._buildChildren(child_, node, nodeName_, True)
# end class DemandResponseProgramList


class DemandResponseProgram(IdentifiedObject):
    """DemandResponseProgram -- Demand response program.
    availabilityUpdatePercentChangeThreshold -- This attribute allows program providers to specify the requested granularity of updates to LoadShedAvailability sheddablePercent. If not present, or set to 0, then updates to LoadShedAvailability SHALL NOT be provided. If present and greater than zero, then clients SHALL provide their LoadShedAvailability if it has not previously been provided, and thereafter if the difference between the previously provided value and the current value of LoadShedAvailability sheddablePercent is greater than availabilityUpdatePercentChangeThreshold.
    availabilityUpdatePowerChangeThreshold -- This attribute allows program providers to specify the requested granularity of updates to LoadShedAvailability sheddablePower. If not present, or set to 0, then updates to LoadShedAvailability SHALL NOT be provided. If present and greater than zero, then clients SHALL provide their LoadShedAvailability if it has not previously been provided, and thereafter if the difference between the previously provided value and the current value of LoadShedAvailability sheddablePower is greater than availabilityUpdatePowerChangeThreshold.
    primacy -- Indicates the relative primacy of the provider of this program.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, ActiveEndDeviceControlListLink=None, availabilityUpdatePercentChangeThreshold=None, availabilityUpdatePowerChangeThreshold=None, EndDeviceControlListLink=None, primacy=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DemandResponseProgram"), self).__init__( **kwargs_)
        self.ActiveEndDeviceControlListLink = ActiveEndDeviceControlListLink
        self.ActiveEndDeviceControlListLink_nsprefix_ = None
        self.availabilityUpdatePercentChangeThreshold = availabilityUpdatePercentChangeThreshold
        self.availabilityUpdatePercentChangeThreshold_nsprefix_ = None
        self.availabilityUpdatePowerChangeThreshold = availabilityUpdatePowerChangeThreshold
        self.availabilityUpdatePowerChangeThreshold_nsprefix_ = None
        self.EndDeviceControlListLink = EndDeviceControlListLink
        self.EndDeviceControlListLink_nsprefix_ = None
        self.primacy = primacy
        self.primacy_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DemandResponseProgram)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DemandResponseProgram.subclass:
            return DemandResponseProgram.subclass(*args_, **kwargs_)
        else:
            return DemandResponseProgram(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ActiveEndDeviceControlListLink(self):
        return self.ActiveEndDeviceControlListLink
    def set_ActiveEndDeviceControlListLink(self, ActiveEndDeviceControlListLink):
        self.ActiveEndDeviceControlListLink = ActiveEndDeviceControlListLink
    def get_availabilityUpdatePercentChangeThreshold(self):
        return self.availabilityUpdatePercentChangeThreshold
    def set_availabilityUpdatePercentChangeThreshold(self, availabilityUpdatePercentChangeThreshold):
        self.availabilityUpdatePercentChangeThreshold = availabilityUpdatePercentChangeThreshold
    def get_availabilityUpdatePowerChangeThreshold(self):
        return self.availabilityUpdatePowerChangeThreshold
    def set_availabilityUpdatePowerChangeThreshold(self, availabilityUpdatePowerChangeThreshold):
        self.availabilityUpdatePowerChangeThreshold = availabilityUpdatePowerChangeThreshold
    def get_EndDeviceControlListLink(self):
        return self.EndDeviceControlListLink
    def set_EndDeviceControlListLink(self, EndDeviceControlListLink):
        self.EndDeviceControlListLink = EndDeviceControlListLink
    def get_primacy(self):
        return self.primacy
    def set_primacy(self, primacy):
        self.primacy = primacy
    def _hasContent(self):
        if (
            self.ActiveEndDeviceControlListLink is not None or
            self.availabilityUpdatePercentChangeThreshold is not None or
            self.availabilityUpdatePowerChangeThreshold is not None or
            self.EndDeviceControlListLink is not None or
            self.primacy is not None or
            super(DemandResponseProgram, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DemandResponseProgram', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DemandResponseProgram')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DemandResponseProgram':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseProgram')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DemandResponseProgram', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DemandResponseProgram'):
        super(DemandResponseProgram, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DemandResponseProgram')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DemandResponseProgram', fromsubclass_=False, pretty_print=True):
        super(DemandResponseProgram, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ActiveEndDeviceControlListLink is not None:
            namespaceprefix_ = self.ActiveEndDeviceControlListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ActiveEndDeviceControlListLink_nsprefix_) else ''
            self.ActiveEndDeviceControlListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ActiveEndDeviceControlListLink', pretty_print=pretty_print)
        if self.availabilityUpdatePercentChangeThreshold is not None:
            namespaceprefix_ = self.availabilityUpdatePercentChangeThreshold_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityUpdatePercentChangeThreshold_nsprefix_) else ''
            self.availabilityUpdatePercentChangeThreshold.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availabilityUpdatePercentChangeThreshold', pretty_print=pretty_print)
        if self.availabilityUpdatePowerChangeThreshold is not None:
            namespaceprefix_ = self.availabilityUpdatePowerChangeThreshold_nsprefix_ + ':' if (UseCapturedNS_ and self.availabilityUpdatePowerChangeThreshold_nsprefix_) else ''
            self.availabilityUpdatePowerChangeThreshold.export(outfile, level, namespaceprefix_, namespacedef_='', name_='availabilityUpdatePowerChangeThreshold', pretty_print=pretty_print)
        if self.EndDeviceControlListLink is not None:
            namespaceprefix_ = self.EndDeviceControlListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.EndDeviceControlListLink_nsprefix_) else ''
            self.EndDeviceControlListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndDeviceControlListLink', pretty_print=pretty_print)
        if self.primacy is not None:
            namespaceprefix_ = self.primacy_nsprefix_ + ':' if (UseCapturedNS_ and self.primacy_nsprefix_) else ''
            self.primacy.export(outfile, level, namespaceprefix_, namespacedef_='', name_='primacy', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DemandResponseProgram, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ActiveEndDeviceControlListLink':
            obj_ = ActiveEndDeviceControlListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ActiveEndDeviceControlListLink = obj_
            obj_.original_tagname_ = 'ActiveEndDeviceControlListLink'
        elif nodeName_ == 'availabilityUpdatePercentChangeThreshold':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availabilityUpdatePercentChangeThreshold = obj_
            obj_.original_tagname_ = 'availabilityUpdatePercentChangeThreshold'
        elif nodeName_ == 'availabilityUpdatePowerChangeThreshold':
            obj_ = ActivePower.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.availabilityUpdatePowerChangeThreshold = obj_
            obj_.original_tagname_ = 'availabilityUpdatePowerChangeThreshold'
        elif nodeName_ == 'EndDeviceControlListLink':
            obj_ = EndDeviceControlListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndDeviceControlListLink = obj_
            obj_.original_tagname_ = 'EndDeviceControlListLink'
        elif nodeName_ == 'primacy':
            obj_ = PrimacyType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primacy = obj_
            obj_.original_tagname_ = 'primacy'
        super(DemandResponseProgram, self)._buildChildren(child_, node, nodeName_, True)
# end class DemandResponseProgram


class LoadShedAvailabilityList(List):
    """LoadShedAvailabilityList -- A List element to hold LoadShedAvailability objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, pollRate='900', LoadShedAvailability=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LoadShedAvailabilityList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if LoadShedAvailability is None:
            self.LoadShedAvailability = []
        else:
            self.LoadShedAvailability = LoadShedAvailability
        self.LoadShedAvailability_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LoadShedAvailabilityList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LoadShedAvailabilityList.subclass:
            return LoadShedAvailabilityList.subclass(*args_, **kwargs_)
        else:
            return LoadShedAvailabilityList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LoadShedAvailability(self):
        return self.LoadShedAvailability
    def set_LoadShedAvailability(self, LoadShedAvailability):
        self.LoadShedAvailability = LoadShedAvailability
    def add_LoadShedAvailability(self, value):
        self.LoadShedAvailability.append(value)
    def insert_LoadShedAvailability_at(self, index, value):
        self.LoadShedAvailability.insert(index, value)
    def replace_LoadShedAvailability_at(self, index, value):
        self.LoadShedAvailability[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.LoadShedAvailability or
            super(LoadShedAvailabilityList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LoadShedAvailabilityList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LoadShedAvailabilityList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LoadShedAvailabilityList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LoadShedAvailabilityList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LoadShedAvailabilityList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LoadShedAvailabilityList'):
        super(LoadShedAvailabilityList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LoadShedAvailabilityList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LoadShedAvailabilityList', fromsubclass_=False, pretty_print=True):
        super(LoadShedAvailabilityList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LoadShedAvailability_ in self.LoadShedAvailability:
            namespaceprefix_ = self.LoadShedAvailability_nsprefix_ + ':' if (UseCapturedNS_ and self.LoadShedAvailability_nsprefix_) else ''
            LoadShedAvailability_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LoadShedAvailability', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(LoadShedAvailabilityList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LoadShedAvailability':
            obj_ = LoadShedAvailability.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LoadShedAvailability.append(obj_)
            obj_.original_tagname_ = 'LoadShedAvailability'
        super(LoadShedAvailabilityList, self)._buildChildren(child_, node, nodeName_, True)
# end class LoadShedAvailabilityList


class FileStatus(Resource):
    """FileStatus -- This object provides status of device file load and activation operations.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    activateTime -- Date/time at which this File, referred to by FileLink, will be activated. Omission of or presence and value of this element MUST exactly match omission or presence and value of the activateTime element from the File resource.
    loadPercent -- This element MUST be set to the percentage of the file, indicated by FileLink, that was loaded during the latest load attempt. This value MUST be reset to 0 each time a load attempt is started for the File indicated by FileLink. This value MUST be increased when an LD receives HTTP response containing file content. This value MUST be set to 100 when the full content of the file has been received by the LD
    nextRequestAttempt -- This element MUST be set to the time at which the LD will issue its next GET request for file content from the File indicated by FileLink
    request503Count -- This value MUST be reset to 0 when FileLink is first pointed at a new File. This value MUST be incremented each time an
    LD receives a 503 error from the FS.
    requestFailCount -- This value MUST be reset to 0 when FileLink is first pointed at a new File. This value MUST be incremented each time a GET request for file content failed. 503 errors MUST be excluded from this counter.
    status -- Current loading status of the file indicated by FileLink. This element MUST be set to one of the following values:
    0 - No load operation in progress
    1 - File load in progress (first request for file content has been issued by LD)
    2 - File load failed
    3 - File loaded successfully (full content of file has been received by the LD), signature verification in progress
    4 - File signature verification failed
    5 - File signature verified, waiting to activate file.
    6 - File activation failed
    7 - File activation in progress
    8 - File activated successfully (this state may not be reached/persisted through an image activation)
    9-255 - Reserved for future use.
    statusTime -- This element MUST be set to the time at which file status transitioned to the value indicated in the status element.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, pollRate='900', activateTime=None, FileLink=None, loadPercent=None, nextRequestAttempt=None, request503Count=None, requestFailCount=None, status=None, statusTime=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FileStatus"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        self.activateTime = activateTime
        self.activateTime_nsprefix_ = None
        self.FileLink = FileLink
        self.FileLink_nsprefix_ = None
        self.loadPercent = loadPercent
        self.validate_UInt8(self.loadPercent)
        self.loadPercent_nsprefix_ = None
        self.nextRequestAttempt = nextRequestAttempt
        self.nextRequestAttempt_nsprefix_ = None
        self.request503Count = request503Count
        self.validate_UInt16(self.request503Count)
        self.request503Count_nsprefix_ = None
        self.requestFailCount = requestFailCount
        self.validate_UInt16(self.requestFailCount)
        self.requestFailCount_nsprefix_ = None
        self.status = status
        self.validate_UInt8(self.status)
        self.status_nsprefix_ = None
        self.statusTime = statusTime
        self.statusTime_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FileStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FileStatus.subclass:
            return FileStatus.subclass(*args_, **kwargs_)
        else:
            return FileStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_activateTime(self):
        return self.activateTime
    def set_activateTime(self, activateTime):
        self.activateTime = activateTime
    def get_FileLink(self):
        return self.FileLink
    def set_FileLink(self, FileLink):
        self.FileLink = FileLink
    def get_loadPercent(self):
        return self.loadPercent
    def set_loadPercent(self, loadPercent):
        self.loadPercent = loadPercent
    def get_nextRequestAttempt(self):
        return self.nextRequestAttempt
    def set_nextRequestAttempt(self, nextRequestAttempt):
        self.nextRequestAttempt = nextRequestAttempt
    def get_request503Count(self):
        return self.request503Count
    def set_request503Count(self, request503Count):
        self.request503Count = request503Count
    def get_requestFailCount(self):
        return self.requestFailCount
    def set_requestFailCount(self, requestFailCount):
        self.requestFailCount = requestFailCount
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def get_statusTime(self):
        return self.statusTime
    def set_statusTime(self, statusTime):
        self.statusTime = statusTime
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.activateTime is not None or
            self.FileLink is not None or
            self.loadPercent is not None or
            self.nextRequestAttempt is not None or
            self.request503Count is not None or
            self.requestFailCount is not None or
            self.status is not None or
            self.statusTime is not None or
            super(FileStatus, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FileStatus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FileStatus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FileStatus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileStatus')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FileStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FileStatus'):
        super(FileStatus, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileStatus')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FileStatus', fromsubclass_=False, pretty_print=True):
        super(FileStatus, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.activateTime is not None:
            namespaceprefix_ = self.activateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.activateTime_nsprefix_) else ''
            self.activateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activateTime', pretty_print=pretty_print)
        if self.FileLink is not None:
            namespaceprefix_ = self.FileLink_nsprefix_ + ':' if (UseCapturedNS_ and self.FileLink_nsprefix_) else ''
            self.FileLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FileLink', pretty_print=pretty_print)
        if self.loadPercent is not None:
            namespaceprefix_ = self.loadPercent_nsprefix_ + ':' if (UseCapturedNS_ and self.loadPercent_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sloadPercent>%s</%sloadPercent>%s' % (namespaceprefix_ , self.gds_format_integer(self.loadPercent, input_name='loadPercent'), namespaceprefix_ , eol_))
        if self.nextRequestAttempt is not None:
            namespaceprefix_ = self.nextRequestAttempt_nsprefix_ + ':' if (UseCapturedNS_ and self.nextRequestAttempt_nsprefix_) else ''
            self.nextRequestAttempt.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nextRequestAttempt', pretty_print=pretty_print)
        if self.request503Count is not None:
            namespaceprefix_ = self.request503Count_nsprefix_ + ':' if (UseCapturedNS_ and self.request503Count_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequest503Count>%s</%srequest503Count>%s' % (namespaceprefix_ , self.gds_format_integer(self.request503Count, input_name='request503Count'), namespaceprefix_ , eol_))
        if self.requestFailCount is not None:
            namespaceprefix_ = self.requestFailCount_nsprefix_ + ':' if (UseCapturedNS_ and self.requestFailCount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srequestFailCount>%s</%srequestFailCount>%s' % (namespaceprefix_ , self.gds_format_integer(self.requestFailCount, input_name='requestFailCount'), namespaceprefix_ , eol_))
        if self.status is not None:
            namespaceprefix_ = self.status_nsprefix_ + ':' if (UseCapturedNS_ and self.status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.status, input_name='status'), namespaceprefix_ , eol_))
        if self.statusTime is not None:
            namespaceprefix_ = self.statusTime_nsprefix_ + ':' if (UseCapturedNS_ and self.statusTime_nsprefix_) else ''
            self.statusTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='statusTime', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(FileStatus, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'activateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activateTime = obj_
            obj_.original_tagname_ = 'activateTime'
        elif nodeName_ == 'FileLink':
            obj_ = FileLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FileLink = obj_
            obj_.original_tagname_ = 'FileLink'
        elif nodeName_ == 'loadPercent' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'loadPercent')
            ival_ = self.gds_validate_integer(ival_, node, 'loadPercent')
            self.loadPercent = ival_
            self.loadPercent_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.loadPercent)
        elif nodeName_ == 'nextRequestAttempt':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nextRequestAttempt = obj_
            obj_.original_tagname_ = 'nextRequestAttempt'
        elif nodeName_ == 'request503Count' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'request503Count')
            ival_ = self.gds_validate_integer(ival_, node, 'request503Count')
            self.request503Count = ival_
            self.request503Count_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.request503Count)
        elif nodeName_ == 'requestFailCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'requestFailCount')
            ival_ = self.gds_validate_integer(ival_, node, 'requestFailCount')
            self.requestFailCount = ival_
            self.requestFailCount_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.requestFailCount)
        elif nodeName_ == 'status' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'status')
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
            self.status_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.status)
        elif nodeName_ == 'statusTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.statusTime = obj_
            obj_.original_tagname_ = 'statusTime'
        super(FileStatus, self)._buildChildren(child_, node, nodeName_, True)
# end class FileStatus


class FileList(List):
    """FileList -- A List element to hold File objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, pollRate='900', File=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FileList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if File is None:
            self.File = []
        else:
            self.File = File
        self.File_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FileList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FileList.subclass:
            return FileList.subclass(*args_, **kwargs_)
        else:
            return FileList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_File(self):
        return self.File
    def set_File(self, File):
        self.File = File
    def add_File(self, value):
        self.File.append(value)
    def insert_File_at(self, index, value):
        self.File.insert(index, value)
    def replace_File_at(self, index, value):
        self.File[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.File or
            super(FileList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FileList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FileList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FileList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FileList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FileList'):
        super(FileList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FileList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FileList', fromsubclass_=False, pretty_print=True):
        super(FileList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for File_ in self.File:
            namespaceprefix_ = self.File_nsprefix_ + ':' if (UseCapturedNS_ and self.File_nsprefix_) else ''
            File_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='File', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(FileList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'File':
            obj_ = File.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.File.append(obj_)
            obj_.original_tagname_ = 'File'
        super(FileList, self)._buildChildren(child_, node, nodeName_, True)
# end class FileList


class File(Resource):
    """File -- This resource contains various meta-data describing a file's characteristics.  The meta-data provides general file information and also is used to support filtered queries of file lists
    activateTime -- This element MUST be set to the date/time at which this file is activated. If the activation time is less than or equal to current time, the LD MUST immediately place the file into the activated state (in the case of a firmware file, the file is now the running image).  If the activation time is greater than the current time, the LD MUST wait until the specified activation time is reached, then MUST place the file into the activated state. Omission of this element means that the LD MUST NOT take any action to activate the file until a subsequent GET to this File resource provides an activateTime.
    fileURI -- This element MUST be set to the URI location of the file binary artifact.  This is the BLOB (binary large object) that is actually loaded by the LD
    lFDI -- This element MUST be set to the LFDI of the device for which this file in targeted.
    mfHwVer -- This element MUST be set to the hardware version for which this file is targeted.
    mfID -- This element MUST be set to the manufacturer's Private Enterprise Number (assigned by IANA).
    mfModel -- This element MUST be set to the manufacturer model number for which this file is targeted. The syntax and semantics are left to the manufacturer.
    mfSerNum -- This element MUST be set to the manufacturer serial number for which this file is targeted. The syntax and semantics are left to the manufacturer.
    mfVer -- This element MUST be set to the software version information for this file. The syntax and semantics are left to the manufacturer.
    size -- This element MUST be set to the total size (in bytes) of the file referenced by fileURI.
    type -- A value indicating the type of the file.  MUST be one of the following values:
    00 = Software Image
    01 = Security Credential
    02 = Configuration
    03 = Log
    04
    
    7FFF = reserved
    8000-FFFF = Manufacturer defined
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, activateTime=None, fileURI=None, lFDI=None, mfHwVer=None, mfID=None, mfModel=None, mfSerNum=None, mfVer=None, size=None, type_=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("File"), self).__init__( **kwargs_)
        self.activateTime = activateTime
        self.activateTime_nsprefix_ = None
        self.fileURI = fileURI
        self.fileURI_nsprefix_ = None
        self.lFDI = lFDI
        self.validate_HexBinary160(self.lFDI)
        self.lFDI_nsprefix_ = None
        self.mfHwVer = mfHwVer
        self.validate_String32(self.mfHwVer)
        self.mfHwVer_nsprefix_ = None
        self.mfID = mfID
        self.mfID_nsprefix_ = None
        self.mfModel = mfModel
        self.validate_String32(self.mfModel)
        self.mfModel_nsprefix_ = None
        self.mfSerNum = mfSerNum
        self.validate_String32(self.mfSerNum)
        self.mfSerNum_nsprefix_ = None
        self.mfVer = mfVer
        self.validate_String16(self.mfVer)
        self.mfVer_nsprefix_ = None
        self.size = size
        self.validate_UInt32(self.size)
        self.size_nsprefix_ = None
        self.type_ = type_
        self.validate_HexBinary16(self.type_)
        self.type__nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, File)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if File.subclass:
            return File.subclass(*args_, **kwargs_)
        else:
            return File(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_activateTime(self):
        return self.activateTime
    def set_activateTime(self, activateTime):
        self.activateTime = activateTime
    def get_fileURI(self):
        return self.fileURI
    def set_fileURI(self, fileURI):
        self.fileURI = fileURI
    def get_lFDI(self):
        return self.lFDI
    def set_lFDI(self, lFDI):
        self.lFDI = lFDI
    def get_mfHwVer(self):
        return self.mfHwVer
    def set_mfHwVer(self, mfHwVer):
        self.mfHwVer = mfHwVer
    def get_mfID(self):
        return self.mfID
    def set_mfID(self, mfID):
        self.mfID = mfID
    def get_mfModel(self):
        return self.mfModel
    def set_mfModel(self, mfModel):
        self.mfModel = mfModel
    def get_mfSerNum(self):
        return self.mfSerNum
    def set_mfSerNum(self, mfSerNum):
        self.mfSerNum = mfSerNum
    def get_mfVer(self):
        return self.mfVer
    def set_mfVer(self, mfVer):
        self.mfVer = mfVer
    def get_size(self):
        return self.size
    def set_size(self, size):
        self.size = size
    def get_type(self):
        return self.type_
    def set_type(self, type_):
        self.type_ = type_
    def validate_HexBinary160(self, value):
        result = True
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary160' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_String16(self, value):
        result = True
        # Validate type String16, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String16' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_HexBinary16(self, value):
        result = True
        # Validate type HexBinary16, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 4:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary16' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.activateTime is not None or
            self.fileURI is not None or
            self.lFDI is not None or
            self.mfHwVer is not None or
            self.mfID is not None or
            self.mfModel is not None or
            self.mfSerNum is not None or
            self.mfVer is not None or
            self.size is not None or
            self.type_ is not None or
            super(File, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='File', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('File')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'File':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='File')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='File', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='File'):
        super(File, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='File')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='File', fromsubclass_=False, pretty_print=True):
        super(File, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.activateTime is not None:
            namespaceprefix_ = self.activateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.activateTime_nsprefix_) else ''
            self.activateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='activateTime', pretty_print=pretty_print)
        if self.fileURI is not None:
            namespaceprefix_ = self.fileURI_nsprefix_ + ':' if (UseCapturedNS_ and self.fileURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfileURI>%s</%sfileURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.fileURI), input_name='fileURI')), namespaceprefix_ , eol_))
        if self.lFDI is not None:
            namespaceprefix_ = self.lFDI_nsprefix_ + ':' if (UseCapturedNS_ and self.lFDI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slFDI>%s</%slFDI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lFDI), input_name='lFDI')), namespaceprefix_ , eol_))
        if self.mfHwVer is not None:
            namespaceprefix_ = self.mfHwVer_nsprefix_ + ':' if (UseCapturedNS_ and self.mfHwVer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfHwVer>%s</%smfHwVer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mfHwVer), input_name='mfHwVer')), namespaceprefix_ , eol_))
        if self.mfID is not None:
            namespaceprefix_ = self.mfID_nsprefix_ + ':' if (UseCapturedNS_ and self.mfID_nsprefix_) else ''
            self.mfID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mfID', pretty_print=pretty_print)
        if self.mfModel is not None:
            namespaceprefix_ = self.mfModel_nsprefix_ + ':' if (UseCapturedNS_ and self.mfModel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfModel>%s</%smfModel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mfModel), input_name='mfModel')), namespaceprefix_ , eol_))
        if self.mfSerNum is not None:
            namespaceprefix_ = self.mfSerNum_nsprefix_ + ':' if (UseCapturedNS_ and self.mfSerNum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfSerNum>%s</%smfSerNum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mfSerNum), input_name='mfSerNum')), namespaceprefix_ , eol_))
        if self.mfVer is not None:
            namespaceprefix_ = self.mfVer_nsprefix_ + ':' if (UseCapturedNS_ and self.mfVer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfVer>%s</%smfVer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mfVer), input_name='mfVer')), namespaceprefix_ , eol_))
        if self.size is not None:
            namespaceprefix_ = self.size_nsprefix_ + ':' if (UseCapturedNS_ and self.size_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssize>%s</%ssize>%s' % (namespaceprefix_ , self.gds_format_integer(self.size, input_name='size'), namespaceprefix_ , eol_))
        if self.type_ is not None:
            namespaceprefix_ = self.type__nsprefix_ + ':' if (UseCapturedNS_ and self.type__nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stype>%s</%stype>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.type_), input_name='type')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(File, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'activateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.activateTime = obj_
            obj_.original_tagname_ = 'activateTime'
        elif nodeName_ == 'fileURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'fileURI')
            value_ = self.gds_validate_string(value_, node, 'fileURI')
            self.fileURI = value_
            self.fileURI_nsprefix_ = child_.prefix
        elif nodeName_ == 'lFDI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lFDI')
            value_ = self.gds_validate_string(value_, node, 'lFDI')
            self.lFDI = value_
            self.lFDI_nsprefix_ = child_.prefix
            # validate type HexBinary160
            self.validate_HexBinary160(self.lFDI)
        elif nodeName_ == 'mfHwVer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mfHwVer')
            value_ = self.gds_validate_string(value_, node, 'mfHwVer')
            self.mfHwVer = value_
            self.mfHwVer_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.mfHwVer)
        elif nodeName_ == 'mfID':
            obj_ = PENType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mfID = obj_
            obj_.original_tagname_ = 'mfID'
        elif nodeName_ == 'mfModel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mfModel')
            value_ = self.gds_validate_string(value_, node, 'mfModel')
            self.mfModel = value_
            self.mfModel_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.mfModel)
        elif nodeName_ == 'mfSerNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mfSerNum')
            value_ = self.gds_validate_string(value_, node, 'mfSerNum')
            self.mfSerNum = value_
            self.mfSerNum_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.mfSerNum)
        elif nodeName_ == 'mfVer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mfVer')
            value_ = self.gds_validate_string(value_, node, 'mfVer')
            self.mfVer = value_
            self.mfVer_nsprefix_ = child_.prefix
            # validate type String16
            self.validate_String16(self.mfVer)
        elif nodeName_ == 'size' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'size')
            ival_ = self.gds_validate_integer(ival_, node, 'size')
            self.size = ival_
            self.size_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.size)
        elif nodeName_ == 'type':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'type')
            value_ = self.gds_validate_string(value_, node, 'type')
            self.type_ = value_
            self.type_nsprefix_ = child_.prefix
            # validate type HexBinary16
            self.validate_HexBinary16(self.type_)
        super(File, self)._buildChildren(child_, node, nodeName_, True)
# end class File


class PriceResponseCfgList(List):
    """PriceResponseCfgList -- A List element to hold PriceResponseCfg objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, PriceResponseCfg=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PriceResponseCfgList"), self).__init__( **kwargs_)
        if PriceResponseCfg is None:
            self.PriceResponseCfg = []
        else:
            self.PriceResponseCfg = PriceResponseCfg
        self.PriceResponseCfg_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PriceResponseCfgList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PriceResponseCfgList.subclass:
            return PriceResponseCfgList.subclass(*args_, **kwargs_)
        else:
            return PriceResponseCfgList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_PriceResponseCfg(self):
        return self.PriceResponseCfg
    def set_PriceResponseCfg(self, PriceResponseCfg):
        self.PriceResponseCfg = PriceResponseCfg
    def add_PriceResponseCfg(self, value):
        self.PriceResponseCfg.append(value)
    def insert_PriceResponseCfg_at(self, index, value):
        self.PriceResponseCfg.insert(index, value)
    def replace_PriceResponseCfg_at(self, index, value):
        self.PriceResponseCfg[index] = value
    def _hasContent(self):
        if (
            self.PriceResponseCfg or
            super(PriceResponseCfgList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PriceResponseCfgList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PriceResponseCfgList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PriceResponseCfgList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PriceResponseCfgList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PriceResponseCfgList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PriceResponseCfgList'):
        super(PriceResponseCfgList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PriceResponseCfgList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PriceResponseCfgList', fromsubclass_=False, pretty_print=True):
        super(PriceResponseCfgList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PriceResponseCfg_ in self.PriceResponseCfg:
            namespaceprefix_ = self.PriceResponseCfg_nsprefix_ + ':' if (UseCapturedNS_ and self.PriceResponseCfg_nsprefix_) else ''
            PriceResponseCfg_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PriceResponseCfg', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PriceResponseCfgList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'PriceResponseCfg':
            obj_ = PriceResponseCfg.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PriceResponseCfg.append(obj_)
            obj_.original_tagname_ = 'PriceResponseCfg'
        super(PriceResponseCfgList, self)._buildChildren(child_, node, nodeName_, True)
# end class PriceResponseCfgList


class PriceResponseCfg(Resource):
    """PriceResponseCfg -- Configuration data that specifies how price responsive devices SHOULD respond to price changes while acting upon a given RateComponent.
    consumeThreshold -- Price responsive clients acting upon the associated RateComponent SHOULD consume the associated commodity while the price is less than this threshold.
    maxReductionThreshold -- Price responsive clients acting upon the associated RateComponent SHOULD reduce consumption to the maximum extent possible while the price is greater than this threshold.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, consumeThreshold=None, maxReductionThreshold=None, RateComponentLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PriceResponseCfg"), self).__init__( **kwargs_)
        self.consumeThreshold = consumeThreshold
        self.validate_Int32(self.consumeThreshold)
        self.consumeThreshold_nsprefix_ = None
        self.maxReductionThreshold = maxReductionThreshold
        self.validate_Int32(self.maxReductionThreshold)
        self.maxReductionThreshold_nsprefix_ = None
        self.RateComponentLink = RateComponentLink
        self.RateComponentLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PriceResponseCfg)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PriceResponseCfg.subclass:
            return PriceResponseCfg.subclass(*args_, **kwargs_)
        else:
            return PriceResponseCfg(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_consumeThreshold(self):
        return self.consumeThreshold
    def set_consumeThreshold(self, consumeThreshold):
        self.consumeThreshold = consumeThreshold
    def get_maxReductionThreshold(self):
        return self.maxReductionThreshold
    def set_maxReductionThreshold(self, maxReductionThreshold):
        self.maxReductionThreshold = maxReductionThreshold
    def get_RateComponentLink(self):
        return self.RateComponentLink
    def set_RateComponentLink(self, RateComponentLink):
        self.RateComponentLink = RateComponentLink
    def validate_Int32(self, value):
        result = True
        # Validate type Int32, a restriction on xs:int.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.consumeThreshold is not None or
            self.maxReductionThreshold is not None or
            self.RateComponentLink is not None or
            super(PriceResponseCfg, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PriceResponseCfg', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PriceResponseCfg')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PriceResponseCfg':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PriceResponseCfg')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PriceResponseCfg', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PriceResponseCfg'):
        super(PriceResponseCfg, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PriceResponseCfg')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PriceResponseCfg', fromsubclass_=False, pretty_print=True):
        super(PriceResponseCfg, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.consumeThreshold is not None:
            namespaceprefix_ = self.consumeThreshold_nsprefix_ + ':' if (UseCapturedNS_ and self.consumeThreshold_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sconsumeThreshold>%s</%sconsumeThreshold>%s' % (namespaceprefix_ , self.gds_format_integer(self.consumeThreshold, input_name='consumeThreshold'), namespaceprefix_ , eol_))
        if self.maxReductionThreshold is not None:
            namespaceprefix_ = self.maxReductionThreshold_nsprefix_ + ':' if (UseCapturedNS_ and self.maxReductionThreshold_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smaxReductionThreshold>%s</%smaxReductionThreshold>%s' % (namespaceprefix_ , self.gds_format_integer(self.maxReductionThreshold, input_name='maxReductionThreshold'), namespaceprefix_ , eol_))
        if self.RateComponentLink is not None:
            namespaceprefix_ = self.RateComponentLink_nsprefix_ + ':' if (UseCapturedNS_ and self.RateComponentLink_nsprefix_) else ''
            self.RateComponentLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RateComponentLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PriceResponseCfg, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'consumeThreshold' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'consumeThreshold')
            ival_ = self.gds_validate_integer(ival_, node, 'consumeThreshold')
            self.consumeThreshold = ival_
            self.consumeThreshold_nsprefix_ = child_.prefix
            # validate type Int32
            self.validate_Int32(self.consumeThreshold)
        elif nodeName_ == 'maxReductionThreshold' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'maxReductionThreshold')
            ival_ = self.gds_validate_integer(ival_, node, 'maxReductionThreshold')
            self.maxReductionThreshold = ival_
            self.maxReductionThreshold_nsprefix_ = child_.prefix
            # validate type Int32
            self.validate_Int32(self.maxReductionThreshold)
        elif nodeName_ == 'RateComponentLink':
            obj_ = RateComponentLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RateComponentLink = obj_
            obj_.original_tagname_ = 'RateComponentLink'
        super(PriceResponseCfg, self)._buildChildren(child_, node, nodeName_, True)
# end class PriceResponseCfg


class Configuration(SubscribableResource):
    """Configuration -- This resource contains various settings to control the operation of the device
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    currentLocale -- [RFC 4646] identifier of the language-region currently in use.
    userDeviceName -- User assigned, convenience name used for network browsing displays, etc.  Example "My Thermostat"
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableResource
    def __init__(self, pollRate='900', currentLocale=None, PowerConfiguration=None, PriceResponseCfgListLink=None, TimeConfiguration=None, userDeviceName=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Configuration"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        self.currentLocale = currentLocale
        self.currentLocale_nsprefix_ = None
        self.PowerConfiguration = PowerConfiguration
        self.PowerConfiguration_nsprefix_ = None
        self.PriceResponseCfgListLink = PriceResponseCfgListLink
        self.PriceResponseCfgListLink_nsprefix_ = None
        self.TimeConfiguration = TimeConfiguration
        self.TimeConfiguration_nsprefix_ = None
        self.userDeviceName = userDeviceName
        self.validate_String32(self.userDeviceName)
        self.userDeviceName_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Configuration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Configuration.subclass:
            return Configuration.subclass(*args_, **kwargs_)
        else:
            return Configuration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currentLocale(self):
        return self.currentLocale
    def set_currentLocale(self, currentLocale):
        self.currentLocale = currentLocale
    def get_PowerConfiguration(self):
        return self.PowerConfiguration
    def set_PowerConfiguration(self, PowerConfiguration):
        self.PowerConfiguration = PowerConfiguration
    def get_PriceResponseCfgListLink(self):
        return self.PriceResponseCfgListLink
    def set_PriceResponseCfgListLink(self, PriceResponseCfgListLink):
        self.PriceResponseCfgListLink = PriceResponseCfgListLink
    def get_TimeConfiguration(self):
        return self.TimeConfiguration
    def set_TimeConfiguration(self, TimeConfiguration):
        self.TimeConfiguration = TimeConfiguration
    def get_userDeviceName(self):
        return self.userDeviceName
    def set_userDeviceName(self, userDeviceName):
        self.userDeviceName = userDeviceName
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.currentLocale is not None or
            self.PowerConfiguration is not None or
            self.PriceResponseCfgListLink is not None or
            self.TimeConfiguration is not None or
            self.userDeviceName is not None or
            super(Configuration, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Configuration', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Configuration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Configuration':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Configuration')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Configuration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Configuration'):
        super(Configuration, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Configuration')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Configuration', fromsubclass_=False, pretty_print=True):
        super(Configuration, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentLocale is not None:
            namespaceprefix_ = self.currentLocale_nsprefix_ + ':' if (UseCapturedNS_ and self.currentLocale_nsprefix_) else ''
            self.currentLocale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='currentLocale', pretty_print=pretty_print)
        if self.PowerConfiguration is not None:
            namespaceprefix_ = self.PowerConfiguration_nsprefix_ + ':' if (UseCapturedNS_ and self.PowerConfiguration_nsprefix_) else ''
            self.PowerConfiguration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PowerConfiguration', pretty_print=pretty_print)
        if self.PriceResponseCfgListLink is not None:
            namespaceprefix_ = self.PriceResponseCfgListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.PriceResponseCfgListLink_nsprefix_) else ''
            self.PriceResponseCfgListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PriceResponseCfgListLink', pretty_print=pretty_print)
        if self.TimeConfiguration is not None:
            namespaceprefix_ = self.TimeConfiguration_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeConfiguration_nsprefix_) else ''
            self.TimeConfiguration.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeConfiguration', pretty_print=pretty_print)
        if self.userDeviceName is not None:
            namespaceprefix_ = self.userDeviceName_nsprefix_ + ':' if (UseCapturedNS_ and self.userDeviceName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%suserDeviceName>%s</%suserDeviceName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.userDeviceName), input_name='userDeviceName')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(Configuration, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currentLocale':
            obj_ = LocaleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currentLocale = obj_
            obj_.original_tagname_ = 'currentLocale'
        elif nodeName_ == 'PowerConfiguration':
            obj_ = PowerConfiguration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PowerConfiguration = obj_
            obj_.original_tagname_ = 'PowerConfiguration'
        elif nodeName_ == 'PriceResponseCfgListLink':
            obj_ = PriceResponseCfgListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PriceResponseCfgListLink = obj_
            obj_.original_tagname_ = 'PriceResponseCfgListLink'
        elif nodeName_ == 'TimeConfiguration':
            obj_ = TimeConfiguration.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeConfiguration = obj_
            obj_.original_tagname_ = 'TimeConfiguration'
        elif nodeName_ == 'userDeviceName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'userDeviceName')
            value_ = self.gds_validate_string(value_, node, 'userDeviceName')
            self.userDeviceName = value_
            self.userDeviceName_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.userDeviceName)
        super(Configuration, self)._buildChildren(child_, node, nodeName_, True)
# end class Configuration


class LogEventList(SubscribableList):
    """LogEventList -- A List element to hold LogEvent objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', LogEvent=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogEventList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if LogEvent is None:
            self.LogEvent = []
        else:
            self.LogEvent = LogEvent
        self.LogEvent_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogEventList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogEventList.subclass:
            return LogEventList.subclass(*args_, **kwargs_)
        else:
            return LogEventList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LogEvent(self):
        return self.LogEvent
    def set_LogEvent(self, LogEvent):
        self.LogEvent = LogEvent
    def add_LogEvent(self, value):
        self.LogEvent.append(value)
    def insert_LogEvent_at(self, index, value):
        self.LogEvent.insert(index, value)
    def replace_LogEvent_at(self, index, value):
        self.LogEvent[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.LogEvent or
            super(LogEventList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LogEventList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LogEventList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LogEventList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LogEventList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LogEventList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LogEventList'):
        super(LogEventList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LogEventList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LogEventList', fromsubclass_=False, pretty_print=True):
        super(LogEventList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LogEvent_ in self.LogEvent:
            namespaceprefix_ = self.LogEvent_nsprefix_ + ':' if (UseCapturedNS_ and self.LogEvent_nsprefix_) else ''
            LogEvent_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LogEvent', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(LogEventList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LogEvent':
            obj_ = LogEvent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogEvent.append(obj_)
            obj_.original_tagname_ = 'LogEvent'
        super(LogEventList, self)._buildChildren(child_, node, nodeName_, True)
# end class LogEventList


class LogEvent(Resource):
    """LogEvent -- A time stamped instance of a significant event detected by the device.
    createdDateTime -- The date and time that the event occurred.
    details -- Human readable text that MAY be used to transmit additional details about the event. A host MAY remove this field when received.
    extendedData -- May be used to transmit additional details about the event.
    functionSet -- If the profileID indicates this is IEEE 2030.5, the functionSet is defined by IEEE 2030.5 and SHALL be one of the values from the table below (IEEE 2030.5 function set identifiers). If the profileID is anything else, the functionSet is defined by the identified profile.
    0	General (not specific to a function set)
    1	Publish and Subscribe
    2	End Device
    3	Function Set Assignment
    4	Response
    5	Demand Response and Load Control
    6	Metering
    7	Pricing
    8	Messaging
    9	Billing
    10	Prepayment
    11	Distributed Energy Resources
    12	Time
    13	Software  Download
    14	Device Information
    15	Power Status
    16	Network Status
    17	Log Event List
    18	Configuration
    19	Security
    All other values are reserved.
    logEventCode -- An 8 bit unsigned integer. logEventCodes are scoped to a profile and a function set. If the profile is IEEE 2030.5, the logEventCode is defined by IEEE 2030.5 within one of the function sets of IEEE 2030.5. If the profile is anything else, the logEventCode is defined by the specified profile.
    logEventID -- This 16-bit value, combined with createdDateTime, profileID, and logEventPEN, should provide a reasonable level of uniqueness.
    logEventPEN -- The Private Enterprise Number(PEN) of the entity that defined the profileID, functionSet, and logEventCode of the logEvent. IEEE 2030.5-assigned logEventCodes SHALL use the IEEE 2030.5 PEN.  Combinations of profileID, functionSet, and logEventCode SHALL have unique meaning within a logEventPEN and are defined by the owner of the PEN.
    profileID -- The profileID identifies which profile (HA, BA, SE, etc) defines the following event information.
    0	Not profile specific.
    1	Vendor Defined
    2	IEEE 2030.5
    3	Home Automation
    4	Building Automation
    All other values are reserved.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, createdDateTime=None, details=None, extendedData=None, functionSet=None, logEventCode=None, logEventID=None, logEventPEN=None, profileID=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LogEvent"), self).__init__( **kwargs_)
        self.createdDateTime = createdDateTime
        self.createdDateTime_nsprefix_ = None
        self.details = details
        self.validate_String32(self.details)
        self.details_nsprefix_ = None
        self.extendedData = extendedData
        self.validate_UInt32(self.extendedData)
        self.extendedData_nsprefix_ = None
        self.functionSet = functionSet
        self.validate_UInt8(self.functionSet)
        self.functionSet_nsprefix_ = None
        self.logEventCode = logEventCode
        self.validate_UInt8(self.logEventCode)
        self.logEventCode_nsprefix_ = None
        self.logEventID = logEventID
        self.validate_UInt16(self.logEventID)
        self.logEventID_nsprefix_ = None
        self.logEventPEN = logEventPEN
        self.logEventPEN_nsprefix_ = None
        self.profileID = profileID
        self.validate_UInt8(self.profileID)
        self.profileID_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LogEvent)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LogEvent.subclass:
            return LogEvent.subclass(*args_, **kwargs_)
        else:
            return LogEvent(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_createdDateTime(self):
        return self.createdDateTime
    def set_createdDateTime(self, createdDateTime):
        self.createdDateTime = createdDateTime
    def get_details(self):
        return self.details
    def set_details(self, details):
        self.details = details
    def get_extendedData(self):
        return self.extendedData
    def set_extendedData(self, extendedData):
        self.extendedData = extendedData
    def get_functionSet(self):
        return self.functionSet
    def set_functionSet(self, functionSet):
        self.functionSet = functionSet
    def get_logEventCode(self):
        return self.logEventCode
    def set_logEventCode(self, logEventCode):
        self.logEventCode = logEventCode
    def get_logEventID(self):
        return self.logEventID
    def set_logEventID(self, logEventID):
        self.logEventID = logEventID
    def get_logEventPEN(self):
        return self.logEventPEN
    def set_logEventPEN(self, logEventPEN):
        self.logEventPEN = logEventPEN
    def get_profileID(self):
        return self.profileID
    def set_profileID(self, profileID):
        self.profileID = profileID
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.createdDateTime is not None or
            self.details is not None or
            self.extendedData is not None or
            self.functionSet is not None or
            self.logEventCode is not None or
            self.logEventID is not None or
            self.logEventPEN is not None or
            self.profileID is not None or
            super(LogEvent, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LogEvent', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LogEvent')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LogEvent':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LogEvent')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LogEvent', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LogEvent'):
        super(LogEvent, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LogEvent')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LogEvent', fromsubclass_=False, pretty_print=True):
        super(LogEvent, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.createdDateTime is not None:
            namespaceprefix_ = self.createdDateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.createdDateTime_nsprefix_) else ''
            self.createdDateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='createdDateTime', pretty_print=pretty_print)
        if self.details is not None:
            namespaceprefix_ = self.details_nsprefix_ + ':' if (UseCapturedNS_ and self.details_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdetails>%s</%sdetails>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.details), input_name='details')), namespaceprefix_ , eol_))
        if self.extendedData is not None:
            namespaceprefix_ = self.extendedData_nsprefix_ + ':' if (UseCapturedNS_ and self.extendedData_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sextendedData>%s</%sextendedData>%s' % (namespaceprefix_ , self.gds_format_integer(self.extendedData, input_name='extendedData'), namespaceprefix_ , eol_))
        if self.functionSet is not None:
            namespaceprefix_ = self.functionSet_nsprefix_ + ':' if (UseCapturedNS_ and self.functionSet_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfunctionSet>%s</%sfunctionSet>%s' % (namespaceprefix_ , self.gds_format_integer(self.functionSet, input_name='functionSet'), namespaceprefix_ , eol_))
        if self.logEventCode is not None:
            namespaceprefix_ = self.logEventCode_nsprefix_ + ':' if (UseCapturedNS_ and self.logEventCode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogEventCode>%s</%slogEventCode>%s' % (namespaceprefix_ , self.gds_format_integer(self.logEventCode, input_name='logEventCode'), namespaceprefix_ , eol_))
        if self.logEventID is not None:
            namespaceprefix_ = self.logEventID_nsprefix_ + ':' if (UseCapturedNS_ and self.logEventID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slogEventID>%s</%slogEventID>%s' % (namespaceprefix_ , self.gds_format_integer(self.logEventID, input_name='logEventID'), namespaceprefix_ , eol_))
        if self.logEventPEN is not None:
            namespaceprefix_ = self.logEventPEN_nsprefix_ + ':' if (UseCapturedNS_ and self.logEventPEN_nsprefix_) else ''
            self.logEventPEN.export(outfile, level, namespaceprefix_, namespacedef_='', name_='logEventPEN', pretty_print=pretty_print)
        if self.profileID is not None:
            namespaceprefix_ = self.profileID_nsprefix_ + ':' if (UseCapturedNS_ and self.profileID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sprofileID>%s</%sprofileID>%s' % (namespaceprefix_ , self.gds_format_integer(self.profileID, input_name='profileID'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LogEvent, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'createdDateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.createdDateTime = obj_
            obj_.original_tagname_ = 'createdDateTime'
        elif nodeName_ == 'details':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'details')
            value_ = self.gds_validate_string(value_, node, 'details')
            self.details = value_
            self.details_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.details)
        elif nodeName_ == 'extendedData' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'extendedData')
            ival_ = self.gds_validate_integer(ival_, node, 'extendedData')
            self.extendedData = ival_
            self.extendedData_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.extendedData)
        elif nodeName_ == 'functionSet' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'functionSet')
            ival_ = self.gds_validate_integer(ival_, node, 'functionSet')
            self.functionSet = ival_
            self.functionSet_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.functionSet)
        elif nodeName_ == 'logEventCode' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'logEventCode')
            ival_ = self.gds_validate_integer(ival_, node, 'logEventCode')
            self.logEventCode = ival_
            self.logEventCode_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.logEventCode)
        elif nodeName_ == 'logEventID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'logEventID')
            ival_ = self.gds_validate_integer(ival_, node, 'logEventID')
            self.logEventID = ival_
            self.logEventID_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.logEventID)
        elif nodeName_ == 'logEventPEN':
            obj_ = PENType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.logEventPEN = obj_
            obj_.original_tagname_ = 'logEventPEN'
        elif nodeName_ == 'profileID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'profileID')
            ival_ = self.gds_validate_integer(ival_, node, 'profileID')
            self.profileID = ival_
            self.profileID_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.profileID)
        super(LogEvent, self)._buildChildren(child_, node, nodeName_, True)
# end class LogEvent


class RPLSourceRoutesList(List):
    """RPLSourceRoutesList -- List or RPL source routes if the hosting device is the DODAGroot
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, RPLSourceRoutes=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RPLSourceRoutesList"), self).__init__( **kwargs_)
        if RPLSourceRoutes is None:
            self.RPLSourceRoutes = []
        else:
            self.RPLSourceRoutes = RPLSourceRoutes
        self.RPLSourceRoutes_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RPLSourceRoutesList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RPLSourceRoutesList.subclass:
            return RPLSourceRoutesList.subclass(*args_, **kwargs_)
        else:
            return RPLSourceRoutesList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RPLSourceRoutes(self):
        return self.RPLSourceRoutes
    def set_RPLSourceRoutes(self, RPLSourceRoutes):
        self.RPLSourceRoutes = RPLSourceRoutes
    def add_RPLSourceRoutes(self, value):
        self.RPLSourceRoutes.append(value)
    def insert_RPLSourceRoutes_at(self, index, value):
        self.RPLSourceRoutes.insert(index, value)
    def replace_RPLSourceRoutes_at(self, index, value):
        self.RPLSourceRoutes[index] = value
    def _hasContent(self):
        if (
            self.RPLSourceRoutes or
            super(RPLSourceRoutesList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RPLSourceRoutesList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RPLSourceRoutesList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RPLSourceRoutesList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLSourceRoutesList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RPLSourceRoutesList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RPLSourceRoutesList'):
        super(RPLSourceRoutesList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLSourceRoutesList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RPLSourceRoutesList', fromsubclass_=False, pretty_print=True):
        super(RPLSourceRoutesList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RPLSourceRoutes_ in self.RPLSourceRoutes:
            namespaceprefix_ = self.RPLSourceRoutes_nsprefix_ + ':' if (UseCapturedNS_ and self.RPLSourceRoutes_nsprefix_) else ''
            RPLSourceRoutes_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RPLSourceRoutes', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RPLSourceRoutesList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RPLSourceRoutes':
            obj_ = RPLSourceRoutes.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RPLSourceRoutes.append(obj_)
            obj_.original_tagname_ = 'RPLSourceRoutes'
        super(RPLSourceRoutesList, self)._buildChildren(child_, node, nodeName_, True)
# end class RPLSourceRoutesList


class RPLSourceRoutes(Resource):
    """RPLSourceRoutes -- A RPL source routes object.
    DestAddress -- See [RFC 6554].
    SourceRoute -- See [RFC 6554].
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, DestAddress=None, SourceRoute=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RPLSourceRoutes"), self).__init__( **kwargs_)
        self.DestAddress = DestAddress
        self.validate_HexBinary128(self.DestAddress)
        self.DestAddress_nsprefix_ = None
        self.SourceRoute = SourceRoute
        self.validate_HexBinary128(self.SourceRoute)
        self.SourceRoute_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RPLSourceRoutes)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RPLSourceRoutes.subclass:
            return RPLSourceRoutes.subclass(*args_, **kwargs_)
        else:
            return RPLSourceRoutes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DestAddress(self):
        return self.DestAddress
    def set_DestAddress(self, DestAddress):
        self.DestAddress = DestAddress
    def get_SourceRoute(self):
        return self.SourceRoute
    def set_SourceRoute(self, SourceRoute):
        self.SourceRoute = SourceRoute
    def validate_HexBinary128(self, value):
        result = True
        # Validate type HexBinary128, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary128' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.DestAddress is not None or
            self.SourceRoute is not None or
            super(RPLSourceRoutes, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RPLSourceRoutes', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RPLSourceRoutes')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RPLSourceRoutes':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLSourceRoutes')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RPLSourceRoutes', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RPLSourceRoutes'):
        super(RPLSourceRoutes, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLSourceRoutes')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RPLSourceRoutes', fromsubclass_=False, pretty_print=True):
        super(RPLSourceRoutes, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DestAddress is not None:
            namespaceprefix_ = self.DestAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.DestAddress_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDestAddress>%s</%sDestAddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.DestAddress), input_name='DestAddress')), namespaceprefix_ , eol_))
        if self.SourceRoute is not None:
            namespaceprefix_ = self.SourceRoute_nsprefix_ + ':' if (UseCapturedNS_ and self.SourceRoute_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSourceRoute>%s</%sSourceRoute>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.SourceRoute), input_name='SourceRoute')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RPLSourceRoutes, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DestAddress':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'DestAddress')
            value_ = self.gds_validate_string(value_, node, 'DestAddress')
            self.DestAddress = value_
            self.DestAddress_nsprefix_ = child_.prefix
            # validate type HexBinary128
            self.validate_HexBinary128(self.DestAddress)
        elif nodeName_ == 'SourceRoute':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'SourceRoute')
            value_ = self.gds_validate_string(value_, node, 'SourceRoute')
            self.SourceRoute = value_
            self.SourceRoute_nsprefix_ = child_.prefix
            # validate type HexBinary128
            self.validate_HexBinary128(self.SourceRoute)
        super(RPLSourceRoutes, self)._buildChildren(child_, node, nodeName_, True)
# end class RPLSourceRoutes


class RPLInstanceList(List):
    """RPLInstanceList -- List of RPLInstances associated with the IPinterface.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, RPLInstance=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RPLInstanceList"), self).__init__( **kwargs_)
        if RPLInstance is None:
            self.RPLInstance = []
        else:
            self.RPLInstance = RPLInstance
        self.RPLInstance_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RPLInstanceList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RPLInstanceList.subclass:
            return RPLInstanceList.subclass(*args_, **kwargs_)
        else:
            return RPLInstanceList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RPLInstance(self):
        return self.RPLInstance
    def set_RPLInstance(self, RPLInstance):
        self.RPLInstance = RPLInstance
    def add_RPLInstance(self, value):
        self.RPLInstance.append(value)
    def insert_RPLInstance_at(self, index, value):
        self.RPLInstance.insert(index, value)
    def replace_RPLInstance_at(self, index, value):
        self.RPLInstance[index] = value
    def _hasContent(self):
        if (
            self.RPLInstance or
            super(RPLInstanceList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RPLInstanceList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RPLInstanceList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RPLInstanceList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLInstanceList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RPLInstanceList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RPLInstanceList'):
        super(RPLInstanceList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLInstanceList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RPLInstanceList', fromsubclass_=False, pretty_print=True):
        super(RPLInstanceList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RPLInstance_ in self.RPLInstance:
            namespaceprefix_ = self.RPLInstance_nsprefix_ + ':' if (UseCapturedNS_ and self.RPLInstance_nsprefix_) else ''
            RPLInstance_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RPLInstance', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RPLInstanceList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RPLInstance':
            obj_ = RPLInstance.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RPLInstance.append(obj_)
            obj_.original_tagname_ = 'RPLInstance'
        super(RPLInstanceList, self)._buildChildren(child_, node, nodeName_, True)
# end class RPLInstanceList


class RPLInstance(Resource):
    """RPLInstance -- Specific RPLInstance resource.  This resource may be thought of as network status information for a specific RPL instance associated with IPInterface.
    DODAGid -- See [RFC 6550].
    DODAGroot -- See [RFC 6550].
    flags -- See [RFC 6550].
    groundedFlag -- See [RFC 6550].
    MOP -- See [RFC 6550].
    PRF -- See [RFC 6550].
    rank -- See [RFC 6550].
    RPLInstanceID -- See [RFC 6550].
    versionNumber -- See [RFC 6550].
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, DODAGid=None, DODAGroot=None, flags=None, groundedFlag=None, MOP=None, PRF=None, rank=None, RPLInstanceID=None, RPLSourceRoutesListLink=None, versionNumber=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("RPLInstance"), self).__init__( **kwargs_)
        self.DODAGid = DODAGid
        self.validate_UInt8(self.DODAGid)
        self.DODAGid_nsprefix_ = None
        self.DODAGroot = DODAGroot
        self.DODAGroot_nsprefix_ = None
        self.flags = flags
        self.validate_UInt8(self.flags)
        self.flags_nsprefix_ = None
        self.groundedFlag = groundedFlag
        self.groundedFlag_nsprefix_ = None
        self.MOP = MOP
        self.validate_UInt8(self.MOP)
        self.MOP_nsprefix_ = None
        self.PRF = PRF
        self.validate_UInt8(self.PRF)
        self.PRF_nsprefix_ = None
        self.rank = rank
        self.validate_UInt16(self.rank)
        self.rank_nsprefix_ = None
        self.RPLInstanceID = RPLInstanceID
        self.validate_UInt8(self.RPLInstanceID)
        self.RPLInstanceID_nsprefix_ = None
        self.RPLSourceRoutesListLink = RPLSourceRoutesListLink
        self.RPLSourceRoutesListLink_nsprefix_ = None
        self.versionNumber = versionNumber
        self.validate_UInt8(self.versionNumber)
        self.versionNumber_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, RPLInstance)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if RPLInstance.subclass:
            return RPLInstance.subclass(*args_, **kwargs_)
        else:
            return RPLInstance(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DODAGid(self):
        return self.DODAGid
    def set_DODAGid(self, DODAGid):
        self.DODAGid = DODAGid
    def get_DODAGroot(self):
        return self.DODAGroot
    def set_DODAGroot(self, DODAGroot):
        self.DODAGroot = DODAGroot
    def get_flags(self):
        return self.flags
    def set_flags(self, flags):
        self.flags = flags
    def get_groundedFlag(self):
        return self.groundedFlag
    def set_groundedFlag(self, groundedFlag):
        self.groundedFlag = groundedFlag
    def get_MOP(self):
        return self.MOP
    def set_MOP(self, MOP):
        self.MOP = MOP
    def get_PRF(self):
        return self.PRF
    def set_PRF(self, PRF):
        self.PRF = PRF
    def get_rank(self):
        return self.rank
    def set_rank(self, rank):
        self.rank = rank
    def get_RPLInstanceID(self):
        return self.RPLInstanceID
    def set_RPLInstanceID(self, RPLInstanceID):
        self.RPLInstanceID = RPLInstanceID
    def get_RPLSourceRoutesListLink(self):
        return self.RPLSourceRoutesListLink
    def set_RPLSourceRoutesListLink(self, RPLSourceRoutesListLink):
        self.RPLSourceRoutesListLink = RPLSourceRoutesListLink
    def get_versionNumber(self):
        return self.versionNumber
    def set_versionNumber(self, versionNumber):
        self.versionNumber = versionNumber
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.DODAGid is not None or
            self.DODAGroot is not None or
            self.flags is not None or
            self.groundedFlag is not None or
            self.MOP is not None or
            self.PRF is not None or
            self.rank is not None or
            self.RPLInstanceID is not None or
            self.RPLSourceRoutesListLink is not None or
            self.versionNumber is not None or
            super(RPLInstance, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RPLInstance', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('RPLInstance')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'RPLInstance':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLInstance')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='RPLInstance', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='RPLInstance'):
        super(RPLInstance, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='RPLInstance')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='RPLInstance', fromsubclass_=False, pretty_print=True):
        super(RPLInstance, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DODAGid is not None:
            namespaceprefix_ = self.DODAGid_nsprefix_ + ':' if (UseCapturedNS_ and self.DODAGid_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDODAGid>%s</%sDODAGid>%s' % (namespaceprefix_ , self.gds_format_integer(self.DODAGid, input_name='DODAGid'), namespaceprefix_ , eol_))
        if self.DODAGroot is not None:
            namespaceprefix_ = self.DODAGroot_nsprefix_ + ':' if (UseCapturedNS_ and self.DODAGroot_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDODAGroot>%s</%sDODAGroot>%s' % (namespaceprefix_ , self.gds_format_boolean(self.DODAGroot, input_name='DODAGroot'), namespaceprefix_ , eol_))
        if self.flags is not None:
            namespaceprefix_ = self.flags_nsprefix_ + ':' if (UseCapturedNS_ and self.flags_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sflags>%s</%sflags>%s' % (namespaceprefix_ , self.gds_format_integer(self.flags, input_name='flags'), namespaceprefix_ , eol_))
        if self.groundedFlag is not None:
            namespaceprefix_ = self.groundedFlag_nsprefix_ + ':' if (UseCapturedNS_ and self.groundedFlag_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sgroundedFlag>%s</%sgroundedFlag>%s' % (namespaceprefix_ , self.gds_format_boolean(self.groundedFlag, input_name='groundedFlag'), namespaceprefix_ , eol_))
        if self.MOP is not None:
            namespaceprefix_ = self.MOP_nsprefix_ + ':' if (UseCapturedNS_ and self.MOP_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMOP>%s</%sMOP>%s' % (namespaceprefix_ , self.gds_format_integer(self.MOP, input_name='MOP'), namespaceprefix_ , eol_))
        if self.PRF is not None:
            namespaceprefix_ = self.PRF_nsprefix_ + ':' if (UseCapturedNS_ and self.PRF_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPRF>%s</%sPRF>%s' % (namespaceprefix_ , self.gds_format_integer(self.PRF, input_name='PRF'), namespaceprefix_ , eol_))
        if self.rank is not None:
            namespaceprefix_ = self.rank_nsprefix_ + ':' if (UseCapturedNS_ and self.rank_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%srank>%s</%srank>%s' % (namespaceprefix_ , self.gds_format_integer(self.rank, input_name='rank'), namespaceprefix_ , eol_))
        if self.RPLInstanceID is not None:
            namespaceprefix_ = self.RPLInstanceID_nsprefix_ + ':' if (UseCapturedNS_ and self.RPLInstanceID_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRPLInstanceID>%s</%sRPLInstanceID>%s' % (namespaceprefix_ , self.gds_format_integer(self.RPLInstanceID, input_name='RPLInstanceID'), namespaceprefix_ , eol_))
        if self.RPLSourceRoutesListLink is not None:
            namespaceprefix_ = self.RPLSourceRoutesListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.RPLSourceRoutesListLink_nsprefix_) else ''
            self.RPLSourceRoutesListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RPLSourceRoutesListLink', pretty_print=pretty_print)
        if self.versionNumber is not None:
            namespaceprefix_ = self.versionNumber_nsprefix_ + ':' if (UseCapturedNS_ and self.versionNumber_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversionNumber>%s</%sversionNumber>%s' % (namespaceprefix_ , self.gds_format_integer(self.versionNumber, input_name='versionNumber'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(RPLInstance, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DODAGid' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'DODAGid')
            ival_ = self.gds_validate_integer(ival_, node, 'DODAGid')
            self.DODAGid = ival_
            self.DODAGid_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.DODAGid)
        elif nodeName_ == 'DODAGroot':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'DODAGroot')
            ival_ = self.gds_validate_boolean(ival_, node, 'DODAGroot')
            self.DODAGroot = ival_
            self.DODAGroot_nsprefix_ = child_.prefix
        elif nodeName_ == 'flags' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'flags')
            ival_ = self.gds_validate_integer(ival_, node, 'flags')
            self.flags = ival_
            self.flags_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.flags)
        elif nodeName_ == 'groundedFlag':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'groundedFlag')
            ival_ = self.gds_validate_boolean(ival_, node, 'groundedFlag')
            self.groundedFlag = ival_
            self.groundedFlag_nsprefix_ = child_.prefix
        elif nodeName_ == 'MOP' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'MOP')
            ival_ = self.gds_validate_integer(ival_, node, 'MOP')
            self.MOP = ival_
            self.MOP_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.MOP)
        elif nodeName_ == 'PRF' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'PRF')
            ival_ = self.gds_validate_integer(ival_, node, 'PRF')
            self.PRF = ival_
            self.PRF_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.PRF)
        elif nodeName_ == 'rank' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'rank')
            ival_ = self.gds_validate_integer(ival_, node, 'rank')
            self.rank = ival_
            self.rank_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.rank)
        elif nodeName_ == 'RPLInstanceID' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'RPLInstanceID')
            ival_ = self.gds_validate_integer(ival_, node, 'RPLInstanceID')
            self.RPLInstanceID = ival_
            self.RPLInstanceID_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.RPLInstanceID)
        elif nodeName_ == 'RPLSourceRoutesListLink':
            obj_ = RPLSourceRoutesListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RPLSourceRoutesListLink = obj_
            obj_.original_tagname_ = 'RPLSourceRoutesListLink'
        elif nodeName_ == 'versionNumber' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'versionNumber')
            ival_ = self.gds_validate_integer(ival_, node, 'versionNumber')
            self.versionNumber = ival_
            self.versionNumber_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.versionNumber)
        super(RPLInstance, self)._buildChildren(child_, node, nodeName_, True)
# end class RPLInstance


class NeighborList(List):
    """NeighborList -- List of 15.4 neighbors.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, Neighbor=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("NeighborList"), self).__init__( **kwargs_)
        if Neighbor is None:
            self.Neighbor = []
        else:
            self.Neighbor = Neighbor
        self.Neighbor_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NeighborList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NeighborList.subclass:
            return NeighborList.subclass(*args_, **kwargs_)
        else:
            return NeighborList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Neighbor(self):
        return self.Neighbor
    def set_Neighbor(self, Neighbor):
        self.Neighbor = Neighbor
    def add_Neighbor(self, value):
        self.Neighbor.append(value)
    def insert_Neighbor_at(self, index, value):
        self.Neighbor.insert(index, value)
    def replace_Neighbor_at(self, index, value):
        self.Neighbor[index] = value
    def _hasContent(self):
        if (
            self.Neighbor or
            super(NeighborList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='NeighborList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NeighborList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NeighborList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeighborList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NeighborList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NeighborList'):
        super(NeighborList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NeighborList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='NeighborList', fromsubclass_=False, pretty_print=True):
        super(NeighborList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Neighbor_ in self.Neighbor:
            namespaceprefix_ = self.Neighbor_nsprefix_ + ':' if (UseCapturedNS_ and self.Neighbor_nsprefix_) else ''
            Neighbor_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Neighbor', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(NeighborList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Neighbor':
            obj_ = Neighbor.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Neighbor.append(obj_)
            obj_.original_tagname_ = 'Neighbor'
        super(NeighborList, self)._buildChildren(child_, node, nodeName_, True)
# end class NeighborList


class Neighbor(Resource):
    """Neighbor -- Contains 802.15.4 link layer specific attributes.
    isChild -- True if the neighbor is a child.
    linkQuality -- The quality of the link, as defined by 802.15.4
    shortAddress -- As defined by IEEE 802.15.4
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, isChild=None, linkQuality=None, shortAddress=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Neighbor"), self).__init__( **kwargs_)
        self.isChild = isChild
        self.isChild_nsprefix_ = None
        self.linkQuality = linkQuality
        self.validate_UInt8(self.linkQuality)
        self.linkQuality_nsprefix_ = None
        self.shortAddress = shortAddress
        self.validate_UInt16(self.shortAddress)
        self.shortAddress_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Neighbor)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Neighbor.subclass:
            return Neighbor.subclass(*args_, **kwargs_)
        else:
            return Neighbor(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_isChild(self):
        return self.isChild
    def set_isChild(self, isChild):
        self.isChild = isChild
    def get_linkQuality(self):
        return self.linkQuality
    def set_linkQuality(self, linkQuality):
        self.linkQuality = linkQuality
    def get_shortAddress(self):
        return self.shortAddress
    def set_shortAddress(self, shortAddress):
        self.shortAddress = shortAddress
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.isChild is not None or
            self.linkQuality is not None or
            self.shortAddress is not None or
            super(Neighbor, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Neighbor', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Neighbor')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Neighbor':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Neighbor')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Neighbor', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Neighbor'):
        super(Neighbor, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Neighbor')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Neighbor', fromsubclass_=False, pretty_print=True):
        super(Neighbor, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.isChild is not None:
            namespaceprefix_ = self.isChild_nsprefix_ + ':' if (UseCapturedNS_ and self.isChild_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sisChild>%s</%sisChild>%s' % (namespaceprefix_ , self.gds_format_boolean(self.isChild, input_name='isChild'), namespaceprefix_ , eol_))
        if self.linkQuality is not None:
            namespaceprefix_ = self.linkQuality_nsprefix_ + ':' if (UseCapturedNS_ and self.linkQuality_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slinkQuality>%s</%slinkQuality>%s' % (namespaceprefix_ , self.gds_format_integer(self.linkQuality, input_name='linkQuality'), namespaceprefix_ , eol_))
        if self.shortAddress is not None:
            namespaceprefix_ = self.shortAddress_nsprefix_ + ':' if (UseCapturedNS_ and self.shortAddress_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sshortAddress>%s</%sshortAddress>%s' % (namespaceprefix_ , self.gds_format_integer(self.shortAddress, input_name='shortAddress'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Neighbor, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'isChild':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'isChild')
            ival_ = self.gds_validate_boolean(ival_, node, 'isChild')
            self.isChild = ival_
            self.isChild_nsprefix_ = child_.prefix
        elif nodeName_ == 'linkQuality' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'linkQuality')
            ival_ = self.gds_validate_integer(ival_, node, 'linkQuality')
            self.linkQuality = ival_
            self.linkQuality_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.linkQuality)
        elif nodeName_ == 'shortAddress' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'shortAddress')
            ival_ = self.gds_validate_integer(ival_, node, 'shortAddress')
            self.shortAddress = ival_
            self.shortAddress_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.shortAddress)
        super(Neighbor, self)._buildChildren(child_, node, nodeName_, True)
# end class Neighbor


class LLInterfaceList(List):
    """LLInterfaceList -- List of LLInterface instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, LLInterface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LLInterfaceList"), self).__init__( **kwargs_)
        if LLInterface is None:
            self.LLInterface = []
        else:
            self.LLInterface = LLInterface
        self.LLInterface_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LLInterfaceList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LLInterfaceList.subclass:
            return LLInterfaceList.subclass(*args_, **kwargs_)
        else:
            return LLInterfaceList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_LLInterface(self):
        return self.LLInterface
    def set_LLInterface(self, LLInterface):
        self.LLInterface = LLInterface
    def add_LLInterface(self, value):
        self.LLInterface.append(value)
    def insert_LLInterface_at(self, index, value):
        self.LLInterface.insert(index, value)
    def replace_LLInterface_at(self, index, value):
        self.LLInterface[index] = value
    def _hasContent(self):
        if (
            self.LLInterface or
            super(LLInterfaceList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LLInterfaceList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LLInterfaceList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LLInterfaceList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LLInterfaceList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LLInterfaceList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LLInterfaceList'):
        super(LLInterfaceList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LLInterfaceList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LLInterfaceList', fromsubclass_=False, pretty_print=True):
        super(LLInterfaceList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LLInterface_ in self.LLInterface:
            namespaceprefix_ = self.LLInterface_nsprefix_ + ':' if (UseCapturedNS_ and self.LLInterface_nsprefix_) else ''
            LLInterface_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LLInterface', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LLInterfaceList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'LLInterface':
            obj_ = LLInterface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LLInterface.append(obj_)
            obj_.original_tagname_ = 'LLInterface'
        super(LLInterfaceList, self)._buildChildren(child_, node, nodeName_, True)
# end class LLInterfaceList


class LLInterface(Resource):
    """LLInterface -- A link-layer interface object.
    CRCerrors -- Contains the number of CRC errors since reset.
    EUI64 -- Contains the EUI-64 of the link layer interface. 48 bit MAC addresses SHALL be changed into an EUI-64 using the method defined in [RFC 4291], Appendix A. (The method is to insert "0xFFFE" as described in the reference.)
    linkLayerType -- Specifies the type of link layer interface associated with the IPInterface. Values are below.
    0 = Unspecified
    1 = IEEE 802.3 (Ethernet)
    2 = IEEE 802.11 (WLAN)
    3 = IEEE 802.15 (PAN)
    4 = IEEE 1901 (PLC)
    All other values reserved.
    LLAckNotRx -- Number of times an ACK was not received for a frame transmitted (when ACK was requested).
    LLCSMAFail -- Number of times CSMA failed.
    LLFramesDropRx -- Number of dropped receive frames.
    LLFramesDropTx -- Number of dropped transmit frames.
    LLFramesRx -- Number of link layer frames received.
    LLFramesTx -- Number of link layer frames transmitted.
    LLMediaAccessFail -- Number of times access to media failed.
    LLOctetsRx -- Number of Bytes received.
    LLOctetsTx -- Number of Bytes transmitted.
    LLRetryCount -- Number of MAC transmit retries.
    LLSecurityErrorRx -- Number of receive security errors.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, CRCerrors=None, EUI64=None, IEEE_802_15_4=None, linkLayerType=None, LLAckNotRx=None, LLCSMAFail=None, LLFramesDropRx=None, LLFramesDropTx=None, LLFramesRx=None, LLFramesTx=None, LLMediaAccessFail=None, LLOctetsRx=None, LLOctetsTx=None, LLRetryCount=None, LLSecurityErrorRx=None, loWPAN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("LLInterface"), self).__init__( **kwargs_)
        self.CRCerrors = CRCerrors
        self.validate_UInt32(self.CRCerrors)
        self.CRCerrors_nsprefix_ = None
        self.EUI64 = EUI64
        self.validate_HexBinary64(self.EUI64)
        self.EUI64_nsprefix_ = None
        self.IEEE_802_15_4 = IEEE_802_15_4
        self.IEEE_802_15_4_nsprefix_ = None
        self.linkLayerType = linkLayerType
        self.validate_UInt8(self.linkLayerType)
        self.linkLayerType_nsprefix_ = None
        self.LLAckNotRx = LLAckNotRx
        self.validate_UInt32(self.LLAckNotRx)
        self.LLAckNotRx_nsprefix_ = None
        self.LLCSMAFail = LLCSMAFail
        self.validate_UInt32(self.LLCSMAFail)
        self.LLCSMAFail_nsprefix_ = None
        self.LLFramesDropRx = LLFramesDropRx
        self.validate_UInt32(self.LLFramesDropRx)
        self.LLFramesDropRx_nsprefix_ = None
        self.LLFramesDropTx = LLFramesDropTx
        self.validate_UInt32(self.LLFramesDropTx)
        self.LLFramesDropTx_nsprefix_ = None
        self.LLFramesRx = LLFramesRx
        self.validate_UInt32(self.LLFramesRx)
        self.LLFramesRx_nsprefix_ = None
        self.LLFramesTx = LLFramesTx
        self.validate_UInt32(self.LLFramesTx)
        self.LLFramesTx_nsprefix_ = None
        self.LLMediaAccessFail = LLMediaAccessFail
        self.validate_UInt32(self.LLMediaAccessFail)
        self.LLMediaAccessFail_nsprefix_ = None
        self.LLOctetsRx = LLOctetsRx
        self.validate_UInt32(self.LLOctetsRx)
        self.LLOctetsRx_nsprefix_ = None
        self.LLOctetsTx = LLOctetsTx
        self.validate_UInt32(self.LLOctetsTx)
        self.LLOctetsTx_nsprefix_ = None
        self.LLRetryCount = LLRetryCount
        self.validate_UInt32(self.LLRetryCount)
        self.LLRetryCount_nsprefix_ = None
        self.LLSecurityErrorRx = LLSecurityErrorRx
        self.validate_UInt32(self.LLSecurityErrorRx)
        self.LLSecurityErrorRx_nsprefix_ = None
        self.loWPAN = loWPAN
        self.loWPAN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, LLInterface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if LLInterface.subclass:
            return LLInterface.subclass(*args_, **kwargs_)
        else:
            return LLInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CRCerrors(self):
        return self.CRCerrors
    def set_CRCerrors(self, CRCerrors):
        self.CRCerrors = CRCerrors
    def get_EUI64(self):
        return self.EUI64
    def set_EUI64(self, EUI64):
        self.EUI64 = EUI64
    def get_IEEE_802_15_4(self):
        return self.IEEE_802_15_4
    def set_IEEE_802_15_4(self, IEEE_802_15_4):
        self.IEEE_802_15_4 = IEEE_802_15_4
    def get_linkLayerType(self):
        return self.linkLayerType
    def set_linkLayerType(self, linkLayerType):
        self.linkLayerType = linkLayerType
    def get_LLAckNotRx(self):
        return self.LLAckNotRx
    def set_LLAckNotRx(self, LLAckNotRx):
        self.LLAckNotRx = LLAckNotRx
    def get_LLCSMAFail(self):
        return self.LLCSMAFail
    def set_LLCSMAFail(self, LLCSMAFail):
        self.LLCSMAFail = LLCSMAFail
    def get_LLFramesDropRx(self):
        return self.LLFramesDropRx
    def set_LLFramesDropRx(self, LLFramesDropRx):
        self.LLFramesDropRx = LLFramesDropRx
    def get_LLFramesDropTx(self):
        return self.LLFramesDropTx
    def set_LLFramesDropTx(self, LLFramesDropTx):
        self.LLFramesDropTx = LLFramesDropTx
    def get_LLFramesRx(self):
        return self.LLFramesRx
    def set_LLFramesRx(self, LLFramesRx):
        self.LLFramesRx = LLFramesRx
    def get_LLFramesTx(self):
        return self.LLFramesTx
    def set_LLFramesTx(self, LLFramesTx):
        self.LLFramesTx = LLFramesTx
    def get_LLMediaAccessFail(self):
        return self.LLMediaAccessFail
    def set_LLMediaAccessFail(self, LLMediaAccessFail):
        self.LLMediaAccessFail = LLMediaAccessFail
    def get_LLOctetsRx(self):
        return self.LLOctetsRx
    def set_LLOctetsRx(self, LLOctetsRx):
        self.LLOctetsRx = LLOctetsRx
    def get_LLOctetsTx(self):
        return self.LLOctetsTx
    def set_LLOctetsTx(self, LLOctetsTx):
        self.LLOctetsTx = LLOctetsTx
    def get_LLRetryCount(self):
        return self.LLRetryCount
    def set_LLRetryCount(self, LLRetryCount):
        self.LLRetryCount = LLRetryCount
    def get_LLSecurityErrorRx(self):
        return self.LLSecurityErrorRx
    def set_LLSecurityErrorRx(self, LLSecurityErrorRx):
        self.LLSecurityErrorRx = LLSecurityErrorRx
    def get_loWPAN(self):
        return self.loWPAN
    def set_loWPAN(self, loWPAN):
        self.loWPAN = loWPAN
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_HexBinary64(self, value):
        result = True
        # Validate type HexBinary64, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary64' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.CRCerrors is not None or
            self.EUI64 is not None or
            self.IEEE_802_15_4 is not None or
            self.linkLayerType is not None or
            self.LLAckNotRx is not None or
            self.LLCSMAFail is not None or
            self.LLFramesDropRx is not None or
            self.LLFramesDropTx is not None or
            self.LLFramesRx is not None or
            self.LLFramesTx is not None or
            self.LLMediaAccessFail is not None or
            self.LLOctetsRx is not None or
            self.LLOctetsTx is not None or
            self.LLRetryCount is not None or
            self.LLSecurityErrorRx is not None or
            self.loWPAN is not None or
            super(LLInterface, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LLInterface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('LLInterface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'LLInterface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LLInterface')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='LLInterface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='LLInterface'):
        super(LLInterface, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='LLInterface')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='LLInterface', fromsubclass_=False, pretty_print=True):
        super(LLInterface, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CRCerrors is not None:
            namespaceprefix_ = self.CRCerrors_nsprefix_ + ':' if (UseCapturedNS_ and self.CRCerrors_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCRCerrors>%s</%sCRCerrors>%s' % (namespaceprefix_ , self.gds_format_integer(self.CRCerrors, input_name='CRCerrors'), namespaceprefix_ , eol_))
        if self.EUI64 is not None:
            namespaceprefix_ = self.EUI64_nsprefix_ + ':' if (UseCapturedNS_ and self.EUI64_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEUI64>%s</%sEUI64>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.EUI64), input_name='EUI64')), namespaceprefix_ , eol_))
        if self.IEEE_802_15_4 is not None:
            namespaceprefix_ = self.IEEE_802_15_4_nsprefix_ + ':' if (UseCapturedNS_ and self.IEEE_802_15_4_nsprefix_) else ''
            self.IEEE_802_15_4.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IEEE_802_15_4', pretty_print=pretty_print)
        if self.linkLayerType is not None:
            namespaceprefix_ = self.linkLayerType_nsprefix_ + ':' if (UseCapturedNS_ and self.linkLayerType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slinkLayerType>%s</%slinkLayerType>%s' % (namespaceprefix_ , self.gds_format_integer(self.linkLayerType, input_name='linkLayerType'), namespaceprefix_ , eol_))
        if self.LLAckNotRx is not None:
            namespaceprefix_ = self.LLAckNotRx_nsprefix_ + ':' if (UseCapturedNS_ and self.LLAckNotRx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLAckNotRx>%s</%sLLAckNotRx>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLAckNotRx, input_name='LLAckNotRx'), namespaceprefix_ , eol_))
        if self.LLCSMAFail is not None:
            namespaceprefix_ = self.LLCSMAFail_nsprefix_ + ':' if (UseCapturedNS_ and self.LLCSMAFail_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLCSMAFail>%s</%sLLCSMAFail>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLCSMAFail, input_name='LLCSMAFail'), namespaceprefix_ , eol_))
        if self.LLFramesDropRx is not None:
            namespaceprefix_ = self.LLFramesDropRx_nsprefix_ + ':' if (UseCapturedNS_ and self.LLFramesDropRx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLFramesDropRx>%s</%sLLFramesDropRx>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLFramesDropRx, input_name='LLFramesDropRx'), namespaceprefix_ , eol_))
        if self.LLFramesDropTx is not None:
            namespaceprefix_ = self.LLFramesDropTx_nsprefix_ + ':' if (UseCapturedNS_ and self.LLFramesDropTx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLFramesDropTx>%s</%sLLFramesDropTx>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLFramesDropTx, input_name='LLFramesDropTx'), namespaceprefix_ , eol_))
        if self.LLFramesRx is not None:
            namespaceprefix_ = self.LLFramesRx_nsprefix_ + ':' if (UseCapturedNS_ and self.LLFramesRx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLFramesRx>%s</%sLLFramesRx>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLFramesRx, input_name='LLFramesRx'), namespaceprefix_ , eol_))
        if self.LLFramesTx is not None:
            namespaceprefix_ = self.LLFramesTx_nsprefix_ + ':' if (UseCapturedNS_ and self.LLFramesTx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLFramesTx>%s</%sLLFramesTx>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLFramesTx, input_name='LLFramesTx'), namespaceprefix_ , eol_))
        if self.LLMediaAccessFail is not None:
            namespaceprefix_ = self.LLMediaAccessFail_nsprefix_ + ':' if (UseCapturedNS_ and self.LLMediaAccessFail_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLMediaAccessFail>%s</%sLLMediaAccessFail>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLMediaAccessFail, input_name='LLMediaAccessFail'), namespaceprefix_ , eol_))
        if self.LLOctetsRx is not None:
            namespaceprefix_ = self.LLOctetsRx_nsprefix_ + ':' if (UseCapturedNS_ and self.LLOctetsRx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLOctetsRx>%s</%sLLOctetsRx>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLOctetsRx, input_name='LLOctetsRx'), namespaceprefix_ , eol_))
        if self.LLOctetsTx is not None:
            namespaceprefix_ = self.LLOctetsTx_nsprefix_ + ':' if (UseCapturedNS_ and self.LLOctetsTx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLOctetsTx>%s</%sLLOctetsTx>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLOctetsTx, input_name='LLOctetsTx'), namespaceprefix_ , eol_))
        if self.LLRetryCount is not None:
            namespaceprefix_ = self.LLRetryCount_nsprefix_ + ':' if (UseCapturedNS_ and self.LLRetryCount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLRetryCount>%s</%sLLRetryCount>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLRetryCount, input_name='LLRetryCount'), namespaceprefix_ , eol_))
        if self.LLSecurityErrorRx is not None:
            namespaceprefix_ = self.LLSecurityErrorRx_nsprefix_ + ':' if (UseCapturedNS_ and self.LLSecurityErrorRx_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLLSecurityErrorRx>%s</%sLLSecurityErrorRx>%s' % (namespaceprefix_ , self.gds_format_integer(self.LLSecurityErrorRx, input_name='LLSecurityErrorRx'), namespaceprefix_ , eol_))
        if self.loWPAN is not None:
            namespaceprefix_ = self.loWPAN_nsprefix_ + ':' if (UseCapturedNS_ and self.loWPAN_nsprefix_) else ''
            self.loWPAN.export(outfile, level, namespaceprefix_, namespacedef_='', name_='loWPAN', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(LLInterface, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CRCerrors' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'CRCerrors')
            ival_ = self.gds_validate_integer(ival_, node, 'CRCerrors')
            self.CRCerrors = ival_
            self.CRCerrors_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.CRCerrors)
        elif nodeName_ == 'EUI64':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'EUI64')
            value_ = self.gds_validate_string(value_, node, 'EUI64')
            self.EUI64 = value_
            self.EUI64_nsprefix_ = child_.prefix
            # validate type HexBinary64
            self.validate_HexBinary64(self.EUI64)
        elif nodeName_ == 'IEEE_802_15_4':
            obj_ = IEEE_802_15_4.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IEEE_802_15_4 = obj_
            obj_.original_tagname_ = 'IEEE_802_15_4'
        elif nodeName_ == 'linkLayerType' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'linkLayerType')
            ival_ = self.gds_validate_integer(ival_, node, 'linkLayerType')
            self.linkLayerType = ival_
            self.linkLayerType_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.linkLayerType)
        elif nodeName_ == 'LLAckNotRx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLAckNotRx')
            ival_ = self.gds_validate_integer(ival_, node, 'LLAckNotRx')
            self.LLAckNotRx = ival_
            self.LLAckNotRx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLAckNotRx)
        elif nodeName_ == 'LLCSMAFail' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLCSMAFail')
            ival_ = self.gds_validate_integer(ival_, node, 'LLCSMAFail')
            self.LLCSMAFail = ival_
            self.LLCSMAFail_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLCSMAFail)
        elif nodeName_ == 'LLFramesDropRx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLFramesDropRx')
            ival_ = self.gds_validate_integer(ival_, node, 'LLFramesDropRx')
            self.LLFramesDropRx = ival_
            self.LLFramesDropRx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLFramesDropRx)
        elif nodeName_ == 'LLFramesDropTx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLFramesDropTx')
            ival_ = self.gds_validate_integer(ival_, node, 'LLFramesDropTx')
            self.LLFramesDropTx = ival_
            self.LLFramesDropTx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLFramesDropTx)
        elif nodeName_ == 'LLFramesRx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLFramesRx')
            ival_ = self.gds_validate_integer(ival_, node, 'LLFramesRx')
            self.LLFramesRx = ival_
            self.LLFramesRx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLFramesRx)
        elif nodeName_ == 'LLFramesTx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLFramesTx')
            ival_ = self.gds_validate_integer(ival_, node, 'LLFramesTx')
            self.LLFramesTx = ival_
            self.LLFramesTx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLFramesTx)
        elif nodeName_ == 'LLMediaAccessFail' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLMediaAccessFail')
            ival_ = self.gds_validate_integer(ival_, node, 'LLMediaAccessFail')
            self.LLMediaAccessFail = ival_
            self.LLMediaAccessFail_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLMediaAccessFail)
        elif nodeName_ == 'LLOctetsRx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLOctetsRx')
            ival_ = self.gds_validate_integer(ival_, node, 'LLOctetsRx')
            self.LLOctetsRx = ival_
            self.LLOctetsRx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLOctetsRx)
        elif nodeName_ == 'LLOctetsTx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLOctetsTx')
            ival_ = self.gds_validate_integer(ival_, node, 'LLOctetsTx')
            self.LLOctetsTx = ival_
            self.LLOctetsTx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLOctetsTx)
        elif nodeName_ == 'LLRetryCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLRetryCount')
            ival_ = self.gds_validate_integer(ival_, node, 'LLRetryCount')
            self.LLRetryCount = ival_
            self.LLRetryCount_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLRetryCount)
        elif nodeName_ == 'LLSecurityErrorRx' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'LLSecurityErrorRx')
            ival_ = self.gds_validate_integer(ival_, node, 'LLSecurityErrorRx')
            self.LLSecurityErrorRx = ival_
            self.LLSecurityErrorRx_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.LLSecurityErrorRx)
        elif nodeName_ == 'loWPAN':
            obj_ = loWPAN.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.loWPAN = obj_
            obj_.original_tagname_ = 'loWPAN'
        super(LLInterface, self)._buildChildren(child_, node, nodeName_, True)
# end class LLInterface


class IPInterfaceList(List):
    """IPInterfaceList -- List of IPInterface instances.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, pollRate='900', IPInterface=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IPInterfaceList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if IPInterface is None:
            self.IPInterface = []
        else:
            self.IPInterface = IPInterface
        self.IPInterface_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPInterfaceList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPInterfaceList.subclass:
            return IPInterfaceList.subclass(*args_, **kwargs_)
        else:
            return IPInterfaceList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IPInterface(self):
        return self.IPInterface
    def set_IPInterface(self, IPInterface):
        self.IPInterface = IPInterface
    def add_IPInterface(self, value):
        self.IPInterface.append(value)
    def insert_IPInterface_at(self, index, value):
        self.IPInterface.insert(index, value)
    def replace_IPInterface_at(self, index, value):
        self.IPInterface[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.IPInterface or
            super(IPInterfaceList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IPInterfaceList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPInterfaceList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IPInterfaceList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPInterfaceList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPInterfaceList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPInterfaceList'):
        super(IPInterfaceList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPInterfaceList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IPInterfaceList', fromsubclass_=False, pretty_print=True):
        super(IPInterfaceList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IPInterface_ in self.IPInterface:
            namespaceprefix_ = self.IPInterface_nsprefix_ + ':' if (UseCapturedNS_ and self.IPInterface_nsprefix_) else ''
            IPInterface_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IPInterface', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(IPInterfaceList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IPInterface':
            obj_ = IPInterface.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IPInterface.append(obj_)
            obj_.original_tagname_ = 'IPInterface'
        super(IPInterfaceList, self)._buildChildren(child_, node, nodeName_, True)
# end class IPInterfaceList


class IPInterface(Resource):
    """IPInterface -- Specific IPInterface resource.  This resource may be thought of as network status information for a specific network (IP) layer interface.
    ifDescr -- Use rules from [RFC 2863].
    ifHighSpeed -- Use rules from [RFC 2863].
    ifInBroadcastPkts -- Use rules from [RFC 2863].
    ifIndex -- Use rules from [RFC 2863].
    ifInDiscards -- Use rules from [RFC 2863]. Can be thought of as Input Datagrams Discarded.
    ifInErrors -- Use rules from [RFC 2863].
    ifInMulticastPkts -- Use rules from [RFC 2863]. Can be thought of as Multicast Datagrams Received.
    ifInOctets -- Use rules from [RFC 2863]. Can be thought of as Bytes Received.
    ifInUcastPkts -- Use rules from [RFC 2863]. Can be thought of as Datagrams Received.
    ifInUnknownProtos -- Use rules from [RFC 2863]. Can be thought of as Datagrams with Unknown Protocol Received.
    ifMtu -- Use rules from [RFC 2863].
    ifName -- Use rules from [RFC 2863].
    ifOperStatus -- Use rules and assignments from [RFC 2863].
    ifOutBroadcastPkts -- Use rules from [RFC 2863]. Can be thought of as Broadcast Datagrams Sent.
    ifOutDiscards -- Use rules from [RFC 2863]. Can be thought of as Output Datagrams Discarded.
    ifOutErrors -- Use rules from [RFC 2863].
    ifOutMulticastPkts -- Use rules from [RFC 2863]. Can be thought of as Multicast Datagrams Sent.
    ifOutOctets -- Use rules from [RFC 2863]. Can be thought of as Bytes Sent.
    ifOutUcastPkts -- Use rules from [RFC 2863]. Can be thought of as Datagrams Sent.
    ifPromiscuousMode -- Use rules from [RFC 2863].
    ifSpeed -- Use rules from [RFC 2863].
    ifType -- Use rules and assignments from [RFC 2863].
    lastResetTime -- Similar to ifLastChange in [RFC 2863].
    lastUpdatedTime -- The date/time of the reported status.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, ifDescr=None, ifHighSpeed=None, ifInBroadcastPkts=None, ifIndex=None, ifInDiscards=None, ifInErrors=None, ifInMulticastPkts=None, ifInOctets=None, ifInUcastPkts=None, ifInUnknownProtos=None, ifMtu=None, ifName=None, ifOperStatus=None, ifOutBroadcastPkts=None, ifOutDiscards=None, ifOutErrors=None, ifOutMulticastPkts=None, ifOutOctets=None, ifOutUcastPkts=None, ifPromiscuousMode=None, ifSpeed=None, ifType=None, IPAddrListLink=None, lastResetTime=None, lastUpdatedTime=None, LLInterfaceListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IPInterface"), self).__init__( **kwargs_)
        self.ifDescr = ifDescr
        self.validate_String192(self.ifDescr)
        self.ifDescr_nsprefix_ = None
        self.ifHighSpeed = ifHighSpeed
        self.validate_UInt32(self.ifHighSpeed)
        self.ifHighSpeed_nsprefix_ = None
        self.ifInBroadcastPkts = ifInBroadcastPkts
        self.validate_UInt32(self.ifInBroadcastPkts)
        self.ifInBroadcastPkts_nsprefix_ = None
        self.ifIndex = ifIndex
        self.validate_UInt32(self.ifIndex)
        self.ifIndex_nsprefix_ = None
        self.ifInDiscards = ifInDiscards
        self.validate_UInt32(self.ifInDiscards)
        self.ifInDiscards_nsprefix_ = None
        self.ifInErrors = ifInErrors
        self.validate_UInt32(self.ifInErrors)
        self.ifInErrors_nsprefix_ = None
        self.ifInMulticastPkts = ifInMulticastPkts
        self.validate_UInt32(self.ifInMulticastPkts)
        self.ifInMulticastPkts_nsprefix_ = None
        self.ifInOctets = ifInOctets
        self.validate_UInt32(self.ifInOctets)
        self.ifInOctets_nsprefix_ = None
        self.ifInUcastPkts = ifInUcastPkts
        self.validate_UInt32(self.ifInUcastPkts)
        self.ifInUcastPkts_nsprefix_ = None
        self.ifInUnknownProtos = ifInUnknownProtos
        self.validate_UInt32(self.ifInUnknownProtos)
        self.ifInUnknownProtos_nsprefix_ = None
        self.ifMtu = ifMtu
        self.validate_UInt32(self.ifMtu)
        self.ifMtu_nsprefix_ = None
        self.ifName = ifName
        self.validate_String16(self.ifName)
        self.ifName_nsprefix_ = None
        self.ifOperStatus = ifOperStatus
        self.validate_UInt8(self.ifOperStatus)
        self.ifOperStatus_nsprefix_ = None
        self.ifOutBroadcastPkts = ifOutBroadcastPkts
        self.validate_UInt32(self.ifOutBroadcastPkts)
        self.ifOutBroadcastPkts_nsprefix_ = None
        self.ifOutDiscards = ifOutDiscards
        self.validate_UInt32(self.ifOutDiscards)
        self.ifOutDiscards_nsprefix_ = None
        self.ifOutErrors = ifOutErrors
        self.validate_UInt32(self.ifOutErrors)
        self.ifOutErrors_nsprefix_ = None
        self.ifOutMulticastPkts = ifOutMulticastPkts
        self.validate_UInt32(self.ifOutMulticastPkts)
        self.ifOutMulticastPkts_nsprefix_ = None
        self.ifOutOctets = ifOutOctets
        self.validate_UInt32(self.ifOutOctets)
        self.ifOutOctets_nsprefix_ = None
        self.ifOutUcastPkts = ifOutUcastPkts
        self.validate_UInt32(self.ifOutUcastPkts)
        self.ifOutUcastPkts_nsprefix_ = None
        self.ifPromiscuousMode = ifPromiscuousMode
        self.ifPromiscuousMode_nsprefix_ = None
        self.ifSpeed = ifSpeed
        self.validate_UInt32(self.ifSpeed)
        self.ifSpeed_nsprefix_ = None
        self.ifType = ifType
        self.validate_UInt16(self.ifType)
        self.ifType_nsprefix_ = None
        self.IPAddrListLink = IPAddrListLink
        self.IPAddrListLink_nsprefix_ = None
        self.lastResetTime = lastResetTime
        self.validate_Int64(self.lastResetTime)
        self.lastResetTime_nsprefix_ = None
        self.lastUpdatedTime = lastUpdatedTime
        self.validate_Int64(self.lastUpdatedTime)
        self.lastUpdatedTime_nsprefix_ = None
        self.LLInterfaceListLink = LLInterfaceListLink
        self.LLInterfaceListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPInterface)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPInterface.subclass:
            return IPInterface.subclass(*args_, **kwargs_)
        else:
            return IPInterface(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ifDescr(self):
        return self.ifDescr
    def set_ifDescr(self, ifDescr):
        self.ifDescr = ifDescr
    def get_ifHighSpeed(self):
        return self.ifHighSpeed
    def set_ifHighSpeed(self, ifHighSpeed):
        self.ifHighSpeed = ifHighSpeed
    def get_ifInBroadcastPkts(self):
        return self.ifInBroadcastPkts
    def set_ifInBroadcastPkts(self, ifInBroadcastPkts):
        self.ifInBroadcastPkts = ifInBroadcastPkts
    def get_ifIndex(self):
        return self.ifIndex
    def set_ifIndex(self, ifIndex):
        self.ifIndex = ifIndex
    def get_ifInDiscards(self):
        return self.ifInDiscards
    def set_ifInDiscards(self, ifInDiscards):
        self.ifInDiscards = ifInDiscards
    def get_ifInErrors(self):
        return self.ifInErrors
    def set_ifInErrors(self, ifInErrors):
        self.ifInErrors = ifInErrors
    def get_ifInMulticastPkts(self):
        return self.ifInMulticastPkts
    def set_ifInMulticastPkts(self, ifInMulticastPkts):
        self.ifInMulticastPkts = ifInMulticastPkts
    def get_ifInOctets(self):
        return self.ifInOctets
    def set_ifInOctets(self, ifInOctets):
        self.ifInOctets = ifInOctets
    def get_ifInUcastPkts(self):
        return self.ifInUcastPkts
    def set_ifInUcastPkts(self, ifInUcastPkts):
        self.ifInUcastPkts = ifInUcastPkts
    def get_ifInUnknownProtos(self):
        return self.ifInUnknownProtos
    def set_ifInUnknownProtos(self, ifInUnknownProtos):
        self.ifInUnknownProtos = ifInUnknownProtos
    def get_ifMtu(self):
        return self.ifMtu
    def set_ifMtu(self, ifMtu):
        self.ifMtu = ifMtu
    def get_ifName(self):
        return self.ifName
    def set_ifName(self, ifName):
        self.ifName = ifName
    def get_ifOperStatus(self):
        return self.ifOperStatus
    def set_ifOperStatus(self, ifOperStatus):
        self.ifOperStatus = ifOperStatus
    def get_ifOutBroadcastPkts(self):
        return self.ifOutBroadcastPkts
    def set_ifOutBroadcastPkts(self, ifOutBroadcastPkts):
        self.ifOutBroadcastPkts = ifOutBroadcastPkts
    def get_ifOutDiscards(self):
        return self.ifOutDiscards
    def set_ifOutDiscards(self, ifOutDiscards):
        self.ifOutDiscards = ifOutDiscards
    def get_ifOutErrors(self):
        return self.ifOutErrors
    def set_ifOutErrors(self, ifOutErrors):
        self.ifOutErrors = ifOutErrors
    def get_ifOutMulticastPkts(self):
        return self.ifOutMulticastPkts
    def set_ifOutMulticastPkts(self, ifOutMulticastPkts):
        self.ifOutMulticastPkts = ifOutMulticastPkts
    def get_ifOutOctets(self):
        return self.ifOutOctets
    def set_ifOutOctets(self, ifOutOctets):
        self.ifOutOctets = ifOutOctets
    def get_ifOutUcastPkts(self):
        return self.ifOutUcastPkts
    def set_ifOutUcastPkts(self, ifOutUcastPkts):
        self.ifOutUcastPkts = ifOutUcastPkts
    def get_ifPromiscuousMode(self):
        return self.ifPromiscuousMode
    def set_ifPromiscuousMode(self, ifPromiscuousMode):
        self.ifPromiscuousMode = ifPromiscuousMode
    def get_ifSpeed(self):
        return self.ifSpeed
    def set_ifSpeed(self, ifSpeed):
        self.ifSpeed = ifSpeed
    def get_ifType(self):
        return self.ifType
    def set_ifType(self, ifType):
        self.ifType = ifType
    def get_IPAddrListLink(self):
        return self.IPAddrListLink
    def set_IPAddrListLink(self, IPAddrListLink):
        self.IPAddrListLink = IPAddrListLink
    def get_lastResetTime(self):
        return self.lastResetTime
    def set_lastResetTime(self, lastResetTime):
        self.lastResetTime = lastResetTime
    def get_lastUpdatedTime(self):
        return self.lastUpdatedTime
    def set_lastUpdatedTime(self, lastUpdatedTime):
        self.lastUpdatedTime = lastUpdatedTime
    def get_LLInterfaceListLink(self):
        return self.LLInterfaceListLink
    def set_LLInterfaceListLink(self, LLInterfaceListLink):
        self.LLInterfaceListLink = LLInterfaceListLink
    def validate_String192(self, value):
        result = True
        # Validate type String192, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 192:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String192' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_String16(self, value):
        result = True
        # Validate type String16, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String16' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_Int64(self, value):
        result = True
        # Validate type Int64, a restriction on xs:long.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.ifDescr is not None or
            self.ifHighSpeed is not None or
            self.ifInBroadcastPkts is not None or
            self.ifIndex is not None or
            self.ifInDiscards is not None or
            self.ifInErrors is not None or
            self.ifInMulticastPkts is not None or
            self.ifInOctets is not None or
            self.ifInUcastPkts is not None or
            self.ifInUnknownProtos is not None or
            self.ifMtu is not None or
            self.ifName is not None or
            self.ifOperStatus is not None or
            self.ifOutBroadcastPkts is not None or
            self.ifOutDiscards is not None or
            self.ifOutErrors is not None or
            self.ifOutMulticastPkts is not None or
            self.ifOutOctets is not None or
            self.ifOutUcastPkts is not None or
            self.ifPromiscuousMode is not None or
            self.ifSpeed is not None or
            self.ifType is not None or
            self.IPAddrListLink is not None or
            self.lastResetTime is not None or
            self.lastUpdatedTime is not None or
            self.LLInterfaceListLink is not None or
            super(IPInterface, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IPInterface', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPInterface')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IPInterface':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPInterface')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPInterface', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPInterface'):
        super(IPInterface, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPInterface')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IPInterface', fromsubclass_=False, pretty_print=True):
        super(IPInterface, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ifDescr is not None:
            namespaceprefix_ = self.ifDescr_nsprefix_ + ':' if (UseCapturedNS_ and self.ifDescr_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifDescr>%s</%sifDescr>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ifDescr), input_name='ifDescr')), namespaceprefix_ , eol_))
        if self.ifHighSpeed is not None:
            namespaceprefix_ = self.ifHighSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.ifHighSpeed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifHighSpeed>%s</%sifHighSpeed>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifHighSpeed, input_name='ifHighSpeed'), namespaceprefix_ , eol_))
        if self.ifInBroadcastPkts is not None:
            namespaceprefix_ = self.ifInBroadcastPkts_nsprefix_ + ':' if (UseCapturedNS_ and self.ifInBroadcastPkts_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInBroadcastPkts>%s</%sifInBroadcastPkts>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifInBroadcastPkts, input_name='ifInBroadcastPkts'), namespaceprefix_ , eol_))
        if self.ifIndex is not None:
            namespaceprefix_ = self.ifIndex_nsprefix_ + ':' if (UseCapturedNS_ and self.ifIndex_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifIndex>%s</%sifIndex>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifIndex, input_name='ifIndex'), namespaceprefix_ , eol_))
        if self.ifInDiscards is not None:
            namespaceprefix_ = self.ifInDiscards_nsprefix_ + ':' if (UseCapturedNS_ and self.ifInDiscards_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInDiscards>%s</%sifInDiscards>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifInDiscards, input_name='ifInDiscards'), namespaceprefix_ , eol_))
        if self.ifInErrors is not None:
            namespaceprefix_ = self.ifInErrors_nsprefix_ + ':' if (UseCapturedNS_ and self.ifInErrors_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInErrors>%s</%sifInErrors>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifInErrors, input_name='ifInErrors'), namespaceprefix_ , eol_))
        if self.ifInMulticastPkts is not None:
            namespaceprefix_ = self.ifInMulticastPkts_nsprefix_ + ':' if (UseCapturedNS_ and self.ifInMulticastPkts_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInMulticastPkts>%s</%sifInMulticastPkts>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifInMulticastPkts, input_name='ifInMulticastPkts'), namespaceprefix_ , eol_))
        if self.ifInOctets is not None:
            namespaceprefix_ = self.ifInOctets_nsprefix_ + ':' if (UseCapturedNS_ and self.ifInOctets_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInOctets>%s</%sifInOctets>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifInOctets, input_name='ifInOctets'), namespaceprefix_ , eol_))
        if self.ifInUcastPkts is not None:
            namespaceprefix_ = self.ifInUcastPkts_nsprefix_ + ':' if (UseCapturedNS_ and self.ifInUcastPkts_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInUcastPkts>%s</%sifInUcastPkts>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifInUcastPkts, input_name='ifInUcastPkts'), namespaceprefix_ , eol_))
        if self.ifInUnknownProtos is not None:
            namespaceprefix_ = self.ifInUnknownProtos_nsprefix_ + ':' if (UseCapturedNS_ and self.ifInUnknownProtos_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifInUnknownProtos>%s</%sifInUnknownProtos>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifInUnknownProtos, input_name='ifInUnknownProtos'), namespaceprefix_ , eol_))
        if self.ifMtu is not None:
            namespaceprefix_ = self.ifMtu_nsprefix_ + ':' if (UseCapturedNS_ and self.ifMtu_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifMtu>%s</%sifMtu>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifMtu, input_name='ifMtu'), namespaceprefix_ , eol_))
        if self.ifName is not None:
            namespaceprefix_ = self.ifName_nsprefix_ + ':' if (UseCapturedNS_ and self.ifName_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifName>%s</%sifName>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.ifName), input_name='ifName')), namespaceprefix_ , eol_))
        if self.ifOperStatus is not None:
            namespaceprefix_ = self.ifOperStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.ifOperStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOperStatus>%s</%sifOperStatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifOperStatus, input_name='ifOperStatus'), namespaceprefix_ , eol_))
        if self.ifOutBroadcastPkts is not None:
            namespaceprefix_ = self.ifOutBroadcastPkts_nsprefix_ + ':' if (UseCapturedNS_ and self.ifOutBroadcastPkts_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutBroadcastPkts>%s</%sifOutBroadcastPkts>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifOutBroadcastPkts, input_name='ifOutBroadcastPkts'), namespaceprefix_ , eol_))
        if self.ifOutDiscards is not None:
            namespaceprefix_ = self.ifOutDiscards_nsprefix_ + ':' if (UseCapturedNS_ and self.ifOutDiscards_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutDiscards>%s</%sifOutDiscards>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifOutDiscards, input_name='ifOutDiscards'), namespaceprefix_ , eol_))
        if self.ifOutErrors is not None:
            namespaceprefix_ = self.ifOutErrors_nsprefix_ + ':' if (UseCapturedNS_ and self.ifOutErrors_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutErrors>%s</%sifOutErrors>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifOutErrors, input_name='ifOutErrors'), namespaceprefix_ , eol_))
        if self.ifOutMulticastPkts is not None:
            namespaceprefix_ = self.ifOutMulticastPkts_nsprefix_ + ':' if (UseCapturedNS_ and self.ifOutMulticastPkts_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutMulticastPkts>%s</%sifOutMulticastPkts>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifOutMulticastPkts, input_name='ifOutMulticastPkts'), namespaceprefix_ , eol_))
        if self.ifOutOctets is not None:
            namespaceprefix_ = self.ifOutOctets_nsprefix_ + ':' if (UseCapturedNS_ and self.ifOutOctets_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutOctets>%s</%sifOutOctets>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifOutOctets, input_name='ifOutOctets'), namespaceprefix_ , eol_))
        if self.ifOutUcastPkts is not None:
            namespaceprefix_ = self.ifOutUcastPkts_nsprefix_ + ':' if (UseCapturedNS_ and self.ifOutUcastPkts_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifOutUcastPkts>%s</%sifOutUcastPkts>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifOutUcastPkts, input_name='ifOutUcastPkts'), namespaceprefix_ , eol_))
        if self.ifPromiscuousMode is not None:
            namespaceprefix_ = self.ifPromiscuousMode_nsprefix_ + ':' if (UseCapturedNS_ and self.ifPromiscuousMode_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifPromiscuousMode>%s</%sifPromiscuousMode>%s' % (namespaceprefix_ , self.gds_format_boolean(self.ifPromiscuousMode, input_name='ifPromiscuousMode'), namespaceprefix_ , eol_))
        if self.ifSpeed is not None:
            namespaceprefix_ = self.ifSpeed_nsprefix_ + ':' if (UseCapturedNS_ and self.ifSpeed_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifSpeed>%s</%sifSpeed>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifSpeed, input_name='ifSpeed'), namespaceprefix_ , eol_))
        if self.ifType is not None:
            namespaceprefix_ = self.ifType_nsprefix_ + ':' if (UseCapturedNS_ and self.ifType_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sifType>%s</%sifType>%s' % (namespaceprefix_ , self.gds_format_integer(self.ifType, input_name='ifType'), namespaceprefix_ , eol_))
        if self.IPAddrListLink is not None:
            namespaceprefix_ = self.IPAddrListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.IPAddrListLink_nsprefix_) else ''
            self.IPAddrListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IPAddrListLink', pretty_print=pretty_print)
        if self.lastResetTime is not None:
            namespaceprefix_ = self.lastResetTime_nsprefix_ + ':' if (UseCapturedNS_ and self.lastResetTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastResetTime>%s</%slastResetTime>%s' % (namespaceprefix_ , self.gds_format_integer(self.lastResetTime, input_name='lastResetTime'), namespaceprefix_ , eol_))
        if self.lastUpdatedTime is not None:
            namespaceprefix_ = self.lastUpdatedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.lastUpdatedTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slastUpdatedTime>%s</%slastUpdatedTime>%s' % (namespaceprefix_ , self.gds_format_integer(self.lastUpdatedTime, input_name='lastUpdatedTime'), namespaceprefix_ , eol_))
        if self.LLInterfaceListLink is not None:
            namespaceprefix_ = self.LLInterfaceListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.LLInterfaceListLink_nsprefix_) else ''
            self.LLInterfaceListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LLInterfaceListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IPInterface, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ifDescr':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ifDescr')
            value_ = self.gds_validate_string(value_, node, 'ifDescr')
            self.ifDescr = value_
            self.ifDescr_nsprefix_ = child_.prefix
            # validate type String192
            self.validate_String192(self.ifDescr)
        elif nodeName_ == 'ifHighSpeed' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifHighSpeed')
            ival_ = self.gds_validate_integer(ival_, node, 'ifHighSpeed')
            self.ifHighSpeed = ival_
            self.ifHighSpeed_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifHighSpeed)
        elif nodeName_ == 'ifInBroadcastPkts' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifInBroadcastPkts')
            ival_ = self.gds_validate_integer(ival_, node, 'ifInBroadcastPkts')
            self.ifInBroadcastPkts = ival_
            self.ifInBroadcastPkts_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifInBroadcastPkts)
        elif nodeName_ == 'ifIndex' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifIndex')
            ival_ = self.gds_validate_integer(ival_, node, 'ifIndex')
            self.ifIndex = ival_
            self.ifIndex_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifIndex)
        elif nodeName_ == 'ifInDiscards' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifInDiscards')
            ival_ = self.gds_validate_integer(ival_, node, 'ifInDiscards')
            self.ifInDiscards = ival_
            self.ifInDiscards_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifInDiscards)
        elif nodeName_ == 'ifInErrors' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifInErrors')
            ival_ = self.gds_validate_integer(ival_, node, 'ifInErrors')
            self.ifInErrors = ival_
            self.ifInErrors_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifInErrors)
        elif nodeName_ == 'ifInMulticastPkts' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifInMulticastPkts')
            ival_ = self.gds_validate_integer(ival_, node, 'ifInMulticastPkts')
            self.ifInMulticastPkts = ival_
            self.ifInMulticastPkts_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifInMulticastPkts)
        elif nodeName_ == 'ifInOctets' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifInOctets')
            ival_ = self.gds_validate_integer(ival_, node, 'ifInOctets')
            self.ifInOctets = ival_
            self.ifInOctets_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifInOctets)
        elif nodeName_ == 'ifInUcastPkts' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifInUcastPkts')
            ival_ = self.gds_validate_integer(ival_, node, 'ifInUcastPkts')
            self.ifInUcastPkts = ival_
            self.ifInUcastPkts_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifInUcastPkts)
        elif nodeName_ == 'ifInUnknownProtos' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifInUnknownProtos')
            ival_ = self.gds_validate_integer(ival_, node, 'ifInUnknownProtos')
            self.ifInUnknownProtos = ival_
            self.ifInUnknownProtos_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifInUnknownProtos)
        elif nodeName_ == 'ifMtu' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifMtu')
            ival_ = self.gds_validate_integer(ival_, node, 'ifMtu')
            self.ifMtu = ival_
            self.ifMtu_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifMtu)
        elif nodeName_ == 'ifName':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'ifName')
            value_ = self.gds_validate_string(value_, node, 'ifName')
            self.ifName = value_
            self.ifName_nsprefix_ = child_.prefix
            # validate type String16
            self.validate_String16(self.ifName)
        elif nodeName_ == 'ifOperStatus' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifOperStatus')
            ival_ = self.gds_validate_integer(ival_, node, 'ifOperStatus')
            self.ifOperStatus = ival_
            self.ifOperStatus_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.ifOperStatus)
        elif nodeName_ == 'ifOutBroadcastPkts' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifOutBroadcastPkts')
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutBroadcastPkts')
            self.ifOutBroadcastPkts = ival_
            self.ifOutBroadcastPkts_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifOutBroadcastPkts)
        elif nodeName_ == 'ifOutDiscards' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifOutDiscards')
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutDiscards')
            self.ifOutDiscards = ival_
            self.ifOutDiscards_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifOutDiscards)
        elif nodeName_ == 'ifOutErrors' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifOutErrors')
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutErrors')
            self.ifOutErrors = ival_
            self.ifOutErrors_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifOutErrors)
        elif nodeName_ == 'ifOutMulticastPkts' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifOutMulticastPkts')
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutMulticastPkts')
            self.ifOutMulticastPkts = ival_
            self.ifOutMulticastPkts_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifOutMulticastPkts)
        elif nodeName_ == 'ifOutOctets' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifOutOctets')
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutOctets')
            self.ifOutOctets = ival_
            self.ifOutOctets_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifOutOctets)
        elif nodeName_ == 'ifOutUcastPkts' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifOutUcastPkts')
            ival_ = self.gds_validate_integer(ival_, node, 'ifOutUcastPkts')
            self.ifOutUcastPkts = ival_
            self.ifOutUcastPkts_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifOutUcastPkts)
        elif nodeName_ == 'ifPromiscuousMode':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'ifPromiscuousMode')
            ival_ = self.gds_validate_boolean(ival_, node, 'ifPromiscuousMode')
            self.ifPromiscuousMode = ival_
            self.ifPromiscuousMode_nsprefix_ = child_.prefix
        elif nodeName_ == 'ifSpeed' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifSpeed')
            ival_ = self.gds_validate_integer(ival_, node, 'ifSpeed')
            self.ifSpeed = ival_
            self.ifSpeed_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.ifSpeed)
        elif nodeName_ == 'ifType' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'ifType')
            ival_ = self.gds_validate_integer(ival_, node, 'ifType')
            self.ifType = ival_
            self.ifType_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.ifType)
        elif nodeName_ == 'IPAddrListLink':
            obj_ = IPAddrListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IPAddrListLink = obj_
            obj_.original_tagname_ = 'IPAddrListLink'
        elif nodeName_ == 'lastResetTime' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lastResetTime')
            ival_ = self.gds_validate_integer(ival_, node, 'lastResetTime')
            self.lastResetTime = ival_
            self.lastResetTime_nsprefix_ = child_.prefix
            # validate type Int64
            self.validate_Int64(self.lastResetTime)
        elif nodeName_ == 'lastUpdatedTime' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'lastUpdatedTime')
            ival_ = self.gds_validate_integer(ival_, node, 'lastUpdatedTime')
            self.lastUpdatedTime = ival_
            self.lastUpdatedTime_nsprefix_ = child_.prefix
            # validate type Int64
            self.validate_Int64(self.lastUpdatedTime)
        elif nodeName_ == 'LLInterfaceListLink':
            obj_ = LLInterfaceListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LLInterfaceListLink = obj_
            obj_.original_tagname_ = 'LLInterfaceListLink'
        super(IPInterface, self)._buildChildren(child_, node, nodeName_, True)
# end class IPInterface


class IPAddrList(List):
    """IPAddrList -- List of IPAddr instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, IPAddr=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IPAddrList"), self).__init__( **kwargs_)
        if IPAddr is None:
            self.IPAddr = []
        else:
            self.IPAddr = IPAddr
        self.IPAddr_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPAddrList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPAddrList.subclass:
            return IPAddrList.subclass(*args_, **kwargs_)
        else:
            return IPAddrList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_IPAddr(self):
        return self.IPAddr
    def set_IPAddr(self, IPAddr):
        self.IPAddr = IPAddr
    def add_IPAddr(self, value):
        self.IPAddr.append(value)
    def insert_IPAddr_at(self, index, value):
        self.IPAddr.insert(index, value)
    def replace_IPAddr_at(self, index, value):
        self.IPAddr[index] = value
    def _hasContent(self):
        if (
            self.IPAddr or
            super(IPAddrList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IPAddrList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPAddrList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IPAddrList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPAddrList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPAddrList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPAddrList'):
        super(IPAddrList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPAddrList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IPAddrList', fromsubclass_=False, pretty_print=True):
        super(IPAddrList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for IPAddr_ in self.IPAddr:
            namespaceprefix_ = self.IPAddr_nsprefix_ + ':' if (UseCapturedNS_ and self.IPAddr_nsprefix_) else ''
            IPAddr_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IPAddr', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IPAddrList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'IPAddr':
            obj_ = IPAddr.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IPAddr.append(obj_)
            obj_.original_tagname_ = 'IPAddr'
        super(IPAddrList, self)._buildChildren(child_, node, nodeName_, True)
# end class IPAddrList


class IPAddr(Resource):
    """IPAddr -- An Internet Protocol address object.
    address -- An IP address value.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, address=None, RPLInstanceListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("IPAddr"), self).__init__( **kwargs_)
        self.address = address
        self.validate_HexBinary128(self.address)
        self.address_nsprefix_ = None
        self.RPLInstanceListLink = RPLInstanceListLink
        self.RPLInstanceListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, IPAddr)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if IPAddr.subclass:
            return IPAddr.subclass(*args_, **kwargs_)
        else:
            return IPAddr(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_address(self):
        return self.address
    def set_address(self, address):
        self.address = address
    def get_RPLInstanceListLink(self):
        return self.RPLInstanceListLink
    def set_RPLInstanceListLink(self, RPLInstanceListLink):
        self.RPLInstanceListLink = RPLInstanceListLink
    def validate_HexBinary128(self, value):
        result = True
        # Validate type HexBinary128, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary128' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.address is not None or
            self.RPLInstanceListLink is not None or
            super(IPAddr, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IPAddr', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('IPAddr')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'IPAddr':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPAddr')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='IPAddr', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='IPAddr'):
        super(IPAddr, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='IPAddr')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='IPAddr', fromsubclass_=False, pretty_print=True):
        super(IPAddr, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.address is not None:
            namespaceprefix_ = self.address_nsprefix_ + ':' if (UseCapturedNS_ and self.address_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%saddress>%s</%saddress>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.address), input_name='address')), namespaceprefix_ , eol_))
        if self.RPLInstanceListLink is not None:
            namespaceprefix_ = self.RPLInstanceListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.RPLInstanceListLink_nsprefix_) else ''
            self.RPLInstanceListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RPLInstanceListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(IPAddr, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'address':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'address')
            value_ = self.gds_validate_string(value_, node, 'address')
            self.address = value_
            self.address_nsprefix_ = child_.prefix
            # validate type HexBinary128
            self.validate_HexBinary128(self.address)
        elif nodeName_ == 'RPLInstanceListLink':
            obj_ = RPLInstanceListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RPLInstanceListLink = obj_
            obj_.original_tagname_ = 'RPLInstanceListLink'
        super(IPAddr, self)._buildChildren(child_, node, nodeName_, True)
# end class IPAddr


class PowerStatus(Resource):
    """PowerStatus -- Contains the status of the device's power sources
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    batteryStatus -- Battery system status
    0 = unknown
    1 = normal (more than LowChargeThreshold remaining)
    2 = low (less than LowChargeThreshold remaining)
    3 = depleted (0% charge remaining)
    4 = not applicable (mains powered only)
    changedTime -- The time at which the reported values were recorded.
    currentPowerSource -- This value will be fixed for devices powered by a single source.  This value may change for devices able to transition between multiple power sources (mains to battery backup, etc.).
    estimatedChargeRemaining -- Estimate of remaining battery charge as a percent of full charge.
    estimatedTimeRemaining -- Estimated time (in seconds) to total battery charge depletion (under current load)
    sessionTimeOnBattery -- If the device has a battery, this is the time since the device last switched to battery power, or the time since the device was restarted, whichever is less, in seconds.
    totalTimeOnBattery -- If the device has a battery, this is the total time the device has been on battery power, in seconds. It may be reset when the battery is replaced.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, pollRate='900', batteryStatus=None, changedTime=None, currentPowerSource=None, estimatedChargeRemaining=None, estimatedTimeRemaining=None, PEVInfo=None, sessionTimeOnBattery=None, totalTimeOnBattery=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PowerStatus"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        self.batteryStatus = batteryStatus
        self.validate_UInt8(self.batteryStatus)
        self.batteryStatus_nsprefix_ = None
        self.changedTime = changedTime
        self.changedTime_nsprefix_ = None
        self.currentPowerSource = currentPowerSource
        self.currentPowerSource_nsprefix_ = None
        self.estimatedChargeRemaining = estimatedChargeRemaining
        self.estimatedChargeRemaining_nsprefix_ = None
        self.estimatedTimeRemaining = estimatedTimeRemaining
        self.validate_UInt32(self.estimatedTimeRemaining)
        self.estimatedTimeRemaining_nsprefix_ = None
        self.PEVInfo = PEVInfo
        self.PEVInfo_nsprefix_ = None
        self.sessionTimeOnBattery = sessionTimeOnBattery
        self.validate_UInt32(self.sessionTimeOnBattery)
        self.sessionTimeOnBattery_nsprefix_ = None
        self.totalTimeOnBattery = totalTimeOnBattery
        self.validate_UInt32(self.totalTimeOnBattery)
        self.totalTimeOnBattery_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PowerStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PowerStatus.subclass:
            return PowerStatus.subclass(*args_, **kwargs_)
        else:
            return PowerStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_batteryStatus(self):
        return self.batteryStatus
    def set_batteryStatus(self, batteryStatus):
        self.batteryStatus = batteryStatus
    def get_changedTime(self):
        return self.changedTime
    def set_changedTime(self, changedTime):
        self.changedTime = changedTime
    def get_currentPowerSource(self):
        return self.currentPowerSource
    def set_currentPowerSource(self, currentPowerSource):
        self.currentPowerSource = currentPowerSource
    def get_estimatedChargeRemaining(self):
        return self.estimatedChargeRemaining
    def set_estimatedChargeRemaining(self, estimatedChargeRemaining):
        self.estimatedChargeRemaining = estimatedChargeRemaining
    def get_estimatedTimeRemaining(self):
        return self.estimatedTimeRemaining
    def set_estimatedTimeRemaining(self, estimatedTimeRemaining):
        self.estimatedTimeRemaining = estimatedTimeRemaining
    def get_PEVInfo(self):
        return self.PEVInfo
    def set_PEVInfo(self, PEVInfo):
        self.PEVInfo = PEVInfo
    def get_sessionTimeOnBattery(self):
        return self.sessionTimeOnBattery
    def set_sessionTimeOnBattery(self, sessionTimeOnBattery):
        self.sessionTimeOnBattery = sessionTimeOnBattery
    def get_totalTimeOnBattery(self):
        return self.totalTimeOnBattery
    def set_totalTimeOnBattery(self, totalTimeOnBattery):
        self.totalTimeOnBattery = totalTimeOnBattery
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.batteryStatus is not None or
            self.changedTime is not None or
            self.currentPowerSource is not None or
            self.estimatedChargeRemaining is not None or
            self.estimatedTimeRemaining is not None or
            self.PEVInfo is not None or
            self.sessionTimeOnBattery is not None or
            self.totalTimeOnBattery is not None or
            super(PowerStatus, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PowerStatus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PowerStatus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PowerStatus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerStatus')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PowerStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PowerStatus'):
        super(PowerStatus, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PowerStatus')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='PowerStatus', fromsubclass_=False, pretty_print=True):
        super(PowerStatus, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.batteryStatus is not None:
            namespaceprefix_ = self.batteryStatus_nsprefix_ + ':' if (UseCapturedNS_ and self.batteryStatus_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sbatteryStatus>%s</%sbatteryStatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.batteryStatus, input_name='batteryStatus'), namespaceprefix_ , eol_))
        if self.changedTime is not None:
            namespaceprefix_ = self.changedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.changedTime_nsprefix_) else ''
            self.changedTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='changedTime', pretty_print=pretty_print)
        if self.currentPowerSource is not None:
            namespaceprefix_ = self.currentPowerSource_nsprefix_ + ':' if (UseCapturedNS_ and self.currentPowerSource_nsprefix_) else ''
            self.currentPowerSource.export(outfile, level, namespaceprefix_, namespacedef_='', name_='currentPowerSource', pretty_print=pretty_print)
        if self.estimatedChargeRemaining is not None:
            namespaceprefix_ = self.estimatedChargeRemaining_nsprefix_ + ':' if (UseCapturedNS_ and self.estimatedChargeRemaining_nsprefix_) else ''
            self.estimatedChargeRemaining.export(outfile, level, namespaceprefix_, namespacedef_='', name_='estimatedChargeRemaining', pretty_print=pretty_print)
        if self.estimatedTimeRemaining is not None:
            namespaceprefix_ = self.estimatedTimeRemaining_nsprefix_ + ':' if (UseCapturedNS_ and self.estimatedTimeRemaining_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sestimatedTimeRemaining>%s</%sestimatedTimeRemaining>%s' % (namespaceprefix_ , self.gds_format_integer(self.estimatedTimeRemaining, input_name='estimatedTimeRemaining'), namespaceprefix_ , eol_))
        if self.PEVInfo is not None:
            namespaceprefix_ = self.PEVInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.PEVInfo_nsprefix_) else ''
            self.PEVInfo.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PEVInfo', pretty_print=pretty_print)
        if self.sessionTimeOnBattery is not None:
            namespaceprefix_ = self.sessionTimeOnBattery_nsprefix_ + ':' if (UseCapturedNS_ and self.sessionTimeOnBattery_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssessionTimeOnBattery>%s</%ssessionTimeOnBattery>%s' % (namespaceprefix_ , self.gds_format_integer(self.sessionTimeOnBattery, input_name='sessionTimeOnBattery'), namespaceprefix_ , eol_))
        if self.totalTimeOnBattery is not None:
            namespaceprefix_ = self.totalTimeOnBattery_nsprefix_ + ':' if (UseCapturedNS_ and self.totalTimeOnBattery_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%stotalTimeOnBattery>%s</%stotalTimeOnBattery>%s' % (namespaceprefix_ , self.gds_format_integer(self.totalTimeOnBattery, input_name='totalTimeOnBattery'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(PowerStatus, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'batteryStatus' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'batteryStatus')
            ival_ = self.gds_validate_integer(ival_, node, 'batteryStatus')
            self.batteryStatus = ival_
            self.batteryStatus_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.batteryStatus)
        elif nodeName_ == 'changedTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.changedTime = obj_
            obj_.original_tagname_ = 'changedTime'
        elif nodeName_ == 'currentPowerSource':
            obj_ = PowerSourceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currentPowerSource = obj_
            obj_.original_tagname_ = 'currentPowerSource'
        elif nodeName_ == 'estimatedChargeRemaining':
            obj_ = PerCent.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.estimatedChargeRemaining = obj_
            obj_.original_tagname_ = 'estimatedChargeRemaining'
        elif nodeName_ == 'estimatedTimeRemaining' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'estimatedTimeRemaining')
            ival_ = self.gds_validate_integer(ival_, node, 'estimatedTimeRemaining')
            self.estimatedTimeRemaining = ival_
            self.estimatedTimeRemaining_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.estimatedTimeRemaining)
        elif nodeName_ == 'PEVInfo':
            obj_ = PEVInfo.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PEVInfo = obj_
            obj_.original_tagname_ = 'PEVInfo'
        elif nodeName_ == 'sessionTimeOnBattery' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'sessionTimeOnBattery')
            ival_ = self.gds_validate_integer(ival_, node, 'sessionTimeOnBattery')
            self.sessionTimeOnBattery = ival_
            self.sessionTimeOnBattery_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.sessionTimeOnBattery)
        elif nodeName_ == 'totalTimeOnBattery' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'totalTimeOnBattery')
            ival_ = self.gds_validate_integer(ival_, node, 'totalTimeOnBattery')
            self.totalTimeOnBattery = ival_
            self.totalTimeOnBattery_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.totalTimeOnBattery)
        super(PowerStatus, self)._buildChildren(child_, node, nodeName_, True)
# end class PowerStatus


class SupportedLocaleList(List):
    """SupportedLocaleList -- A List element to hold SupportedLocale objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, SupportedLocale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SupportedLocaleList"), self).__init__( **kwargs_)
        if SupportedLocale is None:
            self.SupportedLocale = []
        else:
            self.SupportedLocale = SupportedLocale
        self.SupportedLocale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportedLocaleList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportedLocaleList.subclass:
            return SupportedLocaleList.subclass(*args_, **kwargs_)
        else:
            return SupportedLocaleList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_SupportedLocale(self):
        return self.SupportedLocale
    def set_SupportedLocale(self, SupportedLocale):
        self.SupportedLocale = SupportedLocale
    def add_SupportedLocale(self, value):
        self.SupportedLocale.append(value)
    def insert_SupportedLocale_at(self, index, value):
        self.SupportedLocale.insert(index, value)
    def replace_SupportedLocale_at(self, index, value):
        self.SupportedLocale[index] = value
    def _hasContent(self):
        if (
            self.SupportedLocale or
            super(SupportedLocaleList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SupportedLocaleList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportedLocaleList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupportedLocaleList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportedLocaleList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupportedLocaleList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupportedLocaleList'):
        super(SupportedLocaleList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportedLocaleList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SupportedLocaleList', fromsubclass_=False, pretty_print=True):
        super(SupportedLocaleList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SupportedLocale_ in self.SupportedLocale:
            namespaceprefix_ = self.SupportedLocale_nsprefix_ + ':' if (UseCapturedNS_ and self.SupportedLocale_nsprefix_) else ''
            SupportedLocale_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SupportedLocale', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SupportedLocaleList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'SupportedLocale':
            obj_ = SupportedLocale.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SupportedLocale.append(obj_)
            obj_.original_tagname_ = 'SupportedLocale'
        super(SupportedLocaleList, self)._buildChildren(child_, node, nodeName_, True)
# end class SupportedLocaleList


class SupportedLocale(Resource):
    """SupportedLocale -- Specifies a locale that is supported
    locale -- The code for a locale that is supported
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, locale=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SupportedLocale"), self).__init__( **kwargs_)
        self.locale = locale
        self.locale_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SupportedLocale)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SupportedLocale.subclass:
            return SupportedLocale.subclass(*args_, **kwargs_)
        else:
            return SupportedLocale(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_locale(self):
        return self.locale
    def set_locale(self, locale):
        self.locale = locale
    def _hasContent(self):
        if (
            self.locale is not None or
            super(SupportedLocale, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SupportedLocale', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SupportedLocale')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SupportedLocale':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportedLocale')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SupportedLocale', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SupportedLocale'):
        super(SupportedLocale, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SupportedLocale')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SupportedLocale', fromsubclass_=False, pretty_print=True):
        super(SupportedLocale, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.locale is not None:
            namespaceprefix_ = self.locale_nsprefix_ + ':' if (UseCapturedNS_ and self.locale_nsprefix_) else ''
            self.locale.export(outfile, level, namespaceprefix_, namespacedef_='', name_='locale', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SupportedLocale, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'locale':
            obj_ = LocaleType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.locale = obj_
            obj_.original_tagname_ = 'locale'
        super(SupportedLocale, self)._buildChildren(child_, node, nodeName_, True)
# end class SupportedLocale


class DeviceInformation(Resource):
    """DeviceInformation -- Contains identification and other information about the device that changes very infrequently, typically only when updates are applied, if ever.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    functionsImplemented -- Bitmap indicating the function sets used by the device as a client.
    0 - Device Capability
    1 - Self Device Resource
    2 - End Device Resource
    3 - Function Set Assignments
    4 - Subscription/Notification Mechanism
    5 - Response
    6 - Time
    7 - Device Information
    8 - Power Status
    9 - Network Status
    10 - Log Event
    11 - Configuration Resource
    12 - Software Download
    13 - DRLC
    14 - Metering
    15 - Pricing
    16 - Messaging
    17 - Billing
    18 - Prepayment
    19 - Flow Reservation
    20 - DER Control
    gpsLocation -- GPS location of this device.
    lFDI -- Long form device identifier. See the Security section for full details.
    mfDate -- Date/time of manufacture
    mfHwVer -- Manufacturer hardware version
    mfID -- The manufacturer's IANA Enterprise Number.
    mfInfo -- Manufacturer dependent information related to the manufacture of this device
    mfModel -- Manufacturer's model number
    mfSerNum -- Manufacturer assigned serial number
    primaryPower -- Primary source of power.
    secondaryPower -- Secondary source of power
    swActTime -- Activation date/time of currently running software
    swVer -- Currently running software version
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, pollRate='900', DRLCCapabilities=None, functionsImplemented=None, gpsLocation=None, lFDI=None, mfDate=None, mfHwVer=None, mfID=None, mfInfo=None, mfModel=None, mfSerNum=None, primaryPower=None, secondaryPower=None, SupportedLocaleListLink=None, swActTime=None, swVer=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DeviceInformation"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        self.DRLCCapabilities = DRLCCapabilities
        self.DRLCCapabilities_nsprefix_ = None
        self.functionsImplemented = functionsImplemented
        self.validate_HexBinary64(self.functionsImplemented)
        self.functionsImplemented_nsprefix_ = None
        self.gpsLocation = gpsLocation
        self.gpsLocation_nsprefix_ = None
        self.lFDI = lFDI
        self.validate_HexBinary160(self.lFDI)
        self.lFDI_nsprefix_ = None
        self.mfDate = mfDate
        self.mfDate_nsprefix_ = None
        self.mfHwVer = mfHwVer
        self.validate_String32(self.mfHwVer)
        self.mfHwVer_nsprefix_ = None
        self.mfID = mfID
        self.mfID_nsprefix_ = None
        self.mfInfo = mfInfo
        self.validate_String32(self.mfInfo)
        self.mfInfo_nsprefix_ = None
        self.mfModel = mfModel
        self.validate_String32(self.mfModel)
        self.mfModel_nsprefix_ = None
        self.mfSerNum = mfSerNum
        self.validate_String32(self.mfSerNum)
        self.mfSerNum_nsprefix_ = None
        self.primaryPower = primaryPower
        self.primaryPower_nsprefix_ = None
        self.secondaryPower = secondaryPower
        self.secondaryPower_nsprefix_ = None
        self.SupportedLocaleListLink = SupportedLocaleListLink
        self.SupportedLocaleListLink_nsprefix_ = None
        self.swActTime = swActTime
        self.swActTime_nsprefix_ = None
        self.swVer = swVer
        self.validate_String32(self.swVer)
        self.swVer_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeviceInformation)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeviceInformation.subclass:
            return DeviceInformation.subclass(*args_, **kwargs_)
        else:
            return DeviceInformation(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_DRLCCapabilities(self):
        return self.DRLCCapabilities
    def set_DRLCCapabilities(self, DRLCCapabilities):
        self.DRLCCapabilities = DRLCCapabilities
    def get_functionsImplemented(self):
        return self.functionsImplemented
    def set_functionsImplemented(self, functionsImplemented):
        self.functionsImplemented = functionsImplemented
    def get_gpsLocation(self):
        return self.gpsLocation
    def set_gpsLocation(self, gpsLocation):
        self.gpsLocation = gpsLocation
    def get_lFDI(self):
        return self.lFDI
    def set_lFDI(self, lFDI):
        self.lFDI = lFDI
    def get_mfDate(self):
        return self.mfDate
    def set_mfDate(self, mfDate):
        self.mfDate = mfDate
    def get_mfHwVer(self):
        return self.mfHwVer
    def set_mfHwVer(self, mfHwVer):
        self.mfHwVer = mfHwVer
    def get_mfID(self):
        return self.mfID
    def set_mfID(self, mfID):
        self.mfID = mfID
    def get_mfInfo(self):
        return self.mfInfo
    def set_mfInfo(self, mfInfo):
        self.mfInfo = mfInfo
    def get_mfModel(self):
        return self.mfModel
    def set_mfModel(self, mfModel):
        self.mfModel = mfModel
    def get_mfSerNum(self):
        return self.mfSerNum
    def set_mfSerNum(self, mfSerNum):
        self.mfSerNum = mfSerNum
    def get_primaryPower(self):
        return self.primaryPower
    def set_primaryPower(self, primaryPower):
        self.primaryPower = primaryPower
    def get_secondaryPower(self):
        return self.secondaryPower
    def set_secondaryPower(self, secondaryPower):
        self.secondaryPower = secondaryPower
    def get_SupportedLocaleListLink(self):
        return self.SupportedLocaleListLink
    def set_SupportedLocaleListLink(self, SupportedLocaleListLink):
        self.SupportedLocaleListLink = SupportedLocaleListLink
    def get_swActTime(self):
        return self.swActTime
    def set_swActTime(self, swActTime):
        self.swActTime = swActTime
    def get_swVer(self):
        return self.swVer
    def set_swVer(self, swVer):
        self.swVer = swVer
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_HexBinary64(self, value):
        result = True
        # Validate type HexBinary64, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary64' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_HexBinary160(self, value):
        result = True
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary160' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.DRLCCapabilities is not None or
            self.functionsImplemented is not None or
            self.gpsLocation is not None or
            self.lFDI is not None or
            self.mfDate is not None or
            self.mfHwVer is not None or
            self.mfID is not None or
            self.mfInfo is not None or
            self.mfModel is not None or
            self.mfSerNum is not None or
            self.primaryPower is not None or
            self.secondaryPower is not None or
            self.SupportedLocaleListLink is not None or
            self.swActTime is not None or
            self.swVer is not None or
            super(DeviceInformation, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DeviceInformation', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeviceInformation')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeviceInformation':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceInformation')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeviceInformation', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DeviceInformation'):
        super(DeviceInformation, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceInformation')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DeviceInformation', fromsubclass_=False, pretty_print=True):
        super(DeviceInformation, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DRLCCapabilities is not None:
            namespaceprefix_ = self.DRLCCapabilities_nsprefix_ + ':' if (UseCapturedNS_ and self.DRLCCapabilities_nsprefix_) else ''
            self.DRLCCapabilities.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DRLCCapabilities', pretty_print=pretty_print)
        if self.functionsImplemented is not None:
            namespaceprefix_ = self.functionsImplemented_nsprefix_ + ':' if (UseCapturedNS_ and self.functionsImplemented_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sfunctionsImplemented>%s</%sfunctionsImplemented>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.functionsImplemented), input_name='functionsImplemented')), namespaceprefix_ , eol_))
        if self.gpsLocation is not None:
            namespaceprefix_ = self.gpsLocation_nsprefix_ + ':' if (UseCapturedNS_ and self.gpsLocation_nsprefix_) else ''
            self.gpsLocation.export(outfile, level, namespaceprefix_, namespacedef_='', name_='gpsLocation', pretty_print=pretty_print)
        if self.lFDI is not None:
            namespaceprefix_ = self.lFDI_nsprefix_ + ':' if (UseCapturedNS_ and self.lFDI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slFDI>%s</%slFDI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lFDI), input_name='lFDI')), namespaceprefix_ , eol_))
        if self.mfDate is not None:
            namespaceprefix_ = self.mfDate_nsprefix_ + ':' if (UseCapturedNS_ and self.mfDate_nsprefix_) else ''
            self.mfDate.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mfDate', pretty_print=pretty_print)
        if self.mfHwVer is not None:
            namespaceprefix_ = self.mfHwVer_nsprefix_ + ':' if (UseCapturedNS_ and self.mfHwVer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfHwVer>%s</%smfHwVer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mfHwVer), input_name='mfHwVer')), namespaceprefix_ , eol_))
        if self.mfID is not None:
            namespaceprefix_ = self.mfID_nsprefix_ + ':' if (UseCapturedNS_ and self.mfID_nsprefix_) else ''
            self.mfID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mfID', pretty_print=pretty_print)
        if self.mfInfo is not None:
            namespaceprefix_ = self.mfInfo_nsprefix_ + ':' if (UseCapturedNS_ and self.mfInfo_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfInfo>%s</%smfInfo>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mfInfo), input_name='mfInfo')), namespaceprefix_ , eol_))
        if self.mfModel is not None:
            namespaceprefix_ = self.mfModel_nsprefix_ + ':' if (UseCapturedNS_ and self.mfModel_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfModel>%s</%smfModel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mfModel), input_name='mfModel')), namespaceprefix_ , eol_))
        if self.mfSerNum is not None:
            namespaceprefix_ = self.mfSerNum_nsprefix_ + ':' if (UseCapturedNS_ and self.mfSerNum_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%smfSerNum>%s</%smfSerNum>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.mfSerNum), input_name='mfSerNum')), namespaceprefix_ , eol_))
        if self.primaryPower is not None:
            namespaceprefix_ = self.primaryPower_nsprefix_ + ':' if (UseCapturedNS_ and self.primaryPower_nsprefix_) else ''
            self.primaryPower.export(outfile, level, namespaceprefix_, namespacedef_='', name_='primaryPower', pretty_print=pretty_print)
        if self.secondaryPower is not None:
            namespaceprefix_ = self.secondaryPower_nsprefix_ + ':' if (UseCapturedNS_ and self.secondaryPower_nsprefix_) else ''
            self.secondaryPower.export(outfile, level, namespaceprefix_, namespacedef_='', name_='secondaryPower', pretty_print=pretty_print)
        if self.SupportedLocaleListLink is not None:
            namespaceprefix_ = self.SupportedLocaleListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.SupportedLocaleListLink_nsprefix_) else ''
            self.SupportedLocaleListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SupportedLocaleListLink', pretty_print=pretty_print)
        if self.swActTime is not None:
            namespaceprefix_ = self.swActTime_nsprefix_ + ':' if (UseCapturedNS_ and self.swActTime_nsprefix_) else ''
            self.swActTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='swActTime', pretty_print=pretty_print)
        if self.swVer is not None:
            namespaceprefix_ = self.swVer_nsprefix_ + ':' if (UseCapturedNS_ and self.swVer_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sswVer>%s</%sswVer>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.swVer), input_name='swVer')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(DeviceInformation, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'DRLCCapabilities':
            obj_ = DRLCCapabilities.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DRLCCapabilities = obj_
            obj_.original_tagname_ = 'DRLCCapabilities'
        elif nodeName_ == 'functionsImplemented':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'functionsImplemented')
            value_ = self.gds_validate_string(value_, node, 'functionsImplemented')
            self.functionsImplemented = value_
            self.functionsImplemented_nsprefix_ = child_.prefix
            # validate type HexBinary64
            self.validate_HexBinary64(self.functionsImplemented)
        elif nodeName_ == 'gpsLocation':
            obj_ = GPSLocationType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.gpsLocation = obj_
            obj_.original_tagname_ = 'gpsLocation'
        elif nodeName_ == 'lFDI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lFDI')
            value_ = self.gds_validate_string(value_, node, 'lFDI')
            self.lFDI = value_
            self.lFDI_nsprefix_ = child_.prefix
            # validate type HexBinary160
            self.validate_HexBinary160(self.lFDI)
        elif nodeName_ == 'mfDate':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mfDate = obj_
            obj_.original_tagname_ = 'mfDate'
        elif nodeName_ == 'mfHwVer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mfHwVer')
            value_ = self.gds_validate_string(value_, node, 'mfHwVer')
            self.mfHwVer = value_
            self.mfHwVer_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.mfHwVer)
        elif nodeName_ == 'mfID':
            obj_ = PENType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mfID = obj_
            obj_.original_tagname_ = 'mfID'
        elif nodeName_ == 'mfInfo':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mfInfo')
            value_ = self.gds_validate_string(value_, node, 'mfInfo')
            self.mfInfo = value_
            self.mfInfo_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.mfInfo)
        elif nodeName_ == 'mfModel':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mfModel')
            value_ = self.gds_validate_string(value_, node, 'mfModel')
            self.mfModel = value_
            self.mfModel_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.mfModel)
        elif nodeName_ == 'mfSerNum':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'mfSerNum')
            value_ = self.gds_validate_string(value_, node, 'mfSerNum')
            self.mfSerNum = value_
            self.mfSerNum_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.mfSerNum)
        elif nodeName_ == 'primaryPower':
            obj_ = PowerSourceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.primaryPower = obj_
            obj_.original_tagname_ = 'primaryPower'
        elif nodeName_ == 'secondaryPower':
            obj_ = PowerSourceType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.secondaryPower = obj_
            obj_.original_tagname_ = 'secondaryPower'
        elif nodeName_ == 'SupportedLocaleListLink':
            obj_ = SupportedLocaleListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SupportedLocaleListLink = obj_
            obj_.original_tagname_ = 'SupportedLocaleListLink'
        elif nodeName_ == 'swActTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.swActTime = obj_
            obj_.original_tagname_ = 'swActTime'
        elif nodeName_ == 'swVer':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'swVer')
            value_ = self.gds_validate_string(value_, node, 'swVer')
            self.swVer = value_
            self.swVer_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.swVer)
        super(DeviceInformation, self)._buildChildren(child_, node, nodeName_, True)
# end class DeviceInformation


class Time(Resource):
    """Time -- Contains the representation of time, constantly updated.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    currentTime -- The current time, in the format defined by TimeType.
    dstEndTime -- Time at which daylight savings ends (dstOffset no longer applied).  Result of dstEndRule calculation.
    dstOffset -- Daylight savings time offset from local standard time. A typical practice is advancing clocks one hour when daylight savings time is in effect, which would result in a positive dstOffset.
    dstStartTime -- Time at which daylight savings begins (apply dstOffset).  Result of dstStartRule calculation.
    localTime -- Local time: localTime = currentTime + tzOffset (+ dstOffset when in effect).
    quality -- Metric indicating the quality of the time source from which the service acquired time. Lower (smaller) quality enumeration values are assumed to be more accurate.
    3 - time obtained from external authoritative source such as NTP
    4 - time obtained from level 3 source
    5 - time manually set or obtained from level 4 source
    6 - time obtained from level 5 source
    7 - time intentionally uncoordinated
    All other values are reserved for future use.
    tzOffset -- Local time zone offset from currentTime. Does not include any daylight savings time offsets. For American time zones, a negative tzOffset SHALL be used (eg, EST = GMT-5 which is -18000).
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, pollRate='900', currentTime=None, dstEndTime=None, dstOffset=None, dstStartTime=None, localTime=None, quality=None, tzOffset=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Time"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        self.currentTime = currentTime
        self.currentTime_nsprefix_ = None
        self.dstEndTime = dstEndTime
        self.dstEndTime_nsprefix_ = None
        self.dstOffset = dstOffset
        self.dstOffset_nsprefix_ = None
        self.dstStartTime = dstStartTime
        self.dstStartTime_nsprefix_ = None
        self.localTime = localTime
        self.localTime_nsprefix_ = None
        self.quality = quality
        self.validate_UInt8(self.quality)
        self.quality_nsprefix_ = None
        self.tzOffset = tzOffset
        self.tzOffset_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Time)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Time.subclass:
            return Time.subclass(*args_, **kwargs_)
        else:
            return Time(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_currentTime(self):
        return self.currentTime
    def set_currentTime(self, currentTime):
        self.currentTime = currentTime
    def get_dstEndTime(self):
        return self.dstEndTime
    def set_dstEndTime(self, dstEndTime):
        self.dstEndTime = dstEndTime
    def get_dstOffset(self):
        return self.dstOffset
    def set_dstOffset(self, dstOffset):
        self.dstOffset = dstOffset
    def get_dstStartTime(self):
        return self.dstStartTime
    def set_dstStartTime(self, dstStartTime):
        self.dstStartTime = dstStartTime
    def get_localTime(self):
        return self.localTime
    def set_localTime(self, localTime):
        self.localTime = localTime
    def get_quality(self):
        return self.quality
    def set_quality(self, quality):
        self.quality = quality
    def get_tzOffset(self):
        return self.tzOffset
    def set_tzOffset(self, tzOffset):
        self.tzOffset = tzOffset
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.currentTime is not None or
            self.dstEndTime is not None or
            self.dstOffset is not None or
            self.dstStartTime is not None or
            self.localTime is not None or
            self.quality is not None or
            self.tzOffset is not None or
            super(Time, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Time', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Time')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Time':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Time')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Time', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Time'):
        super(Time, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Time')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Time', fromsubclass_=False, pretty_print=True):
        super(Time, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.currentTime is not None:
            namespaceprefix_ = self.currentTime_nsprefix_ + ':' if (UseCapturedNS_ and self.currentTime_nsprefix_) else ''
            self.currentTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='currentTime', pretty_print=pretty_print)
        if self.dstEndTime is not None:
            namespaceprefix_ = self.dstEndTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dstEndTime_nsprefix_) else ''
            self.dstEndTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dstEndTime', pretty_print=pretty_print)
        if self.dstOffset is not None:
            namespaceprefix_ = self.dstOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.dstOffset_nsprefix_) else ''
            self.dstOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dstOffset', pretty_print=pretty_print)
        if self.dstStartTime is not None:
            namespaceprefix_ = self.dstStartTime_nsprefix_ + ':' if (UseCapturedNS_ and self.dstStartTime_nsprefix_) else ''
            self.dstStartTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dstStartTime', pretty_print=pretty_print)
        if self.localTime is not None:
            namespaceprefix_ = self.localTime_nsprefix_ + ':' if (UseCapturedNS_ and self.localTime_nsprefix_) else ''
            self.localTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='localTime', pretty_print=pretty_print)
        if self.quality is not None:
            namespaceprefix_ = self.quality_nsprefix_ + ':' if (UseCapturedNS_ and self.quality_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%squality>%s</%squality>%s' % (namespaceprefix_ , self.gds_format_integer(self.quality, input_name='quality'), namespaceprefix_ , eol_))
        if self.tzOffset is not None:
            namespaceprefix_ = self.tzOffset_nsprefix_ + ':' if (UseCapturedNS_ and self.tzOffset_nsprefix_) else ''
            self.tzOffset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='tzOffset', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(Time, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'currentTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.currentTime = obj_
            obj_.original_tagname_ = 'currentTime'
        elif nodeName_ == 'dstEndTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dstEndTime = obj_
            obj_.original_tagname_ = 'dstEndTime'
        elif nodeName_ == 'dstOffset':
            obj_ = TimeOffsetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dstOffset = obj_
            obj_.original_tagname_ = 'dstOffset'
        elif nodeName_ == 'dstStartTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dstStartTime = obj_
            obj_.original_tagname_ = 'dstStartTime'
        elif nodeName_ == 'localTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.localTime = obj_
            obj_.original_tagname_ = 'localTime'
        elif nodeName_ == 'quality' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'quality')
            ival_ = self.gds_validate_integer(ival_, node, 'quality')
            self.quality = ival_
            self.quality_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.quality)
        elif nodeName_ == 'tzOffset':
            obj_ = TimeOffsetType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.tzOffset = obj_
            obj_.original_tagname_ = 'tzOffset'
        super(Time, self)._buildChildren(child_, node, nodeName_, True)
# end class Time


class ResponseSetList(List):
    """ResponseSetList -- A List element to hold ResponseSet objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, pollRate='900', ResponseSet=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ResponseSetList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if ResponseSet is None:
            self.ResponseSet = []
        else:
            self.ResponseSet = ResponseSet
        self.ResponseSet_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseSetList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseSetList.subclass:
            return ResponseSetList.subclass(*args_, **kwargs_)
        else:
            return ResponseSetList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResponseSet(self):
        return self.ResponseSet
    def set_ResponseSet(self, ResponseSet):
        self.ResponseSet = ResponseSet
    def add_ResponseSet(self, value):
        self.ResponseSet.append(value)
    def insert_ResponseSet_at(self, index, value):
        self.ResponseSet.insert(index, value)
    def replace_ResponseSet_at(self, index, value):
        self.ResponseSet[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.ResponseSet or
            super(ResponseSetList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ResponseSetList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseSetList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResponseSetList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseSetList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResponseSetList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResponseSetList'):
        super(ResponseSetList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseSetList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ResponseSetList', fromsubclass_=False, pretty_print=True):
        super(ResponseSetList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ResponseSet_ in self.ResponseSet:
            namespaceprefix_ = self.ResponseSet_nsprefix_ + ':' if (UseCapturedNS_ and self.ResponseSet_nsprefix_) else ''
            ResponseSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResponseSet', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(ResponseSetList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResponseSet':
            obj_ = ResponseSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResponseSet.append(obj_)
            obj_.original_tagname_ = 'ResponseSet'
        super(ResponseSetList, self)._buildChildren(child_, node, nodeName_, True)
# end class ResponseSetList


class ResponseSet(IdentifiedObject):
    """ResponseSet -- A container for a ResponseList.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, ResponseListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ResponseSet"), self).__init__( **kwargs_)
        self.ResponseListLink = ResponseListLink
        self.ResponseListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseSet.subclass:
            return ResponseSet.subclass(*args_, **kwargs_)
        else:
            return ResponseSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ResponseListLink(self):
        return self.ResponseListLink
    def set_ResponseListLink(self, ResponseListLink):
        self.ResponseListLink = ResponseListLink
    def _hasContent(self):
        if (
            self.ResponseListLink is not None or
            super(ResponseSet, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ResponseSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResponseSet':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseSet')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResponseSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResponseSet'):
        super(ResponseSet, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseSet')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ResponseSet', fromsubclass_=False, pretty_print=True):
        super(ResponseSet, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ResponseListLink is not None:
            namespaceprefix_ = self.ResponseListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ResponseListLink_nsprefix_) else ''
            self.ResponseListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResponseListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ResponseSet, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ResponseListLink':
            obj_ = ResponseListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResponseListLink = obj_
            obj_.original_tagname_ = 'ResponseListLink'
        super(ResponseSet, self)._buildChildren(child_, node, nodeName_, True)
# end class ResponseSet


class ResponseList(List):
    """ResponseList -- A List element to hold Response objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, Response=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ResponseList"), self).__init__( **kwargs_)
        if Response is None:
            self.Response = []
        else:
            self.Response = Response
        self.Response_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ResponseList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ResponseList.subclass:
            return ResponseList.subclass(*args_, **kwargs_)
        else:
            return ResponseList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Response(self):
        return self.Response
    def set_Response(self, Response):
        self.Response = Response
    def add_Response(self, value):
        self.Response.append(value)
    def insert_Response_at(self, index, value):
        self.Response.insert(index, value)
    def replace_Response_at(self, index, value):
        self.Response[index] = value
    def _hasContent(self):
        if (
            self.Response or
            super(ResponseList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ResponseList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ResponseList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ResponseList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ResponseList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ResponseList'):
        super(ResponseList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ResponseList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ResponseList', fromsubclass_=False, pretty_print=True):
        super(ResponseList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Response_ in self.Response:
            namespaceprefix_ = self.Response_nsprefix_ + ':' if (UseCapturedNS_ and self.Response_nsprefix_) else ''
            Response_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Response', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ResponseList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Response':
            class_obj_ = self.get_class_obj_(child_, Response)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Response.append(obj_)
            obj_.original_tagname_ = 'Response'
        super(ResponseList, self)._buildChildren(child_, node, nodeName_, True)
# end class ResponseList


class Response(Resource):
    """Response -- The Response object is the generic response data repository which is extended for specific function sets.
    createdDateTime -- The createdDateTime field contains the date and time when the acknowledgement/status occurred in the client. The client will provide the timestamp to ensure the proper time is captured in case the response is delayed in reaching the server (server receipt time would not be the same as the actual confirmation time). The time reported from the client should be relative to the time server indicated by the FunctionSetAssignment that also indicated the event resource; if no FunctionSetAssignment exists, the time of the server where the event resource was hosted.
    endDeviceLFDI -- Contains the LFDI of the device providing the response.
    status -- The status field contains the acknowledgement or status. Each event type (DRLC, DER, Price, or Text) can return different status information (e.g. an Acknowledge will be returned for a Price event where a DRLC event can return Event Received, Event Started, and Event Completed). The Status field value definitions are defined in Table 27: Response Types by Function Set.
    subject -- The subject field provides a method to match the response with the originating event. It is populated with the mRID of the original object.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, createdDateTime=None, endDeviceLFDI=None, status=None, subject=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Response"), self).__init__( **kwargs_)
        self.createdDateTime = createdDateTime
        self.createdDateTime_nsprefix_ = None
        self.endDeviceLFDI = endDeviceLFDI
        self.validate_HexBinary160(self.endDeviceLFDI)
        self.endDeviceLFDI_nsprefix_ = None
        self.status = status
        self.validate_UInt8(self.status)
        self.status_nsprefix_ = None
        self.subject = subject
        self.subject_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Response)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Response.subclass:
            return Response.subclass(*args_, **kwargs_)
        else:
            return Response(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_createdDateTime(self):
        return self.createdDateTime
    def set_createdDateTime(self, createdDateTime):
        self.createdDateTime = createdDateTime
    def get_endDeviceLFDI(self):
        return self.endDeviceLFDI
    def set_endDeviceLFDI(self, endDeviceLFDI):
        self.endDeviceLFDI = endDeviceLFDI
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def get_subject(self):
        return self.subject
    def set_subject(self, subject):
        self.subject = subject
    def validate_HexBinary160(self, value):
        result = True
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary160' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.createdDateTime is not None or
            self.endDeviceLFDI is not None or
            self.status is not None or
            self.subject is not None or
            super(Response, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Response', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Response')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Response':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Response')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Response', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Response'):
        super(Response, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Response')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Response', fromsubclass_=False, pretty_print=True):
        super(Response, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.createdDateTime is not None:
            namespaceprefix_ = self.createdDateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.createdDateTime_nsprefix_) else ''
            self.createdDateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='createdDateTime', pretty_print=pretty_print)
        if self.endDeviceLFDI is not None:
            namespaceprefix_ = self.endDeviceLFDI_nsprefix_ + ':' if (UseCapturedNS_ and self.endDeviceLFDI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sendDeviceLFDI>%s</%sendDeviceLFDI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.endDeviceLFDI), input_name='endDeviceLFDI')), namespaceprefix_ , eol_))
        if self.status is not None:
            namespaceprefix_ = self.status_nsprefix_ + ':' if (UseCapturedNS_ and self.status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.status, input_name='status'), namespaceprefix_ , eol_))
        if self.subject is not None:
            namespaceprefix_ = self.subject_nsprefix_ + ':' if (UseCapturedNS_ and self.subject_nsprefix_) else ''
            self.subject.export(outfile, level, namespaceprefix_, namespacedef_='', name_='subject', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Response, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'createdDateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.createdDateTime = obj_
            obj_.original_tagname_ = 'createdDateTime'
        elif nodeName_ == 'endDeviceLFDI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'endDeviceLFDI')
            value_ = self.gds_validate_string(value_, node, 'endDeviceLFDI')
            self.endDeviceLFDI = value_
            self.endDeviceLFDI_nsprefix_ = child_.prefix
            # validate type HexBinary160
            self.validate_HexBinary160(self.endDeviceLFDI)
        elif nodeName_ == 'status' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'status')
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
            self.status_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.status)
        elif nodeName_ == 'subject':
            obj_ = mRIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.subject = obj_
            obj_.original_tagname_ = 'subject'
        super(Response, self)._buildChildren(child_, node, nodeName_, True)
# end class Response


class PriceResponse(Response):
    """PriceResponse -- A response related to a price message.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Response
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("PriceResponse"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, PriceResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if PriceResponse.subclass:
            return PriceResponse.subclass(*args_, **kwargs_)
        else:
            return PriceResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(PriceResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PriceResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('PriceResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'PriceResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PriceResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='PriceResponse', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='PriceResponse'):
        super(PriceResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='PriceResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='PriceResponse', fromsubclass_=False, pretty_print=True):
        super(PriceResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(PriceResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(PriceResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class PriceResponse


class DrResponse(Response):
    """DrResponse -- A response to a Demand Response Load Control (EndDeviceControl) message.
    overrideDuration -- Indicates the amount of time, in seconds, that the client partially opts-out during the demand response event. When overriding within the allowed override duration, the client SHALL send a partial opt-out (Response status code 8) for partial opt-out upon completion, with the total time the event was overridden (this attribute) populated. The client SHALL send a no participation status response (status type 10) if the user partially opts-out for longer than EndDeviceControl.overrideDuration.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Response
    def __init__(self, ApplianceLoadReduction=None, AppliedTargetReduction=None, DutyCycle=None, Offset=None, overrideDuration=None, SetPoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DrResponse"), self).__init__( **kwargs_)
        self.ApplianceLoadReduction = ApplianceLoadReduction
        self.ApplianceLoadReduction_nsprefix_ = None
        self.AppliedTargetReduction = AppliedTargetReduction
        self.AppliedTargetReduction_nsprefix_ = None
        self.DutyCycle = DutyCycle
        self.DutyCycle_nsprefix_ = None
        self.Offset = Offset
        self.Offset_nsprefix_ = None
        self.overrideDuration = overrideDuration
        self.validate_UInt16(self.overrideDuration)
        self.overrideDuration_nsprefix_ = None
        self.SetPoint = SetPoint
        self.SetPoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DrResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DrResponse.subclass:
            return DrResponse.subclass(*args_, **kwargs_)
        else:
            return DrResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ApplianceLoadReduction(self):
        return self.ApplianceLoadReduction
    def set_ApplianceLoadReduction(self, ApplianceLoadReduction):
        self.ApplianceLoadReduction = ApplianceLoadReduction
    def get_AppliedTargetReduction(self):
        return self.AppliedTargetReduction
    def set_AppliedTargetReduction(self, AppliedTargetReduction):
        self.AppliedTargetReduction = AppliedTargetReduction
    def get_DutyCycle(self):
        return self.DutyCycle
    def set_DutyCycle(self, DutyCycle):
        self.DutyCycle = DutyCycle
    def get_Offset(self):
        return self.Offset
    def set_Offset(self, Offset):
        self.Offset = Offset
    def get_overrideDuration(self):
        return self.overrideDuration
    def set_overrideDuration(self, overrideDuration):
        self.overrideDuration = overrideDuration
    def get_SetPoint(self):
        return self.SetPoint
    def set_SetPoint(self, SetPoint):
        self.SetPoint = SetPoint
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.ApplianceLoadReduction is not None or
            self.AppliedTargetReduction is not None or
            self.DutyCycle is not None or
            self.Offset is not None or
            self.overrideDuration is not None or
            self.SetPoint is not None or
            super(DrResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DrResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DrResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DrResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DrResponse', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DrResponse'):
        super(DrResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DrResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DrResponse', fromsubclass_=False, pretty_print=True):
        super(DrResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ApplianceLoadReduction is not None:
            namespaceprefix_ = self.ApplianceLoadReduction_nsprefix_ + ':' if (UseCapturedNS_ and self.ApplianceLoadReduction_nsprefix_) else ''
            self.ApplianceLoadReduction.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ApplianceLoadReduction', pretty_print=pretty_print)
        if self.AppliedTargetReduction is not None:
            namespaceprefix_ = self.AppliedTargetReduction_nsprefix_ + ':' if (UseCapturedNS_ and self.AppliedTargetReduction_nsprefix_) else ''
            self.AppliedTargetReduction.export(outfile, level, namespaceprefix_, namespacedef_='', name_='AppliedTargetReduction', pretty_print=pretty_print)
        if self.DutyCycle is not None:
            namespaceprefix_ = self.DutyCycle_nsprefix_ + ':' if (UseCapturedNS_ and self.DutyCycle_nsprefix_) else ''
            self.DutyCycle.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DutyCycle', pretty_print=pretty_print)
        if self.Offset is not None:
            namespaceprefix_ = self.Offset_nsprefix_ + ':' if (UseCapturedNS_ and self.Offset_nsprefix_) else ''
            self.Offset.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Offset', pretty_print=pretty_print)
        if self.overrideDuration is not None:
            namespaceprefix_ = self.overrideDuration_nsprefix_ + ':' if (UseCapturedNS_ and self.overrideDuration_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%soverrideDuration>%s</%soverrideDuration>%s' % (namespaceprefix_ , self.gds_format_integer(self.overrideDuration, input_name='overrideDuration'), namespaceprefix_ , eol_))
        if self.SetPoint is not None:
            namespaceprefix_ = self.SetPoint_nsprefix_ + ':' if (UseCapturedNS_ and self.SetPoint_nsprefix_) else ''
            self.SetPoint.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SetPoint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DrResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ApplianceLoadReduction':
            obj_ = ApplianceLoadReduction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ApplianceLoadReduction = obj_
            obj_.original_tagname_ = 'ApplianceLoadReduction'
        elif nodeName_ == 'AppliedTargetReduction':
            obj_ = AppliedTargetReduction.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.AppliedTargetReduction = obj_
            obj_.original_tagname_ = 'AppliedTargetReduction'
        elif nodeName_ == 'DutyCycle':
            obj_ = DutyCycle.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DutyCycle = obj_
            obj_.original_tagname_ = 'DutyCycle'
        elif nodeName_ == 'Offset':
            obj_ = Offset.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Offset = obj_
            obj_.original_tagname_ = 'Offset'
        elif nodeName_ == 'overrideDuration' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'overrideDuration')
            ival_ = self.gds_validate_integer(ival_, node, 'overrideDuration')
            self.overrideDuration = ival_
            self.overrideDuration_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.overrideDuration)
        elif nodeName_ == 'SetPoint':
            obj_ = SetPoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SetPoint = obj_
            obj_.original_tagname_ = 'SetPoint'
        super(DrResponse, self)._buildChildren(child_, node, nodeName_, True)
# end class DrResponse


class FlowReservationResponseResponse(Response):
    """FlowReservationResponseResponse -- A response to a FlowReservationResponse
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Response
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FlowReservationResponseResponse"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FlowReservationResponseResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FlowReservationResponseResponse.subclass:
            return FlowReservationResponseResponse.subclass(*args_, **kwargs_)
        else:
            return FlowReservationResponseResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(FlowReservationResponseResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlowReservationResponseResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FlowReservationResponseResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FlowReservationResponseResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationResponseResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FlowReservationResponseResponse', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FlowReservationResponseResponse'):
        super(FlowReservationResponseResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FlowReservationResponseResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='FlowReservationResponseResponse', fromsubclass_=False, pretty_print=True):
        super(FlowReservationResponseResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FlowReservationResponseResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(FlowReservationResponseResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class FlowReservationResponseResponse


class DERControlResponse(Response):
    """DERControlResponse -- A response to a DERControl
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Response
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DERControlResponse"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DERControlResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DERControlResponse.subclass:
            return DERControlResponse.subclass(*args_, **kwargs_)
        else:
            return DERControlResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(DERControlResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERControlResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DERControlResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DERControlResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControlResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DERControlResponse', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DERControlResponse'):
        super(DERControlResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DERControlResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='DERControlResponse', fromsubclass_=False, pretty_print=True):
        super(DERControlResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(DERControlResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(DERControlResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class DERControlResponse


class NotificationList(List):
    """NotificationList -- A List element to hold Notification objects.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, Notification=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("NotificationList"), self).__init__( **kwargs_)
        if Notification is None:
            self.Notification = []
        else:
            self.Notification = Notification
        self.Notification_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, NotificationList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if NotificationList.subclass:
            return NotificationList.subclass(*args_, **kwargs_)
        else:
            return NotificationList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Notification(self):
        return self.Notification
    def set_Notification(self, Notification):
        self.Notification = Notification
    def add_Notification(self, value):
        self.Notification.append(value)
    def insert_Notification_at(self, index, value):
        self.Notification.insert(index, value)
    def replace_Notification_at(self, index, value):
        self.Notification[index] = value
    def _hasContent(self):
        if (
            self.Notification or
            super(NotificationList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='NotificationList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('NotificationList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'NotificationList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NotificationList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='NotificationList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='NotificationList'):
        super(NotificationList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='NotificationList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='NotificationList', fromsubclass_=False, pretty_print=True):
        super(NotificationList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Notification_ in self.Notification:
            namespaceprefix_ = self.Notification_nsprefix_ + ':' if (UseCapturedNS_ and self.Notification_nsprefix_) else ''
            Notification_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Notification', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(NotificationList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Notification':
            obj_ = Notification.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Notification.append(obj_)
            obj_.original_tagname_ = 'Notification'
        super(NotificationList, self)._buildChildren(child_, node, nodeName_, True)
# end class NotificationList


class SubscriptionList(List):
    """SubscriptionList -- A List element to hold Subscription objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, pollRate='900', Subscription=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubscriptionList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if Subscription is None:
            self.Subscription = []
        else:
            self.Subscription = Subscription
        self.Subscription_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubscriptionList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubscriptionList.subclass:
            return SubscriptionList.subclass(*args_, **kwargs_)
        else:
            return SubscriptionList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Subscription(self):
        return self.Subscription
    def set_Subscription(self, Subscription):
        self.Subscription = Subscription
    def add_Subscription(self, value):
        self.Subscription.append(value)
    def insert_Subscription_at(self, index, value):
        self.Subscription.insert(index, value)
    def replace_Subscription_at(self, index, value):
        self.Subscription[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.Subscription or
            super(SubscriptionList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SubscriptionList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubscriptionList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubscriptionList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscriptionList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubscriptionList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubscriptionList'):
        super(SubscriptionList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscriptionList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SubscriptionList', fromsubclass_=False, pretty_print=True):
        super(SubscriptionList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Subscription_ in self.Subscription:
            namespaceprefix_ = self.Subscription_nsprefix_ + ':' if (UseCapturedNS_ and self.Subscription_nsprefix_) else ''
            Subscription_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Subscription', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(SubscriptionList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Subscription':
            obj_ = Subscription.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Subscription.append(obj_)
            obj_.original_tagname_ = 'Subscription'
        super(SubscriptionList, self)._buildChildren(child_, node, nodeName_, True)
# end class SubscriptionList


class SubscriptionBase(Resource):
    """SubscriptionBase -- Holds the information related to a client subscription to receive updates to a resource automatically. The actual resources may be passed in the Notification by specifying a specific xsi:type for the Resource and passing the full representation.
    subscribedResource -- The resource for which the subscription applies. Query string parameters SHALL NOT be specified when subscribing to list resources.  Should a query string parameter be specified, servers SHALL ignore them.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, subscribedResource=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SubscriptionBase"), self).__init__( **kwargs_)
        self.subscribedResource = subscribedResource
        self.subscribedResource_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SubscriptionBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SubscriptionBase.subclass:
            return SubscriptionBase.subclass(*args_, **kwargs_)
        else:
            return SubscriptionBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_subscribedResource(self):
        return self.subscribedResource
    def set_subscribedResource(self, subscribedResource):
        self.subscribedResource = subscribedResource
    def _hasContent(self):
        if (
            self.subscribedResource is not None or
            super(SubscriptionBase, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SubscriptionBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SubscriptionBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SubscriptionBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscriptionBase')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SubscriptionBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SubscriptionBase'):
        super(SubscriptionBase, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SubscriptionBase')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='SubscriptionBase', fromsubclass_=False, pretty_print=True):
        super(SubscriptionBase, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.subscribedResource is not None:
            namespaceprefix_ = self.subscribedResource_nsprefix_ + ':' if (UseCapturedNS_ and self.subscribedResource_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubscribedResource>%s</%ssubscribedResource>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.subscribedResource), input_name='subscribedResource')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(SubscriptionBase, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'subscribedResource':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subscribedResource')
            value_ = self.gds_validate_string(value_, node, 'subscribedResource')
            self.subscribedResource = value_
            self.subscribedResource_nsprefix_ = child_.prefix
        super(SubscriptionBase, self)._buildChildren(child_, node, nodeName_, True)
# end class SubscriptionBase


class FunctionSetAssignmentsList(SubscribableList):
    """FunctionSetAssignmentsList -- A List element to hold FunctionSetAssignments objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', FunctionSetAssignments=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FunctionSetAssignmentsList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if FunctionSetAssignments is None:
            self.FunctionSetAssignments = []
        else:
            self.FunctionSetAssignments = FunctionSetAssignments
        self.FunctionSetAssignments_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FunctionSetAssignmentsList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FunctionSetAssignmentsList.subclass:
            return FunctionSetAssignmentsList.subclass(*args_, **kwargs_)
        else:
            return FunctionSetAssignmentsList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_FunctionSetAssignments(self):
        return self.FunctionSetAssignments
    def set_FunctionSetAssignments(self, FunctionSetAssignments):
        self.FunctionSetAssignments = FunctionSetAssignments
    def add_FunctionSetAssignments(self, value):
        self.FunctionSetAssignments.append(value)
    def insert_FunctionSetAssignments_at(self, index, value):
        self.FunctionSetAssignments.insert(index, value)
    def replace_FunctionSetAssignments_at(self, index, value):
        self.FunctionSetAssignments[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.FunctionSetAssignments or
            super(FunctionSetAssignmentsList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FunctionSetAssignmentsList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FunctionSetAssignmentsList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FunctionSetAssignmentsList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FunctionSetAssignmentsList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FunctionSetAssignmentsList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FunctionSetAssignmentsList'):
        super(FunctionSetAssignmentsList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FunctionSetAssignmentsList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FunctionSetAssignmentsList', fromsubclass_=False, pretty_print=True):
        super(FunctionSetAssignmentsList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FunctionSetAssignments_ in self.FunctionSetAssignments:
            namespaceprefix_ = self.FunctionSetAssignments_nsprefix_ + ':' if (UseCapturedNS_ and self.FunctionSetAssignments_nsprefix_) else ''
            FunctionSetAssignments_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FunctionSetAssignments', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(FunctionSetAssignmentsList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'FunctionSetAssignments':
            obj_ = FunctionSetAssignments.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FunctionSetAssignments.append(obj_)
            obj_.original_tagname_ = 'FunctionSetAssignments'
        super(FunctionSetAssignmentsList, self)._buildChildren(child_, node, nodeName_, True)
# end class FunctionSetAssignmentsList


class FunctionSetAssignmentsBase(Resource):
    """FunctionSetAssignmentsBase -- Defines a collection of function set instances that are to be used by one or more devices as indicated by the EndDevice object(s) of the server.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, CustomerAccountListLink=None, DemandResponseProgramListLink=None, DERProgramListLink=None, FileListLink=None, MessagingProgramListLink=None, PrepaymentListLink=None, ResponseSetListLink=None, TariffProfileListLink=None, TimeLink=None, UsagePointListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FunctionSetAssignmentsBase"), self).__init__( **kwargs_)
        self.CustomerAccountListLink = CustomerAccountListLink
        self.CustomerAccountListLink_nsprefix_ = None
        self.DemandResponseProgramListLink = DemandResponseProgramListLink
        self.DemandResponseProgramListLink_nsprefix_ = None
        self.DERProgramListLink = DERProgramListLink
        self.DERProgramListLink_nsprefix_ = None
        self.FileListLink = FileListLink
        self.FileListLink_nsprefix_ = None
        self.MessagingProgramListLink = MessagingProgramListLink
        self.MessagingProgramListLink_nsprefix_ = None
        self.PrepaymentListLink = PrepaymentListLink
        self.PrepaymentListLink_nsprefix_ = None
        self.ResponseSetListLink = ResponseSetListLink
        self.ResponseSetListLink_nsprefix_ = None
        self.TariffProfileListLink = TariffProfileListLink
        self.TariffProfileListLink_nsprefix_ = None
        self.TimeLink = TimeLink
        self.TimeLink_nsprefix_ = None
        self.UsagePointListLink = UsagePointListLink
        self.UsagePointListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FunctionSetAssignmentsBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FunctionSetAssignmentsBase.subclass:
            return FunctionSetAssignmentsBase.subclass(*args_, **kwargs_)
        else:
            return FunctionSetAssignmentsBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_CustomerAccountListLink(self):
        return self.CustomerAccountListLink
    def set_CustomerAccountListLink(self, CustomerAccountListLink):
        self.CustomerAccountListLink = CustomerAccountListLink
    def get_DemandResponseProgramListLink(self):
        return self.DemandResponseProgramListLink
    def set_DemandResponseProgramListLink(self, DemandResponseProgramListLink):
        self.DemandResponseProgramListLink = DemandResponseProgramListLink
    def get_DERProgramListLink(self):
        return self.DERProgramListLink
    def set_DERProgramListLink(self, DERProgramListLink):
        self.DERProgramListLink = DERProgramListLink
    def get_FileListLink(self):
        return self.FileListLink
    def set_FileListLink(self, FileListLink):
        self.FileListLink = FileListLink
    def get_MessagingProgramListLink(self):
        return self.MessagingProgramListLink
    def set_MessagingProgramListLink(self, MessagingProgramListLink):
        self.MessagingProgramListLink = MessagingProgramListLink
    def get_PrepaymentListLink(self):
        return self.PrepaymentListLink
    def set_PrepaymentListLink(self, PrepaymentListLink):
        self.PrepaymentListLink = PrepaymentListLink
    def get_ResponseSetListLink(self):
        return self.ResponseSetListLink
    def set_ResponseSetListLink(self, ResponseSetListLink):
        self.ResponseSetListLink = ResponseSetListLink
    def get_TariffProfileListLink(self):
        return self.TariffProfileListLink
    def set_TariffProfileListLink(self, TariffProfileListLink):
        self.TariffProfileListLink = TariffProfileListLink
    def get_TimeLink(self):
        return self.TimeLink
    def set_TimeLink(self, TimeLink):
        self.TimeLink = TimeLink
    def get_UsagePointListLink(self):
        return self.UsagePointListLink
    def set_UsagePointListLink(self, UsagePointListLink):
        self.UsagePointListLink = UsagePointListLink
    def _hasContent(self):
        if (
            self.CustomerAccountListLink is not None or
            self.DemandResponseProgramListLink is not None or
            self.DERProgramListLink is not None or
            self.FileListLink is not None or
            self.MessagingProgramListLink is not None or
            self.PrepaymentListLink is not None or
            self.ResponseSetListLink is not None or
            self.TariffProfileListLink is not None or
            self.TimeLink is not None or
            self.UsagePointListLink is not None or
            super(FunctionSetAssignmentsBase, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FunctionSetAssignmentsBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FunctionSetAssignmentsBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FunctionSetAssignmentsBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FunctionSetAssignmentsBase')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FunctionSetAssignmentsBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FunctionSetAssignmentsBase'):
        super(FunctionSetAssignmentsBase, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FunctionSetAssignmentsBase')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FunctionSetAssignmentsBase', fromsubclass_=False, pretty_print=True):
        super(FunctionSetAssignmentsBase, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CustomerAccountListLink is not None:
            namespaceprefix_ = self.CustomerAccountListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.CustomerAccountListLink_nsprefix_) else ''
            self.CustomerAccountListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='CustomerAccountListLink', pretty_print=pretty_print)
        if self.DemandResponseProgramListLink is not None:
            namespaceprefix_ = self.DemandResponseProgramListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DemandResponseProgramListLink_nsprefix_) else ''
            self.DemandResponseProgramListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DemandResponseProgramListLink', pretty_print=pretty_print)
        if self.DERProgramListLink is not None:
            namespaceprefix_ = self.DERProgramListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DERProgramListLink_nsprefix_) else ''
            self.DERProgramListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERProgramListLink', pretty_print=pretty_print)
        if self.FileListLink is not None:
            namespaceprefix_ = self.FileListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.FileListLink_nsprefix_) else ''
            self.FileListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FileListLink', pretty_print=pretty_print)
        if self.MessagingProgramListLink is not None:
            namespaceprefix_ = self.MessagingProgramListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.MessagingProgramListLink_nsprefix_) else ''
            self.MessagingProgramListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MessagingProgramListLink', pretty_print=pretty_print)
        if self.PrepaymentListLink is not None:
            namespaceprefix_ = self.PrepaymentListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.PrepaymentListLink_nsprefix_) else ''
            self.PrepaymentListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PrepaymentListLink', pretty_print=pretty_print)
        if self.ResponseSetListLink is not None:
            namespaceprefix_ = self.ResponseSetListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ResponseSetListLink_nsprefix_) else ''
            self.ResponseSetListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ResponseSetListLink', pretty_print=pretty_print)
        if self.TariffProfileListLink is not None:
            namespaceprefix_ = self.TariffProfileListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.TariffProfileListLink_nsprefix_) else ''
            self.TariffProfileListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TariffProfileListLink', pretty_print=pretty_print)
        if self.TimeLink is not None:
            namespaceprefix_ = self.TimeLink_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeLink_nsprefix_) else ''
            self.TimeLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeLink', pretty_print=pretty_print)
        if self.UsagePointListLink is not None:
            namespaceprefix_ = self.UsagePointListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.UsagePointListLink_nsprefix_) else ''
            self.UsagePointListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='UsagePointListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(FunctionSetAssignmentsBase, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'CustomerAccountListLink':
            obj_ = CustomerAccountListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.CustomerAccountListLink = obj_
            obj_.original_tagname_ = 'CustomerAccountListLink'
        elif nodeName_ == 'DemandResponseProgramListLink':
            obj_ = DemandResponseProgramListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DemandResponseProgramListLink = obj_
            obj_.original_tagname_ = 'DemandResponseProgramListLink'
        elif nodeName_ == 'DERProgramListLink':
            obj_ = DERProgramListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERProgramListLink = obj_
            obj_.original_tagname_ = 'DERProgramListLink'
        elif nodeName_ == 'FileListLink':
            obj_ = FileListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FileListLink = obj_
            obj_.original_tagname_ = 'FileListLink'
        elif nodeName_ == 'MessagingProgramListLink':
            obj_ = MessagingProgramListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MessagingProgramListLink = obj_
            obj_.original_tagname_ = 'MessagingProgramListLink'
        elif nodeName_ == 'PrepaymentListLink':
            obj_ = PrepaymentListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PrepaymentListLink = obj_
            obj_.original_tagname_ = 'PrepaymentListLink'
        elif nodeName_ == 'ResponseSetListLink':
            obj_ = ResponseSetListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ResponseSetListLink = obj_
            obj_.original_tagname_ = 'ResponseSetListLink'
        elif nodeName_ == 'TariffProfileListLink':
            obj_ = TariffProfileListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TariffProfileListLink = obj_
            obj_.original_tagname_ = 'TariffProfileListLink'
        elif nodeName_ == 'TimeLink':
            obj_ = TimeLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeLink = obj_
            obj_.original_tagname_ = 'TimeLink'
        elif nodeName_ == 'UsagePointListLink':
            obj_ = UsagePointListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.UsagePointListLink = obj_
            obj_.original_tagname_ = 'UsagePointListLink'
        super(FunctionSetAssignmentsBase, self)._buildChildren(child_, node, nodeName_, True)
# end class FunctionSetAssignmentsBase


class Registration(Resource):
    """Registration -- Registration represents an authorization to access the resources on a host.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    dateTimeRegistered -- Contains the time at which this registration was created, by which clients MAY prioritize information providers with the most recent registrations, when no additional direction from the consumer is available.
    pIN -- Contains the registration PIN number associated with the device, including the checksum digit.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, pollRate='900', dateTimeRegistered=None, pIN=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Registration"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        self.dateTimeRegistered = dateTimeRegistered
        self.dateTimeRegistered_nsprefix_ = None
        self.pIN = pIN
        self.pIN_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Registration)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Registration.subclass:
            return Registration.subclass(*args_, **kwargs_)
        else:
            return Registration(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_dateTimeRegistered(self):
        return self.dateTimeRegistered
    def set_dateTimeRegistered(self, dateTimeRegistered):
        self.dateTimeRegistered = dateTimeRegistered
    def get_pIN(self):
        return self.pIN
    def set_pIN(self, pIN):
        self.pIN = pIN
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.dateTimeRegistered is not None or
            self.pIN is not None or
            super(Registration, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Registration', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Registration')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Registration':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Registration')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Registration', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Registration'):
        super(Registration, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Registration')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Registration', fromsubclass_=False, pretty_print=True):
        super(Registration, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.dateTimeRegistered is not None:
            namespaceprefix_ = self.dateTimeRegistered_nsprefix_ + ':' if (UseCapturedNS_ and self.dateTimeRegistered_nsprefix_) else ''
            self.dateTimeRegistered.export(outfile, level, namespaceprefix_, namespacedef_='', name_='dateTimeRegistered', pretty_print=pretty_print)
        if self.pIN is not None:
            namespaceprefix_ = self.pIN_nsprefix_ + ':' if (UseCapturedNS_ and self.pIN_nsprefix_) else ''
            self.pIN.export(outfile, level, namespaceprefix_, namespacedef_='', name_='pIN', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(Registration, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'dateTimeRegistered':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.dateTimeRegistered = obj_
            obj_.original_tagname_ = 'dateTimeRegistered'
        elif nodeName_ == 'pIN':
            obj_ = PINType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.pIN = obj_
            obj_.original_tagname_ = 'pIN'
        super(Registration, self)._buildChildren(child_, node, nodeName_, True)
# end class Registration


class EndDeviceList(SubscribableList):
    """EndDeviceList -- A List element to hold EndDevice objects.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableList
    def __init__(self, pollRate='900', EndDevice=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EndDeviceList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if EndDevice is None:
            self.EndDevice = []
        else:
            self.EndDevice = EndDevice
        self.EndDevice_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndDeviceList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndDeviceList.subclass:
            return EndDeviceList.subclass(*args_, **kwargs_)
        else:
            return EndDeviceList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EndDevice(self):
        return self.EndDevice
    def set_EndDevice(self, EndDevice):
        self.EndDevice = EndDevice
    def add_EndDevice(self, value):
        self.EndDevice.append(value)
    def insert_EndDevice_at(self, index, value):
        self.EndDevice.insert(index, value)
    def replace_EndDevice_at(self, index, value):
        self.EndDevice[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.EndDevice or
            super(EndDeviceList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EndDeviceList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndDeviceList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndDeviceList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndDeviceList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndDeviceList'):
        super(EndDeviceList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDeviceList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EndDeviceList', fromsubclass_=False, pretty_print=True):
        super(EndDeviceList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EndDevice_ in self.EndDevice:
            namespaceprefix_ = self.EndDevice_nsprefix_ + ':' if (UseCapturedNS_ and self.EndDevice_nsprefix_) else ''
            EndDevice_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndDevice', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(EndDeviceList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EndDevice':
            obj_ = EndDevice.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndDevice.append(obj_)
            obj_.original_tagname_ = 'EndDevice'
        super(EndDeviceList, self)._buildChildren(child_, node, nodeName_, True)
# end class EndDeviceList


class DeviceStatus(Resource):
    """DeviceStatus -- Status of device
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    changedTime -- The time at which the reported values were recorded.
    onCount -- The number of times that the device has been turned on: Count of "device on" times, since the last time the counter was reset
    opState -- Device operational state:
    0 - Not applicable / Unknown
    1 - Not operating
    2 - Operating
    3 - Starting up
    4 - Shutting down
    5 - At disconnect level
    6 - kW ramping
    7 - kVar ramping
    opTime -- Total time device has operated: re-settable: Accumulated time in seconds since the last time the counter was reset.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Resource
    def __init__(self, pollRate='900', changedTime=None, onCount=None, opState=None, opTime=None, Temperature=None, TimeLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DeviceStatus"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        self.changedTime = changedTime
        self.changedTime_nsprefix_ = None
        self.onCount = onCount
        self.validate_UInt16(self.onCount)
        self.onCount_nsprefix_ = None
        self.opState = opState
        self.validate_UInt8(self.opState)
        self.opState_nsprefix_ = None
        self.opTime = opTime
        self.validate_UInt32(self.opTime)
        self.opTime_nsprefix_ = None
        if Temperature is None:
            self.Temperature = []
        else:
            self.Temperature = Temperature
        self.Temperature_nsprefix_ = None
        self.TimeLink = TimeLink
        self.TimeLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeviceStatus)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeviceStatus.subclass:
            return DeviceStatus.subclass(*args_, **kwargs_)
        else:
            return DeviceStatus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_changedTime(self):
        return self.changedTime
    def set_changedTime(self, changedTime):
        self.changedTime = changedTime
    def get_onCount(self):
        return self.onCount
    def set_onCount(self, onCount):
        self.onCount = onCount
    def get_opState(self):
        return self.opState
    def set_opState(self, opState):
        self.opState = opState
    def get_opTime(self):
        return self.opTime
    def set_opTime(self, opTime):
        self.opTime = opTime
    def get_Temperature(self):
        return self.Temperature
    def set_Temperature(self, Temperature):
        self.Temperature = Temperature
    def add_Temperature(self, value):
        self.Temperature.append(value)
    def insert_Temperature_at(self, index, value):
        self.Temperature.insert(index, value)
    def replace_Temperature_at(self, index, value):
        self.Temperature[index] = value
    def get_TimeLink(self):
        return self.TimeLink
    def set_TimeLink(self, TimeLink):
        self.TimeLink = TimeLink
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt16(self, value):
        result = True
        # Validate type UInt16, a restriction on xs:unsignedShort.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.changedTime is not None or
            self.onCount is not None or
            self.opState is not None or
            self.opTime is not None or
            self.Temperature or
            self.TimeLink is not None or
            super(DeviceStatus, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DeviceStatus', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeviceStatus')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeviceStatus':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceStatus')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeviceStatus', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DeviceStatus'):
        super(DeviceStatus, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceStatus')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DeviceStatus', fromsubclass_=False, pretty_print=True):
        super(DeviceStatus, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.changedTime is not None:
            namespaceprefix_ = self.changedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.changedTime_nsprefix_) else ''
            self.changedTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='changedTime', pretty_print=pretty_print)
        if self.onCount is not None:
            namespaceprefix_ = self.onCount_nsprefix_ + ':' if (UseCapturedNS_ and self.onCount_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sonCount>%s</%sonCount>%s' % (namespaceprefix_ , self.gds_format_integer(self.onCount, input_name='onCount'), namespaceprefix_ , eol_))
        if self.opState is not None:
            namespaceprefix_ = self.opState_nsprefix_ + ':' if (UseCapturedNS_ and self.opState_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopState>%s</%sopState>%s' % (namespaceprefix_ , self.gds_format_integer(self.opState, input_name='opState'), namespaceprefix_ , eol_))
        if self.opTime is not None:
            namespaceprefix_ = self.opTime_nsprefix_ + ':' if (UseCapturedNS_ and self.opTime_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sopTime>%s</%sopTime>%s' % (namespaceprefix_ , self.gds_format_integer(self.opTime, input_name='opTime'), namespaceprefix_ , eol_))
        for Temperature_ in self.Temperature:
            namespaceprefix_ = self.Temperature_nsprefix_ + ':' if (UseCapturedNS_ and self.Temperature_nsprefix_) else ''
            Temperature_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Temperature', pretty_print=pretty_print)
        if self.TimeLink is not None:
            namespaceprefix_ = self.TimeLink_nsprefix_ + ':' if (UseCapturedNS_ and self.TimeLink_nsprefix_) else ''
            self.TimeLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='TimeLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(DeviceStatus, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'changedTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.changedTime = obj_
            obj_.original_tagname_ = 'changedTime'
        elif nodeName_ == 'onCount' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'onCount')
            ival_ = self.gds_validate_integer(ival_, node, 'onCount')
            self.onCount = ival_
            self.onCount_nsprefix_ = child_.prefix
            # validate type UInt16
            self.validate_UInt16(self.onCount)
        elif nodeName_ == 'opState' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'opState')
            ival_ = self.gds_validate_integer(ival_, node, 'opState')
            self.opState = ival_
            self.opState_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.opState)
        elif nodeName_ == 'opTime' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'opTime')
            ival_ = self.gds_validate_integer(ival_, node, 'opTime')
            self.opTime = ival_
            self.opTime_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.opTime)
        elif nodeName_ == 'Temperature':
            obj_ = Temperature.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Temperature.append(obj_)
            obj_.original_tagname_ = 'Temperature'
        elif nodeName_ == 'TimeLink':
            obj_ = TimeLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.TimeLink = obj_
            obj_.original_tagname_ = 'TimeLink'
        super(DeviceStatus, self)._buildChildren(child_, node, nodeName_, True)
# end class DeviceStatus


class AbstractDevice(SubscribableResource):
    """AbstractDevice -- The EndDevice providing the resources available within the DeviceCapabilities.
    deviceCategory -- This field is for use in devices that can adjust energy usage (e.g., demand response, distributed energy resources).  For devices that do not respond to EndDeviceControls or DERControls (for instance, an ESI), this field should not have any bits set.
    lFDI -- Long form of device identifier. See the Security section for additional details.
    sFDI -- Short form of device identifier, WITH the checksum digit. See the Security section for additional details.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscribableResource
    def __init__(self, ConfigurationLink=None, DERListLink=None, deviceCategory=None, DeviceInformationLink=None, DeviceStatusLink=None, FileStatusLink=None, IPInterfaceListLink=None, lFDI=None, LoadShedAvailabilityListLink=None, LogEventListLink=None, PowerStatusLink=None, sFDI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("AbstractDevice"), self).__init__( **kwargs_)
        self.ConfigurationLink = ConfigurationLink
        self.ConfigurationLink_nsprefix_ = None
        self.DERListLink = DERListLink
        self.DERListLink_nsprefix_ = None
        self.deviceCategory = deviceCategory
        self.deviceCategory_nsprefix_ = None
        self.DeviceInformationLink = DeviceInformationLink
        self.DeviceInformationLink_nsprefix_ = None
        self.DeviceStatusLink = DeviceStatusLink
        self.DeviceStatusLink_nsprefix_ = None
        self.FileStatusLink = FileStatusLink
        self.FileStatusLink_nsprefix_ = None
        self.IPInterfaceListLink = IPInterfaceListLink
        self.IPInterfaceListLink_nsprefix_ = None
        self.lFDI = lFDI
        self.validate_HexBinary160(self.lFDI)
        self.lFDI_nsprefix_ = None
        self.LoadShedAvailabilityListLink = LoadShedAvailabilityListLink
        self.LoadShedAvailabilityListLink_nsprefix_ = None
        self.LogEventListLink = LogEventListLink
        self.LogEventListLink_nsprefix_ = None
        self.PowerStatusLink = PowerStatusLink
        self.PowerStatusLink_nsprefix_ = None
        self.sFDI = sFDI
        self.sFDI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, AbstractDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if AbstractDevice.subclass:
            return AbstractDevice.subclass(*args_, **kwargs_)
        else:
            return AbstractDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ConfigurationLink(self):
        return self.ConfigurationLink
    def set_ConfigurationLink(self, ConfigurationLink):
        self.ConfigurationLink = ConfigurationLink
    def get_DERListLink(self):
        return self.DERListLink
    def set_DERListLink(self, DERListLink):
        self.DERListLink = DERListLink
    def get_deviceCategory(self):
        return self.deviceCategory
    def set_deviceCategory(self, deviceCategory):
        self.deviceCategory = deviceCategory
    def get_DeviceInformationLink(self):
        return self.DeviceInformationLink
    def set_DeviceInformationLink(self, DeviceInformationLink):
        self.DeviceInformationLink = DeviceInformationLink
    def get_DeviceStatusLink(self):
        return self.DeviceStatusLink
    def set_DeviceStatusLink(self, DeviceStatusLink):
        self.DeviceStatusLink = DeviceStatusLink
    def get_FileStatusLink(self):
        return self.FileStatusLink
    def set_FileStatusLink(self, FileStatusLink):
        self.FileStatusLink = FileStatusLink
    def get_IPInterfaceListLink(self):
        return self.IPInterfaceListLink
    def set_IPInterfaceListLink(self, IPInterfaceListLink):
        self.IPInterfaceListLink = IPInterfaceListLink
    def get_lFDI(self):
        return self.lFDI
    def set_lFDI(self, lFDI):
        self.lFDI = lFDI
    def get_LoadShedAvailabilityListLink(self):
        return self.LoadShedAvailabilityListLink
    def set_LoadShedAvailabilityListLink(self, LoadShedAvailabilityListLink):
        self.LoadShedAvailabilityListLink = LoadShedAvailabilityListLink
    def get_LogEventListLink(self):
        return self.LogEventListLink
    def set_LogEventListLink(self, LogEventListLink):
        self.LogEventListLink = LogEventListLink
    def get_PowerStatusLink(self):
        return self.PowerStatusLink
    def set_PowerStatusLink(self, PowerStatusLink):
        self.PowerStatusLink = PowerStatusLink
    def get_sFDI(self):
        return self.sFDI
    def set_sFDI(self, sFDI):
        self.sFDI = sFDI
    def validate_HexBinary160(self, value):
        result = True
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary160' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.ConfigurationLink is not None or
            self.DERListLink is not None or
            self.deviceCategory is not None or
            self.DeviceInformationLink is not None or
            self.DeviceStatusLink is not None or
            self.FileStatusLink is not None or
            self.IPInterfaceListLink is not None or
            self.lFDI is not None or
            self.LoadShedAvailabilityListLink is not None or
            self.LogEventListLink is not None or
            self.PowerStatusLink is not None or
            self.sFDI is not None or
            super(AbstractDevice, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AbstractDevice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('AbstractDevice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'AbstractDevice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractDevice')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='AbstractDevice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='AbstractDevice'):
        super(AbstractDevice, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='AbstractDevice')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='AbstractDevice', fromsubclass_=False, pretty_print=True):
        super(AbstractDevice, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConfigurationLink is not None:
            namespaceprefix_ = self.ConfigurationLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ConfigurationLink_nsprefix_) else ''
            self.ConfigurationLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ConfigurationLink', pretty_print=pretty_print)
        if self.DERListLink is not None:
            namespaceprefix_ = self.DERListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DERListLink_nsprefix_) else ''
            self.DERListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DERListLink', pretty_print=pretty_print)
        if self.deviceCategory is not None:
            namespaceprefix_ = self.deviceCategory_nsprefix_ + ':' if (UseCapturedNS_ and self.deviceCategory_nsprefix_) else ''
            self.deviceCategory.export(outfile, level, namespaceprefix_, namespacedef_='', name_='deviceCategory', pretty_print=pretty_print)
        if self.DeviceInformationLink is not None:
            namespaceprefix_ = self.DeviceInformationLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DeviceInformationLink_nsprefix_) else ''
            self.DeviceInformationLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DeviceInformationLink', pretty_print=pretty_print)
        if self.DeviceStatusLink is not None:
            namespaceprefix_ = self.DeviceStatusLink_nsprefix_ + ':' if (UseCapturedNS_ and self.DeviceStatusLink_nsprefix_) else ''
            self.DeviceStatusLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='DeviceStatusLink', pretty_print=pretty_print)
        if self.FileStatusLink is not None:
            namespaceprefix_ = self.FileStatusLink_nsprefix_ + ':' if (UseCapturedNS_ and self.FileStatusLink_nsprefix_) else ''
            self.FileStatusLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FileStatusLink', pretty_print=pretty_print)
        if self.IPInterfaceListLink is not None:
            namespaceprefix_ = self.IPInterfaceListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.IPInterfaceListLink_nsprefix_) else ''
            self.IPInterfaceListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='IPInterfaceListLink', pretty_print=pretty_print)
        if self.lFDI is not None:
            namespaceprefix_ = self.lFDI_nsprefix_ + ':' if (UseCapturedNS_ and self.lFDI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slFDI>%s</%slFDI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.lFDI), input_name='lFDI')), namespaceprefix_ , eol_))
        if self.LoadShedAvailabilityListLink is not None:
            namespaceprefix_ = self.LoadShedAvailabilityListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.LoadShedAvailabilityListLink_nsprefix_) else ''
            self.LoadShedAvailabilityListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LoadShedAvailabilityListLink', pretty_print=pretty_print)
        if self.LogEventListLink is not None:
            namespaceprefix_ = self.LogEventListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.LogEventListLink_nsprefix_) else ''
            self.LogEventListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='LogEventListLink', pretty_print=pretty_print)
        if self.PowerStatusLink is not None:
            namespaceprefix_ = self.PowerStatusLink_nsprefix_ + ':' if (UseCapturedNS_ and self.PowerStatusLink_nsprefix_) else ''
            self.PowerStatusLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='PowerStatusLink', pretty_print=pretty_print)
        if self.sFDI is not None:
            namespaceprefix_ = self.sFDI_nsprefix_ + ':' if (UseCapturedNS_ and self.sFDI_nsprefix_) else ''
            self.sFDI.export(outfile, level, namespaceprefix_, namespacedef_='', name_='sFDI', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(AbstractDevice, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ConfigurationLink':
            obj_ = ConfigurationLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ConfigurationLink = obj_
            obj_.original_tagname_ = 'ConfigurationLink'
        elif nodeName_ == 'DERListLink':
            obj_ = DERListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DERListLink = obj_
            obj_.original_tagname_ = 'DERListLink'
        elif nodeName_ == 'deviceCategory':
            obj_ = DeviceCategoryType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.deviceCategory = obj_
            obj_.original_tagname_ = 'deviceCategory'
        elif nodeName_ == 'DeviceInformationLink':
            obj_ = DeviceInformationLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DeviceInformationLink = obj_
            obj_.original_tagname_ = 'DeviceInformationLink'
        elif nodeName_ == 'DeviceStatusLink':
            obj_ = DeviceStatusLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.DeviceStatusLink = obj_
            obj_.original_tagname_ = 'DeviceStatusLink'
        elif nodeName_ == 'FileStatusLink':
            obj_ = FileStatusLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FileStatusLink = obj_
            obj_.original_tagname_ = 'FileStatusLink'
        elif nodeName_ == 'IPInterfaceListLink':
            obj_ = IPInterfaceListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.IPInterfaceListLink = obj_
            obj_.original_tagname_ = 'IPInterfaceListLink'
        elif nodeName_ == 'lFDI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'lFDI')
            value_ = self.gds_validate_string(value_, node, 'lFDI')
            self.lFDI = value_
            self.lFDI_nsprefix_ = child_.prefix
            # validate type HexBinary160
            self.validate_HexBinary160(self.lFDI)
        elif nodeName_ == 'LoadShedAvailabilityListLink':
            obj_ = LoadShedAvailabilityListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LoadShedAvailabilityListLink = obj_
            obj_.original_tagname_ = 'LoadShedAvailabilityListLink'
        elif nodeName_ == 'LogEventListLink':
            obj_ = LogEventListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.LogEventListLink = obj_
            obj_.original_tagname_ = 'LogEventListLink'
        elif nodeName_ == 'PowerStatusLink':
            obj_ = PowerStatusLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.PowerStatusLink = obj_
            obj_.original_tagname_ = 'PowerStatusLink'
        elif nodeName_ == 'sFDI':
            obj_ = SFDIType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.sFDI = obj_
            obj_.original_tagname_ = 'sFDI'
        super(AbstractDevice, self)._buildChildren(child_, node, nodeName_, True)
# end class AbstractDevice


class DeviceCapability(FunctionSetAssignmentsBase):
    """DeviceCapability -- Returned by the URI provided by DNS-SD, to allow clients to find the URIs to the resources in which they are interested.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FunctionSetAssignmentsBase
    def __init__(self, pollRate='900', EndDeviceListLink=None, MirrorUsagePointListLink=None, SelfDeviceLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("DeviceCapability"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        self.EndDeviceListLink = EndDeviceListLink
        self.EndDeviceListLink_nsprefix_ = None
        self.MirrorUsagePointListLink = MirrorUsagePointListLink
        self.MirrorUsagePointListLink_nsprefix_ = None
        self.SelfDeviceLink = SelfDeviceLink
        self.SelfDeviceLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, DeviceCapability)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if DeviceCapability.subclass:
            return DeviceCapability.subclass(*args_, **kwargs_)
        else:
            return DeviceCapability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_EndDeviceListLink(self):
        return self.EndDeviceListLink
    def set_EndDeviceListLink(self, EndDeviceListLink):
        self.EndDeviceListLink = EndDeviceListLink
    def get_MirrorUsagePointListLink(self):
        return self.MirrorUsagePointListLink
    def set_MirrorUsagePointListLink(self, MirrorUsagePointListLink):
        self.MirrorUsagePointListLink = MirrorUsagePointListLink
    def get_SelfDeviceLink(self):
        return self.SelfDeviceLink
    def set_SelfDeviceLink(self, SelfDeviceLink):
        self.SelfDeviceLink = SelfDeviceLink
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.EndDeviceListLink is not None or
            self.MirrorUsagePointListLink is not None or
            self.SelfDeviceLink is not None or
            super(DeviceCapability, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DeviceCapability', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('DeviceCapability')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'DeviceCapability':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceCapability')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='DeviceCapability', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='DeviceCapability'):
        super(DeviceCapability, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='DeviceCapability')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='DeviceCapability', fromsubclass_=False, pretty_print=True):
        super(DeviceCapability, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EndDeviceListLink is not None:
            namespaceprefix_ = self.EndDeviceListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.EndDeviceListLink_nsprefix_) else ''
            self.EndDeviceListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='EndDeviceListLink', pretty_print=pretty_print)
        if self.MirrorUsagePointListLink is not None:
            namespaceprefix_ = self.MirrorUsagePointListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.MirrorUsagePointListLink_nsprefix_) else ''
            self.MirrorUsagePointListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MirrorUsagePointListLink', pretty_print=pretty_print)
        if self.SelfDeviceLink is not None:
            namespaceprefix_ = self.SelfDeviceLink_nsprefix_ + ':' if (UseCapturedNS_ and self.SelfDeviceLink_nsprefix_) else ''
            self.SelfDeviceLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SelfDeviceLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(DeviceCapability, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'EndDeviceListLink':
            obj_ = EndDeviceListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.EndDeviceListLink = obj_
            obj_.original_tagname_ = 'EndDeviceListLink'
        elif nodeName_ == 'MirrorUsagePointListLink':
            obj_ = MirrorUsagePointListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MirrorUsagePointListLink = obj_
            obj_.original_tagname_ = 'MirrorUsagePointListLink'
        elif nodeName_ == 'SelfDeviceLink':
            obj_ = SelfDeviceLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SelfDeviceLink = obj_
            obj_.original_tagname_ = 'SelfDeviceLink'
        super(DeviceCapability, self)._buildChildren(child_, node, nodeName_, True)
# end class DeviceCapability


class UsagePointBase(IdentifiedObject):
    """UsagePointBase -- Logical point on a network at which consumption or production is either physically measured (e.g. metered) or estimated (e.g. unmetered street lights). A container for associating ReadingType, Readings and ReadingSets.
    roleFlags -- Specifies the roles that apply to the usage point.
    serviceCategoryKind -- The kind of service provided by this usage point.
    status -- Specifies the current status of the service at this usage point.
    0 = off
    1 = on
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, roleFlags=None, serviceCategoryKind=None, status=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UsagePointBase"), self).__init__( **kwargs_)
        self.roleFlags = roleFlags
        self.roleFlags_nsprefix_ = None
        self.serviceCategoryKind = serviceCategoryKind
        self.serviceCategoryKind_nsprefix_ = None
        self.status = status
        self.validate_UInt8(self.status)
        self.status_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UsagePointBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UsagePointBase.subclass:
            return UsagePointBase.subclass(*args_, **kwargs_)
        else:
            return UsagePointBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_roleFlags(self):
        return self.roleFlags
    def set_roleFlags(self, roleFlags):
        self.roleFlags = roleFlags
    def get_serviceCategoryKind(self):
        return self.serviceCategoryKind
    def set_serviceCategoryKind(self, serviceCategoryKind):
        self.serviceCategoryKind = serviceCategoryKind
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.roleFlags is not None or
            self.serviceCategoryKind is not None or
            self.status is not None or
            super(UsagePointBase, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UsagePointBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UsagePointBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UsagePointBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePointBase')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UsagePointBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UsagePointBase'):
        super(UsagePointBase, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePointBase')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UsagePointBase', fromsubclass_=False, pretty_print=True):
        super(UsagePointBase, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.roleFlags is not None:
            namespaceprefix_ = self.roleFlags_nsprefix_ + ':' if (UseCapturedNS_ and self.roleFlags_nsprefix_) else ''
            self.roleFlags.export(outfile, level, namespaceprefix_, namespacedef_='', name_='roleFlags', pretty_print=pretty_print)
        if self.serviceCategoryKind is not None:
            namespaceprefix_ = self.serviceCategoryKind_nsprefix_ + ':' if (UseCapturedNS_ and self.serviceCategoryKind_nsprefix_) else ''
            self.serviceCategoryKind.export(outfile, level, namespaceprefix_, namespacedef_='', name_='serviceCategoryKind', pretty_print=pretty_print)
        if self.status is not None:
            namespaceprefix_ = self.status_nsprefix_ + ':' if (UseCapturedNS_ and self.status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.status, input_name='status'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(UsagePointBase, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'roleFlags':
            obj_ = RoleFlagsType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.roleFlags = obj_
            obj_.original_tagname_ = 'roleFlags'
        elif nodeName_ == 'serviceCategoryKind':
            obj_ = ServiceKind.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.serviceCategoryKind = obj_
            obj_.original_tagname_ = 'serviceCategoryKind'
        elif nodeName_ == 'status' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'status')
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
            self.status_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.status)
        super(UsagePointBase, self)._buildChildren(child_, node, nodeName_, True)
# end class UsagePointBase


class ReadingSetBase(IdentifiedObject):
    """ReadingSetBase -- A set of Readings of the ReadingType indicated by the parent MeterReading. ReadingBase is abstract, used to define the elements common to ReadingSet and IntervalBlock.
    timePeriod -- Specifies the time range during which the contained readings were taken.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, timePeriod=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingSetBase"), self).__init__( **kwargs_)
        self.timePeriod = timePeriod
        self.timePeriod_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingSetBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingSetBase.subclass:
            return ReadingSetBase.subclass(*args_, **kwargs_)
        else:
            return ReadingSetBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_timePeriod(self):
        return self.timePeriod
    def set_timePeriod(self, timePeriod):
        self.timePeriod = timePeriod
    def _hasContent(self):
        if (
            self.timePeriod is not None or
            super(ReadingSetBase, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingSetBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingSetBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingSetBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingSetBase')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingSetBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingSetBase'):
        super(ReadingSetBase, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingSetBase')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingSetBase', fromsubclass_=False, pretty_print=True):
        super(ReadingSetBase, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.timePeriod is not None:
            namespaceprefix_ = self.timePeriod_nsprefix_ + ':' if (UseCapturedNS_ and self.timePeriod_nsprefix_) else ''
            self.timePeriod.export(outfile, level, namespaceprefix_, namespacedef_='', name_='timePeriod', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingSetBase, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'timePeriod':
            obj_ = DateTimeInterval.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.timePeriod = obj_
            obj_.original_tagname_ = 'timePeriod'
        super(ReadingSetBase, self)._buildChildren(child_, node, nodeName_, True)
# end class ReadingSetBase


class MirrorUsagePointList(List):
    """MirrorUsagePointList -- A List of MirrorUsagePoint instances.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, pollRate='900', MirrorUsagePoint=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MirrorUsagePointList"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
        if MirrorUsagePoint is None:
            self.MirrorUsagePoint = []
        else:
            self.MirrorUsagePoint = MirrorUsagePoint
        self.MirrorUsagePoint_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MirrorUsagePointList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MirrorUsagePointList.subclass:
            return MirrorUsagePointList.subclass(*args_, **kwargs_)
        else:
            return MirrorUsagePointList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MirrorUsagePoint(self):
        return self.MirrorUsagePoint
    def set_MirrorUsagePoint(self, MirrorUsagePoint):
        self.MirrorUsagePoint = MirrorUsagePoint
    def add_MirrorUsagePoint(self, value):
        self.MirrorUsagePoint.append(value)
    def insert_MirrorUsagePoint_at(self, index, value):
        self.MirrorUsagePoint.insert(index, value)
    def replace_MirrorUsagePoint_at(self, index, value):
        self.MirrorUsagePoint[index] = value
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.MirrorUsagePoint or
            super(MirrorUsagePointList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorUsagePointList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MirrorUsagePointList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MirrorUsagePointList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorUsagePointList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MirrorUsagePointList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MirrorUsagePointList'):
        super(MirrorUsagePointList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorUsagePointList')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorUsagePointList', fromsubclass_=False, pretty_print=True):
        super(MirrorUsagePointList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MirrorUsagePoint_ in self.MirrorUsagePoint:
            namespaceprefix_ = self.MirrorUsagePoint_nsprefix_ + ':' if (UseCapturedNS_ and self.MirrorUsagePoint_nsprefix_) else ''
            MirrorUsagePoint_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MirrorUsagePoint', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(MirrorUsagePointList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MirrorUsagePoint':
            obj_ = MirrorUsagePoint.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MirrorUsagePoint.append(obj_)
            obj_.original_tagname_ = 'MirrorUsagePoint'
        super(MirrorUsagePointList, self)._buildChildren(child_, node, nodeName_, True)
# end class MirrorUsagePointList


class MirrorUsagePoint(UsagePointBase):
    """MirrorUsagePoint -- A parallel to UsagePoint to support mirroring
    deviceLFDI -- The LFDI of the device being mirrored.
    postRate -- POST rate, or how often mirrored data should be POSTed, in seconds. A client MAY indicate a preferred postRate when POSTing MirrorUsagePoint. A server MAY add or modify postRate to indicate its preferred posting rate.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = UsagePointBase
    def __init__(self, deviceLFDI=None, MirrorMeterReading=None, postRate=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MirrorUsagePoint"), self).__init__( **kwargs_)
        self.deviceLFDI = deviceLFDI
        self.validate_HexBinary160(self.deviceLFDI)
        self.deviceLFDI_nsprefix_ = None
        if MirrorMeterReading is None:
            self.MirrorMeterReading = []
        else:
            self.MirrorMeterReading = MirrorMeterReading
        self.MirrorMeterReading_nsprefix_ = None
        self.postRate = postRate
        self.validate_UInt32(self.postRate)
        self.postRate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MirrorUsagePoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MirrorUsagePoint.subclass:
            return MirrorUsagePoint.subclass(*args_, **kwargs_)
        else:
            return MirrorUsagePoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_deviceLFDI(self):
        return self.deviceLFDI
    def set_deviceLFDI(self, deviceLFDI):
        self.deviceLFDI = deviceLFDI
    def get_MirrorMeterReading(self):
        return self.MirrorMeterReading
    def set_MirrorMeterReading(self, MirrorMeterReading):
        self.MirrorMeterReading = MirrorMeterReading
    def add_MirrorMeterReading(self, value):
        self.MirrorMeterReading.append(value)
    def insert_MirrorMeterReading_at(self, index, value):
        self.MirrorMeterReading.insert(index, value)
    def replace_MirrorMeterReading_at(self, index, value):
        self.MirrorMeterReading[index] = value
    def get_postRate(self):
        return self.postRate
    def set_postRate(self, postRate):
        self.postRate = postRate
    def validate_HexBinary160(self, value):
        result = True
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary160' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.deviceLFDI is not None or
            self.MirrorMeterReading or
            self.postRate is not None or
            super(MirrorUsagePoint, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorUsagePoint', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MirrorUsagePoint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MirrorUsagePoint':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorUsagePoint')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MirrorUsagePoint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MirrorUsagePoint'):
        super(MirrorUsagePoint, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorUsagePoint')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorUsagePoint', fromsubclass_=False, pretty_print=True):
        super(MirrorUsagePoint, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deviceLFDI is not None:
            namespaceprefix_ = self.deviceLFDI_nsprefix_ + ':' if (UseCapturedNS_ and self.deviceLFDI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeviceLFDI>%s</%sdeviceLFDI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.deviceLFDI), input_name='deviceLFDI')), namespaceprefix_ , eol_))
        for MirrorMeterReading_ in self.MirrorMeterReading:
            namespaceprefix_ = self.MirrorMeterReading_nsprefix_ + ':' if (UseCapturedNS_ and self.MirrorMeterReading_nsprefix_) else ''
            MirrorMeterReading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MirrorMeterReading', pretty_print=pretty_print)
        if self.postRate is not None:
            namespaceprefix_ = self.postRate_nsprefix_ + ':' if (UseCapturedNS_ and self.postRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostRate>%s</%spostRate>%s' % (namespaceprefix_ , self.gds_format_integer(self.postRate, input_name='postRate'), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MirrorUsagePoint, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'deviceLFDI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'deviceLFDI')
            value_ = self.gds_validate_string(value_, node, 'deviceLFDI')
            self.deviceLFDI = value_
            self.deviceLFDI_nsprefix_ = child_.prefix
            # validate type HexBinary160
            self.validate_HexBinary160(self.deviceLFDI)
        elif nodeName_ == 'MirrorMeterReading':
            obj_ = MirrorMeterReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MirrorMeterReading.append(obj_)
            obj_.original_tagname_ = 'MirrorMeterReading'
        elif nodeName_ == 'postRate' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'postRate')
            ival_ = self.gds_validate_integer(ival_, node, 'postRate')
            self.postRate = ival_
            self.postRate_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.postRate)
        super(MirrorUsagePoint, self)._buildChildren(child_, node, nodeName_, True)
# end class MirrorUsagePoint


class MirrorReadingSet(ReadingSetBase):
    """MirrorReadingSet -- A set of Readings of the ReadingType indicated by the parent MeterReading.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReadingSetBase
    def __init__(self, Reading=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MirrorReadingSet"), self).__init__( **kwargs_)
        if Reading is None:
            self.Reading = []
        else:
            self.Reading = Reading
        self.Reading_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MirrorReadingSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MirrorReadingSet.subclass:
            return MirrorReadingSet.subclass(*args_, **kwargs_)
        else:
            return MirrorReadingSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Reading(self):
        return self.Reading
    def set_Reading(self, Reading):
        self.Reading = Reading
    def add_Reading(self, value):
        self.Reading.append(value)
    def insert_Reading_at(self, index, value):
        self.Reading.insert(index, value)
    def replace_Reading_at(self, index, value):
        self.Reading[index] = value
    def _hasContent(self):
        if (
            self.Reading or
            super(MirrorReadingSet, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorReadingSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MirrorReadingSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MirrorReadingSet':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorReadingSet')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MirrorReadingSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MirrorReadingSet'):
        super(MirrorReadingSet, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorReadingSet')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorReadingSet', fromsubclass_=False, pretty_print=True):
        super(MirrorReadingSet, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Reading_ in self.Reading:
            namespaceprefix_ = self.Reading_nsprefix_ + ':' if (UseCapturedNS_ and self.Reading_nsprefix_) else ''
            Reading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reading', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MirrorReadingSet, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Reading':
            obj_ = Reading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reading.append(obj_)
            obj_.original_tagname_ = 'Reading'
        super(MirrorReadingSet, self)._buildChildren(child_, node, nodeName_, True)
# end class MirrorReadingSet


class MeterReadingBase(IdentifiedObject):
    """MeterReadingBase -- A container for associating ReadingType, Readings and ReadingSets.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = IdentifiedObject
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MeterReadingBase"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeterReadingBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeterReadingBase.subclass:
            return MeterReadingBase.subclass(*args_, **kwargs_)
        else:
            return MeterReadingBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(MeterReadingBase, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeterReadingBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeterReadingBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MeterReadingBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReadingBase')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeterReadingBase', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeterReadingBase'):
        super(MeterReadingBase, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReadingBase')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='MeterReadingBase', fromsubclass_=False, pretty_print=True):
        super(MeterReadingBase, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MeterReadingBase, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(MeterReadingBase, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class MeterReadingBase


class MirrorMeterReadingList(List):
    """MirrorMeterReadingList -- A List of MirrorMeterReading instances.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = List
    def __init__(self, MirrorMeterReading=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MirrorMeterReadingList"), self).__init__( **kwargs_)
        if MirrorMeterReading is None:
            self.MirrorMeterReading = []
        else:
            self.MirrorMeterReading = MirrorMeterReading
        self.MirrorMeterReading_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MirrorMeterReadingList)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MirrorMeterReadingList.subclass:
            return MirrorMeterReadingList.subclass(*args_, **kwargs_)
        else:
            return MirrorMeterReadingList(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_MirrorMeterReading(self):
        return self.MirrorMeterReading
    def set_MirrorMeterReading(self, MirrorMeterReading):
        self.MirrorMeterReading = MirrorMeterReading
    def add_MirrorMeterReading(self, value):
        self.MirrorMeterReading.append(value)
    def insert_MirrorMeterReading_at(self, index, value):
        self.MirrorMeterReading.insert(index, value)
    def replace_MirrorMeterReading_at(self, index, value):
        self.MirrorMeterReading[index] = value
    def _hasContent(self):
        if (
            self.MirrorMeterReading or
            super(MirrorMeterReadingList, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorMeterReadingList', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MirrorMeterReadingList')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MirrorMeterReadingList':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorMeterReadingList')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MirrorMeterReadingList', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MirrorMeterReadingList'):
        super(MirrorMeterReadingList, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorMeterReadingList')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorMeterReadingList', fromsubclass_=False, pretty_print=True):
        super(MirrorMeterReadingList, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MirrorMeterReading_ in self.MirrorMeterReading:
            namespaceprefix_ = self.MirrorMeterReading_nsprefix_ + ':' if (UseCapturedNS_ and self.MirrorMeterReading_nsprefix_) else ''
            MirrorMeterReading_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MirrorMeterReading', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MirrorMeterReadingList, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'MirrorMeterReading':
            obj_ = MirrorMeterReading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MirrorMeterReading.append(obj_)
            obj_.original_tagname_ = 'MirrorMeterReading'
        super(MirrorMeterReadingList, self)._buildChildren(child_, node, nodeName_, True)
# end class MirrorMeterReadingList


class MirrorMeterReading(MeterReadingBase):
    """MirrorMeterReading -- Mimic of MeterReading used for managing mirrors.
    lastUpdateTime -- The date and time of the last update.
    nextUpdateTime -- The date and time of the next planned update.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MeterReadingBase
    def __init__(self, lastUpdateTime=None, MirrorReadingSet=None, nextUpdateTime=None, Reading=None, ReadingType=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MirrorMeterReading"), self).__init__( **kwargs_)
        self.lastUpdateTime = lastUpdateTime
        self.lastUpdateTime_nsprefix_ = None
        if MirrorReadingSet is None:
            self.MirrorReadingSet = []
        else:
            self.MirrorReadingSet = MirrorReadingSet
        self.MirrorReadingSet_nsprefix_ = None
        self.nextUpdateTime = nextUpdateTime
        self.nextUpdateTime_nsprefix_ = None
        self.Reading = Reading
        self.Reading_nsprefix_ = None
        self.ReadingType = ReadingType
        self.ReadingType_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MirrorMeterReading)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MirrorMeterReading.subclass:
            return MirrorMeterReading.subclass(*args_, **kwargs_)
        else:
            return MirrorMeterReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_lastUpdateTime(self):
        return self.lastUpdateTime
    def set_lastUpdateTime(self, lastUpdateTime):
        self.lastUpdateTime = lastUpdateTime
    def get_MirrorReadingSet(self):
        return self.MirrorReadingSet
    def set_MirrorReadingSet(self, MirrorReadingSet):
        self.MirrorReadingSet = MirrorReadingSet
    def add_MirrorReadingSet(self, value):
        self.MirrorReadingSet.append(value)
    def insert_MirrorReadingSet_at(self, index, value):
        self.MirrorReadingSet.insert(index, value)
    def replace_MirrorReadingSet_at(self, index, value):
        self.MirrorReadingSet[index] = value
    def get_nextUpdateTime(self):
        return self.nextUpdateTime
    def set_nextUpdateTime(self, nextUpdateTime):
        self.nextUpdateTime = nextUpdateTime
    def get_Reading(self):
        return self.Reading
    def set_Reading(self, Reading):
        self.Reading = Reading
    def get_ReadingType(self):
        return self.ReadingType
    def set_ReadingType(self, ReadingType):
        self.ReadingType = ReadingType
    def _hasContent(self):
        if (
            self.lastUpdateTime is not None or
            self.MirrorReadingSet or
            self.nextUpdateTime is not None or
            self.Reading is not None or
            self.ReadingType is not None or
            super(MirrorMeterReading, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorMeterReading', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MirrorMeterReading')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MirrorMeterReading':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorMeterReading')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MirrorMeterReading', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MirrorMeterReading'):
        super(MirrorMeterReading, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MirrorMeterReading')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MirrorMeterReading', fromsubclass_=False, pretty_print=True):
        super(MirrorMeterReading, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.lastUpdateTime is not None:
            namespaceprefix_ = self.lastUpdateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.lastUpdateTime_nsprefix_) else ''
            self.lastUpdateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='lastUpdateTime', pretty_print=pretty_print)
        for MirrorReadingSet_ in self.MirrorReadingSet:
            namespaceprefix_ = self.MirrorReadingSet_nsprefix_ + ':' if (UseCapturedNS_ and self.MirrorReadingSet_nsprefix_) else ''
            MirrorReadingSet_.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MirrorReadingSet', pretty_print=pretty_print)
        if self.nextUpdateTime is not None:
            namespaceprefix_ = self.nextUpdateTime_nsprefix_ + ':' if (UseCapturedNS_ and self.nextUpdateTime_nsprefix_) else ''
            self.nextUpdateTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='nextUpdateTime', pretty_print=pretty_print)
        if self.Reading is not None:
            namespaceprefix_ = self.Reading_nsprefix_ + ':' if (UseCapturedNS_ and self.Reading_nsprefix_) else ''
            self.Reading.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Reading', pretty_print=pretty_print)
        if self.ReadingType is not None:
            namespaceprefix_ = self.ReadingType_nsprefix_ + ':' if (UseCapturedNS_ and self.ReadingType_nsprefix_) else ''
            self.ReadingType.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReadingType', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MirrorMeterReading, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'lastUpdateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.lastUpdateTime = obj_
            obj_.original_tagname_ = 'lastUpdateTime'
        elif nodeName_ == 'MirrorReadingSet':
            obj_ = MirrorReadingSet.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MirrorReadingSet.append(obj_)
            obj_.original_tagname_ = 'MirrorReadingSet'
        elif nodeName_ == 'nextUpdateTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.nextUpdateTime = obj_
            obj_.original_tagname_ = 'nextUpdateTime'
        elif nodeName_ == 'Reading':
            obj_ = Reading.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Reading = obj_
            obj_.original_tagname_ = 'Reading'
        elif nodeName_ == 'ReadingType':
            obj_ = ReadingType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReadingType = obj_
            obj_.original_tagname_ = 'ReadingType'
        super(MirrorMeterReading, self)._buildChildren(child_, node, nodeName_, True)
# end class MirrorMeterReading


class BillingReadingSet(ReadingSetBase):
    """BillingReadingSet -- Time sequence of readings of the same reading type.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReadingSetBase
    def __init__(self, BillingReadingListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingReadingSet"), self).__init__( **kwargs_)
        self.BillingReadingListLink = BillingReadingListLink
        self.BillingReadingListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingReadingSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingReadingSet.subclass:
            return BillingReadingSet.subclass(*args_, **kwargs_)
        else:
            return BillingReadingSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BillingReadingListLink(self):
        return self.BillingReadingListLink
    def set_BillingReadingListLink(self, BillingReadingListLink):
        self.BillingReadingListLink = BillingReadingListLink
    def _hasContent(self):
        if (
            self.BillingReadingListLink is not None or
            super(BillingReadingSet, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingReadingSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingReadingSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingReadingSet':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingSet')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingReadingSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingReadingSet'):
        super(BillingReadingSet, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingReadingSet')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingReadingSet', fromsubclass_=False, pretty_print=True):
        super(BillingReadingSet, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BillingReadingListLink is not None:
            namespaceprefix_ = self.BillingReadingListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.BillingReadingListLink_nsprefix_) else ''
            self.BillingReadingListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BillingReadingListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingReadingSet, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BillingReadingListLink':
            obj_ = BillingReadingListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BillingReadingListLink = obj_
            obj_.original_tagname_ = 'BillingReadingListLink'
        super(BillingReadingSet, self)._buildChildren(child_, node, nodeName_, True)
# end class BillingReadingSet


class BillingMeterReadingBase(MeterReadingBase):
    """BillingMeterReadingBase -- Contains historical, target, and projection readings of various types, possibly associated with charges.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MeterReadingBase
    def __init__(self, BillingReadingSetListLink=None, ReadingTypeLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("BillingMeterReadingBase"), self).__init__( **kwargs_)
        self.BillingReadingSetListLink = BillingReadingSetListLink
        self.BillingReadingSetListLink_nsprefix_ = None
        self.ReadingTypeLink = ReadingTypeLink
        self.ReadingTypeLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, BillingMeterReadingBase)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if BillingMeterReadingBase.subclass:
            return BillingMeterReadingBase.subclass(*args_, **kwargs_)
        else:
            return BillingMeterReadingBase(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_BillingReadingSetListLink(self):
        return self.BillingReadingSetListLink
    def set_BillingReadingSetListLink(self, BillingReadingSetListLink):
        self.BillingReadingSetListLink = BillingReadingSetListLink
    def get_ReadingTypeLink(self):
        return self.ReadingTypeLink
    def set_ReadingTypeLink(self, ReadingTypeLink):
        self.ReadingTypeLink = ReadingTypeLink
    def _hasContent(self):
        if (
            self.BillingReadingSetListLink is not None or
            self.ReadingTypeLink is not None or
            super(BillingMeterReadingBase, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingMeterReadingBase', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('BillingMeterReadingBase')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'BillingMeterReadingBase':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingMeterReadingBase')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='BillingMeterReadingBase', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='BillingMeterReadingBase'):
        super(BillingMeterReadingBase, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='BillingMeterReadingBase')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='BillingMeterReadingBase', fromsubclass_=False, pretty_print=True):
        super(BillingMeterReadingBase, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.BillingReadingSetListLink is not None:
            namespaceprefix_ = self.BillingReadingSetListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.BillingReadingSetListLink_nsprefix_) else ''
            self.BillingReadingSetListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='BillingReadingSetListLink', pretty_print=pretty_print)
        if self.ReadingTypeLink is not None:
            namespaceprefix_ = self.ReadingTypeLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ReadingTypeLink_nsprefix_) else ''
            self.ReadingTypeLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReadingTypeLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(BillingMeterReadingBase, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'BillingReadingSetListLink':
            obj_ = BillingReadingSetListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.BillingReadingSetListLink = obj_
            obj_.original_tagname_ = 'BillingReadingSetListLink'
        elif nodeName_ == 'ReadingTypeLink':
            obj_ = ReadingTypeLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReadingTypeLink = obj_
            obj_.original_tagname_ = 'ReadingTypeLink'
        super(BillingMeterReadingBase, self)._buildChildren(child_, node, nodeName_, True)
# end class BillingMeterReadingBase


class UsagePoint(UsagePointBase):
    """UsagePoint -- Logical point on a network at which consumption or production is either physically measured (e.g. metered) or estimated (e.g. unmetered street lights).
    deviceLFDI -- The LFDI of the source device. This attribute SHALL be present when mirroring.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = UsagePointBase
    def __init__(self, deviceLFDI=None, MeterReadingListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("UsagePoint"), self).__init__( **kwargs_)
        self.deviceLFDI = deviceLFDI
        self.validate_HexBinary160(self.deviceLFDI)
        self.deviceLFDI_nsprefix_ = None
        self.MeterReadingListLink = MeterReadingListLink
        self.MeterReadingListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, UsagePoint)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if UsagePoint.subclass:
            return UsagePoint.subclass(*args_, **kwargs_)
        else:
            return UsagePoint(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_deviceLFDI(self):
        return self.deviceLFDI
    def set_deviceLFDI(self, deviceLFDI):
        self.deviceLFDI = deviceLFDI
    def get_MeterReadingListLink(self):
        return self.MeterReadingListLink
    def set_MeterReadingListLink(self, MeterReadingListLink):
        self.MeterReadingListLink = MeterReadingListLink
    def validate_HexBinary160(self, value):
        result = True
        # Validate type HexBinary160, a restriction on xs:hexBinary.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 40:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on HexBinary160' % {"value": value, "lineno": lineno} )
                result = False
        return result
    def _hasContent(self):
        if (
            self.deviceLFDI is not None or
            self.MeterReadingListLink is not None or
            super(UsagePoint, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UsagePoint', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('UsagePoint')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'UsagePoint':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePoint')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='UsagePoint', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='UsagePoint'):
        super(UsagePoint, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='UsagePoint')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='UsagePoint', fromsubclass_=False, pretty_print=True):
        super(UsagePoint, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.deviceLFDI is not None:
            namespaceprefix_ = self.deviceLFDI_nsprefix_ + ':' if (UseCapturedNS_ and self.deviceLFDI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdeviceLFDI>%s</%sdeviceLFDI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.deviceLFDI), input_name='deviceLFDI')), namespaceprefix_ , eol_))
        if self.MeterReadingListLink is not None:
            namespaceprefix_ = self.MeterReadingListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.MeterReadingListLink_nsprefix_) else ''
            self.MeterReadingListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='MeterReadingListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(UsagePoint, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'deviceLFDI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'deviceLFDI')
            value_ = self.gds_validate_string(value_, node, 'deviceLFDI')
            self.deviceLFDI = value_
            self.deviceLFDI_nsprefix_ = child_.prefix
            # validate type HexBinary160
            self.validate_HexBinary160(self.deviceLFDI)
        elif nodeName_ == 'MeterReadingListLink':
            obj_ = MeterReadingListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.MeterReadingListLink = obj_
            obj_.original_tagname_ = 'MeterReadingListLink'
        super(UsagePoint, self)._buildChildren(child_, node, nodeName_, True)
# end class UsagePoint


class ReadingSet(ReadingSetBase):
    """ReadingSet -- A set of Readings of the ReadingType indicated by the parent MeterReading.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = ReadingSetBase
    def __init__(self, ReadingListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ReadingSet"), self).__init__( **kwargs_)
        self.ReadingListLink = ReadingListLink
        self.ReadingListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ReadingSet)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ReadingSet.subclass:
            return ReadingSet.subclass(*args_, **kwargs_)
        else:
            return ReadingSet(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_ReadingListLink(self):
        return self.ReadingListLink
    def set_ReadingListLink(self, ReadingListLink):
        self.ReadingListLink = ReadingListLink
    def _hasContent(self):
        if (
            self.ReadingListLink is not None or
            super(ReadingSet, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingSet', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ReadingSet')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ReadingSet':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingSet')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ReadingSet', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ReadingSet'):
        super(ReadingSet, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ReadingSet')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='ReadingSet', fromsubclass_=False, pretty_print=True):
        super(ReadingSet, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ReadingListLink is not None:
            namespaceprefix_ = self.ReadingListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ReadingListLink_nsprefix_) else ''
            self.ReadingListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReadingListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ReadingSet, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'ReadingListLink':
            obj_ = ReadingListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReadingListLink = obj_
            obj_.original_tagname_ = 'ReadingListLink'
        super(ReadingSet, self)._buildChildren(child_, node, nodeName_, True)
# end class ReadingSet


class MeterReading(MeterReadingBase):
    """MeterReading -- Set of values obtained from the meter.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = MeterReadingBase
    def __init__(self, RateComponentListLink=None, ReadingLink=None, ReadingSetListLink=None, ReadingTypeLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("MeterReading"), self).__init__( **kwargs_)
        self.RateComponentListLink = RateComponentListLink
        self.RateComponentListLink_nsprefix_ = None
        self.ReadingLink = ReadingLink
        self.ReadingLink_nsprefix_ = None
        self.ReadingSetListLink = ReadingSetListLink
        self.ReadingSetListLink_nsprefix_ = None
        self.ReadingTypeLink = ReadingTypeLink
        self.ReadingTypeLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, MeterReading)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if MeterReading.subclass:
            return MeterReading.subclass(*args_, **kwargs_)
        else:
            return MeterReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_RateComponentListLink(self):
        return self.RateComponentListLink
    def set_RateComponentListLink(self, RateComponentListLink):
        self.RateComponentListLink = RateComponentListLink
    def get_ReadingLink(self):
        return self.ReadingLink
    def set_ReadingLink(self, ReadingLink):
        self.ReadingLink = ReadingLink
    def get_ReadingSetListLink(self):
        return self.ReadingSetListLink
    def set_ReadingSetListLink(self, ReadingSetListLink):
        self.ReadingSetListLink = ReadingSetListLink
    def get_ReadingTypeLink(self):
        return self.ReadingTypeLink
    def set_ReadingTypeLink(self, ReadingTypeLink):
        self.ReadingTypeLink = ReadingTypeLink
    def _hasContent(self):
        if (
            self.RateComponentListLink is not None or
            self.ReadingLink is not None or
            self.ReadingSetListLink is not None or
            self.ReadingTypeLink is not None or
            super(MeterReading, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MeterReading', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('MeterReading')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'MeterReading':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReading')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='MeterReading', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='MeterReading'):
        super(MeterReading, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='MeterReading')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='MeterReading', fromsubclass_=False, pretty_print=True):
        super(MeterReading, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RateComponentListLink is not None:
            namespaceprefix_ = self.RateComponentListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.RateComponentListLink_nsprefix_) else ''
            self.RateComponentListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RateComponentListLink', pretty_print=pretty_print)
        if self.ReadingLink is not None:
            namespaceprefix_ = self.ReadingLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ReadingLink_nsprefix_) else ''
            self.ReadingLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReadingLink', pretty_print=pretty_print)
        if self.ReadingSetListLink is not None:
            namespaceprefix_ = self.ReadingSetListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ReadingSetListLink_nsprefix_) else ''
            self.ReadingSetListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReadingSetListLink', pretty_print=pretty_print)
        if self.ReadingTypeLink is not None:
            namespaceprefix_ = self.ReadingTypeLink_nsprefix_ + ':' if (UseCapturedNS_ and self.ReadingTypeLink_nsprefix_) else ''
            self.ReadingTypeLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='ReadingTypeLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(MeterReading, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'RateComponentListLink':
            obj_ = RateComponentListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RateComponentListLink = obj_
            obj_.original_tagname_ = 'RateComponentListLink'
        elif nodeName_ == 'ReadingLink':
            obj_ = ReadingLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReadingLink = obj_
            obj_.original_tagname_ = 'ReadingLink'
        elif nodeName_ == 'ReadingSetListLink':
            obj_ = ReadingSetListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReadingSetListLink = obj_
            obj_.original_tagname_ = 'ReadingSetListLink'
        elif nodeName_ == 'ReadingTypeLink':
            obj_ = ReadingTypeLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.ReadingTypeLink = obj_
            obj_.original_tagname_ = 'ReadingTypeLink'
        super(MeterReading, self)._buildChildren(child_, node, nodeName_, True)
# end class MeterReading


class TextResponse(Response):
    """TextResponse -- A response to a text message
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = Response
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TextResponse"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TextResponse)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TextResponse.subclass:
            return TextResponse.subclass(*args_, **kwargs_)
        else:
            return TextResponse(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TextResponse, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextResponse', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TextResponse')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TextResponse':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextResponse')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TextResponse', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TextResponse'):
        super(TextResponse, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TextResponse')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TextResponse', fromsubclass_=False, pretty_print=True):
        super(TextResponse, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TextResponse, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TextResponse, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TextResponse


class Notification(SubscriptionBase):
    """Notification -- Holds the information related to a client subscription to receive updates to a resource automatically. The actual resources may be passed in the Notification by specifying a specific xsi:type for the Resource and passing the full representation.
    newResourceURI -- The new location of the resource, if moved. This attribute SHALL be a fully-qualified absolute URI, not a relative reference.
    status -- 0 = Default Status
    1 = Subscription canceled, no additional information
    2 = Subscription canceled, resource moved
    3 = Subscription canceled, resource definition changed (e.g., a new version of IEEE 2030.5)
    4 = Subscription canceled, resource deleted
    All other values reserved.
    subscriptionURI -- The subscription from which this notification was triggered. This attribute SHALL be a fully-qualified absolute URI, not a relative reference.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscriptionBase
    def __init__(self, newResourceURI=None, Resource=None, status=None, subscriptionURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Notification"), self).__init__( **kwargs_)
        self.newResourceURI = newResourceURI
        self.newResourceURI_nsprefix_ = None
        self.Resource = Resource
        self.Resource_nsprefix_ = None
        self.status = status
        self.validate_UInt8(self.status)
        self.status_nsprefix_ = None
        self.subscriptionURI = subscriptionURI
        self.subscriptionURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Notification)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Notification.subclass:
            return Notification.subclass(*args_, **kwargs_)
        else:
            return Notification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_newResourceURI(self):
        return self.newResourceURI
    def set_newResourceURI(self, newResourceURI):
        self.newResourceURI = newResourceURI
    def get_Resource(self):
        return self.Resource
    def set_Resource(self, Resource):
        self.Resource = Resource
    def get_status(self):
        return self.status
    def set_status(self, status):
        self.status = status
    def get_subscriptionURI(self):
        return self.subscriptionURI
    def set_subscriptionURI(self, subscriptionURI):
        self.subscriptionURI = subscriptionURI
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.newResourceURI is not None or
            self.Resource is not None or
            self.status is not None or
            self.subscriptionURI is not None or
            super(Notification, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Notification', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Notification')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Notification':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Notification')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Notification', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Notification'):
        super(Notification, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Notification')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Notification', fromsubclass_=False, pretty_print=True):
        super(Notification, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.newResourceURI is not None:
            namespaceprefix_ = self.newResourceURI_nsprefix_ + ':' if (UseCapturedNS_ and self.newResourceURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snewResourceURI>%s</%snewResourceURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.newResourceURI), input_name='newResourceURI')), namespaceprefix_ , eol_))
        if self.Resource is not None:
            namespaceprefix_ = self.Resource_nsprefix_ + ':' if (UseCapturedNS_ and self.Resource_nsprefix_) else ''
            self.Resource.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Resource', pretty_print=pretty_print)
        if self.status is not None:
            namespaceprefix_ = self.status_nsprefix_ + ':' if (UseCapturedNS_ and self.status_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sstatus>%s</%sstatus>%s' % (namespaceprefix_ , self.gds_format_integer(self.status, input_name='status'), namespaceprefix_ , eol_))
        if self.subscriptionURI is not None:
            namespaceprefix_ = self.subscriptionURI_nsprefix_ + ':' if (UseCapturedNS_ and self.subscriptionURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%ssubscriptionURI>%s</%ssubscriptionURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.subscriptionURI), input_name='subscriptionURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Notification, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'newResourceURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'newResourceURI')
            value_ = self.gds_validate_string(value_, node, 'newResourceURI')
            self.newResourceURI = value_
            self.newResourceURI_nsprefix_ = child_.prefix
        elif nodeName_ == 'Resource':
            class_obj_ = self.get_class_obj_(child_, Resource)
            obj_ = class_obj_.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Resource = obj_
            obj_.original_tagname_ = 'Resource'
        elif nodeName_ == 'status' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'status')
            ival_ = self.gds_validate_integer(ival_, node, 'status')
            self.status = ival_
            self.status_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.status)
        elif nodeName_ == 'subscriptionURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'subscriptionURI')
            value_ = self.gds_validate_string(value_, node, 'subscriptionURI')
            self.subscriptionURI = value_
            self.subscriptionURI_nsprefix_ = child_.prefix
        super(Notification, self)._buildChildren(child_, node, nodeName_, True)
# end class Notification


class Subscription(SubscriptionBase):
    """Subscription -- Holds the information related to a client subscription to receive updates to a resource automatically.
    encoding -- 0 - application/sep+xml
    1 - application/sep-exi
    2-255 - reserved
    level -- Contains the preferred schema and extensibility level indication such as "+S1"
    limit -- This element is used to indicate the maximum number of list items that should be included in a notification when the subscribed resource changes. This limit is meant to be functionally equivalent to the
    
    limit
    
    query string parameter, but applies to both list resources as well as other resources.  For list resources, if a limit of
    
    0
    
    is specified, then notifications SHALL contain a list resource with results=
    
    0
    
    (equivalent to a simple change notification).  For list resources, if a limit greater than
    
    0
    
    is specified, then notifications SHALL contain a list resource with results equal to the limit specified (or less, should the list contain fewer items than the limit specified or should the server be unable to provide the requested number of items for any reason) and follow the same rules for list resources (e.g., ordering).  For non-list resources, if a limit of
    
    0
    
    is specified, then notifications SHALL NOT contain a resource representation (equivalent to a simple change notification).  For non-list resources, if a limit greater than
    
    0
    
    is specified, then notifications SHALL contain the representation of the changed resource.
    notificationURI -- The resource to which to post the notifications about the requested subscribed resource. Because this URI will exist on a server other than the one being POSTed to, this attribute SHALL be a fully-qualified absolute URI, not a relative reference.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = SubscriptionBase
    def __init__(self, Condition=None, encoding=None, level=None, limit=None, notificationURI=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("Subscription"), self).__init__( **kwargs_)
        self.Condition = Condition
        self.Condition_nsprefix_ = None
        self.encoding = encoding
        self.validate_UInt8(self.encoding)
        self.encoding_nsprefix_ = None
        self.level = level
        self.validate_String16(self.level)
        self.level_nsprefix_ = None
        self.limit = limit
        self.validate_UInt32(self.limit)
        self.limit_nsprefix_ = None
        self.notificationURI = notificationURI
        self.notificationURI_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, Subscription)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if Subscription.subclass:
            return Subscription.subclass(*args_, **kwargs_)
        else:
            return Subscription(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_Condition(self):
        return self.Condition
    def set_Condition(self, Condition):
        self.Condition = Condition
    def get_encoding(self):
        return self.encoding
    def set_encoding(self, encoding):
        self.encoding = encoding
    def get_level(self):
        return self.level
    def set_level(self, level):
        self.level = level
    def get_limit(self):
        return self.limit
    def set_limit(self, limit):
        self.limit = limit
    def get_notificationURI(self):
        return self.notificationURI
    def set_notificationURI(self, notificationURI):
        self.notificationURI = notificationURI
    def validate_UInt8(self, value):
        result = True
        # Validate type UInt8, a restriction on xs:unsignedByte.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def validate_String16(self, value):
        result = True
        # Validate type String16, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 16:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String16' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.Condition is not None or
            self.encoding is not None or
            self.level is not None or
            self.limit is not None or
            self.notificationURI is not None or
            super(Subscription, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Subscription', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('Subscription')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'Subscription':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Subscription')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='Subscription', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='Subscription'):
        super(Subscription, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='Subscription')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='Subscription', fromsubclass_=False, pretty_print=True):
        super(Subscription, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Condition is not None:
            namespaceprefix_ = self.Condition_nsprefix_ + ':' if (UseCapturedNS_ and self.Condition_nsprefix_) else ''
            self.Condition.export(outfile, level, namespaceprefix_, namespacedef_='', name_='Condition', pretty_print=pretty_print)
        if self.encoding is not None:
            namespaceprefix_ = self.encoding_nsprefix_ + ':' if (UseCapturedNS_ and self.encoding_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sencoding>%s</%sencoding>%s' % (namespaceprefix_ , self.gds_format_integer(self.encoding, input_name='encoding'), namespaceprefix_ , eol_))
        if self.level is not None:
            namespaceprefix_ = self.level_nsprefix_ + ':' if (UseCapturedNS_ and self.level_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slevel>%s</%slevel>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.level), input_name='level')), namespaceprefix_ , eol_))
        if self.limit is not None:
            namespaceprefix_ = self.limit_nsprefix_ + ':' if (UseCapturedNS_ and self.limit_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%slimit>%s</%slimit>%s' % (namespaceprefix_ , self.gds_format_integer(self.limit, input_name='limit'), namespaceprefix_ , eol_))
        if self.notificationURI is not None:
            namespaceprefix_ = self.notificationURI_nsprefix_ + ':' if (UseCapturedNS_ and self.notificationURI_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%snotificationURI>%s</%snotificationURI>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.notificationURI), input_name='notificationURI')), namespaceprefix_ , eol_))
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(Subscription, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'Condition':
            obj_ = Condition.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.Condition = obj_
            obj_.original_tagname_ = 'Condition'
        elif nodeName_ == 'encoding' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'encoding')
            ival_ = self.gds_validate_integer(ival_, node, 'encoding')
            self.encoding = ival_
            self.encoding_nsprefix_ = child_.prefix
            # validate type UInt8
            self.validate_UInt8(self.encoding)
        elif nodeName_ == 'level':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'level')
            value_ = self.gds_validate_string(value_, node, 'level')
            self.level = value_
            self.level_nsprefix_ = child_.prefix
            # validate type String16
            self.validate_String16(self.level)
        elif nodeName_ == 'limit' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'limit')
            ival_ = self.gds_validate_integer(ival_, node, 'limit')
            self.limit = ival_
            self.limit_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.limit)
        elif nodeName_ == 'notificationURI':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'notificationURI')
            value_ = self.gds_validate_string(value_, node, 'notificationURI')
            self.notificationURI = value_
            self.notificationURI_nsprefix_ = child_.prefix
        super(Subscription, self)._buildChildren(child_, node, nodeName_, True)
# end class Subscription


class FunctionSetAssignments(FunctionSetAssignmentsBase):
    """FunctionSetAssignments -- Provides an identifiable, subscribable collection of resources for a particular device to consume.
    subscribable -- Indicates whether or not subscriptions are supported for this resource, and whether or not conditional (thresholds) are supported. If not specified, is "not subscribable" (0).
    mRID -- The global identifier of the object.
    description -- The description is a human readable text describing or naming the object.
    version -- Contains the version number of the object. See the type definition for details.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = FunctionSetAssignmentsBase
    def __init__(self, subscribable='0', mRID=None, description=None, version=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("FunctionSetAssignments"), self).__init__( **kwargs_)
        self.subscribable = _cast(int, subscribable)
        self.subscribable_nsprefix_ = None
        self.mRID = mRID
        self.mRID_nsprefix_ = None
        self.description = description
        self.validate_String32(self.description)
        self.description_nsprefix_ = None
        self.version = version
        self.version_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, FunctionSetAssignments)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if FunctionSetAssignments.subclass:
            return FunctionSetAssignments.subclass(*args_, **kwargs_)
        else:
            return FunctionSetAssignments(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_mRID(self):
        return self.mRID
    def set_mRID(self, mRID):
        self.mRID = mRID
    def get_description(self):
        return self.description
    def set_description(self, description):
        self.description = description
    def get_version(self):
        return self.version
    def set_version(self, version):
        self.version = version
    def get_subscribable(self):
        return self.subscribable
    def set_subscribable(self, subscribable):
        self.subscribable = subscribable
    def validate_String32(self, value):
        result = True
        # Validate type String32, a restriction on xs:string.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, str):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (str)' % {"value": value, "lineno": lineno, })
                return False
            if len(value) > 32:
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s does not match xsd maxLength restriction on String32' % {"value" : encode_str_2_3(value), "lineno": lineno} )
                result = False
        return result
    def validate_SubscribableType(self, value):
        # Validate type SubscribableType, a restriction on UInt8.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            self.mRID is not None or
            self.description is not None or
            self.version is not None or
            super(FunctionSetAssignments, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FunctionSetAssignments', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('FunctionSetAssignments')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'FunctionSetAssignments':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FunctionSetAssignments')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='FunctionSetAssignments', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='FunctionSetAssignments'):
        super(FunctionSetAssignments, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='FunctionSetAssignments')
        if self.subscribable != "0" and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            outfile.write(' subscribable=%s' % (quote_attrib(self.subscribable), ))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='FunctionSetAssignments', fromsubclass_=False, pretty_print=True):
        super(FunctionSetAssignments, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.mRID is not None:
            namespaceprefix_ = self.mRID_nsprefix_ + ':' if (UseCapturedNS_ and self.mRID_nsprefix_) else ''
            self.mRID.export(outfile, level, namespaceprefix_, namespacedef_='', name_='mRID', pretty_print=pretty_print)
        if self.description is not None:
            namespaceprefix_ = self.description_nsprefix_ + ':' if (UseCapturedNS_ and self.description_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sdescription>%s</%sdescription>%s' % (namespaceprefix_ , self.gds_encode(self.gds_format_string(quote_xml(self.description), input_name='description')), namespaceprefix_ , eol_))
        if self.version is not None:
            namespaceprefix_ = self.version_nsprefix_ + ':' if (UseCapturedNS_ and self.version_nsprefix_) else ''
            self.version.export(outfile, level, namespaceprefix_, namespacedef_='', name_='version', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('subscribable', node)
        if value is not None and 'subscribable' not in already_processed:
            already_processed.add('subscribable')
            self.subscribable = self.gds_parse_integer(value, node, 'subscribable')
            self.validate_SubscribableType(self.subscribable)    # validate type SubscribableType
        super(FunctionSetAssignments, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'mRID':
            obj_ = mRIDType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.mRID = obj_
            obj_.original_tagname_ = 'mRID'
        elif nodeName_ == 'description':
            value_ = child_.text
            value_ = self.gds_parse_string(value_, node, 'description')
            value_ = self.gds_validate_string(value_, node, 'description')
            self.description = value_
            self.description_nsprefix_ = child_.prefix
            # validate type String32
            self.validate_String32(self.description)
        elif nodeName_ == 'version':
            obj_ = VersionType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.version = obj_
            obj_.original_tagname_ = 'version'
        super(FunctionSetAssignments, self)._buildChildren(child_, node, nodeName_, True)
# end class FunctionSetAssignments


class SelfDevice(AbstractDevice):
    """SelfDevice -- The EndDevice providing the resources available within the DeviceCapabilities.
    pollRate -- The default polling rate for this function set (this resource and all resources below), in seconds. If not specified, a default of 900 seconds (15 minutes) is used. It is RECOMMENDED a client poll the resources of this function set every pollRate seconds.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AbstractDevice
    def __init__(self, pollRate='900', gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("SelfDevice"), self).__init__( **kwargs_)
        self.pollRate = _cast(int, pollRate)
        self.pollRate_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, SelfDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if SelfDevice.subclass:
            return SelfDevice.subclass(*args_, **kwargs_)
        else:
            return SelfDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_pollRate(self):
        return self.pollRate
    def set_pollRate(self, pollRate):
        self.pollRate = pollRate
    def validate_UInt32(self, value):
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
    def _hasContent(self):
        if (
            super(SelfDevice, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SelfDevice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('SelfDevice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'SelfDevice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelfDevice')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='SelfDevice', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='SelfDevice'):
        super(SelfDevice, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='SelfDevice')
        if self.pollRate != 900 and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            outfile.write(' pollRate="%s"' % self.gds_format_integer(self.pollRate, input_name='pollRate'))
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='SelfDevice', fromsubclass_=False, pretty_print=True):
        super(SelfDevice, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('pollRate', node)
        if value is not None and 'pollRate' not in already_processed:
            already_processed.add('pollRate')
            self.pollRate = self.gds_parse_integer(value, node, 'pollRate')
            self.validate_UInt32(self.pollRate)    # validate type UInt32
        super(SelfDevice, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(SelfDevice, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class SelfDevice


class EndDevice(AbstractDevice):
    """EndDevice -- Asset container that performs one or more end device functions. Contains information about individual devices in the network.
    changedTime -- The time at which this resource was last modified or created.
    enabled -- This attribute indicates whether or not an EndDevice is enabled, or registered, on the server. If a server sets this attribute to false, the device is no longer registered. It should be noted that servers can delete EndDevice instances, but using this attribute for some time is more convenient for clients.
    postRate -- POST rate, or how often EndDevice and subordinate resources should be POSTed, in seconds. A client MAY indicate a preferred postRate when POSTing EndDevice. A server MAY add or modify postRate to indicate its preferred posting rate.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = AbstractDevice
    def __init__(self, changedTime=None, enabled=None, FlowReservationRequestListLink=None, FlowReservationResponseListLink=None, FunctionSetAssignmentsListLink=None, postRate=None, RegistrationLink=None, SubscriptionListLink=None, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("EndDevice"), self).__init__( **kwargs_)
        self.changedTime = changedTime
        self.changedTime_nsprefix_ = None
        self.enabled = enabled
        self.enabled_nsprefix_ = None
        self.FlowReservationRequestListLink = FlowReservationRequestListLink
        self.FlowReservationRequestListLink_nsprefix_ = None
        self.FlowReservationResponseListLink = FlowReservationResponseListLink
        self.FlowReservationResponseListLink_nsprefix_ = None
        self.FunctionSetAssignmentsListLink = FunctionSetAssignmentsListLink
        self.FunctionSetAssignmentsListLink_nsprefix_ = None
        self.postRate = postRate
        self.validate_UInt32(self.postRate)
        self.postRate_nsprefix_ = None
        self.RegistrationLink = RegistrationLink
        self.RegistrationLink_nsprefix_ = None
        self.SubscriptionListLink = SubscriptionListLink
        self.SubscriptionListLink_nsprefix_ = None
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, EndDevice)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if EndDevice.subclass:
            return EndDevice.subclass(*args_, **kwargs_)
        else:
            return EndDevice(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def get_changedTime(self):
        return self.changedTime
    def set_changedTime(self, changedTime):
        self.changedTime = changedTime
    def get_enabled(self):
        return self.enabled
    def set_enabled(self, enabled):
        self.enabled = enabled
    def get_FlowReservationRequestListLink(self):
        return self.FlowReservationRequestListLink
    def set_FlowReservationRequestListLink(self, FlowReservationRequestListLink):
        self.FlowReservationRequestListLink = FlowReservationRequestListLink
    def get_FlowReservationResponseListLink(self):
        return self.FlowReservationResponseListLink
    def set_FlowReservationResponseListLink(self, FlowReservationResponseListLink):
        self.FlowReservationResponseListLink = FlowReservationResponseListLink
    def get_FunctionSetAssignmentsListLink(self):
        return self.FunctionSetAssignmentsListLink
    def set_FunctionSetAssignmentsListLink(self, FunctionSetAssignmentsListLink):
        self.FunctionSetAssignmentsListLink = FunctionSetAssignmentsListLink
    def get_postRate(self):
        return self.postRate
    def set_postRate(self, postRate):
        self.postRate = postRate
    def get_RegistrationLink(self):
        return self.RegistrationLink
    def set_RegistrationLink(self, RegistrationLink):
        self.RegistrationLink = RegistrationLink
    def get_SubscriptionListLink(self):
        return self.SubscriptionListLink
    def set_SubscriptionListLink(self, SubscriptionListLink):
        self.SubscriptionListLink = SubscriptionListLink
    def validate_UInt32(self, value):
        result = True
        # Validate type UInt32, a restriction on xs:unsignedInt.
        if value is not None and Validate_simpletypes_ and self.gds_collector_ is not None:
            if not isinstance(value, int):
                lineno = self.gds_get_node_lineno_()
                self.gds_collector_.add_message('Value "%(value)s"%(lineno)s is not of the correct base simple type (int)' % {"value": value, "lineno": lineno, })
                return False
            pass
        return result
    def _hasContent(self):
        if (
            self.changedTime is not None or
            self.enabled is not None or
            self.FlowReservationRequestListLink is not None or
            self.FlowReservationResponseListLink is not None or
            self.FunctionSetAssignmentsListLink is not None or
            self.postRate is not None or
            self.RegistrationLink is not None or
            self.SubscriptionListLink is not None or
            super(EndDevice, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EndDevice', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('EndDevice')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'EndDevice':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDevice')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='EndDevice', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='EndDevice'):
        super(EndDevice, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='EndDevice')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_=' xmlns:None="urn:ieee:std:2030.5:ns" ', name_='EndDevice', fromsubclass_=False, pretty_print=True):
        super(EndDevice, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.changedTime is not None:
            namespaceprefix_ = self.changedTime_nsprefix_ + ':' if (UseCapturedNS_ and self.changedTime_nsprefix_) else ''
            self.changedTime.export(outfile, level, namespaceprefix_, namespacedef_='', name_='changedTime', pretty_print=pretty_print)
        if self.enabled is not None:
            namespaceprefix_ = self.enabled_nsprefix_ + ':' if (UseCapturedNS_ and self.enabled_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%senabled>%s</%senabled>%s' % (namespaceprefix_ , self.gds_format_boolean(self.enabled, input_name='enabled'), namespaceprefix_ , eol_))
        if self.FlowReservationRequestListLink is not None:
            namespaceprefix_ = self.FlowReservationRequestListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.FlowReservationRequestListLink_nsprefix_) else ''
            self.FlowReservationRequestListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FlowReservationRequestListLink', pretty_print=pretty_print)
        if self.FlowReservationResponseListLink is not None:
            namespaceprefix_ = self.FlowReservationResponseListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.FlowReservationResponseListLink_nsprefix_) else ''
            self.FlowReservationResponseListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FlowReservationResponseListLink', pretty_print=pretty_print)
        if self.FunctionSetAssignmentsListLink is not None:
            namespaceprefix_ = self.FunctionSetAssignmentsListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.FunctionSetAssignmentsListLink_nsprefix_) else ''
            self.FunctionSetAssignmentsListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='FunctionSetAssignmentsListLink', pretty_print=pretty_print)
        if self.postRate is not None:
            namespaceprefix_ = self.postRate_nsprefix_ + ':' if (UseCapturedNS_ and self.postRate_nsprefix_) else ''
            showIndent(outfile, level, pretty_print)
            outfile.write('<%spostRate>%s</%spostRate>%s' % (namespaceprefix_ , self.gds_format_integer(self.postRate, input_name='postRate'), namespaceprefix_ , eol_))
        if self.RegistrationLink is not None:
            namespaceprefix_ = self.RegistrationLink_nsprefix_ + ':' if (UseCapturedNS_ and self.RegistrationLink_nsprefix_) else ''
            self.RegistrationLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='RegistrationLink', pretty_print=pretty_print)
        if self.SubscriptionListLink is not None:
            namespaceprefix_ = self.SubscriptionListLink_nsprefix_ + ':' if (UseCapturedNS_ and self.SubscriptionListLink_nsprefix_) else ''
            self.SubscriptionListLink.export(outfile, level, namespaceprefix_, namespacedef_='', name_='SubscriptionListLink', pretty_print=pretty_print)
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(EndDevice, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        if nodeName_ == 'changedTime':
            obj_ = TimeType.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.changedTime = obj_
            obj_.original_tagname_ = 'changedTime'
        elif nodeName_ == 'enabled':
            sval_ = child_.text
            ival_ = self.gds_parse_boolean(sval_, node, 'enabled')
            ival_ = self.gds_validate_boolean(ival_, node, 'enabled')
            self.enabled = ival_
            self.enabled_nsprefix_ = child_.prefix
        elif nodeName_ == 'FlowReservationRequestListLink':
            obj_ = FlowReservationRequestListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FlowReservationRequestListLink = obj_
            obj_.original_tagname_ = 'FlowReservationRequestListLink'
        elif nodeName_ == 'FlowReservationResponseListLink':
            obj_ = FlowReservationResponseListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FlowReservationResponseListLink = obj_
            obj_.original_tagname_ = 'FlowReservationResponseListLink'
        elif nodeName_ == 'FunctionSetAssignmentsListLink':
            obj_ = FunctionSetAssignmentsListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.FunctionSetAssignmentsListLink = obj_
            obj_.original_tagname_ = 'FunctionSetAssignmentsListLink'
        elif nodeName_ == 'postRate' and child_.text:
            sval_ = child_.text
            ival_ = self.gds_parse_integer(sval_, node, 'postRate')
            ival_ = self.gds_validate_integer(ival_, node, 'postRate')
            self.postRate = ival_
            self.postRate_nsprefix_ = child_.prefix
            # validate type UInt32
            self.validate_UInt32(self.postRate)
        elif nodeName_ == 'RegistrationLink':
            obj_ = RegistrationLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.RegistrationLink = obj_
            obj_.original_tagname_ = 'RegistrationLink'
        elif nodeName_ == 'SubscriptionListLink':
            obj_ = SubscriptionListLink.factory(parent_object_=self)
            obj_.build(child_, gds_collector_=gds_collector_)
            self.SubscriptionListLink = obj_
            obj_.original_tagname_ = 'SubscriptionListLink'
        super(EndDevice, self)._buildChildren(child_, node, nodeName_, True)
# end class EndDevice


class TargetReading(BillingMeterReadingBase):
    """TargetReading -- Contains readings that specify a target or goal, such as a consumption target, to which billing incentives or other contractual ramifications may be associated.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BillingMeterReadingBase
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("TargetReading"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, TargetReading)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if TargetReading.subclass:
            return TargetReading.subclass(*args_, **kwargs_)
        else:
            return TargetReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(TargetReading, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TargetReading', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('TargetReading')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'TargetReading':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetReading')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='TargetReading', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='TargetReading'):
        super(TargetReading, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='TargetReading')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='TargetReading', fromsubclass_=False, pretty_print=True):
        super(TargetReading, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(TargetReading, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(TargetReading, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class TargetReading


class ProjectionReading(BillingMeterReadingBase):
    """ProjectionReading -- Contains values that forecast a future reading for the time or interval specified.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BillingMeterReadingBase
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("ProjectionReading"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, ProjectionReading)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if ProjectionReading.subclass:
            return ProjectionReading.subclass(*args_, **kwargs_)
        else:
            return ProjectionReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(ProjectionReading, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProjectionReading', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('ProjectionReading')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'ProjectionReading':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectionReading')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='ProjectionReading', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='ProjectionReading'):
        super(ProjectionReading, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='ProjectionReading')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='ProjectionReading', fromsubclass_=False, pretty_print=True):
        super(ProjectionReading, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(ProjectionReading, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(ProjectionReading, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class ProjectionReading


class HistoricalReading(BillingMeterReadingBase):
    """HistoricalReading -- To be used to present readings that have been processed and possibly corrected (as allowed, due to missing or incorrect data) by backend systems. This includes quality codes valid, verified, estimated, and derived / corrected.
    
    """
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = BillingMeterReadingBase
    def __init__(self, gds_collector_=None, **kwargs_):
        self.gds_collector_ = gds_collector_
        self.gds_elementtree_node_ = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs_.get('parent_object_')
        self.ns_prefix_ = None
        super(globals().get("HistoricalReading"), self).__init__( **kwargs_)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, HistoricalReading)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if HistoricalReading.subclass:
            return HistoricalReading.subclass(*args_, **kwargs_)
        else:
            return HistoricalReading(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ns_prefix_(self):
        return self.ns_prefix_
    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix
    def _hasContent(self):
        if (
            super(HistoricalReading, self)._hasContent()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HistoricalReading', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('HistoricalReading')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None and name_ == 'HistoricalReading':
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix_ = self.ns_prefix_ + ':'
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespaceprefix_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HistoricalReading')
        if self._hasContent():
            outfile.write('>%s' % (eol_, ))
            self._exportChildren(outfile, level + 1, namespaceprefix_, namespacedef_, name_='HistoricalReading', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespaceprefix_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def _exportAttributes(self, outfile, level, already_processed, namespaceprefix_='', name_='HistoricalReading'):
        super(HistoricalReading, self)._exportAttributes(outfile, level, already_processed, namespaceprefix_, name_='HistoricalReading')
    def _exportChildren(self, outfile, level, namespaceprefix_='', namespacedef_='', name_='HistoricalReading', fromsubclass_=False, pretty_print=True):
        super(HistoricalReading, self)._exportChildren(outfile, level, namespaceprefix_, namespacedef_, name_, True, pretty_print=pretty_print)
        pass
    def build(self, node, gds_collector_=None):
        self.gds_collector_ = gds_collector_
        if SaveElementTreeNode:
            self.gds_elementtree_node_ = node
        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName_, gds_collector_=gds_collector_)
        return self
    def _buildAttributes(self, node, attrs, already_processed):
        super(HistoricalReading, self)._buildAttributes(node, attrs, already_processed)
    def _buildChildren(self, child_, node, nodeName_, fromsubclass_=False, gds_collector_=None):
        super(HistoricalReading, self)._buildChildren(child_, node, nodeName_, True)
        pass
# end class HistoricalReading


GDSClassesMapping = {
    'AbstractDevice': AbstractDevice,
    'AccountBalance': AccountBalance,
    'AccountBalanceLink': AccountBalanceLink,
    'AccountingUnit': AccountingUnit,
    'AccumulationBehaviourType': AccumulationBehaviourType,
    'ActiveBillingPeriodListLink': ActiveBillingPeriodListLink,
    'ActiveCreditRegisterListLink': ActiveCreditRegisterListLink,
    'ActiveDERControlListLink': ActiveDERControlListLink,
    'ActiveEndDeviceControlListLink': ActiveEndDeviceControlListLink,
    'ActiveFlowReservationListLink': ActiveFlowReservationListLink,
    'ActivePower': ActivePower,
    'ActiveProjectionReadingListLink': ActiveProjectionReadingListLink,
    'ActiveSupplyInterruptionOverrideListLink': ActiveSupplyInterruptionOverrideListLink,
    'ActiveTargetReadingListLink': ActiveTargetReadingListLink,
    'ActiveTextMessageListLink': ActiveTextMessageListLink,
    'ActiveTimeTariffIntervalListLink': ActiveTimeTariffIntervalListLink,
    'AmpereHour': AmpereHour,
    'ApparentPower': ApparentPower,
    'ApplianceLoadReduction': ApplianceLoadReduction,
    'ApplianceLoadReductionType': ApplianceLoadReductionType,
    'AppliedTargetReduction': AppliedTargetReduction,
    'AssociatedDERProgramListLink': AssociatedDERProgramListLink,
    'AssociatedUsagePointLink': AssociatedUsagePointLink,
    'BillingMeterReadingBase': BillingMeterReadingBase,
    'BillingPeriod': BillingPeriod,
    'BillingPeriodList': BillingPeriodList,
    'BillingPeriodListLink': BillingPeriodListLink,
    'BillingReading': BillingReading,
    'BillingReadingList': BillingReadingList,
    'BillingReadingListLink': BillingReadingListLink,
    'BillingReadingSet': BillingReadingSet,
    'BillingReadingSetList': BillingReadingSetList,
    'BillingReadingSetListLink': BillingReadingSetListLink,
    'Charge': Charge,
    'ChargeKind': ChargeKind,
    'CommodityType': CommodityType,
    'Condition': Condition,
    'Configuration': Configuration,
    'ConfigurationLink': ConfigurationLink,
    'ConnectStatusType': ConnectStatusType,
    'ConsumptionBlockType': ConsumptionBlockType,
    'ConsumptionTariffInterval': ConsumptionTariffInterval,
    'ConsumptionTariffIntervalList': ConsumptionTariffIntervalList,
    'ConsumptionTariffIntervalListLink': ConsumptionTariffIntervalListLink,
    'CostKindType': CostKindType,
    'CreditRegister': CreditRegister,
    'CreditRegisterList': CreditRegisterList,
    'CreditRegisterListLink': CreditRegisterListLink,
    'CreditStatusType': CreditStatusType,
    'CreditTypeChange': CreditTypeChange,
    'CreditTypeType': CreditTypeType,
    'CurrencyCode': CurrencyCode,
    'CurrentDERProgramLink': CurrentDERProgramLink,
    'CurrentRMS': CurrentRMS,
    'CurveData': CurveData,
    'CustomerAccount': CustomerAccount,
    'CustomerAccountLink': CustomerAccountLink,
    'CustomerAccountList': CustomerAccountList,
    'CustomerAccountListLink': CustomerAccountListLink,
    'CustomerAgreement': CustomerAgreement,
    'CustomerAgreementList': CustomerAgreementList,
    'CustomerAgreementListLink': CustomerAgreementListLink,
    'DER': DER,
    'DERAvailability': DERAvailability,
    'DERAvailabilityLink': DERAvailabilityLink,
    'DERCapability': DERCapability,
    'DERCapabilityLink': DERCapabilityLink,
    'DERControl': DERControl,
    'DERControlBase': DERControlBase,
    'DERControlList': DERControlList,
    'DERControlListLink': DERControlListLink,
    'DERControlResponse': DERControlResponse,
    'DERControlType': DERControlType,
    'DERCurve': DERCurve,
    'DERCurveLink': DERCurveLink,
    'DERCurveList': DERCurveList,
    'DERCurveListLink': DERCurveListLink,
    'DERCurveType': DERCurveType,
    'DERLink': DERLink,
    'DERList': DERList,
    'DERListLink': DERListLink,
    'DERProgram': DERProgram,
    'DERProgramLink': DERProgramLink,
    'DERProgramList': DERProgramList,
    'DERProgramListLink': DERProgramListLink,
    'DERSettings': DERSettings,
    'DERSettingsLink': DERSettingsLink,
    'DERStatus': DERStatus,
    'DERStatusLink': DERStatusLink,
    'DERType': DERType,
    'DERUnitRefType': DERUnitRefType,
    'DRLCCapabilities': DRLCCapabilities,
    'DataQualifierType': DataQualifierType,
    'DateTimeInterval': DateTimeInterval,
    'DefaultDERControl': DefaultDERControl,
    'DefaultDERControlLink': DefaultDERControlLink,
    'DemandResponseProgram': DemandResponseProgram,
    'DemandResponseProgramLink': DemandResponseProgramLink,
    'DemandResponseProgramList': DemandResponseProgramList,
    'DemandResponseProgramListLink': DemandResponseProgramListLink,
    'DeviceCapability': DeviceCapability,
    'DeviceCapabilityLink': DeviceCapabilityLink,
    'DeviceCategoryType': DeviceCategoryType,
    'DeviceInformation': DeviceInformation,
    'DeviceInformationLink': DeviceInformationLink,
    'DeviceStatus': DeviceStatus,
    'DeviceStatusLink': DeviceStatusLink,
    'DrResponse': DrResponse,
    'DstRuleType': DstRuleType,
    'DutyCycle': DutyCycle,
    'EndDevice': EndDevice,
    'EndDeviceControl': EndDeviceControl,
    'EndDeviceControlList': EndDeviceControlList,
    'EndDeviceControlListLink': EndDeviceControlListLink,
    'EndDeviceLink': EndDeviceLink,
    'EndDeviceList': EndDeviceList,
    'EndDeviceListLink': EndDeviceListLink,
    'EnvironmentalCost': EnvironmentalCost,
    'Error': Error,
    'Event': Event,
    'EventStatus': EventStatus,
    'File': File,
    'FileLink': FileLink,
    'FileList': FileList,
    'FileListLink': FileListLink,
    'FileStatus': FileStatus,
    'FileStatusLink': FileStatusLink,
    'FixedPointType': FixedPointType,
    'FixedVar': FixedVar,
    'FlowDirectionType': FlowDirectionType,
    'FlowReservationRequest': FlowReservationRequest,
    'FlowReservationRequestList': FlowReservationRequestList,
    'FlowReservationRequestListLink': FlowReservationRequestListLink,
    'FlowReservationResponse': FlowReservationResponse,
    'FlowReservationResponseList': FlowReservationResponseList,
    'FlowReservationResponseListLink': FlowReservationResponseListLink,
    'FlowReservationResponseResponse': FlowReservationResponseResponse,
    'FreqDroopType': FreqDroopType,
    'FunctionSetAssignments': FunctionSetAssignments,
    'FunctionSetAssignmentsBase': FunctionSetAssignmentsBase,
    'FunctionSetAssignmentsList': FunctionSetAssignmentsList,
    'FunctionSetAssignmentsListLink': FunctionSetAssignmentsListLink,
    'GPSLocationType': GPSLocationType,
    'HistoricalReading': HistoricalReading,
    'HistoricalReadingList': HistoricalReadingList,
    'HistoricalReadingListLink': HistoricalReadingListLink,
    'IEEE_802_15_4': IEEE_802_15_4,
    'IPAddr': IPAddr,
    'IPAddrList': IPAddrList,
    'IPAddrListLink': IPAddrListLink,
    'IPInterface': IPInterface,
    'IPInterfaceList': IPInterfaceList,
    'IPInterfaceListLink': IPInterfaceListLink,
    'IdentifiedObject': IdentifiedObject,
    'InverterStatusType': InverterStatusType,
    'KindType': KindType,
    'LLInterface': LLInterface,
    'LLInterfaceList': LLInterfaceList,
    'LLInterfaceListLink': LLInterfaceListLink,
    'Link': Link,
    'List': List,
    'ListLink': ListLink,
    'LoadShedAvailability': LoadShedAvailability,
    'LoadShedAvailabilityList': LoadShedAvailabilityList,
    'LoadShedAvailabilityListLink': LoadShedAvailabilityListLink,
    'LocalControlModeStatusType': LocalControlModeStatusType,
    'LocaleType': LocaleType,
    'LogEvent': LogEvent,
    'LogEventList': LogEventList,
    'LogEventListLink': LogEventListLink,
    'ManufacturerStatusType': ManufacturerStatusType,
    'MessagingProgram': MessagingProgram,
    'MessagingProgramList': MessagingProgramList,
    'MessagingProgramListLink': MessagingProgramListLink,
    'MeterReading': MeterReading,
    'MeterReadingBase': MeterReadingBase,
    'MeterReadingLink': MeterReadingLink,
    'MeterReadingList': MeterReadingList,
    'MeterReadingListLink': MeterReadingListLink,
    'MirrorMeterReading': MirrorMeterReading,
    'MirrorMeterReadingList': MirrorMeterReadingList,
    'MirrorReadingSet': MirrorReadingSet,
    'MirrorUsagePoint': MirrorUsagePoint,
    'MirrorUsagePointList': MirrorUsagePointList,
    'MirrorUsagePointListLink': MirrorUsagePointListLink,
    'Neighbor': Neighbor,
    'NeighborList': NeighborList,
    'NeighborListLink': NeighborListLink,
    'Notification': Notification,
    'NotificationList': NotificationList,
    'NotificationListLink': NotificationListLink,
    'Offset': Offset,
    'OneHourRangeType': OneHourRangeType,
    'OperationalModeStatusType': OperationalModeStatusType,
    'PENType': PENType,
    'PEVInfo': PEVInfo,
    'PINType': PINType,
    'PerCent': PerCent,
    'PhaseCode': PhaseCode,
    'PowerConfiguration': PowerConfiguration,
    'PowerFactor': PowerFactor,
    'PowerFactorWithExcitation': PowerFactorWithExcitation,
    'PowerOfTenMultiplierType': PowerOfTenMultiplierType,
    'PowerSourceType': PowerSourceType,
    'PowerStatus': PowerStatus,
    'PowerStatusLink': PowerStatusLink,
    'PrepayModeType': PrepayModeType,
    'PrepayOperationStatus': PrepayOperationStatus,
    'PrepayOperationStatusLink': PrepayOperationStatusLink,
    'Prepayment': Prepayment,
    'PrepaymentLink': PrepaymentLink,
    'PrepaymentList': PrepaymentList,
    'PrepaymentListLink': PrepaymentListLink,
    'PriceResponse': PriceResponse,
    'PriceResponseCfg': PriceResponseCfg,
    'PriceResponseCfgList': PriceResponseCfgList,
    'PriceResponseCfgListLink': PriceResponseCfgListLink,
    'PrimacyType': PrimacyType,
    'PriorityType': PriorityType,
    'ProjectionReading': ProjectionReading,
    'ProjectionReadingList': ProjectionReadingList,
    'ProjectionReadingListLink': ProjectionReadingListLink,
    'RPLInstance': RPLInstance,
    'RPLInstanceList': RPLInstanceList,
    'RPLInstanceListLink': RPLInstanceListLink,
    'RPLSourceRoutes': RPLSourceRoutes,
    'RPLSourceRoutesList': RPLSourceRoutesList,
    'RPLSourceRoutesListLink': RPLSourceRoutesListLink,
    'RandomizableEvent': RandomizableEvent,
    'RateComponent': RateComponent,
    'RateComponentLink': RateComponentLink,
    'RateComponentList': RateComponentList,
    'RateComponentListLink': RateComponentListLink,
    'ReactivePower': ReactivePower,
    'ReactiveSusceptance': ReactiveSusceptance,
    'Reading': Reading,
    'ReadingBase': ReadingBase,
    'ReadingLink': ReadingLink,
    'ReadingList': ReadingList,
    'ReadingListLink': ReadingListLink,
    'ReadingSet': ReadingSet,
    'ReadingSetBase': ReadingSetBase,
    'ReadingSetList': ReadingSetList,
    'ReadingSetListLink': ReadingSetListLink,
    'ReadingType': ReadingType,
    'ReadingTypeLink': ReadingTypeLink,
    'RealEnergy': RealEnergy,
    'Registration': Registration,
    'RegistrationLink': RegistrationLink,
    'RequestStatus': RequestStatus,
    'Resource': Resource,
    'RespondableIdentifiedObject': RespondableIdentifiedObject,
    'RespondableResource': RespondableResource,
    'RespondableSubscribableIdentifiedObject': RespondableSubscribableIdentifiedObject,
    'Response': Response,
    'ResponseList': ResponseList,
    'ResponseListLink': ResponseListLink,
    'ResponseSet': ResponseSet,
    'ResponseSetList': ResponseSetList,
    'ResponseSetListLink': ResponseSetListLink,
    'RoleFlagsType': RoleFlagsType,
    'SFDIType': SFDIType,
    'SelfDevice': SelfDevice,
    'SelfDeviceLink': SelfDeviceLink,
    'ServiceChange': ServiceChange,
    'ServiceKind': ServiceKind,
    'ServiceStatusType': ServiceStatusType,
    'ServiceSupplier': ServiceSupplier,
    'ServiceSupplierLink': ServiceSupplierLink,
    'ServiceSupplierList': ServiceSupplierList,
    'SetPoint': SetPoint,
    'SignedPerCent': SignedPerCent,
    'SignedRealEnergy': SignedRealEnergy,
    'StateOfChargeStatusType': StateOfChargeStatusType,
    'StorageModeStatusType': StorageModeStatusType,
    'SubscribableIdentifiedObject': SubscribableIdentifiedObject,
    'SubscribableList': SubscribableList,
    'SubscribableResource': SubscribableResource,
    'Subscription': Subscription,
    'SubscriptionBase': SubscriptionBase,
    'SubscriptionList': SubscriptionList,
    'SubscriptionListLink': SubscriptionListLink,
    'SupplyInterruptionOverride': SupplyInterruptionOverride,
    'SupplyInterruptionOverrideList': SupplyInterruptionOverrideList,
    'SupplyInterruptionOverrideListLink': SupplyInterruptionOverrideListLink,
    'SupportedLocale': SupportedLocale,
    'SupportedLocaleList': SupportedLocaleList,
    'SupportedLocaleListLink': SupportedLocaleListLink,
    'TOUType': TOUType,
    'TargetReading': TargetReading,
    'TargetReadingList': TargetReadingList,
    'TargetReadingListLink': TargetReadingListLink,
    'TargetReduction': TargetReduction,
    'TariffProfile': TariffProfile,
    'TariffProfileLink': TariffProfileLink,
    'TariffProfileList': TariffProfileList,
    'TariffProfileListLink': TariffProfileListLink,
    'Temperature': Temperature,
    'TextMessage': TextMessage,
    'TextMessageList': TextMessageList,
    'TextMessageListLink': TextMessageListLink,
    'TextResponse': TextResponse,
    'Time': Time,
    'TimeConfiguration': TimeConfiguration,
    'TimeLink': TimeLink,
    'TimeOffsetType': TimeOffsetType,
    'TimeTariffInterval': TimeTariffInterval,
    'TimeTariffIntervalList': TimeTariffIntervalList,
    'TimeTariffIntervalListLink': TimeTariffIntervalListLink,
    'TimeType': TimeType,
    'UnitType': UnitType,
    'UnitValueType': UnitValueType,
    'UnsignedFixedPointType': UnsignedFixedPointType,
    'UomType': UomType,
    'UsagePoint': UsagePoint,
    'UsagePointBase': UsagePointBase,
    'UsagePointLink': UsagePointLink,
    'UsagePointList': UsagePointList,
    'UsagePointListLink': UsagePointListLink,
    'VersionType': VersionType,
    'VoltageRMS': VoltageRMS,
    'WattHour': WattHour,
    'loWPAN': loWPAN,
    'mRIDType': mRIDType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def get_required_ns_prefix_defs(rootNode):
    '''Get all name space prefix definitions required in this XML doc.
    Return a dictionary of definitions and a char string of definitions.
    '''
    nsmap = {
        prefix: uri
        for node in rootNode.iter()
        for (prefix, uri) in node.nsmap.items()
        if prefix is not None
    }
    namespacedefs = ' '.join([
        'xmlns:{}="{}"'.format(prefix, uri)
        for prefix, uri in nsmap.items()
    ])
    return nsmap, namespacedefs


def parse(inFileName, silence=False, print_warnings=True):
    global CapturedNsmap_
    gds_collector = GdsCollector_()
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeviceCapability'
        rootClass = DeviceCapability
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    CapturedNsmap_, namespacedefs = get_required_ns_prefix_defs(rootNode)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_=namespacedefs,
            pretty_print=True)
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseEtree(inFileName, silence=False, print_warnings=True,
               mapping=None, nsmap=None):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeviceCapability'
        rootClass = DeviceCapability
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if mapping is None:
        mapping = {}
    rootElement = rootObj.to_etree(
        None, name_=rootTag, mapping_=mapping, nsmap_=nsmap)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(str(content))
        sys.stdout.write('\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False, print_warnings=True):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    gds_collector = GdsCollector_()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeviceCapability'
        rootClass = DeviceCapability
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    if not SaveElementTreeNode:
        rootNode = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def parseLiteral(inFileName, silence=False, print_warnings=True):
    parser = None
    doc = parsexml_(inFileName, parser)
    gds_collector = GdsCollector_()
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'DeviceCapability'
        rootClass = DeviceCapability
    rootObj = rootClass.factory()
    rootObj.build(rootNode, gds_collector_=gds_collector)
    # Enable Python to collect the space used by the DOM.
    if not SaveElementTreeNode:
        doc = None
        rootNode = None
    if not silence:
        sys.stdout.write('#from new_xsd import *\n\n')
        sys.stdout.write('import new_xsd as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    if print_warnings and len(gds_collector.get_messages()) > 0:
        separator = ('-' * 50) + '\n'
        sys.stderr.write(separator)
        sys.stderr.write('----- Warnings -- count: {} -----\n'.format(
            len(gds_collector.get_messages()), ))
        gds_collector.write_messages(sys.stderr)
        sys.stderr.write(separator)
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

RenameMappings_ = {
}

#
# Mapping of namespaces to types defined in them
# and the file in which each is defined.
# simpleTypes are marked "ST" and complexTypes "CT".
NamespaceToDefMappings_ = {'urn:ieee:std:2030.5:ns': [('SubscribableType', 'sep.xsd', 'ST'),
                            ('HexBinary8', 'sep.xsd', 'ST'),
                            ('HexBinary16', 'sep.xsd', 'ST'),
                            ('HexBinary32', 'sep.xsd', 'ST'),
                            ('HexBinary48', 'sep.xsd', 'ST'),
                            ('HexBinary64', 'sep.xsd', 'ST'),
                            ('HexBinary128', 'sep.xsd', 'ST'),
                            ('HexBinary160', 'sep.xsd', 'ST'),
                            ('String6', 'sep.xsd', 'ST'),
                            ('String16', 'sep.xsd', 'ST'),
                            ('String20', 'sep.xsd', 'ST'),
                            ('String32', 'sep.xsd', 'ST'),
                            ('String42', 'sep.xsd', 'ST'),
                            ('String192', 'sep.xsd', 'ST'),
                            ('UInt8', 'sep.xsd', 'ST'),
                            ('UInt16', 'sep.xsd', 'ST'),
                            ('UInt32', 'sep.xsd', 'ST'),
                            ('UInt40', 'sep.xsd', 'ST'),
                            ('UInt48', 'sep.xsd', 'ST'),
                            ('UInt64', 'sep.xsd', 'ST'),
                            ('Int8', 'sep.xsd', 'ST'),
                            ('Int16', 'sep.xsd', 'ST'),
                            ('Int32', 'sep.xsd', 'ST'),
                            ('Int48', 'sep.xsd', 'ST'),
                            ('Int64', 'sep.xsd', 'ST'),
                            ('DeviceCapability', 'sep.xsd', 'CT'),
                            ('AbstractDevice', 'sep.xsd', 'CT'),
                            ('DeviceStatus', 'sep.xsd', 'CT'),
                            ('EndDevice', 'sep.xsd', 'CT'),
                            ('EndDeviceList', 'sep.xsd', 'CT'),
                            ('Registration', 'sep.xsd', 'CT'),
                            ('SelfDevice', 'sep.xsd', 'CT'),
                            ('Temperature', 'sep.xsd', 'CT'),
                            ('FunctionSetAssignmentsBase', 'sep.xsd', 'CT'),
                            ('FunctionSetAssignments', 'sep.xsd', 'CT'),
                            ('FunctionSetAssignmentsList', 'sep.xsd', 'CT'),
                            ('Condition', 'sep.xsd', 'CT'),
                            ('SubscriptionBase', 'sep.xsd', 'CT'),
                            ('Subscription', 'sep.xsd', 'CT'),
                            ('SubscriptionList', 'sep.xsd', 'CT'),
                            ('Notification', 'sep.xsd', 'CT'),
                            ('NotificationList', 'sep.xsd', 'CT'),
                            ('DERControlResponse', 'sep.xsd', 'CT'),
                            ('FlowReservationResponseResponse',
                             'sep.xsd',
                             'CT'),
                            ('AppliedTargetReduction', 'sep.xsd', 'CT'),
                            ('DrResponse', 'sep.xsd', 'CT'),
                            ('PriceResponse', 'sep.xsd', 'CT'),
                            ('Response', 'sep.xsd', 'CT'),
                            ('ResponseList', 'sep.xsd', 'CT'),
                            ('ResponseSet', 'sep.xsd', 'CT'),
                            ('ResponseSetList', 'sep.xsd', 'CT'),
                            ('TextResponse', 'sep.xsd', 'CT'),
                            ('Time', 'sep.xsd', 'CT'),
                            ('DeviceInformation', 'sep.xsd', 'CT'),
                            ('DRLCCapabilities', 'sep.xsd', 'CT'),
                            ('SupportedLocale', 'sep.xsd', 'CT'),
                            ('SupportedLocaleList', 'sep.xsd', 'CT'),
                            ('PowerStatus', 'sep.xsd', 'CT'),
                            ('PowerSourceType', 'sep.xsd', 'CT'),
                            ('PEVInfo', 'sep.xsd', 'CT'),
                            ('IEEE_802_15_4', 'sep.xsd', 'CT'),
                            ('IPAddr', 'sep.xsd', 'CT'),
                            ('IPAddrList', 'sep.xsd', 'CT'),
                            ('IPInterface', 'sep.xsd', 'CT'),
                            ('IPInterfaceList', 'sep.xsd', 'CT'),
                            ('LLInterface', 'sep.xsd', 'CT'),
                            ('LLInterfaceList', 'sep.xsd', 'CT'),
                            ('loWPAN', 'sep.xsd', 'CT'),
                            ('Neighbor', 'sep.xsd', 'CT'),
                            ('NeighborList', 'sep.xsd', 'CT'),
                            ('RPLInstance', 'sep.xsd', 'CT'),
                            ('RPLInstanceList', 'sep.xsd', 'CT'),
                            ('RPLSourceRoutes', 'sep.xsd', 'CT'),
                            ('RPLSourceRoutesList', 'sep.xsd', 'CT'),
                            ('LogEvent', 'sep.xsd', 'CT'),
                            ('LogEventList', 'sep.xsd', 'CT'),
                            ('Configuration', 'sep.xsd', 'CT'),
                            ('PowerConfiguration', 'sep.xsd', 'CT'),
                            ('PriceResponseCfg', 'sep.xsd', 'CT'),
                            ('PriceResponseCfgList', 'sep.xsd', 'CT'),
                            ('TimeConfiguration', 'sep.xsd', 'CT'),
                            ('File', 'sep.xsd', 'CT'),
                            ('FileList', 'sep.xsd', 'CT'),
                            ('FileStatus', 'sep.xsd', 'CT'),
                            ('LoadShedAvailabilityList', 'sep.xsd', 'CT'),
                            ('ApplianceLoadReduction', 'sep.xsd', 'CT'),
                            ('DemandResponseProgram', 'sep.xsd', 'CT'),
                            ('DemandResponseProgramList', 'sep.xsd', 'CT'),
                            ('DutyCycle', 'sep.xsd', 'CT'),
                            ('EndDeviceControl', 'sep.xsd', 'CT'),
                            ('EndDeviceControlList', 'sep.xsd', 'CT'),
                            ('LoadShedAvailability', 'sep.xsd', 'CT'),
                            ('Offset', 'sep.xsd', 'CT'),
                            ('SetPoint', 'sep.xsd', 'CT'),
                            ('TargetReduction', 'sep.xsd', 'CT'),
                            ('MeterReading', 'sep.xsd', 'CT'),
                            ('MeterReadingList', 'sep.xsd', 'CT'),
                            ('Reading', 'sep.xsd', 'CT'),
                            ('ReadingList', 'sep.xsd', 'CT'),
                            ('ReadingSet', 'sep.xsd', 'CT'),
                            ('ReadingSetList', 'sep.xsd', 'CT'),
                            ('ReadingType', 'sep.xsd', 'CT'),
                            ('UsagePoint', 'sep.xsd', 'CT'),
                            ('UsagePointList', 'sep.xsd', 'CT'),
                            ('ConsumptionTariffInterval', 'sep.xsd', 'CT'),
                            ('ConsumptionTariffIntervalList', 'sep.xsd', 'CT'),
                            ('CostKindType', 'sep.xsd', 'CT'),
                            ('EnvironmentalCost', 'sep.xsd', 'CT'),
                            ('RateComponent', 'sep.xsd', 'CT'),
                            ('RateComponentList', 'sep.xsd', 'CT'),
                            ('TariffProfile', 'sep.xsd', 'CT'),
                            ('TariffProfileList', 'sep.xsd', 'CT'),
                            ('TimeTariffInterval', 'sep.xsd', 'CT'),
                            ('TimeTariffIntervalList', 'sep.xsd', 'CT'),
                            ('MessagingProgram', 'sep.xsd', 'CT'),
                            ('MessagingProgramList', 'sep.xsd', 'CT'),
                            ('PriorityType', 'sep.xsd', 'CT'),
                            ('TextMessage', 'sep.xsd', 'CT'),
                            ('TextMessageList', 'sep.xsd', 'CT'),
                            ('BillingPeriod', 'sep.xsd', 'CT'),
                            ('BillingPeriodList', 'sep.xsd', 'CT'),
                            ('BillingMeterReadingBase', 'sep.xsd', 'CT'),
                            ('BillingReading', 'sep.xsd', 'CT'),
                            ('BillingReadingList', 'sep.xsd', 'CT'),
                            ('BillingReadingSet', 'sep.xsd', 'CT'),
                            ('BillingReadingSetList', 'sep.xsd', 'CT'),
                            ('Charge', 'sep.xsd', 'CT'),
                            ('ChargeKind', 'sep.xsd', 'CT'),
                            ('CustomerAccount', 'sep.xsd', 'CT'),
                            ('CustomerAccountList', 'sep.xsd', 'CT'),
                            ('CustomerAgreement', 'sep.xsd', 'CT'),
                            ('CustomerAgreementList', 'sep.xsd', 'CT'),
                            ('HistoricalReading', 'sep.xsd', 'CT'),
                            ('HistoricalReadingList', 'sep.xsd', 'CT'),
                            ('ProjectionReading', 'sep.xsd', 'CT'),
                            ('ProjectionReadingList', 'sep.xsd', 'CT'),
                            ('TargetReading', 'sep.xsd', 'CT'),
                            ('TargetReadingList', 'sep.xsd', 'CT'),
                            ('ServiceSupplier', 'sep.xsd', 'CT'),
                            ('ServiceSupplierList', 'sep.xsd', 'CT'),
                            ('AccountBalance', 'sep.xsd', 'CT'),
                            ('AccountingUnit', 'sep.xsd', 'CT'),
                            ('CreditRegister', 'sep.xsd', 'CT'),
                            ('CreditRegisterList', 'sep.xsd', 'CT'),
                            ('Prepayment', 'sep.xsd', 'CT'),
                            ('PrepaymentList', 'sep.xsd', 'CT'),
                            ('PrepayModeType', 'sep.xsd', 'CT'),
                            ('PrepayOperationStatus', 'sep.xsd', 'CT'),
                            ('ServiceChange', 'sep.xsd', 'CT'),
                            ('SupplyInterruptionOverride', 'sep.xsd', 'CT'),
                            ('SupplyInterruptionOverrideList', 'sep.xsd', 'CT'),
                            ('CreditStatusType', 'sep.xsd', 'CT'),
                            ('CreditTypeType', 'sep.xsd', 'CT'),
                            ('CreditTypeChange', 'sep.xsd', 'CT'),
                            ('ServiceStatusType', 'sep.xsd', 'CT'),
                            ('RequestStatus', 'sep.xsd', 'CT'),
                            ('FlowReservationRequest', 'sep.xsd', 'CT'),
                            ('FlowReservationRequestList', 'sep.xsd', 'CT'),
                            ('FlowReservationResponse', 'sep.xsd', 'CT'),
                            ('FlowReservationResponseList', 'sep.xsd', 'CT'),
                            ('DefaultDERControl', 'sep.xsd', 'CT'),
                            ('FreqDroopType', 'sep.xsd', 'CT'),
                            ('DER', 'sep.xsd', 'CT'),
                            ('DERList', 'sep.xsd', 'CT'),
                            ('DERSettings', 'sep.xsd', 'CT'),
                            ('DERType', 'sep.xsd', 'CT'),
                            ('DERAvailability', 'sep.xsd', 'CT'),
                            ('DERCapability', 'sep.xsd', 'CT'),
                            ('DERControlBase', 'sep.xsd', 'CT'),
                            ('DERControl', 'sep.xsd', 'CT'),
                            ('DERControlList', 'sep.xsd', 'CT'),
                            ('DERControlType', 'sep.xsd', 'CT'),
                            ('DERCurve', 'sep.xsd', 'CT'),
                            ('CurrentDERProgramLink', 'sep.xsd', 'CT'),
                            ('DERCurveList', 'sep.xsd', 'CT'),
                            ('CurveData', 'sep.xsd', 'CT'),
                            ('DERCurveType', 'sep.xsd', 'CT'),
                            ('DERProgram', 'sep.xsd', 'CT'),
                            ('DERProgramList', 'sep.xsd', 'CT'),
                            ('DERStatus', 'sep.xsd', 'CT'),
                            ('DERUnitRefType', 'sep.xsd', 'CT'),
                            ('CurrentRMS', 'sep.xsd', 'CT'),
                            ('FixedPointType', 'sep.xsd', 'CT'),
                            ('UnsignedFixedPointType', 'sep.xsd', 'CT'),
                            ('ActivePower', 'sep.xsd', 'CT'),
                            ('AmpereHour', 'sep.xsd', 'CT'),
                            ('ApparentPower', 'sep.xsd', 'CT'),
                            ('ReactivePower', 'sep.xsd', 'CT'),
                            ('ReactiveSusceptance', 'sep.xsd', 'CT'),
                            ('PowerFactor', 'sep.xsd', 'CT'),
                            ('PowerFactorWithExcitation', 'sep.xsd', 'CT'),
                            ('FixedVar', 'sep.xsd', 'CT'),
                            ('WattHour', 'sep.xsd', 'CT'),
                            ('VoltageRMS', 'sep.xsd', 'CT'),
                            ('ConnectStatusType', 'sep.xsd', 'CT'),
                            ('InverterStatusType', 'sep.xsd', 'CT'),
                            ('LocalControlModeStatusType', 'sep.xsd', 'CT'),
                            ('ManufacturerStatusType', 'sep.xsd', 'CT'),
                            ('OperationalModeStatusType', 'sep.xsd', 'CT'),
                            ('StateOfChargeStatusType', 'sep.xsd', 'CT'),
                            ('StorageModeStatusType', 'sep.xsd', 'CT'),
                            ('AccountBalanceLink', 'sep.xsd', 'CT'),
                            ('ActiveBillingPeriodListLink', 'sep.xsd', 'CT'),
                            ('ActiveCreditRegisterListLink', 'sep.xsd', 'CT'),
                            ('ActiveDERControlListLink', 'sep.xsd', 'CT'),
                            ('ActiveEndDeviceControlListLink', 'sep.xsd', 'CT'),
                            ('ActiveFlowReservationListLink', 'sep.xsd', 'CT'),
                            ('ActiveProjectionReadingListLink',
                             'sep.xsd',
                             'CT'),
                            ('ActiveSupplyInterruptionOverrideListLink',
                             'sep.xsd',
                             'CT'),
                            ('ActiveTargetReadingListLink', 'sep.xsd', 'CT'),
                            ('ActiveTextMessageListLink', 'sep.xsd', 'CT'),
                            ('ActiveTimeTariffIntervalListLink',
                             'sep.xsd',
                             'CT'),
                            ('AssociatedDERProgramListLink', 'sep.xsd', 'CT'),
                            ('AssociatedUsagePointLink', 'sep.xsd', 'CT'),
                            ('BillingPeriodListLink', 'sep.xsd', 'CT'),
                            ('BillingReadingListLink', 'sep.xsd', 'CT'),
                            ('BillingReadingSetListLink', 'sep.xsd', 'CT'),
                            ('ConfigurationLink', 'sep.xsd', 'CT'),
                            ('ConsumptionTariffIntervalListLink',
                             'sep.xsd',
                             'CT'),
                            ('CreditRegisterListLink', 'sep.xsd', 'CT'),
                            ('CustomerAccountLink', 'sep.xsd', 'CT'),
                            ('CustomerAccountListLink', 'sep.xsd', 'CT'),
                            ('CustomerAgreementListLink', 'sep.xsd', 'CT'),
                            ('DemandResponseProgramLink', 'sep.xsd', 'CT'),
                            ('DemandResponseProgramListLink', 'sep.xsd', 'CT'),
                            ('DERAvailabilityLink', 'sep.xsd', 'CT'),
                            ('DefaultDERControlLink', 'sep.xsd', 'CT'),
                            ('DERCapabilityLink', 'sep.xsd', 'CT'),
                            ('DERControlListLink', 'sep.xsd', 'CT'),
                            ('DERCurveLink', 'sep.xsd', 'CT'),
                            ('DERCurveListLink', 'sep.xsd', 'CT'),
                            ('DERLink', 'sep.xsd', 'CT'),
                            ('DERListLink', 'sep.xsd', 'CT'),
                            ('DERProgramLink', 'sep.xsd', 'CT'),
                            ('DERProgramListLink', 'sep.xsd', 'CT'),
                            ('DERSettingsLink', 'sep.xsd', 'CT'),
                            ('DERStatusLink', 'sep.xsd', 'CT'),
                            ('DeviceCapabilityLink', 'sep.xsd', 'CT'),
                            ('DeviceInformationLink', 'sep.xsd', 'CT'),
                            ('DeviceStatusLink', 'sep.xsd', 'CT'),
                            ('EndDeviceControlListLink', 'sep.xsd', 'CT'),
                            ('EndDeviceLink', 'sep.xsd', 'CT'),
                            ('EndDeviceListLink', 'sep.xsd', 'CT'),
                            ('FileLink', 'sep.xsd', 'CT'),
                            ('FileListLink', 'sep.xsd', 'CT'),
                            ('FileStatusLink', 'sep.xsd', 'CT'),
                            ('FlowReservationRequestListLink', 'sep.xsd', 'CT'),
                            ('FlowReservationResponseListLink',
                             'sep.xsd',
                             'CT'),
                            ('FunctionSetAssignmentsListLink', 'sep.xsd', 'CT'),
                            ('HistoricalReadingListLink', 'sep.xsd', 'CT'),
                            ('IPAddrListLink', 'sep.xsd', 'CT'),
                            ('IPInterfaceListLink', 'sep.xsd', 'CT'),
                            ('LLInterfaceListLink', 'sep.xsd', 'CT'),
                            ('LoadShedAvailabilityListLink', 'sep.xsd', 'CT'),
                            ('LogEventListLink', 'sep.xsd', 'CT'),
                            ('MessagingProgramListLink', 'sep.xsd', 'CT'),
                            ('MeterReadingLink', 'sep.xsd', 'CT'),
                            ('MeterReadingListLink', 'sep.xsd', 'CT'),
                            ('MirrorUsagePointListLink', 'sep.xsd', 'CT'),
                            ('NeighborListLink', 'sep.xsd', 'CT'),
                            ('NotificationListLink', 'sep.xsd', 'CT'),
                            ('PowerStatusLink', 'sep.xsd', 'CT'),
                            ('PrepaymentLink', 'sep.xsd', 'CT'),
                            ('PrepaymentListLink', 'sep.xsd', 'CT'),
                            ('PrepayOperationStatusLink', 'sep.xsd', 'CT'),
                            ('PriceResponseCfgListLink', 'sep.xsd', 'CT'),
                            ('ProjectionReadingListLink', 'sep.xsd', 'CT'),
                            ('RateComponentLink', 'sep.xsd', 'CT'),
                            ('RateComponentListLink', 'sep.xsd', 'CT'),
                            ('ReadingLink', 'sep.xsd', 'CT'),
                            ('ReadingListLink', 'sep.xsd', 'CT'),
                            ('ReadingSetListLink', 'sep.xsd', 'CT'),
                            ('ReadingTypeLink', 'sep.xsd', 'CT'),
                            ('RegistrationLink', 'sep.xsd', 'CT'),
                            ('ResponseListLink', 'sep.xsd', 'CT'),
                            ('ResponseSetListLink', 'sep.xsd', 'CT'),
                            ('RPLInstanceListLink', 'sep.xsd', 'CT'),
                            ('RPLSourceRoutesListLink', 'sep.xsd', 'CT'),
                            ('SelfDeviceLink', 'sep.xsd', 'CT'),
                            ('ServiceSupplierLink', 'sep.xsd', 'CT'),
                            ('SubscriptionListLink', 'sep.xsd', 'CT'),
                            ('SupplyInterruptionOverrideListLink',
                             'sep.xsd',
                             'CT'),
                            ('SupportedLocaleListLink', 'sep.xsd', 'CT'),
                            ('TargetReadingListLink', 'sep.xsd', 'CT'),
                            ('TariffProfileLink', 'sep.xsd', 'CT'),
                            ('TariffProfileListLink', 'sep.xsd', 'CT'),
                            ('TextMessageListLink', 'sep.xsd', 'CT'),
                            ('TimeLink', 'sep.xsd', 'CT'),
                            ('TimeTariffIntervalListLink', 'sep.xsd', 'CT'),
                            ('UsagePointLink', 'sep.xsd', 'CT'),
                            ('UsagePointListLink', 'sep.xsd', 'CT'),
                            ('IdentifiedObject', 'sep.xsd', 'CT'),
                            ('Link', 'sep.xsd', 'CT'),
                            ('List', 'sep.xsd', 'CT'),
                            ('ListLink', 'sep.xsd', 'CT'),
                            ('Resource', 'sep.xsd', 'CT'),
                            ('RespondableIdentifiedObject', 'sep.xsd', 'CT'),
                            ('RespondableResource', 'sep.xsd', 'CT'),
                            ('RespondableSubscribableIdentifiedObject',
                             'sep.xsd',
                             'CT'),
                            ('SubscribableIdentifiedObject', 'sep.xsd', 'CT'),
                            ('SubscribableList', 'sep.xsd', 'CT'),
                            ('SubscribableResource', 'sep.xsd', 'CT'),
                            ('Error', 'sep.xsd', 'CT'),
                            ('Event', 'sep.xsd', 'CT'),
                            ('EventStatus', 'sep.xsd', 'CT'),
                            ('RandomizableEvent', 'sep.xsd', 'CT'),
                            ('AccumulationBehaviourType', 'sep.xsd', 'CT'),
                            ('ApplianceLoadReductionType', 'sep.xsd', 'CT'),
                            ('CommodityType', 'sep.xsd', 'CT'),
                            ('ConsumptionBlockType', 'sep.xsd', 'CT'),
                            ('CurrencyCode', 'sep.xsd', 'CT'),
                            ('DataQualifierType', 'sep.xsd', 'CT'),
                            ('DateTimeInterval', 'sep.xsd', 'CT'),
                            ('DeviceCategoryType', 'sep.xsd', 'CT'),
                            ('DstRuleType', 'sep.xsd', 'CT'),
                            ('FlowDirectionType', 'sep.xsd', 'CT'),
                            ('GPSLocationType', 'sep.xsd', 'CT'),
                            ('KindType', 'sep.xsd', 'CT'),
                            ('LocaleType', 'sep.xsd', 'CT'),
                            ('mRIDType', 'sep.xsd', 'CT'),
                            ('OneHourRangeType', 'sep.xsd', 'CT'),
                            ('PENType', 'sep.xsd', 'CT'),
                            ('PerCent', 'sep.xsd', 'CT'),
                            ('PhaseCode', 'sep.xsd', 'CT'),
                            ('PINType', 'sep.xsd', 'CT'),
                            ('PowerOfTenMultiplierType', 'sep.xsd', 'CT'),
                            ('PrimacyType', 'sep.xsd', 'CT'),
                            ('RealEnergy', 'sep.xsd', 'CT'),
                            ('RoleFlagsType', 'sep.xsd', 'CT'),
                            ('ServiceKind', 'sep.xsd', 'CT'),
                            ('SFDIType', 'sep.xsd', 'CT'),
                            ('SignedPerCent', 'sep.xsd', 'CT'),
                            ('SignedRealEnergy', 'sep.xsd', 'CT'),
                            ('TimeOffsetType', 'sep.xsd', 'CT'),
                            ('TimeType', 'sep.xsd', 'CT'),
                            ('TOUType', 'sep.xsd', 'CT'),
                            ('UnitType', 'sep.xsd', 'CT'),
                            ('UnitValueType', 'sep.xsd', 'CT'),
                            ('UomType', 'sep.xsd', 'CT'),
                            ('VersionType', 'sep.xsd', 'CT'),
                            ('MirrorMeterReading', 'sep.xsd', 'CT'),
                            ('MirrorMeterReadingList', 'sep.xsd', 'CT'),
                            ('MeterReadingBase', 'sep.xsd', 'CT'),
                            ('MirrorReadingSet', 'sep.xsd', 'CT'),
                            ('MirrorUsagePoint', 'sep.xsd', 'CT'),
                            ('MirrorUsagePointList', 'sep.xsd', 'CT'),
                            ('ReadingBase', 'sep.xsd', 'CT'),
                            ('ReadingSetBase', 'sep.xsd', 'CT'),
                            ('UsagePointBase', 'sep.xsd', 'CT')]}

__all__ = [
    "AbstractDevice",
    "AccountBalance",
    "AccountBalanceLink",
    "AccountingUnit",
    "AccumulationBehaviourType",
    "ActiveBillingPeriodListLink",
    "ActiveCreditRegisterListLink",
    "ActiveDERControlListLink",
    "ActiveEndDeviceControlListLink",
    "ActiveFlowReservationListLink",
    "ActivePower",
    "ActiveProjectionReadingListLink",
    "ActiveSupplyInterruptionOverrideListLink",
    "ActiveTargetReadingListLink",
    "ActiveTextMessageListLink",
    "ActiveTimeTariffIntervalListLink",
    "AmpereHour",
    "ApparentPower",
    "ApplianceLoadReduction",
    "ApplianceLoadReductionType",
    "AppliedTargetReduction",
    "AssociatedDERProgramListLink",
    "AssociatedUsagePointLink",
    "BillingMeterReadingBase",
    "BillingPeriod",
    "BillingPeriodList",
    "BillingPeriodListLink",
    "BillingReading",
    "BillingReadingList",
    "BillingReadingListLink",
    "BillingReadingSet",
    "BillingReadingSetList",
    "BillingReadingSetListLink",
    "Charge",
    "ChargeKind",
    "CommodityType",
    "Condition",
    "Configuration",
    "ConfigurationLink",
    "ConnectStatusType",
    "ConsumptionBlockType",
    "ConsumptionTariffInterval",
    "ConsumptionTariffIntervalList",
    "ConsumptionTariffIntervalListLink",
    "CostKindType",
    "CreditRegister",
    "CreditRegisterList",
    "CreditRegisterListLink",
    "CreditStatusType",
    "CreditTypeChange",
    "CreditTypeType",
    "CurrencyCode",
    "CurrentDERProgramLink",
    "CurrentRMS",
    "CurveData",
    "CustomerAccount",
    "CustomerAccountLink",
    "CustomerAccountList",
    "CustomerAccountListLink",
    "CustomerAgreement",
    "CustomerAgreementList",
    "CustomerAgreementListLink",
    "DER",
    "DERAvailability",
    "DERAvailabilityLink",
    "DERCapability",
    "DERCapabilityLink",
    "DERControl",
    "DERControlBase",
    "DERControlList",
    "DERControlListLink",
    "DERControlResponse",
    "DERControlType",
    "DERCurve",
    "DERCurveLink",
    "DERCurveList",
    "DERCurveListLink",
    "DERCurveType",
    "DERLink",
    "DERList",
    "DERListLink",
    "DERProgram",
    "DERProgramLink",
    "DERProgramList",
    "DERProgramListLink",
    "DERSettings",
    "DERSettingsLink",
    "DERStatus",
    "DERStatusLink",
    "DERType",
    "DERUnitRefType",
    "DRLCCapabilities",
    "DataQualifierType",
    "DateTimeInterval",
    "DefaultDERControl",
    "DefaultDERControlLink",
    "DemandResponseProgram",
    "DemandResponseProgramLink",
    "DemandResponseProgramList",
    "DemandResponseProgramListLink",
    "DeviceCapability",
    "DeviceCapabilityLink",
    "DeviceCategoryType",
    "DeviceInformation",
    "DeviceInformationLink",
    "DeviceStatus",
    "DeviceStatusLink",
    "DrResponse",
    "DstRuleType",
    "DutyCycle",
    "EndDevice",
    "EndDeviceControl",
    "EndDeviceControlList",
    "EndDeviceControlListLink",
    "EndDeviceLink",
    "EndDeviceList",
    "EndDeviceListLink",
    "EnvironmentalCost",
    "Error",
    "Event",
    "EventStatus",
    "File",
    "FileLink",
    "FileList",
    "FileListLink",
    "FileStatus",
    "FileStatusLink",
    "FixedPointType",
    "FixedVar",
    "FlowDirectionType",
    "FlowReservationRequest",
    "FlowReservationRequestList",
    "FlowReservationRequestListLink",
    "FlowReservationResponse",
    "FlowReservationResponseList",
    "FlowReservationResponseListLink",
    "FlowReservationResponseResponse",
    "FreqDroopType",
    "FunctionSetAssignments",
    "FunctionSetAssignmentsBase",
    "FunctionSetAssignmentsList",
    "FunctionSetAssignmentsListLink",
    "GPSLocationType",
    "HistoricalReading",
    "HistoricalReadingList",
    "HistoricalReadingListLink",
    "IEEE_802_15_4",
    "IPAddr",
    "IPAddrList",
    "IPAddrListLink",
    "IPInterface",
    "IPInterfaceList",
    "IPInterfaceListLink",
    "IdentifiedObject",
    "InverterStatusType",
    "KindType",
    "LLInterface",
    "LLInterfaceList",
    "LLInterfaceListLink",
    "Link",
    "List",
    "ListLink",
    "LoadShedAvailability",
    "LoadShedAvailabilityList",
    "LoadShedAvailabilityListLink",
    "LocalControlModeStatusType",
    "LocaleType",
    "LogEvent",
    "LogEventList",
    "LogEventListLink",
    "ManufacturerStatusType",
    "MessagingProgram",
    "MessagingProgramList",
    "MessagingProgramListLink",
    "MeterReading",
    "MeterReadingBase",
    "MeterReadingLink",
    "MeterReadingList",
    "MeterReadingListLink",
    "MirrorMeterReading",
    "MirrorMeterReadingList",
    "MirrorReadingSet",
    "MirrorUsagePoint",
    "MirrorUsagePointList",
    "MirrorUsagePointListLink",
    "Neighbor",
    "NeighborList",
    "NeighborListLink",
    "Notification",
    "NotificationList",
    "NotificationListLink",
    "Offset",
    "OneHourRangeType",
    "OperationalModeStatusType",
    "PENType",
    "PEVInfo",
    "PINType",
    "PerCent",
    "PhaseCode",
    "PowerConfiguration",
    "PowerFactor",
    "PowerFactorWithExcitation",
    "PowerOfTenMultiplierType",
    "PowerSourceType",
    "PowerStatus",
    "PowerStatusLink",
    "PrepayModeType",
    "PrepayOperationStatus",
    "PrepayOperationStatusLink",
    "Prepayment",
    "PrepaymentLink",
    "PrepaymentList",
    "PrepaymentListLink",
    "PriceResponse",
    "PriceResponseCfg",
    "PriceResponseCfgList",
    "PriceResponseCfgListLink",
    "PrimacyType",
    "PriorityType",
    "ProjectionReading",
    "ProjectionReadingList",
    "ProjectionReadingListLink",
    "RPLInstance",
    "RPLInstanceList",
    "RPLInstanceListLink",
    "RPLSourceRoutes",
    "RPLSourceRoutesList",
    "RPLSourceRoutesListLink",
    "RandomizableEvent",
    "RateComponent",
    "RateComponentLink",
    "RateComponentList",
    "RateComponentListLink",
    "ReactivePower",
    "ReactiveSusceptance",
    "Reading",
    "ReadingBase",
    "ReadingLink",
    "ReadingList",
    "ReadingListLink",
    "ReadingSet",
    "ReadingSetBase",
    "ReadingSetList",
    "ReadingSetListLink",
    "ReadingType",
    "ReadingTypeLink",
    "RealEnergy",
    "Registration",
    "RegistrationLink",
    "RequestStatus",
    "Resource",
    "RespondableIdentifiedObject",
    "RespondableResource",
    "RespondableSubscribableIdentifiedObject",
    "Response",
    "ResponseList",
    "ResponseListLink",
    "ResponseSet",
    "ResponseSetList",
    "ResponseSetListLink",
    "RoleFlagsType",
    "SFDIType",
    "SelfDevice",
    "SelfDeviceLink",
    "ServiceChange",
    "ServiceKind",
    "ServiceStatusType",
    "ServiceSupplier",
    "ServiceSupplierLink",
    "ServiceSupplierList",
    "SetPoint",
    "SignedPerCent",
    "SignedRealEnergy",
    "StateOfChargeStatusType",
    "StorageModeStatusType",
    "SubscribableIdentifiedObject",
    "SubscribableList",
    "SubscribableResource",
    "Subscription",
    "SubscriptionBase",
    "SubscriptionList",
    "SubscriptionListLink",
    "SupplyInterruptionOverride",
    "SupplyInterruptionOverrideList",
    "SupplyInterruptionOverrideListLink",
    "SupportedLocale",
    "SupportedLocaleList",
    "SupportedLocaleListLink",
    "TOUType",
    "TargetReading",
    "TargetReadingList",
    "TargetReadingListLink",
    "TargetReduction",
    "TariffProfile",
    "TariffProfileLink",
    "TariffProfileList",
    "TariffProfileListLink",
    "Temperature",
    "TextMessage",
    "TextMessageList",
    "TextMessageListLink",
    "TextResponse",
    "Time",
    "TimeConfiguration",
    "TimeLink",
    "TimeOffsetType",
    "TimeTariffInterval",
    "TimeTariffIntervalList",
    "TimeTariffIntervalListLink",
    "TimeType",
    "UnitType",
    "UnitValueType",
    "UnsignedFixedPointType",
    "UomType",
    "UsagePoint",
    "UsagePointBase",
    "UsagePointLink",
    "UsagePointList",
    "UsagePointListLink",
    "VersionType",
    "VoltageRMS",
    "WattHour",
    "loWPAN",
    "mRIDType"
]
