.. _Simulation-Integration-Spec:
 
===================================================================
Specification For Simplifying Integration With Simulation Platforms
===================================================================
 
There are several simulation platforms that can be integrated with VOLTTRON
to run as a single cohesive simulated environment for different type of
applications.  Some of the platforms are FNCS, HELICS, GridAPPS-D and
EnergyPlus.  They all have unique application areas and differ in the type
of simulations they run, inputs they accept and outputs they produce.  There
are some similarities in the some of the basic steps of integrating with
VOLTTRON such as:
 
1. Start simulation
2. Subscribe to outputs from the simulation
3. Publish outputs from simulation to VOLTTRON
4. Subscribe to topics from VOLTTRON
5. Send inputs to simulation
6. Advance simulation time step
7. Pause simulation
8. Resume simulation
9. Stop simulation

Currently, VOLTTRON has individual implementations for integrating with
many of the above simulation platforms.  For example, an example of
integrating with GridAPPSD can be found in `examples/GridAPPS-D/gridappsd_example/agent.py`.
EnergyPlus agent can be found in `examples/EnergyPlusAgent/energyplus/agent.py`.  These implementations
will still be available for users.  Instead, in this specification
we are proposing a base simulation integration class that will provide
common APIs and concrete simulation integration classes that will have 
implementation of the these APIs as per the needs of the individual
simulation platforms.  Users can use appropriate simulation classes based on
which simulation platform they want to integrate with.


Features
========

#. Start simulation

    This will start the simulation or register itself to be participant in 
    the simulation.

#. Register for inputs from simulation

    A list of points need to be made available in a config file. The inputs 
    are then read from the config file and registered with simulation platform. 
    Whenever there is any change in those particular points, they are made
    available to this class to process. The agent using this class object 
    can process it or publish it over VOLTTRON message bus to be consumed by
    other agents.

#. Send inputs to simulation

    Send inputs such as set points (for example, charge_EV5),
    data points etc to the simulation. The simulation would then act on these
    inputs.

#. Receive outputs from simulation
    Receive outputs generated by the simulation (for example, OutdoorAirTemperature
    for a energyPlus simulation). The agent can then act on these output values.
    If the config file has an associated topic, the output value will be republished
    on the VOLTTRON message bus.

#. Simulation time management

    Typically, in a simulation environment, one can run applications in real
    time mode or in fast execution mode. All the participants in the simulation
    have to be in sync with respect to time for simulation to be correct. There
    is typically a central unit which acts as a global timekeeper. This timekeeper
    can possibly be configured to use periodic time keeping, which means it 
    periodically advances in time (based on pre-configured time period) or
    based on time advancement message. After each advancement, it would send
    out all the output messages to the registered participants. Another way of
    advancing the simulation would be based on concept of time request-time grant. Each of the
    participants would request for certain time after it is done with its
    work and get blocked until that is granted. The global time keeper would 
    grant time (and hence advance in simulation) that is lowest among the list
    of time requests and all participants would advance to that time.

#. Pause the simulation

    Some simulation platforms can pause the simulation if needed. We need provide
    wrapper API to call simulation specific pause API.

#. Resume the simulation

    Some simulation platforms can resume the simulation if needed. We need provide
    API to call simulation specific resume API.

#. Stop the simulation

    This will unregister itself from the simulation and stop the simulation. 


APIs
====

#. **start_simulation()**

    - Connect to the simulation platform.
    - Register with the platform as a participant

#. **register_inputs(config=None, callback=None)**

    - Register the config containing inputs and outputs with the simulation platform.
    - If agent provides a callback method, this will be called when new output values is received from simulation

#. **publish_to_simulation(topic, message)**

    - Send message to simulation

#. **make_time_request(time_steps)**

    - Make request to simulation to advance to next time delta

#. **pause_simulation()**

    - Pause simulation

#. **resume_simulation()**

    - Resume simulation

#. **stop_simulation()**

    - Stops the simulation

#. **is_sim_installed()**

    - Flag indicating if simulation is installed
